**IMPORTANT: Return ONLY the two code files. No explanations, no commentary, just the code.**

I am customizing an IOTA dApp built with Next.js, React, and TypeScript. Update the contract integration hook and UI component.

## Contract Details

- **Network:** `testnet`
- **Package ID:** `0x1eaf906106e325943a5ed6359783cb0c9c87a2c0daf3624a52d1d17b5352e2c8`
- **Module Name:** `kfc`
- **Available Methods:**

  - `fry` (constant: `FRY`)
  - `get_flag` (constant: `GET_FLAG`)

---

# **Move Contract: `contract/pizza_box/sources/kfc_box.move`**

```move
module pizza_box::kfc {
use std::bcs;
public struct Chicken has store {
chicken_kg: u16,
garlic_g: u16,
milk_ml: u16,
salt_g: u16,
pepper_g: u16,
flour_g: u16,
cornstarch_g: u16,
eggs: u16,
}
public struct ChickenBox has key, store {
id: UID,
chicken: Chicken,
}
public struct Flag has key, store {
id: UID,
user: address
}
const ENotKFCPerfect: u64 = 1;
#[allow(lint(self_transfer))]
public fun fry(chicken_kg: u16, garlic_g: u16, milk_ml: u16, salt_g: u16, pepper_g: u16, flour_g: u16, cornstarch_g: u16, eggs: u16, ctx: &mut tx_context::TxContext) {
let sender = tx_context::sender(ctx);
let c = Chicken {
chicken_kg,
garlic_g,
milk_ml,
salt_g,
pepper_g,
flour_g,
cornstarch_g,
eggs,
};
transfer::public_transfer(ChickenBox { id: object::new(ctx), chicken: c }, sender);
}
#[allow(lint(self_transfer))]
public fun get_flag(chickenbox: &ChickenBox, ctx: &mut tx_context::TxContext) {
let c = &chickenbox.chicken;
let is_perfect = c.chicken_kg == 1u16
&& c.garlic_g == 10u16
&& c.milk_ml == 300u16
&& c.salt_g == 15u16
&& c.pepper_g == 5u16
&& c.flour_g == 200u16
&& c.cornstarch_g == 100u16
&& c.eggs == 2u16;
assert!(is_perfect, ENotKFCPerfect);
transfer::public_transfer(Flag {
id: object::new(ctx),
user: tx_context::sender(ctx)
}, tx_context::sender(ctx));
}
}
```

---

# File 1: `hooks/useContract.ts`

```ts
'use client';

/**
 * ============================================================================
 * IOTA CONTRACT INTEGRATION HOOK
 * ============================================================================
 *
 * This hook contains ALL the contract interaction logic.
 *
 * To customize your dApp, modify the configuration section below.
 *
 * ============================================================================
 */

import { useState } from 'react';
import {
  useCurrentAccount,
  useIotaClient,
  useSignAndExecuteTransaction,
  useIotaClientQuery,
} from '@iota/dapp-kit';
import { Transaction } from '@iota/iota-sdk/transactions';
import { useNetworkVariable } from '@/lib/config';
import type { IotaObjectData } from '@iota/iota-sdk/client';

// ============================================================================
// CONTRACT CONFIGURATION
// ============================================================================
// Change these values to match your Move contract

export const CONTRACT_MODULE = 'kfc'; // New Move module name (kfc_box::kfc)
export const CONTRACT_METHODS = {
  FRY: 'fry',
  GET_FLAG: 'get_flag',
} as const;

// ============================================================================
// DATA EXTRACTION
// ============================================================================
// Modify this to extract data from your contract's object structure

interface ChickenData {
  chickenKg: number;
  garlicG: number;
  milkMl: number;
  saltG: number;
  pepperG: number;
  flourG: number;
  cornstarchG: number;
  eggs: number;
}

function getChickenBoxFields(data: IotaObjectData): ChickenData | null {
  if (data.content?.dataType !== 'moveObject') {
    console.log('Data is not a moveObject:', data.content?.dataType);
    return null;
  }

  const fields = data.content.fields as Record<string, unknown>;
  if (!fields || !fields.chicken) {
    console.log('No chicken fields found in object data');
    return null;
  }

  // Log the actual structure for debugging
  console.log('ChickenBox fields structure:', JSON.stringify(fields, null, 2));

  const chicken = fields.chicken as Record<string, unknown>;

  try {
    return {
      chickenKg: parseInt(String(chicken.chicken_kg), 10),
      garlicG: parseInt(String(chicken.garlic_g), 10),
      milkMl: parseInt(String(chicken.milk_ml), 10),
      saltG: parseInt(String(chicken.salt_g), 10),
      pepperG: parseInt(String(chicken.pepper_g), 10),
      flourG: parseInt(String(chicken.flour_g), 10),
      cornstarchG: parseInt(String(chicken.cornstarch_g), 10),
      eggs: parseInt(String(chicken.eggs), 10),
    };
  } catch (error) {
    console.error('Error parsing chicken fields:', error);
    return null;
  }
}

// ============================================================================
// MAIN HOOK
// ============================================================================

export interface ContractData {
  chickenKg: number;
  garlicG: number;
  milkMl: number;
  saltG: number;
  pepperG: number;
  flourG: number;
  cornstarchG: number;
  eggs: number;
}

export interface ContractState {
  isLoading: boolean;
  isPending: boolean;
  isConfirming: boolean;
  isConfirmed: boolean;
  hash: string | undefined;
  error: Error | null;
}

export interface ContractActions {
  fryChicken: (
    chickenKg: number,
    garlicG: number,
    milkMl: number,
    saltG: number,
    pepperG: number,
    flourG: number,
    cornstarchG: number,
    eggs: number
  ) => Promise<void>;
  getFlag: () => Promise<void>;
  clearObject: () => void;
}

export const useContract = () => {
  const currentAccount = useCurrentAccount();
  const address = currentAccount?.address;
  const packageId = useNetworkVariable('packageId');
  const iotaClient = useIotaClient();
  const { mutate: signAndExecute, isPending } = useSignAndExecuteTransaction();
  const [chickenBoxId, setChickenBoxId] = useState<string | null>(() => {
    if (typeof window !== 'undefined' && currentAccount?.address) {
      return localStorage.getItem(`chickenBoxId_${currentAccount.address}`);
    }
    return null;
  });
  const [flagId, setFlagId] = useState<string | null>(() => {
    if (typeof window !== 'undefined' && currentAccount?.address) {
      return localStorage.getItem(`flagId_${currentAccount.address}`);
    }
    return null;
  });
  const [isLoading, setIsLoading] = useState(false);
  const [hash, setHash] = useState<string | undefined>();
  const [transactionError, setTransactionError] = useState<Error | null>(null);

  // Fetch chicken box data
  const {
    data,
    isPending: isFetching,
    error: queryError,
    refetch,
  } = useIotaClientQuery(
    'getObject',
    {
      id: chickenBoxId!,
      options: { showContent: true, showOwner: true },
    },
    {
      enabled: !!chickenBoxId,
    }
  );

  // Extract fields
  const fields = data?.data ? getChickenBoxFields(data.data) : null;

  // Check if object exists but data extraction failed
  const objectExists = !!data?.data;
  const hasValidData = !!fields;

  // Fry Chicken
  const fryChicken = async (
    chickenKg: number,
    garlicG: number,
    milkMl: number,
    saltG: number,
    pepperG: number,
    flourG: number,
    cornstarchG: number,
    eggs: number
  ) => {
    if (!packageId) return;

    try {
      setTransactionError(null);
      setHash(undefined);
      const tx = new Transaction();
      tx.moveCall({
        arguments: [
          tx.pure.u16(chickenKg),
          tx.pure.u16(garlicG),
          tx.pure.u16(milkMl),
          tx.pure.u16(saltG),
          tx.pure.u16(pepperG),
          tx.pure.u16(flourG),
          tx.pure.u16(cornstarchG),
          tx.pure.u16(eggs),
        ],
        target: `${packageId}::${CONTRACT_MODULE}::${CONTRACT_METHODS.FRY}`,
      });
      tx.setGasBudget(5000000);

      signAndExecute(
        { transaction: tx as never },
        {
          onSuccess: async ({ digest }) => {
            setHash(digest);
            setIsLoading(true);
            try {
              const { effects } = await iotaClient.waitForTransaction({
                digest,
                options: { showEffects: true },
              });
              const newChickenBoxId = effects?.created?.[0]?.reference?.objectId;
              if (newChickenBoxId) {
                setChickenBoxId(newChickenBoxId);
                if (typeof window !== 'undefined' && address) {
                  localStorage.setItem(`chickenBoxId_${address}`, newChickenBoxId);
                }
                await refetch();
                setIsLoading(false);
              } else {
                setIsLoading(false);
                console.warn('No chicken box ID found in transaction effects');
              }
            } catch (waitError) {
              console.error('Error waiting for transaction:', waitError);
              setIsLoading(false);
            }
          },
          onError: (err) => {
            let errorMessage = String(err);
            if (err instanceof Error) {
              errorMessage = err.message;
            }
            // Handle common wallet rejection messages
            if (errorMessage.includes('Rejected from user')) {
              errorMessage = 'Transaction rejected by user. Please approve in your wallet.';
            } else if (errorMessage.includes('InsufficientGas')) {
              errorMessage = 'Insufficient gas. Please add more gas and try again.';
            }
            const error = new Error(errorMessage);
            setTransactionError(error);
            console.error('Error:', err);
          },
        }
      );
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err));
      setTransactionError(error);
      console.error('Error frying chicken:', err);
    }
  };

  // Get Flag
  const getFlag = async () => {
    if (!chickenBoxId || !packageId) return;

    try {
      setTransactionError(null);
      setHash(undefined);
      const tx = new Transaction();
      tx.moveCall({
        arguments: [tx.object(chickenBoxId)],
        target: `${packageId}::${CONTRACT_MODULE}::${CONTRACT_METHODS.GET_FLAG}`,
      });
      tx.setGasBudget(5000000);

      signAndExecute(
        { transaction: tx as never },
        {
          onSuccess: async ({ digest }) => {
            setHash(digest);
            setIsLoading(true);
            try {
              const { effects } = await iotaClient.waitForTransaction({
                digest,
                options: { showEffects: true },
              });
              // Try to locate the created Flag object robustly across effects
              let newFlagId: string | undefined;
              const created = effects?.created ?? [];
              if (created.length > 0) {
                for (const c of created) {
                  const objId = c?.reference?.objectId;
                  // Try to detect Flag by type string if available
                  const maybeType = (c as any)?.reference?.type || (c as any)?.type || '';
                  if (objId && String(maybeType).toLowerCase().includes('flag')) {
                    newFlagId = objId;
                    break;
                  }
                }
                // Fallback to the first created object if none matched the name
                if (!newFlagId && created[0]?.reference?.objectId) {
                  newFlagId = created[0].reference.objectId;
                }
              }

              // If still not found, check mutated objects (some transfers may appear there)
              if (!newFlagId && effects?.mutated?.length) {
                for (const m of effects.mutated) {
                  const objId = m?.reference?.objectId;
                  const maybeType = (m as any)?.reference?.type || (m as any)?.type || '';
                  if (objId && String(maybeType).toLowerCase().includes('flag')) {
                    newFlagId = objId;
                    break;
                  }
                }
              }

              if (newFlagId) {
                setFlagId(newFlagId);
                if (typeof window !== 'undefined' && address) {
                  localStorage.setItem(`flagId_${address}`, newFlagId);
                }
                setIsLoading(false);
              } else {
                setIsLoading(false);
                console.warn('No flag ID found in transaction effects', effects);
              }
            } catch (waitError) {
              console.error('Error waiting for transaction:', waitError);
              setIsLoading(false);
            }
          },
          onError: (err) => {
            setIsLoading(false);
            let errorMessage = String(err);
            if (err instanceof Error) {
              errorMessage = err.message;
            }
            // Handle common wallet rejection messages
            if (errorMessage.includes('Rejected from user')) {
              errorMessage = 'Transaction rejected by user. Please approve in your wallet.';
            } else if (errorMessage.includes('InsufficientGas')) {
              errorMessage = 'Insufficient gas. Please add more gas and try again.';
            }
            const error = new Error(errorMessage);
            setTransactionError(error);
            console.error('Error:', err);
          },
        }
      );
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err));
      setTransactionError(error);
      console.error('Error getting flag:', err);
    }
  };

  const contractData: ContractData | null = fields;

  const clearObject = () => {
    setChickenBoxId(null);
    setFlagId(null);
    setTransactionError(null);
    if (typeof window !== 'undefined' && address) {
      localStorage.removeItem(`chickenBoxId_${address}`);
      localStorage.removeItem(`flagId_${address}`);
    }
  };

  const actions: ContractActions = {
    fryChicken,
    getFlag,
    clearObject,
  };

  const contractState: ContractState = {
    isLoading: isLoading,
    isPending,
    isConfirming: false,
    isConfirmed: !!hash && !isLoading && !isPending,
    hash,
    error: queryError || transactionError,
  };

  return {
    data: contractData,
    actions,
    state: contractState,
    chickenBoxId,
    flagId,
    objectExists,
    hasValidData,
    isFetching,
  };
};
```

---

# File 2: `components/sample.tsx`

```tsx
'use client';

/**
 * ============================================================================
 * KFC CHICKEN DAPP INTEGRATION COMPONENT
 * ============================================================================
 *
 * This component allows users to fry KFC chicken and get flags when they
 * fry the perfect chicken with the right ingredients.
 *
 * All the contract logic is in hooks/useContract.ts
 *
 * ============================================================================
 */

import { useCurrentAccount } from '@iota/dapp-kit';
import { useContract } from '@/hooks/useContract';
import { Button, Container, Heading, Text, TextField } from '@radix-ui/themes';
import ClipLoader from 'react-spinners/ClipLoader';
import { useState } from 'react';
import copy from 'copy-to-clipboard';
import { showToast } from '@/lib/toast';

const SampleIntegration = () => {
  const currentAccount = useCurrentAccount();
  const { data, actions, state, chickenBoxId, flagId } = useContract();

  const [ingredients, setIngredients] = useState({
    chickenKg: '1',
    garlicG: '10',
    milkMl: '300',
    saltG: '15',
    pepperG: '5',
    flourG: '200',
    cornstarchG: '100',
    eggs: '2',
  });

  const isConnected = !!currentAccount;

  const handleIngredientChange = (field: string, value: string) => {
    setIngredients((prev) => ({ ...prev, [field]: value }));
  };

  const applyPreset = () => {
    setIngredients({
      chickenKg: '1',
      garlicG: '10',
      milkMl: '300',
      saltG: '15',
      pepperG: '5',
      flourG: '200',
      cornstarchG: '100',
      eggs: '2',
    });
  };

  const copyId = (id?: string) => {
    if (!id) return;
    try {
      copy(id);
      showToast('Copied to clipboard');
    } catch (e) {
      console.error(e);
      showToast('Copy failed');
    }
  };

  const handleClaimReward = () => {
    const confirmed = window.confirm(
      'üçó Ready to claim your reward?\n\nYou have successfully completed the challenge!'
    );
    if (confirmed) {
      actions.getFlag();
    }
  };

  const safe = (v: any) => {
    if (v === undefined || v === null) return '-';
    if (typeof v === 'number') return Number.isFinite(v) ? String(v) : '-';
    if (typeof v === 'string') {
      // guard against numeric strings that may be empty
      if (v.trim() === '') return '-';
      return v;
    }
    try {
      return String(v);
    } catch {
      return '-';
    }
  };

  if (!isConnected) {
    return (
      <div className="app-container" style={{ paddingTop: '2.5rem', paddingBottom: '2.5rem' }}>
        <div className="hero" style={{ textAlign: 'left' }}>
          <h1>üçó KFC Chicken dApp</h1>
          <p>Welcome! Connect your wallet to start frying, collecting and claiming rewards.</p>
          <div style={{ marginTop: '1rem' }}>
            <button
              className="primary-btn"
              onClick={() => window.scrollTo({ top: 400, behavior: 'smooth' })}
            >
              Get Started
            </button>
            <button
              className="secondary-btn"
              style={{ marginLeft: '0.6rem' }}
              onClick={() => showToast('Connect to see recipes')}
            >
              Why connect?
            </button>
          </div>
        </div>

        <div className="card" style={{ marginTop: '1.25rem' }}>
          <div className="card-header">
            <span style={{ fontSize: '1.6rem' }}>‚ú®</span>
            <h2>How it works</h2>
          </div>
          <div className="form-grid" style={{ gridTemplateColumns: 'repeat(3, 1fr)', gap: '1rem' }}>
            <div className="feature-card card">
              <h3>Fry</h3>
              <p className="muted">Create recipes and fry chicken on-chain.</p>
            </div>
            <div className="feature-card card">
              <h3>Collect</h3>
              <p className="muted">Store ChickenBoxes as proof of your creations.</p>
            </div>
            <div className="feature-card card">
              <h3>Claim</h3>
              <p className="muted">Complete challenges to earn rewards and flags.</p>
            </div>
          </div>
        </div>
      </div>
    );
  }

  return (
    <div className="app-container">
      <div className="hero">
        <h1>üçó KFC Challenge</h1>
        <p>Master the perfect fried chicken recipe and claim your reward!</p>
      </div>

      <Container style={{ maxWidth: '900px', margin: '0 auto' }}>
        {/* Reward Status Section */}
        {flagId && (
          <div className="card status-reward">
            <div className="card-header">
              <span style={{ fontSize: '2rem' }}>üéñÔ∏è</span>
              <h2>Reward Claimed</h2>
            </div>
            <Text style={{ color: '#fcd34d', marginBottom: '1rem', fontSize: '1.1rem' }}>
              üî• You're a KFC Legend! You've successfully completed the perfect recipe challenge!
            </Text>
            <div
              style={{
                background: 'rgba(0,0,0,0.3)',
                padding: '1rem',
                borderRadius: '8px',
                borderLeft: '3px solid #ffc600',
              }}
            >
              <Text size="1" style={{ color: '#a0a0a0', marginBottom: '0.5rem' }}>
                Reward ID:
              </Text>
              <Text size="2" className="kv">
                {flagId}
              </Text>
            </div>
          </div>
        )}

        {/* Chicken Box Status */}
        {chickenBoxId && data && (
          <div className="card">
            <div className="card-header">
              <span style={{ fontSize: '2rem' }}>üì¶</span>
              <h2>Your Creation</h2>
            </div>
            <div className="form-grid">
              <div className="form-group">
                <span style={{ color: '#ffc600' }}>üêî Chicken</span>
                <Text>{safe(data.chickenKg)} kg</Text>
              </div>
              <div className="form-group">
                <span style={{ color: '#ffc600' }}>üßÑ Garlic</span>
                <Text>{safe(data.garlicG)} g</Text>
              </div>
              <div className="form-group">
                <span style={{ color: '#ffc600' }}>ü•õ Milk</span>
                <Text>{safe(data.milkMl)} ml</Text>
              </div>
              <div className="form-group">
                <span style={{ color: '#ffc600' }}>üßÇ Salt</span>
                <Text>{safe(data.saltG)} g</Text>
              </div>
              <div className="form-group">
                <span style={{ color: '#ffc600' }}>üå∂Ô∏è Pepper</span>
                <Text>{safe(data.pepperG)} g</Text>
              </div>
              <div className="form-group">
                <span style={{ color: '#ffc600' }}>üçû Flour</span>
                <Text>{safe(data.flourG)} g</Text>
              </div>
              <div className="form-group">
                <span style={{ color: '#ffc600' }}>ü•î Cornstarch</span>
                <Text>{safe(data.cornstarchG)} g</Text>
              </div>
              <div className="form-group">
                <span style={{ color: '#ffc600' }}>ü•ö Eggs</span>
                <Text>{safe(data.eggs)}</Text>
              </div>
            </div>
            <div
              style={{
                background: 'rgba(0,0,0,0.3)',
                padding: '1rem',
                borderRadius: '8px',
                marginTop: '1rem',
                marginBottom: '1rem',
                borderLeft: '3px solid #ffc600',
              }}
            >
              <Text size="1" style={{ color: '#a0a0a0' }}>
                ChickenBox ID: <span className="kv">{chickenBoxId}</span>
              </Text>
            </div>
            {!flagId && (
              <Button
                size="3"
                className="primary-btn"
                onClick={handleClaimReward}
                disabled={state.isLoading || state.isPending}
              >
                {state.isLoading || state.isPending ? (
                  <>
                    <ClipLoader size={14} style={{ marginRight: '8px' }} />
                    Processing...
                  </>
                ) : (
                  'üéÅ Claim Reward'
                )}
              </Button>
            )}
          </div>
        )}

        {/* Fry Chicken Form */}
        <div className="card">
          <div className="card-header">
            <span style={{ fontSize: '2rem' }}>üë®‚Äçüç≥</span>
            <h2>Craft Your Recipe</h2>
          </div>

          <div
            style={{ marginBottom: '1.5rem', display: 'flex', gap: '0.75rem', flexWrap: 'wrap' }}
          >
            <button className="secondary-btn" onClick={applyPreset}>
              ‚ö° Use Perfect Recipe
            </button>
            {chickenBoxId && (
              <button className="secondary-btn" onClick={() => copyId(chickenBoxId)}>
                üìã Copy ChickenBox ID
              </button>
            )}
          </div>

          <div className="form-grid">
            <div className="form-group">
              <label>üêî Chicken (kg)</label>
              <TextField.Root
                value={ingredients.chickenKg}
                onChange={(e) => handleIngredientChange('chickenKg', e.target.value)}
                type="number"
                min="0"
                max="65535"
              />
            </div>
            <div className="form-group">
              <label>üßÑ Garlic (g)</label>
              <TextField.Root
                value={ingredients.garlicG}
                onChange={(e) => handleIngredientChange('garlicG', e.target.value)}
                type="number"
                min="0"
                max="65535"
              />
            </div>
            <div className="form-group">
              <label>ü•õ Milk (ml)</label>
              <TextField.Root
                value={ingredients.milkMl}
                onChange={(e) => handleIngredientChange('milkMl', e.target.value)}
                type="number"
                min="0"
                max="65535"
              />
            </div>
            <div className="form-group">
              <label>üßÇ Salt (g)</label>
              <TextField.Root
                value={ingredients.saltG}
                onChange={(e) => handleIngredientChange('saltG', e.target.value)}
                type="number"
                min="0"
                max="65535"
              />
            </div>
            <div className="form-group">
              <label>üå∂Ô∏è Pepper (g)</label>
              <TextField.Root
                value={ingredients.pepperG}
                onChange={(e) => handleIngredientChange('pepperG', e.target.value)}
                type="number"
                min="0"
                max="65535"
              />
            </div>
            <div className="form-group">
              <label>üçû Flour (g)</label>
              <TextField.Root
                value={ingredients.flourG}
                onChange={(e) => handleIngredientChange('flourG', e.target.value)}
                type="number"
                min="0"
                max="65535"
              />
            </div>
            <div className="form-group">
              <label>ü•î Cornstarch (g)</label>
              <TextField.Root
                value={ingredients.cornstarchG}
                onChange={(e) => handleIngredientChange('cornstarchG', e.target.value)}
                type="number"
                min="0"
                max="65535"
              />
            </div>
            <div className="form-group">
              <label>ü•ö Eggs</label>
              <TextField.Root
                value={ingredients.eggs}
                onChange={(e) => handleIngredientChange('eggs', e.target.value)}
                type="number"
                min="0"
                max="65535"
              />
            </div>
          </div>

          <Button
            size="3"
            className="primary-btn"
            onClick={() =>
              actions.fryChicken(
                parseInt(ingredients.chickenKg),
                parseInt(ingredients.garlicG),
                parseInt(ingredients.milkMl),
                parseInt(ingredients.saltG),
                parseInt(ingredients.pepperG),
                parseInt(ingredients.flourG),
                parseInt(ingredients.cornstarchG),
                parseInt(ingredients.eggs)
              )
            }
            disabled={state.isPending || state.isLoading}
          >
            {state.isLoading ? (
              <>
                <ClipLoader size={16} style={{ marginRight: '8px' }} />
                Frying...
              </>
            ) : (
              'üçó Fry KFC Chicken'
            )}
          </Button>
        </div>

        {/* Transaction Status */}
        {state.hash && (
          <div className="card status-success">
            <div
              style={{
                display: 'flex',
                alignItems: 'center',
                gap: '0.75rem',
                marginBottom: '1rem',
              }}
            >
              <span style={{ fontSize: '1.5rem' }}>‚úÖ</span>
              <Text style={{ fontSize: '1.1rem', fontWeight: '600' }}>Transaction Confirmed</Text>
            </div>
            <div
              style={{
                background: 'rgba(0,0,0,0.3)',
                padding: '1rem',
                borderRadius: '8px',
                borderLeft: '3px solid #22c55e',
              }}
            >
              <Text size="1" style={{ color: '#a0a0a0', marginBottom: '0.5rem' }}>
                Transaction Hash:
              </Text>
              <Text size="2" className="kv">
                {state.hash}
              </Text>
            </div>
          </div>
        )}

        {/* Error Display */}
        {state.error && (
          <div className="card status-error">
            <div
              style={{
                display: 'flex',
                alignItems: 'center',
                gap: '0.75rem',
                marginBottom: '1rem',
              }}
            >
              <span style={{ fontSize: '1.5rem' }}>‚ö†Ô∏è</span>
              <Text style={{ fontSize: '1.1rem', fontWeight: '600', color: '#ef4444' }}>
                Oops! Something went wrong
              </Text>
            </div>
            <Text style={{ color: '#fca5a5', marginBottom: '0.75rem' }}>
              {(state.error as Error)?.message || String(state.error)}
            </Text>
            {(state.error as Error)?.message?.includes('Rejected from user') && (
              <Text size="1" style={{ color: '#fca5a5', fontStyle: 'italic' }}>
                üí° Please approve the transaction in your wallet popup
              </Text>
            )}
          </div>
        )}
      </Container>
    </div>
  );
};

export default SampleIntegration;
```

---

# Your Task

Return **two updated files**:

## 1. `hooks/useContract.ts`

- Keep all TypeScript interfaces
- Preserve loading, error, and transaction state logic
- Maintain hook object structure
- Keep contract calls functional
- Use Package ID: `0x1eaf906106e325943a5ed6359783cb0c9c87a2c0daf3624a52d1d17b5352e2c8` and Module: `kfc`
- Only implement requested changes

## 2. `components/sample.tsx`

- Keep UI behavior and wallet checks
- Preserve loading, error, object state and transaction UI
- Maintain interaction logic unless specified
- Apply only requested modifications
