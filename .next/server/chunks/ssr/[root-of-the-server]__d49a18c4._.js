module.exports = [
  47349,
  (a, b, c) => {
    'use strict';
    var d = a.r(72131);
    d.useState,
      d.useEffect,
      d.useLayoutEffect,
      d.useDebugValue,
      (c.useSyncExternalStore =
        void 0 !== d.useSyncExternalStore
          ? d.useSyncExternalStore
          : function (a, b) {
              return b();
            });
  },
  87610,
  (a, b, c) => {
    'use strict';
    b.exports = a.r(47349);
  },
  97514,
  (a, b, c) => {
    'use strict';
    var d = a.r(72131),
      e = a.r(87610),
      f =
        'function' == typeof Object.is
          ? Object.is
          : function (a, b) {
              return (a === b && (0 !== a || 1 / a == 1 / b)) || (a != a && b != b);
            },
      g = e.useSyncExternalStore,
      h = d.useRef,
      i = d.useEffect,
      j = d.useMemo,
      k = d.useDebugValue;
    c.useSyncExternalStoreWithSelector = function (a, b, c, d, e) {
      var l = h(null);
      if (null === l.current) {
        var m = { hasValue: !1, value: null };
        l.current = m;
      } else m = l.current;
      var n = g(
        a,
        (l = j(
          function () {
            function a(a) {
              if (!i) {
                if (((i = !0), (g = a), (a = d(a)), void 0 !== e && m.hasValue)) {
                  var b = m.value;
                  if (e(b, a)) return (h = b);
                }
                return (h = a);
              }
              if (((b = h), f(g, a))) return b;
              var c = d(a);
              return void 0 !== e && e(b, c) ? ((g = a), b) : ((g = a), (h = c));
            }
            var g,
              h,
              i = !1,
              j = void 0 === c ? null : c;
            return [
              function () {
                return a(b());
              },
              null === j
                ? void 0
                : function () {
                    return a(j());
                  },
            ];
          },
          [b, c, d, e]
        ))[0],
        l[1]
      );
      return (
        i(
          function () {
            (m.hasValue = !0), (m.value = n);
          },
          [n]
        ),
        k(n),
        n
      );
    };
  },
  64442,
  (a, b, c) => {
    'use strict';
    b.exports = a.r(97514);
  },
  66680,
  (a, b, c) => {
    b.exports = a.x('node:crypto', () => require('node:crypto'));
  },
  54799,
  (a, b, c) => {
    b.exports = a.x('crypto', () => require('crypto'));
  },
  21756,
  (a, b, c) => {
    !(function (b) {
      'use strict';
      var c,
        d = function (a) {
          var b,
            c = new Float64Array(16);
          if (a) for (b = 0; b < a.length; b++) c[b] = a[b];
          return c;
        },
        e = function () {
          throw Error('no PRNG');
        },
        f = new Uint8Array(16),
        g = new Uint8Array(32);
      g[0] = 9;
      var h = d(),
        i = d([1]),
        j = d([56129, 1]),
        k = d([
          30883, 4953, 19914, 30187, 55467, 16705, 2637, 112, 59544, 30585, 16505, 36039, 65139,
          11119, 27886, 20995,
        ]),
        l = d([
          61785, 9906, 39828, 60374, 45398, 33411, 5274, 224, 53552, 61171, 33010, 6542, 64743,
          22239, 55772, 9222,
        ]),
        m = d([
          54554, 36645, 11616, 51542, 42930, 38181, 51040, 26924, 56412, 64982, 57905, 49316, 21502,
          52590, 14035, 8553,
        ]),
        n = d([
          26200, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214,
          26214, 26214, 26214,
        ]),
        o = d([
          41136, 18958, 6951, 50414, 58488, 44335, 6150, 12099, 55207, 15867, 153, 11085, 57099,
          20417, 9344, 11139,
        ]);
      function p(a, b, c, d) {
        (a[b] = (c >> 24) & 255),
          (a[b + 1] = (c >> 16) & 255),
          (a[b + 2] = (c >> 8) & 255),
          (a[b + 3] = 255 & c),
          (a[b + 4] = (d >> 24) & 255),
          (a[b + 5] = (d >> 16) & 255),
          (a[b + 6] = (d >> 8) & 255),
          (a[b + 7] = 255 & d);
      }
      function q(a, b, c, d, e) {
        var f,
          g = 0;
        for (f = 0; f < e; f++) g |= a[b + f] ^ c[d + f];
        return (1 & ((g - 1) >>> 8)) - 1;
      }
      function s(a, b, c, d) {
        return q(a, b, c, d, 16);
      }
      function t(a, b, c, d) {
        return q(a, b, c, d, 32);
      }
      function u(a, b, c, d) {
        !(function (a, b, c, d) {
          for (
            var e,
              f = (255 & d[0]) | ((255 & d[1]) << 8) | ((255 & d[2]) << 16) | ((255 & d[3]) << 24),
              g = (255 & c[0]) | ((255 & c[1]) << 8) | ((255 & c[2]) << 16) | ((255 & c[3]) << 24),
              h = (255 & c[4]) | ((255 & c[5]) << 8) | ((255 & c[6]) << 16) | ((255 & c[7]) << 24),
              i =
                (255 & c[8]) | ((255 & c[9]) << 8) | ((255 & c[10]) << 16) | ((255 & c[11]) << 24),
              j =
                (255 & c[12]) |
                ((255 & c[13]) << 8) |
                ((255 & c[14]) << 16) |
                ((255 & c[15]) << 24),
              k = (255 & d[4]) | ((255 & d[5]) << 8) | ((255 & d[6]) << 16) | ((255 & d[7]) << 24),
              l = (255 & b[0]) | ((255 & b[1]) << 8) | ((255 & b[2]) << 16) | ((255 & b[3]) << 24),
              m = (255 & b[4]) | ((255 & b[5]) << 8) | ((255 & b[6]) << 16) | ((255 & b[7]) << 24),
              n =
                (255 & b[8]) | ((255 & b[9]) << 8) | ((255 & b[10]) << 16) | ((255 & b[11]) << 24),
              o =
                (255 & b[12]) |
                ((255 & b[13]) << 8) |
                ((255 & b[14]) << 16) |
                ((255 & b[15]) << 24),
              p =
                (255 & d[8]) | ((255 & d[9]) << 8) | ((255 & d[10]) << 16) | ((255 & d[11]) << 24),
              q =
                (255 & c[16]) |
                ((255 & c[17]) << 8) |
                ((255 & c[18]) << 16) |
                ((255 & c[19]) << 24),
              s =
                (255 & c[20]) |
                ((255 & c[21]) << 8) |
                ((255 & c[22]) << 16) |
                ((255 & c[23]) << 24),
              t =
                (255 & c[24]) |
                ((255 & c[25]) << 8) |
                ((255 & c[26]) << 16) |
                ((255 & c[27]) << 24),
              u =
                (255 & c[28]) |
                ((255 & c[29]) << 8) |
                ((255 & c[30]) << 16) |
                ((255 & c[31]) << 24),
              v =
                (255 & d[12]) |
                ((255 & d[13]) << 8) |
                ((255 & d[14]) << 16) |
                ((255 & d[15]) << 24),
              w = f,
              x = g,
              y = h,
              z = i,
              A = j,
              B = k,
              C = l,
              D = m,
              E = n,
              F = o,
              G = p,
              H = q,
              I = s,
              J = t,
              K = u,
              L = v,
              M = 0;
            M < 20;
            M += 2
          )
            (A ^= ((e = (w + I) | 0) << 7) | (e >>> 25)),
              (E ^= ((e = (A + w) | 0) << 9) | (e >>> 23)),
              (I ^= ((e = (E + A) | 0) << 13) | (e >>> 19)),
              (w ^= ((e = (I + E) | 0) << 18) | (e >>> 14)),
              (F ^= ((e = (B + x) | 0) << 7) | (e >>> 25)),
              (J ^= ((e = (F + B) | 0) << 9) | (e >>> 23)),
              (x ^= ((e = (J + F) | 0) << 13) | (e >>> 19)),
              (B ^= ((e = (x + J) | 0) << 18) | (e >>> 14)),
              (K ^= ((e = (G + C) | 0) << 7) | (e >>> 25)),
              (y ^= ((e = (K + G) | 0) << 9) | (e >>> 23)),
              (C ^= ((e = (y + K) | 0) << 13) | (e >>> 19)),
              (G ^= ((e = (C + y) | 0) << 18) | (e >>> 14)),
              (z ^= ((e = (L + H) | 0) << 7) | (e >>> 25)),
              (D ^= ((e = (z + L) | 0) << 9) | (e >>> 23)),
              (H ^= ((e = (D + z) | 0) << 13) | (e >>> 19)),
              (L ^= ((e = (H + D) | 0) << 18) | (e >>> 14)),
              (x ^= ((e = (w + z) | 0) << 7) | (e >>> 25)),
              (y ^= ((e = (x + w) | 0) << 9) | (e >>> 23)),
              (z ^= ((e = (y + x) | 0) << 13) | (e >>> 19)),
              (w ^= ((e = (z + y) | 0) << 18) | (e >>> 14)),
              (C ^= ((e = (B + A) | 0) << 7) | (e >>> 25)),
              (D ^= ((e = (C + B) | 0) << 9) | (e >>> 23)),
              (A ^= ((e = (D + C) | 0) << 13) | (e >>> 19)),
              (B ^= ((e = (A + D) | 0) << 18) | (e >>> 14)),
              (H ^= ((e = (G + F) | 0) << 7) | (e >>> 25)),
              (E ^= ((e = (H + G) | 0) << 9) | (e >>> 23)),
              (F ^= ((e = (E + H) | 0) << 13) | (e >>> 19)),
              (G ^= ((e = (F + E) | 0) << 18) | (e >>> 14)),
              (I ^= ((e = (L + K) | 0) << 7) | (e >>> 25)),
              (J ^= ((e = (I + L) | 0) << 9) | (e >>> 23)),
              (K ^= ((e = (J + I) | 0) << 13) | (e >>> 19)),
              (L ^= ((e = (K + J) | 0) << 18) | (e >>> 14));
          (w = (w + f) | 0),
            (x = (x + g) | 0),
            (y = (y + h) | 0),
            (z = (z + i) | 0),
            (A = (A + j) | 0),
            (B = (B + k) | 0),
            (C = (C + l) | 0),
            (D = (D + m) | 0),
            (E = (E + n) | 0),
            (F = (F + o) | 0),
            (G = (G + p) | 0),
            (H = (H + q) | 0),
            (I = (I + s) | 0),
            (J = (J + t) | 0),
            (K = (K + u) | 0),
            (L = (L + v) | 0),
            (a[0] = (w >>> 0) & 255),
            (a[1] = (w >>> 8) & 255),
            (a[2] = (w >>> 16) & 255),
            (a[3] = (w >>> 24) & 255),
            (a[4] = (x >>> 0) & 255),
            (a[5] = (x >>> 8) & 255),
            (a[6] = (x >>> 16) & 255),
            (a[7] = (x >>> 24) & 255),
            (a[8] = (y >>> 0) & 255),
            (a[9] = (y >>> 8) & 255),
            (a[10] = (y >>> 16) & 255),
            (a[11] = (y >>> 24) & 255),
            (a[12] = (z >>> 0) & 255),
            (a[13] = (z >>> 8) & 255),
            (a[14] = (z >>> 16) & 255),
            (a[15] = (z >>> 24) & 255),
            (a[16] = (A >>> 0) & 255),
            (a[17] = (A >>> 8) & 255),
            (a[18] = (A >>> 16) & 255),
            (a[19] = (A >>> 24) & 255),
            (a[20] = (B >>> 0) & 255),
            (a[21] = (B >>> 8) & 255),
            (a[22] = (B >>> 16) & 255),
            (a[23] = (B >>> 24) & 255),
            (a[24] = (C >>> 0) & 255),
            (a[25] = (C >>> 8) & 255),
            (a[26] = (C >>> 16) & 255),
            (a[27] = (C >>> 24) & 255),
            (a[28] = (D >>> 0) & 255),
            (a[29] = (D >>> 8) & 255),
            (a[30] = (D >>> 16) & 255),
            (a[31] = (D >>> 24) & 255),
            (a[32] = (E >>> 0) & 255),
            (a[33] = (E >>> 8) & 255),
            (a[34] = (E >>> 16) & 255),
            (a[35] = (E >>> 24) & 255),
            (a[36] = (F >>> 0) & 255),
            (a[37] = (F >>> 8) & 255),
            (a[38] = (F >>> 16) & 255),
            (a[39] = (F >>> 24) & 255),
            (a[40] = (G >>> 0) & 255),
            (a[41] = (G >>> 8) & 255),
            (a[42] = (G >>> 16) & 255),
            (a[43] = (G >>> 24) & 255),
            (a[44] = (H >>> 0) & 255),
            (a[45] = (H >>> 8) & 255),
            (a[46] = (H >>> 16) & 255),
            (a[47] = (H >>> 24) & 255),
            (a[48] = (I >>> 0) & 255),
            (a[49] = (I >>> 8) & 255),
            (a[50] = (I >>> 16) & 255),
            (a[51] = (I >>> 24) & 255),
            (a[52] = (J >>> 0) & 255),
            (a[53] = (J >>> 8) & 255),
            (a[54] = (J >>> 16) & 255),
            (a[55] = (J >>> 24) & 255),
            (a[56] = (K >>> 0) & 255),
            (a[57] = (K >>> 8) & 255),
            (a[58] = (K >>> 16) & 255),
            (a[59] = (K >>> 24) & 255),
            (a[60] = (L >>> 0) & 255),
            (a[61] = (L >>> 8) & 255),
            (a[62] = (L >>> 16) & 255),
            (a[63] = (L >>> 24) & 255);
        })(a, b, c, d);
      }
      function v(a, b, c, d) {
        !(function (a, b, c, d) {
          for (
            var e,
              f = (255 & d[0]) | ((255 & d[1]) << 8) | ((255 & d[2]) << 16) | ((255 & d[3]) << 24),
              g = (255 & c[0]) | ((255 & c[1]) << 8) | ((255 & c[2]) << 16) | ((255 & c[3]) << 24),
              h = (255 & c[4]) | ((255 & c[5]) << 8) | ((255 & c[6]) << 16) | ((255 & c[7]) << 24),
              i =
                (255 & c[8]) | ((255 & c[9]) << 8) | ((255 & c[10]) << 16) | ((255 & c[11]) << 24),
              j =
                (255 & c[12]) |
                ((255 & c[13]) << 8) |
                ((255 & c[14]) << 16) |
                ((255 & c[15]) << 24),
              k = (255 & d[4]) | ((255 & d[5]) << 8) | ((255 & d[6]) << 16) | ((255 & d[7]) << 24),
              l = (255 & b[0]) | ((255 & b[1]) << 8) | ((255 & b[2]) << 16) | ((255 & b[3]) << 24),
              m = (255 & b[4]) | ((255 & b[5]) << 8) | ((255 & b[6]) << 16) | ((255 & b[7]) << 24),
              n =
                (255 & b[8]) | ((255 & b[9]) << 8) | ((255 & b[10]) << 16) | ((255 & b[11]) << 24),
              o =
                (255 & b[12]) |
                ((255 & b[13]) << 8) |
                ((255 & b[14]) << 16) |
                ((255 & b[15]) << 24),
              p =
                (255 & d[8]) | ((255 & d[9]) << 8) | ((255 & d[10]) << 16) | ((255 & d[11]) << 24),
              q =
                (255 & c[16]) |
                ((255 & c[17]) << 8) |
                ((255 & c[18]) << 16) |
                ((255 & c[19]) << 24),
              s =
                (255 & c[20]) |
                ((255 & c[21]) << 8) |
                ((255 & c[22]) << 16) |
                ((255 & c[23]) << 24),
              t =
                (255 & c[24]) |
                ((255 & c[25]) << 8) |
                ((255 & c[26]) << 16) |
                ((255 & c[27]) << 24),
              u =
                (255 & c[28]) |
                ((255 & c[29]) << 8) |
                ((255 & c[30]) << 16) |
                ((255 & c[31]) << 24),
              v =
                (255 & d[12]) |
                ((255 & d[13]) << 8) |
                ((255 & d[14]) << 16) |
                ((255 & d[15]) << 24),
              w = f,
              x = g,
              y = h,
              z = i,
              A = j,
              B = k,
              C = l,
              D = m,
              E = n,
              F = o,
              G = p,
              H = q,
              I = s,
              J = t,
              K = u,
              L = v,
              M = 0;
            M < 20;
            M += 2
          )
            (A ^= ((e = (w + I) | 0) << 7) | (e >>> 25)),
              (E ^= ((e = (A + w) | 0) << 9) | (e >>> 23)),
              (I ^= ((e = (E + A) | 0) << 13) | (e >>> 19)),
              (w ^= ((e = (I + E) | 0) << 18) | (e >>> 14)),
              (F ^= ((e = (B + x) | 0) << 7) | (e >>> 25)),
              (J ^= ((e = (F + B) | 0) << 9) | (e >>> 23)),
              (x ^= ((e = (J + F) | 0) << 13) | (e >>> 19)),
              (B ^= ((e = (x + J) | 0) << 18) | (e >>> 14)),
              (K ^= ((e = (G + C) | 0) << 7) | (e >>> 25)),
              (y ^= ((e = (K + G) | 0) << 9) | (e >>> 23)),
              (C ^= ((e = (y + K) | 0) << 13) | (e >>> 19)),
              (G ^= ((e = (C + y) | 0) << 18) | (e >>> 14)),
              (z ^= ((e = (L + H) | 0) << 7) | (e >>> 25)),
              (D ^= ((e = (z + L) | 0) << 9) | (e >>> 23)),
              (H ^= ((e = (D + z) | 0) << 13) | (e >>> 19)),
              (L ^= ((e = (H + D) | 0) << 18) | (e >>> 14)),
              (x ^= ((e = (w + z) | 0) << 7) | (e >>> 25)),
              (y ^= ((e = (x + w) | 0) << 9) | (e >>> 23)),
              (z ^= ((e = (y + x) | 0) << 13) | (e >>> 19)),
              (w ^= ((e = (z + y) | 0) << 18) | (e >>> 14)),
              (C ^= ((e = (B + A) | 0) << 7) | (e >>> 25)),
              (D ^= ((e = (C + B) | 0) << 9) | (e >>> 23)),
              (A ^= ((e = (D + C) | 0) << 13) | (e >>> 19)),
              (B ^= ((e = (A + D) | 0) << 18) | (e >>> 14)),
              (H ^= ((e = (G + F) | 0) << 7) | (e >>> 25)),
              (E ^= ((e = (H + G) | 0) << 9) | (e >>> 23)),
              (F ^= ((e = (E + H) | 0) << 13) | (e >>> 19)),
              (G ^= ((e = (F + E) | 0) << 18) | (e >>> 14)),
              (I ^= ((e = (L + K) | 0) << 7) | (e >>> 25)),
              (J ^= ((e = (I + L) | 0) << 9) | (e >>> 23)),
              (K ^= ((e = (J + I) | 0) << 13) | (e >>> 19)),
              (L ^= ((e = (K + J) | 0) << 18) | (e >>> 14));
          (a[0] = (w >>> 0) & 255),
            (a[1] = (w >>> 8) & 255),
            (a[2] = (w >>> 16) & 255),
            (a[3] = (w >>> 24) & 255),
            (a[4] = (B >>> 0) & 255),
            (a[5] = (B >>> 8) & 255),
            (a[6] = (B >>> 16) & 255),
            (a[7] = (B >>> 24) & 255),
            (a[8] = (G >>> 0) & 255),
            (a[9] = (G >>> 8) & 255),
            (a[10] = (G >>> 16) & 255),
            (a[11] = (G >>> 24) & 255),
            (a[12] = (L >>> 0) & 255),
            (a[13] = (L >>> 8) & 255),
            (a[14] = (L >>> 16) & 255),
            (a[15] = (L >>> 24) & 255),
            (a[16] = (C >>> 0) & 255),
            (a[17] = (C >>> 8) & 255),
            (a[18] = (C >>> 16) & 255),
            (a[19] = (C >>> 24) & 255),
            (a[20] = (D >>> 0) & 255),
            (a[21] = (D >>> 8) & 255),
            (a[22] = (D >>> 16) & 255),
            (a[23] = (D >>> 24) & 255),
            (a[24] = (E >>> 0) & 255),
            (a[25] = (E >>> 8) & 255),
            (a[26] = (E >>> 16) & 255),
            (a[27] = (E >>> 24) & 255),
            (a[28] = (F >>> 0) & 255),
            (a[29] = (F >>> 8) & 255),
            (a[30] = (F >>> 16) & 255),
            (a[31] = (F >>> 24) & 255);
        })(a, b, c, d);
      }
      var w = new Uint8Array([
        101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107,
      ]);
      function x(a, b, c, d, e, f, g) {
        var h,
          i,
          j = new Uint8Array(16),
          k = new Uint8Array(64);
        for (i = 0; i < 16; i++) j[i] = 0;
        for (i = 0; i < 8; i++) j[i] = f[i];
        for (; e >= 64; ) {
          for (u(k, j, g, w), i = 0; i < 64; i++) a[b + i] = c[d + i] ^ k[i];
          for (i = 8, h = 1; i < 16; i++)
            (h = (h + (255 & j[i])) | 0), (j[i] = 255 & h), (h >>>= 8);
          (e -= 64), (b += 64), (d += 64);
        }
        if (e > 0) for (u(k, j, g, w), i = 0; i < e; i++) a[b + i] = c[d + i] ^ k[i];
        return 0;
      }
      function y(a, b, c, d, e) {
        var f,
          g,
          h = new Uint8Array(16),
          i = new Uint8Array(64);
        for (g = 0; g < 16; g++) h[g] = 0;
        for (g = 0; g < 8; g++) h[g] = d[g];
        for (; c >= 64; ) {
          for (u(i, h, e, w), g = 0; g < 64; g++) a[b + g] = i[g];
          for (g = 8, f = 1; g < 16; g++)
            (f = (f + (255 & h[g])) | 0), (h[g] = 255 & f), (f >>>= 8);
          (c -= 64), (b += 64);
        }
        if (c > 0) for (u(i, h, e, w), g = 0; g < c; g++) a[b + g] = i[g];
        return 0;
      }
      function z(a, b, c, d, e) {
        var f = new Uint8Array(32);
        v(f, d, e, w);
        for (var g = new Uint8Array(8), h = 0; h < 8; h++) g[h] = d[h + 16];
        return y(a, b, c, g, f);
      }
      function A(a, b, c, d, e, f, g) {
        var h = new Uint8Array(32);
        v(h, f, g, w);
        for (var i = new Uint8Array(8), j = 0; j < 8; j++) i[j] = f[j + 16];
        return x(a, b, c, d, e, i, h);
      }
      var B = function (a) {
        var b, c, d, e, f, g, h, i;
        (this.buffer = new Uint8Array(16)),
          (this.r = new Uint16Array(10)),
          (this.h = new Uint16Array(10)),
          (this.pad = new Uint16Array(8)),
          (this.leftover = 0),
          (this.fin = 0),
          (b = (255 & a[0]) | ((255 & a[1]) << 8)),
          (this.r[0] = 8191 & b),
          (c = (255 & a[2]) | ((255 & a[3]) << 8)),
          (this.r[1] = ((b >>> 13) | (c << 3)) & 8191),
          (d = (255 & a[4]) | ((255 & a[5]) << 8)),
          (this.r[2] = ((c >>> 10) | (d << 6)) & 7939),
          (e = (255 & a[6]) | ((255 & a[7]) << 8)),
          (this.r[3] = ((d >>> 7) | (e << 9)) & 8191),
          (f = (255 & a[8]) | ((255 & a[9]) << 8)),
          (this.r[4] = ((e >>> 4) | (f << 12)) & 255),
          (this.r[5] = (f >>> 1) & 8190),
          (g = (255 & a[10]) | ((255 & a[11]) << 8)),
          (this.r[6] = ((f >>> 14) | (g << 2)) & 8191),
          (h = (255 & a[12]) | ((255 & a[13]) << 8)),
          (this.r[7] = ((g >>> 11) | (h << 5)) & 8065),
          (i = (255 & a[14]) | ((255 & a[15]) << 8)),
          (this.r[8] = ((h >>> 8) | (i << 8)) & 8191),
          (this.r[9] = (i >>> 5) & 127),
          (this.pad[0] = (255 & a[16]) | ((255 & a[17]) << 8)),
          (this.pad[1] = (255 & a[18]) | ((255 & a[19]) << 8)),
          (this.pad[2] = (255 & a[20]) | ((255 & a[21]) << 8)),
          (this.pad[3] = (255 & a[22]) | ((255 & a[23]) << 8)),
          (this.pad[4] = (255 & a[24]) | ((255 & a[25]) << 8)),
          (this.pad[5] = (255 & a[26]) | ((255 & a[27]) << 8)),
          (this.pad[6] = (255 & a[28]) | ((255 & a[29]) << 8)),
          (this.pad[7] = (255 & a[30]) | ((255 & a[31]) << 8));
      };
      function C(a, b, c, d, e, f) {
        var g = new B(f);
        return g.update(c, d, e), g.finish(a, b), 0;
      }
      function D(a, b, c, d, e, f) {
        var g = new Uint8Array(16);
        return C(g, 0, c, d, e, f), s(a, b, g, 0);
      }
      function E(a, b, c, d, e) {
        var f;
        if (c < 32) return -1;
        for (A(a, 0, b, 0, c, d, e), C(a, 16, a, 32, c - 32, a), f = 0; f < 16; f++) a[f] = 0;
        return 0;
      }
      function F(a, b, c, d, e) {
        var f,
          g = new Uint8Array(32);
        if (c < 32 || (z(g, 0, 32, d, e), 0 !== D(b, 16, b, 32, c - 32, g))) return -1;
        for (A(a, 0, b, 0, c, d, e), f = 0; f < 32; f++) a[f] = 0;
        return 0;
      }
      function G(a, b) {
        var c;
        for (c = 0; c < 16; c++) a[c] = 0 | b[c];
      }
      function H(a) {
        var b,
          c,
          d = 1;
        for (b = 0; b < 16; b++)
          (d = Math.floor((c = a[b] + d + 65535) / 65536)), (a[b] = c - 65536 * d);
        a[0] += d - 1 + 37 * (d - 1);
      }
      function I(a, b, c) {
        for (var d, e = ~(c - 1), f = 0; f < 16; f++)
          (d = e & (a[f] ^ b[f])), (a[f] ^= d), (b[f] ^= d);
      }
      function J(a, b) {
        var c,
          e,
          f,
          g = d(),
          h = d();
        for (c = 0; c < 16; c++) h[c] = b[c];
        for (H(h), H(h), H(h), e = 0; e < 2; e++) {
          for (c = 1, g[0] = h[0] - 65517; c < 15; c++)
            (g[c] = h[c] - 65535 - ((g[c - 1] >> 16) & 1)), (g[c - 1] &= 65535);
          (g[15] = h[15] - 32767 - ((g[14] >> 16) & 1)),
            (f = (g[15] >> 16) & 1),
            (g[14] &= 65535),
            I(h, g, 1 - f);
        }
        for (c = 0; c < 16; c++) (a[2 * c] = 255 & h[c]), (a[2 * c + 1] = h[c] >> 8);
      }
      function K(a, b) {
        var c = new Uint8Array(32),
          d = new Uint8Array(32);
        return J(c, a), J(d, b), t(c, 0, d, 0);
      }
      function L(a) {
        var b = new Uint8Array(32);
        return J(b, a), 1 & b[0];
      }
      function M(a, b) {
        var c;
        for (c = 0; c < 16; c++) a[c] = b[2 * c] + (b[2 * c + 1] << 8);
        a[15] &= 32767;
      }
      function N(a, b, c) {
        for (var d = 0; d < 16; d++) a[d] = b[d] + c[d];
      }
      function O(a, b, c) {
        for (var d = 0; d < 16; d++) a[d] = b[d] - c[d];
      }
      function P(a, b, c) {
        var d,
          e,
          f = 0,
          g = 0,
          h = 0,
          i = 0,
          j = 0,
          k = 0,
          l = 0,
          m = 0,
          n = 0,
          o = 0,
          p = 0,
          q = 0,
          s = 0,
          t = 0,
          u = 0,
          v = 0,
          w = 0,
          x = 0,
          y = 0,
          z = 0,
          A = 0,
          B = 0,
          C = 0,
          D = 0,
          E = 0,
          F = 0,
          G = 0,
          H = 0,
          I = 0,
          J = 0,
          K = 0,
          L = c[0],
          M = c[1],
          N = c[2],
          O = c[3],
          P = c[4],
          Q = c[5],
          R = c[6],
          S = c[7],
          T = c[8],
          U = c[9],
          V = c[10],
          W = c[11],
          X = c[12],
          Y = c[13],
          Z = c[14],
          $ = c[15];
        (f += (d = b[0]) * L),
          (g += d * M),
          (h += d * N),
          (i += d * O),
          (j += d * P),
          (k += d * Q),
          (l += d * R),
          (m += d * S),
          (n += d * T),
          (o += d * U),
          (p += d * V),
          (q += d * W),
          (s += d * X),
          (t += d * Y),
          (u += d * Z),
          (v += d * $),
          (g += (d = b[1]) * L),
          (h += d * M),
          (i += d * N),
          (j += d * O),
          (k += d * P),
          (l += d * Q),
          (m += d * R),
          (n += d * S),
          (o += d * T),
          (p += d * U),
          (q += d * V),
          (s += d * W),
          (t += d * X),
          (u += d * Y),
          (v += d * Z),
          (w += d * $),
          (h += (d = b[2]) * L),
          (i += d * M),
          (j += d * N),
          (k += d * O),
          (l += d * P),
          (m += d * Q),
          (n += d * R),
          (o += d * S),
          (p += d * T),
          (q += d * U),
          (s += d * V),
          (t += d * W),
          (u += d * X),
          (v += d * Y),
          (w += d * Z),
          (x += d * $),
          (i += (d = b[3]) * L),
          (j += d * M),
          (k += d * N),
          (l += d * O),
          (m += d * P),
          (n += d * Q),
          (o += d * R),
          (p += d * S),
          (q += d * T),
          (s += d * U),
          (t += d * V),
          (u += d * W),
          (v += d * X),
          (w += d * Y),
          (x += d * Z),
          (y += d * $),
          (j += (d = b[4]) * L),
          (k += d * M),
          (l += d * N),
          (m += d * O),
          (n += d * P),
          (o += d * Q),
          (p += d * R),
          (q += d * S),
          (s += d * T),
          (t += d * U),
          (u += d * V),
          (v += d * W),
          (w += d * X),
          (x += d * Y),
          (y += d * Z),
          (z += d * $),
          (k += (d = b[5]) * L),
          (l += d * M),
          (m += d * N),
          (n += d * O),
          (o += d * P),
          (p += d * Q),
          (q += d * R),
          (s += d * S),
          (t += d * T),
          (u += d * U),
          (v += d * V),
          (w += d * W),
          (x += d * X),
          (y += d * Y),
          (z += d * Z),
          (A += d * $),
          (l += (d = b[6]) * L),
          (m += d * M),
          (n += d * N),
          (o += d * O),
          (p += d * P),
          (q += d * Q),
          (s += d * R),
          (t += d * S),
          (u += d * T),
          (v += d * U),
          (w += d * V),
          (x += d * W),
          (y += d * X),
          (z += d * Y),
          (A += d * Z),
          (B += d * $),
          (m += (d = b[7]) * L),
          (n += d * M),
          (o += d * N),
          (p += d * O),
          (q += d * P),
          (s += d * Q),
          (t += d * R),
          (u += d * S),
          (v += d * T),
          (w += d * U),
          (x += d * V),
          (y += d * W),
          (z += d * X),
          (A += d * Y),
          (B += d * Z),
          (C += d * $),
          (n += (d = b[8]) * L),
          (o += d * M),
          (p += d * N),
          (q += d * O),
          (s += d * P),
          (t += d * Q),
          (u += d * R),
          (v += d * S),
          (w += d * T),
          (x += d * U),
          (y += d * V),
          (z += d * W),
          (A += d * X),
          (B += d * Y),
          (C += d * Z),
          (D += d * $),
          (o += (d = b[9]) * L),
          (p += d * M),
          (q += d * N),
          (s += d * O),
          (t += d * P),
          (u += d * Q),
          (v += d * R),
          (w += d * S),
          (x += d * T),
          (y += d * U),
          (z += d * V),
          (A += d * W),
          (B += d * X),
          (C += d * Y),
          (D += d * Z),
          (E += d * $),
          (p += (d = b[10]) * L),
          (q += d * M),
          (s += d * N),
          (t += d * O),
          (u += d * P),
          (v += d * Q),
          (w += d * R),
          (x += d * S),
          (y += d * T),
          (z += d * U),
          (A += d * V),
          (B += d * W),
          (C += d * X),
          (D += d * Y),
          (E += d * Z),
          (F += d * $),
          (q += (d = b[11]) * L),
          (s += d * M),
          (t += d * N),
          (u += d * O),
          (v += d * P),
          (w += d * Q),
          (x += d * R),
          (y += d * S),
          (z += d * T),
          (A += d * U),
          (B += d * V),
          (C += d * W),
          (D += d * X),
          (E += d * Y),
          (F += d * Z),
          (G += d * $),
          (s += (d = b[12]) * L),
          (t += d * M),
          (u += d * N),
          (v += d * O),
          (w += d * P),
          (x += d * Q),
          (y += d * R),
          (z += d * S),
          (A += d * T),
          (B += d * U),
          (C += d * V),
          (D += d * W),
          (E += d * X),
          (F += d * Y),
          (G += d * Z),
          (H += d * $),
          (t += (d = b[13]) * L),
          (u += d * M),
          (v += d * N),
          (w += d * O),
          (x += d * P),
          (y += d * Q),
          (z += d * R),
          (A += d * S),
          (B += d * T),
          (C += d * U),
          (D += d * V),
          (E += d * W),
          (F += d * X),
          (G += d * Y),
          (H += d * Z),
          (I += d * $),
          (u += (d = b[14]) * L),
          (v += d * M),
          (w += d * N),
          (x += d * O),
          (y += d * P),
          (z += d * Q),
          (A += d * R),
          (B += d * S),
          (C += d * T),
          (D += d * U),
          (E += d * V),
          (F += d * W),
          (G += d * X),
          (H += d * Y),
          (I += d * Z),
          (J += d * $),
          (v += (d = b[15]) * L),
          (w += d * M),
          (x += d * N),
          (y += d * O),
          (z += d * P),
          (A += d * Q),
          (B += d * R),
          (C += d * S),
          (D += d * T),
          (E += d * U),
          (F += d * V),
          (G += d * W),
          (H += d * X),
          (I += d * Y),
          (J += d * Z),
          (K += d * $),
          (f += 38 * w),
          (g += 38 * x),
          (h += 38 * y),
          (i += 38 * z),
          (j += 38 * A),
          (k += 38 * B),
          (l += 38 * C),
          (m += 38 * D),
          (n += 38 * E),
          (o += 38 * F),
          (p += 38 * G),
          (q += 38 * H),
          (s += 38 * I),
          (t += 38 * J),
          (u += 38 * K),
          (e = Math.floor((d = f + (e = 1) + 65535) / 65536)),
          (f = d - 65536 * e),
          (e = Math.floor((d = g + e + 65535) / 65536)),
          (g = d - 65536 * e),
          (e = Math.floor((d = h + e + 65535) / 65536)),
          (h = d - 65536 * e),
          (e = Math.floor((d = i + e + 65535) / 65536)),
          (i = d - 65536 * e),
          (e = Math.floor((d = j + e + 65535) / 65536)),
          (j = d - 65536 * e),
          (e = Math.floor((d = k + e + 65535) / 65536)),
          (k = d - 65536 * e),
          (e = Math.floor((d = l + e + 65535) / 65536)),
          (l = d - 65536 * e),
          (e = Math.floor((d = m + e + 65535) / 65536)),
          (m = d - 65536 * e),
          (e = Math.floor((d = n + e + 65535) / 65536)),
          (n = d - 65536 * e),
          (e = Math.floor((d = o + e + 65535) / 65536)),
          (o = d - 65536 * e),
          (e = Math.floor((d = p + e + 65535) / 65536)),
          (p = d - 65536 * e),
          (e = Math.floor((d = q + e + 65535) / 65536)),
          (q = d - 65536 * e),
          (e = Math.floor((d = s + e + 65535) / 65536)),
          (s = d - 65536 * e),
          (e = Math.floor((d = t + e + 65535) / 65536)),
          (t = d - 65536 * e),
          (e = Math.floor((d = u + e + 65535) / 65536)),
          (u = d - 65536 * e),
          (e = Math.floor((d = v + e + 65535) / 65536)),
          (v = d - 65536 * e),
          (f += e - 1 + 37 * (e - 1)),
          (e = Math.floor((d = f + (e = 1) + 65535) / 65536)),
          (f = d - 65536 * e),
          (e = Math.floor((d = g + e + 65535) / 65536)),
          (g = d - 65536 * e),
          (e = Math.floor((d = h + e + 65535) / 65536)),
          (h = d - 65536 * e),
          (e = Math.floor((d = i + e + 65535) / 65536)),
          (i = d - 65536 * e),
          (e = Math.floor((d = j + e + 65535) / 65536)),
          (j = d - 65536 * e),
          (e = Math.floor((d = k + e + 65535) / 65536)),
          (k = d - 65536 * e),
          (e = Math.floor((d = l + e + 65535) / 65536)),
          (l = d - 65536 * e),
          (e = Math.floor((d = m + e + 65535) / 65536)),
          (m = d - 65536 * e),
          (e = Math.floor((d = n + e + 65535) / 65536)),
          (n = d - 65536 * e),
          (e = Math.floor((d = o + e + 65535) / 65536)),
          (o = d - 65536 * e),
          (e = Math.floor((d = p + e + 65535) / 65536)),
          (p = d - 65536 * e),
          (e = Math.floor((d = q + e + 65535) / 65536)),
          (q = d - 65536 * e),
          (e = Math.floor((d = s + e + 65535) / 65536)),
          (s = d - 65536 * e),
          (e = Math.floor((d = t + e + 65535) / 65536)),
          (t = d - 65536 * e),
          (e = Math.floor((d = u + e + 65535) / 65536)),
          (u = d - 65536 * e),
          (e = Math.floor((d = v + e + 65535) / 65536)),
          (v = d - 65536 * e),
          (f += e - 1 + 37 * (e - 1)),
          (a[0] = f),
          (a[1] = g),
          (a[2] = h),
          (a[3] = i),
          (a[4] = j),
          (a[5] = k),
          (a[6] = l),
          (a[7] = m),
          (a[8] = n),
          (a[9] = o),
          (a[10] = p),
          (a[11] = q),
          (a[12] = s),
          (a[13] = t),
          (a[14] = u),
          (a[15] = v);
      }
      function Q(a, b) {
        P(a, b, b);
      }
      function R(a, b) {
        var c,
          e = d();
        for (c = 0; c < 16; c++) e[c] = b[c];
        for (c = 253; c >= 0; c--) Q(e, e), 2 !== c && 4 !== c && P(e, e, b);
        for (c = 0; c < 16; c++) a[c] = e[c];
      }
      function S(a, b) {
        var c,
          e = d();
        for (c = 0; c < 16; c++) e[c] = b[c];
        for (c = 250; c >= 0; c--) Q(e, e), 1 !== c && P(e, e, b);
        for (c = 0; c < 16; c++) a[c] = e[c];
      }
      function T(a, b, c) {
        var e,
          f,
          g = new Uint8Array(32),
          h = new Float64Array(80),
          i = d(),
          k = d(),
          l = d(),
          m = d(),
          n = d(),
          o = d();
        for (f = 0; f < 31; f++) g[f] = b[f];
        for (g[31] = (127 & b[31]) | 64, g[0] &= 248, M(h, c), f = 0; f < 16; f++)
          (k[f] = h[f]), (m[f] = i[f] = l[f] = 0);
        for (f = 254, i[0] = m[0] = 1; f >= 0; --f)
          I(i, k, (e = (g[f >>> 3] >>> (7 & f)) & 1)),
            I(l, m, e),
            N(n, i, l),
            O(i, i, l),
            N(l, k, m),
            O(k, k, m),
            Q(m, n),
            Q(o, i),
            P(i, l, i),
            P(l, k, n),
            N(n, i, l),
            O(i, i, l),
            Q(k, i),
            O(l, m, o),
            P(i, l, j),
            N(i, i, m),
            P(l, l, i),
            P(i, m, o),
            P(m, k, h),
            Q(k, n),
            I(i, k, e),
            I(l, m, e);
        for (f = 0; f < 16; f++)
          (h[f + 16] = i[f]), (h[f + 32] = l[f]), (h[f + 48] = k[f]), (h[f + 64] = m[f]);
        var p = h.subarray(32),
          q = h.subarray(16);
        return R(p, p), P(q, q, p), J(a, q), 0;
      }
      function U(a, b) {
        return T(a, b, g);
      }
      function V(a, b) {
        return e(b, 32), U(a, b);
      }
      function W(a, b, c) {
        var d = new Uint8Array(32);
        return T(d, c, b), v(a, f, d, w);
      }
      (B.prototype.blocks = function (a, b, c) {
        for (
          var d,
            e,
            f,
            g,
            h,
            i,
            j,
            k,
            l,
            m,
            n,
            o,
            p,
            q,
            s,
            t,
            u,
            v,
            w,
            x = 2048 * !this.fin,
            y = this.h[0],
            z = this.h[1],
            A = this.h[2],
            B = this.h[3],
            C = this.h[4],
            D = this.h[5],
            E = this.h[6],
            F = this.h[7],
            G = this.h[8],
            H = this.h[9],
            I = this.r[0],
            J = this.r[1],
            K = this.r[2],
            L = this.r[3],
            M = this.r[4],
            N = this.r[5],
            O = this.r[6],
            P = this.r[7],
            Q = this.r[8],
            R = this.r[9];
          c >= 16;

        )
          (y += 8191 & (d = (255 & a[b + 0]) | ((255 & a[b + 1]) << 8))),
            (z += ((d >>> 13) | ((e = (255 & a[b + 2]) | ((255 & a[b + 3]) << 8)) << 3)) & 8191),
            (A += ((e >>> 10) | ((f = (255 & a[b + 4]) | ((255 & a[b + 5]) << 8)) << 6)) & 8191),
            (B += ((f >>> 7) | ((g = (255 & a[b + 6]) | ((255 & a[b + 7]) << 8)) << 9)) & 8191),
            (C += ((g >>> 4) | ((h = (255 & a[b + 8]) | ((255 & a[b + 9]) << 8)) << 12)) & 8191),
            (D += (h >>> 1) & 8191),
            (E += ((h >>> 14) | ((i = (255 & a[b + 10]) | ((255 & a[b + 11]) << 8)) << 2)) & 8191),
            (F += ((i >>> 11) | ((j = (255 & a[b + 12]) | ((255 & a[b + 13]) << 8)) << 5)) & 8191),
            (G += ((j >>> 8) | ((k = (255 & a[b + 14]) | ((255 & a[b + 15]) << 8)) << 8)) & 8191),
            (H += (k >>> 5) | x),
            (l = (m = (l = 0) + y * I + 5 * R * z + 5 * Q * A + 5 * P * B + 5 * O * C) >>> 13),
            (m &= 8191),
            (m += 5 * N * D),
            (m += 5 * M * E),
            (m += 5 * L * F),
            (m += 5 * K * G),
            (m += 5 * J * H),
            (l += m >>> 13),
            (m &= 8191),
            (l = (n = l + y * J + z * I + 5 * R * A + 5 * Q * B + 5 * P * C) >>> 13),
            (n &= 8191),
            (n += 5 * O * D),
            (n += 5 * N * E),
            (n += 5 * M * F),
            (n += 5 * L * G),
            (n += 5 * K * H),
            (l += n >>> 13),
            (n &= 8191),
            (l = (o = l + y * K + z * J + A * I + 5 * R * B + 5 * Q * C) >>> 13),
            (o &= 8191),
            (o += 5 * P * D),
            (o += 5 * O * E),
            (o += 5 * N * F),
            (o += 5 * M * G),
            (o += 5 * L * H),
            (l += o >>> 13),
            (o &= 8191),
            (l = (p = l + y * L + z * K + A * J + B * I + 5 * R * C) >>> 13),
            (p &= 8191),
            (p += 5 * Q * D),
            (p += 5 * P * E),
            (p += 5 * O * F),
            (p += 5 * N * G),
            (p += 5 * M * H),
            (l += p >>> 13),
            (p &= 8191),
            (l = (q = l + y * M + z * L + A * K + B * J + C * I) >>> 13),
            (q &= 8191),
            (q += 5 * R * D),
            (q += 5 * Q * E),
            (q += 5 * P * F),
            (q += 5 * O * G),
            (q += 5 * N * H),
            (l += q >>> 13),
            (q &= 8191),
            (l = (s = l + y * N + z * M + A * L + B * K + C * J) >>> 13),
            (s &= 8191),
            (s += D * I),
            (s += 5 * R * E),
            (s += 5 * Q * F),
            (s += 5 * P * G),
            (s += 5 * O * H),
            (l += s >>> 13),
            (s &= 8191),
            (l = (t = l + y * O + z * N + A * M + B * L + C * K) >>> 13),
            (t &= 8191),
            (t += D * J),
            (t += E * I),
            (t += 5 * R * F),
            (t += 5 * Q * G),
            (t += 5 * P * H),
            (l += t >>> 13),
            (t &= 8191),
            (l = (u = l + y * P + z * O + A * N + B * M + C * L) >>> 13),
            (u &= 8191),
            (u += D * K),
            (u += E * J),
            (u += F * I),
            (u += 5 * R * G),
            (u += 5 * Q * H),
            (l += u >>> 13),
            (u &= 8191),
            (l = (v = l + y * Q + z * P + A * O + B * N + C * M) >>> 13),
            (v &= 8191),
            (v += D * L),
            (v += E * K),
            (v += F * J),
            (v += G * I),
            (v += 5 * R * H),
            (l += v >>> 13),
            (v &= 8191),
            (l = (w = l + y * R + z * Q + A * P + B * O + C * N) >>> 13),
            (w &= 8191),
            (w += D * M),
            (w += E * L),
            (w += F * K),
            (w += G * J),
            (w += H * I),
            (l += w >>> 13),
            (w &= 8191),
            (m = 8191 & (l = ((l = ((l << 2) + l) | 0) + m) | 0)),
            (l >>>= 13),
            (n += l),
            (y = m),
            (z = n),
            (A = o),
            (B = p),
            (C = q),
            (D = s),
            (E = t),
            (F = u),
            (G = v),
            (H = w),
            (b += 16),
            (c -= 16);
        (this.h[0] = y),
          (this.h[1] = z),
          (this.h[2] = A),
          (this.h[3] = B),
          (this.h[4] = C),
          (this.h[5] = D),
          (this.h[6] = E),
          (this.h[7] = F),
          (this.h[8] = G),
          (this.h[9] = H);
      }),
        (B.prototype.finish = function (a, b) {
          var c,
            d,
            e,
            f,
            g = new Uint16Array(10);
          if (this.leftover) {
            for (f = this.leftover, this.buffer[f++] = 1; f < 16; f++) this.buffer[f] = 0;
            (this.fin = 1), this.blocks(this.buffer, 0, 16);
          }
          for (c = this.h[1] >>> 13, this.h[1] &= 8191, f = 2; f < 10; f++)
            (this.h[f] += c), (c = this.h[f] >>> 13), (this.h[f] &= 8191);
          for (
            this.h[0] += 5 * c,
              c = this.h[0] >>> 13,
              this.h[0] &= 8191,
              this.h[1] += c,
              c = this.h[1] >>> 13,
              this.h[1] &= 8191,
              this.h[2] += c,
              g[0] = this.h[0] + 5,
              c = g[0] >>> 13,
              g[0] &= 8191,
              f = 1;
            f < 10;
            f++
          )
            (g[f] = this.h[f] + c), (c = g[f] >>> 13), (g[f] &= 8191);
          for (g[9] -= 8192, d = (1 ^ c) - 1, f = 0; f < 10; f++) g[f] &= d;
          for (f = 0, d = ~d; f < 10; f++) this.h[f] = (this.h[f] & d) | g[f];
          for (
            f = 1,
              this.h[0] = (this.h[0] | (this.h[1] << 13)) & 65535,
              this.h[1] = ((this.h[1] >>> 3) | (this.h[2] << 10)) & 65535,
              this.h[2] = ((this.h[2] >>> 6) | (this.h[3] << 7)) & 65535,
              this.h[3] = ((this.h[3] >>> 9) | (this.h[4] << 4)) & 65535,
              this.h[4] = ((this.h[4] >>> 12) | (this.h[5] << 1) | (this.h[6] << 14)) & 65535,
              this.h[5] = ((this.h[6] >>> 2) | (this.h[7] << 11)) & 65535,
              this.h[6] = ((this.h[7] >>> 5) | (this.h[8] << 8)) & 65535,
              this.h[7] = ((this.h[8] >>> 8) | (this.h[9] << 5)) & 65535,
              e = this.h[0] + this.pad[0],
              this.h[0] = 65535 & e;
            f < 8;
            f++
          )
            (e = (((this.h[f] + this.pad[f]) | 0) + (e >>> 16)) | 0), (this.h[f] = 65535 & e);
          (a[b + 0] = (this.h[0] >>> 0) & 255),
            (a[b + 1] = (this.h[0] >>> 8) & 255),
            (a[b + 2] = (this.h[1] >>> 0) & 255),
            (a[b + 3] = (this.h[1] >>> 8) & 255),
            (a[b + 4] = (this.h[2] >>> 0) & 255),
            (a[b + 5] = (this.h[2] >>> 8) & 255),
            (a[b + 6] = (this.h[3] >>> 0) & 255),
            (a[b + 7] = (this.h[3] >>> 8) & 255),
            (a[b + 8] = (this.h[4] >>> 0) & 255),
            (a[b + 9] = (this.h[4] >>> 8) & 255),
            (a[b + 10] = (this.h[5] >>> 0) & 255),
            (a[b + 11] = (this.h[5] >>> 8) & 255),
            (a[b + 12] = (this.h[6] >>> 0) & 255),
            (a[b + 13] = (this.h[6] >>> 8) & 255),
            (a[b + 14] = (this.h[7] >>> 0) & 255),
            (a[b + 15] = (this.h[7] >>> 8) & 255);
        }),
        (B.prototype.update = function (a, b, c) {
          var d, e;
          if (this.leftover) {
            for ((e = 16 - this.leftover) > c && (e = c), d = 0; d < e; d++)
              this.buffer[this.leftover + d] = a[b + d];
            if (((c -= e), (b += e), (this.leftover += e), this.leftover < 16)) return;
            this.blocks(this.buffer, 0, 16), (this.leftover = 0);
          }
          if ((c >= 16 && ((e = c - (c % 16)), this.blocks(a, b, e), (b += e), (c -= e)), c)) {
            for (d = 0; d < c; d++) this.buffer[this.leftover + d] = a[b + d];
            this.leftover += c;
          }
        });
      var X = [
        0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd, 0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5,
        0x8189dbbc, 0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019, 0x923f82a4, 0xaf194f9b,
        0xab1c5ed5, 0xda6d8118, 0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe, 0x243185be,
        0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2, 0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,
        0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694, 0xe49b69c1, 0x9ef14ad2, 0xefbe4786,
        0x384f25e3, 0xfc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65, 0x2de92c6f, 0x592b0275,
        0x4a7484aa, 0x6ea6e483, 0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5, 0x983e5152,
        0xee66dfab, 0xa831c66d, 0x2db43210, 0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,
        0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725, 0x6ca6351, 0xe003826f, 0x14292967,
        0xa0e6e70, 0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926, 0x4d2c6dfc, 0x5ac42aed,
        0x53380d13, 0x9d95b3df, 0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8, 0x81c2c92e,
        0x47edaee6, 0x92722c85, 0x1482353b, 0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,
        0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x654be30, 0xd192e819, 0xd6ef5218, 0xd6990624,
        0x5565a910, 0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8, 0x19a4c116, 0xb8d2d0c8,
        0x1e376c08, 0x5141ab53, 0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8, 0x391c0cb3,
        0xc5c95a63, 0x4ed8aa4a, 0xe3418acb, 0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,
        0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60, 0x84c87814, 0xa1f0ab72, 0x8cc70208,
        0x1a6439ec, 0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9, 0xbef9a3f7, 0xb2c67915,
        0xc67178f2, 0xe372532b, 0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207, 0xeada7dd6,
        0xcde0eb1e, 0xf57d4f7f, 0xee6ed178, 0x6f067aa, 0x72176fba, 0xa637dc5, 0xa2c898a6,
        0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b, 0x28db77f5, 0x23047d84, 0x32caab7b,
        0x40c72493, 0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c, 0x4cc5d4be, 0xcb3e42b6,
        0x597f299c, 0xfc657e2a, 0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817,
      ];
      function Y(a, b, c, d) {
        for (
          var e,
            f,
            g,
            h,
            i,
            j,
            k,
            l,
            m,
            n,
            o,
            p,
            q,
            s,
            t,
            u,
            v,
            w,
            x,
            y,
            z,
            A,
            B,
            C,
            D,
            E,
            F = new Int32Array(16),
            G = new Int32Array(16),
            H = a[0],
            I = a[1],
            J = a[2],
            K = a[3],
            L = a[4],
            M = a[5],
            N = a[6],
            O = a[7],
            P = b[0],
            Q = b[1],
            R = b[2],
            S = b[3],
            T = b[4],
            U = b[5],
            V = b[6],
            W = b[7],
            Y = 0;
          d >= 128;

        ) {
          for (x = 0; x < 16; x++)
            (y = 8 * x + Y),
              (F[x] = (c[y + 0] << 24) | (c[y + 1] << 16) | (c[y + 2] << 8) | c[y + 3]),
              (G[x] = (c[y + 4] << 24) | (c[y + 5] << 16) | (c[y + 6] << 8) | c[y + 7]);
          for (x = 0; x < 80; x++)
            if (
              ((e = H),
              (f = I),
              (g = J),
              (h = K),
              (i = L),
              (j = M),
              (k = N),
              (l = O),
              (m = P),
              (n = Q),
              (o = R),
              (p = S),
              (q = T),
              (s = U),
              (t = V),
              (u = W),
              (z = O),
              (B = 65535 & (A = W)),
              (C = A >>> 16),
              (D = 65535 & z),
              (E = z >>> 16),
              (z = ((L >>> 14) | (T << 18)) ^ ((L >>> 18) | (T << 14)) ^ ((T >>> 9) | (L << 23))),
              (B +=
                65535 &
                (A =
                  ((T >>> 14) | (L << 18)) ^ ((T >>> 18) | (L << 14)) ^ ((L >>> 9) | (T << 23)))),
              (C += A >>> 16),
              (D += 65535 & z),
              (E += z >>> 16),
              (z = (L & M) ^ (~L & N)),
              (B += 65535 & (A = (T & U) ^ (~T & V))),
              (C += A >>> 16),
              (D += 65535 & z),
              (E += z >>> 16),
              (z = X[2 * x]),
              (B += 65535 & (A = X[2 * x + 1])),
              (C += A >>> 16),
              (D += 65535 & z),
              (E += z >>> 16),
              (z = F[x % 16]),
              (B += 65535 & (A = G[x % 16])),
              (C += A >>> 16),
              (D += 65535 & z),
              (E += z >>> 16),
              (C += B >>> 16),
              (D += C >>> 16),
              (E += D >>> 16),
              (v = (65535 & D) | (E << 16)),
              (w = (65535 & B) | (C << 16)),
              (z = v),
              (B = 65535 & (A = w)),
              (C = A >>> 16),
              (D = 65535 & z),
              (E = z >>> 16),
              (z = ((H >>> 28) | (P << 4)) ^ ((P >>> 2) | (H << 30)) ^ ((P >>> 7) | (H << 25))),
              (B +=
                65535 &
                (A = ((P >>> 28) | (H << 4)) ^ ((H >>> 2) | (P << 30)) ^ ((H >>> 7) | (P << 25)))),
              (C += A >>> 16),
              (D += 65535 & z),
              (E += z >>> 16),
              (z = (H & I) ^ (H & J) ^ (I & J)),
              (B += 65535 & (A = (P & Q) ^ (P & R) ^ (Q & R))),
              (C += A >>> 16),
              (D += 65535 & z),
              (E += z >>> 16),
              (C += B >>> 16),
              (D += C >>> 16),
              (E += D >>> 16),
              (l = (65535 & D) | (E << 16)),
              (u = (65535 & B) | (C << 16)),
              (z = h),
              (B = 65535 & (A = p)),
              (C = A >>> 16),
              (D = 65535 & z),
              (E = z >>> 16),
              (z = v),
              (B += 65535 & (A = w)),
              (C += A >>> 16),
              (D += 65535 & z),
              (E += z >>> 16),
              (C += B >>> 16),
              (D += C >>> 16),
              (E += D >>> 16),
              (h = (65535 & D) | (E << 16)),
              (p = (65535 & B) | (C << 16)),
              (I = e),
              (J = f),
              (K = g),
              (L = h),
              (M = i),
              (N = j),
              (O = k),
              (H = l),
              (Q = m),
              (R = n),
              (S = o),
              (T = p),
              (U = q),
              (V = s),
              (W = t),
              (P = u),
              x % 16 == 15)
            )
              for (y = 0; y < 16; y++)
                (z = F[y]),
                  (B = 65535 & (A = G[y])),
                  (C = A >>> 16),
                  (D = 65535 & z),
                  (E = z >>> 16),
                  (z = F[(y + 9) % 16]),
                  (B += 65535 & (A = G[(y + 9) % 16])),
                  (C += A >>> 16),
                  (D += 65535 & z),
                  (E += z >>> 16),
                  (z =
                    (((v = F[(y + 1) % 16]) >>> 1) | ((w = G[(y + 1) % 16]) << 31)) ^
                    ((v >>> 8) | (w << 24)) ^
                    (v >>> 7)),
                  (B +=
                    65535 &
                    (A =
                      ((w >>> 1) | (v << 31)) ^ ((w >>> 8) | (v << 24)) ^ ((w >>> 7) | (v << 25)))),
                  (C += A >>> 16),
                  (D += 65535 & z),
                  (E += z >>> 16),
                  (z =
                    (((v = F[(y + 14) % 16]) >>> 19) | ((w = G[(y + 14) % 16]) << 13)) ^
                    ((w >>> 29) | (v << 3)) ^
                    (v >>> 6)),
                  (B +=
                    65535 &
                    (A =
                      ((w >>> 19) | (v << 13)) ^
                      ((v >>> 29) | (w << 3)) ^
                      ((w >>> 6) | (v << 26)))),
                  (C += A >>> 16),
                  (D += 65535 & z),
                  (E += z >>> 16),
                  (C += B >>> 16),
                  (D += C >>> 16),
                  (E += D >>> 16),
                  (F[y] = (65535 & D) | (E << 16)),
                  (G[y] = (65535 & B) | (C << 16));
          (z = H),
            (B = 65535 & (A = P)),
            (C = A >>> 16),
            (D = 65535 & z),
            (E = z >>> 16),
            (z = a[0]),
            (B += 65535 & (A = b[0])),
            (C += A >>> 16),
            (D += 65535 & z),
            (E += z >>> 16),
            (C += B >>> 16),
            (D += C >>> 16),
            (E += D >>> 16),
            (a[0] = H = (65535 & D) | (E << 16)),
            (b[0] = P = (65535 & B) | (C << 16)),
            (z = I),
            (B = 65535 & (A = Q)),
            (C = A >>> 16),
            (D = 65535 & z),
            (E = z >>> 16),
            (z = a[1]),
            (B += 65535 & (A = b[1])),
            (C += A >>> 16),
            (D += 65535 & z),
            (E += z >>> 16),
            (C += B >>> 16),
            (D += C >>> 16),
            (E += D >>> 16),
            (a[1] = I = (65535 & D) | (E << 16)),
            (b[1] = Q = (65535 & B) | (C << 16)),
            (z = J),
            (B = 65535 & (A = R)),
            (C = A >>> 16),
            (D = 65535 & z),
            (E = z >>> 16),
            (z = a[2]),
            (B += 65535 & (A = b[2])),
            (C += A >>> 16),
            (D += 65535 & z),
            (E += z >>> 16),
            (C += B >>> 16),
            (D += C >>> 16),
            (E += D >>> 16),
            (a[2] = J = (65535 & D) | (E << 16)),
            (b[2] = R = (65535 & B) | (C << 16)),
            (z = K),
            (B = 65535 & (A = S)),
            (C = A >>> 16),
            (D = 65535 & z),
            (E = z >>> 16),
            (z = a[3]),
            (B += 65535 & (A = b[3])),
            (C += A >>> 16),
            (D += 65535 & z),
            (E += z >>> 16),
            (C += B >>> 16),
            (D += C >>> 16),
            (E += D >>> 16),
            (a[3] = K = (65535 & D) | (E << 16)),
            (b[3] = S = (65535 & B) | (C << 16)),
            (z = L),
            (B = 65535 & (A = T)),
            (C = A >>> 16),
            (D = 65535 & z),
            (E = z >>> 16),
            (z = a[4]),
            (B += 65535 & (A = b[4])),
            (C += A >>> 16),
            (D += 65535 & z),
            (E += z >>> 16),
            (C += B >>> 16),
            (D += C >>> 16),
            (E += D >>> 16),
            (a[4] = L = (65535 & D) | (E << 16)),
            (b[4] = T = (65535 & B) | (C << 16)),
            (z = M),
            (B = 65535 & (A = U)),
            (C = A >>> 16),
            (D = 65535 & z),
            (E = z >>> 16),
            (z = a[5]),
            (B += 65535 & (A = b[5])),
            (C += A >>> 16),
            (D += 65535 & z),
            (E += z >>> 16),
            (C += B >>> 16),
            (D += C >>> 16),
            (E += D >>> 16),
            (a[5] = M = (65535 & D) | (E << 16)),
            (b[5] = U = (65535 & B) | (C << 16)),
            (z = N),
            (B = 65535 & (A = V)),
            (C = A >>> 16),
            (D = 65535 & z),
            (E = z >>> 16),
            (z = a[6]),
            (B += 65535 & (A = b[6])),
            (C += A >>> 16),
            (D += 65535 & z),
            (E += z >>> 16),
            (C += B >>> 16),
            (D += C >>> 16),
            (E += D >>> 16),
            (a[6] = N = (65535 & D) | (E << 16)),
            (b[6] = V = (65535 & B) | (C << 16)),
            (z = O),
            (B = 65535 & (A = W)),
            (C = A >>> 16),
            (D = 65535 & z),
            (E = z >>> 16),
            (z = a[7]),
            (B += 65535 & (A = b[7])),
            (C += A >>> 16),
            (D += 65535 & z),
            (E += z >>> 16),
            (C += B >>> 16),
            (D += C >>> 16),
            (E += D >>> 16),
            (a[7] = O = (65535 & D) | (E << 16)),
            (b[7] = W = (65535 & B) | (C << 16)),
            (Y += 128),
            (d -= 128);
        }
        return d;
      }
      function Z(a, b, c) {
        var d,
          e = new Int32Array(8),
          f = new Int32Array(8),
          g = new Uint8Array(256),
          h = c;
        for (
          e[0] = 0x6a09e667,
            e[1] = 0xbb67ae85,
            e[2] = 0x3c6ef372,
            e[3] = 0xa54ff53a,
            e[4] = 0x510e527f,
            e[5] = 0x9b05688c,
            e[6] = 0x1f83d9ab,
            e[7] = 0x5be0cd19,
            f[0] = 0xf3bcc908,
            f[1] = 0x84caa73b,
            f[2] = 0xfe94f82b,
            f[3] = 0x5f1d36f1,
            f[4] = 0xade682d1,
            f[5] = 0x2b3e6c1f,
            f[6] = 0xfb41bd6b,
            f[7] = 0x137e2179,
            Y(e, f, b, c),
            c %= 128,
            d = 0;
          d < c;
          d++
        )
          g[d] = b[h - c + d];
        for (
          g[c] = 128,
            g[(c = 256 - (c < 112) * 128) - 9] = 0,
            p(g, c - 8, (h / 0x20000000) | 0, h << 3),
            Y(e, f, g, c),
            d = 0;
          d < 8;
          d++
        )
          p(a, 8 * d, e[d], f[d]);
        return 0;
      }
      function $(a, b) {
        var c = d(),
          e = d(),
          f = d(),
          g = d(),
          h = d(),
          i = d(),
          j = d(),
          k = d(),
          m = d();
        O(c, a[1], a[0]),
          O(m, b[1], b[0]),
          P(c, c, m),
          N(e, a[0], a[1]),
          N(m, b[0], b[1]),
          P(e, e, m),
          P(f, a[3], b[3]),
          P(f, f, l),
          P(g, a[2], b[2]),
          N(g, g, g),
          O(h, e, c),
          O(i, g, f),
          N(j, g, f),
          N(k, e, c),
          P(a[0], h, i),
          P(a[1], k, j),
          P(a[2], j, i),
          P(a[3], h, k);
      }
      function _(a, b, c) {
        var d;
        for (d = 0; d < 4; d++) I(a[d], b[d], c);
      }
      function aa(a, b) {
        var c = d(),
          e = d(),
          f = d();
        R(f, b[2]), P(c, b[0], f), P(e, b[1], f), J(a, e), (a[31] ^= L(c) << 7);
      }
      function ab(a, b, c) {
        var d, e;
        for (G(a[0], h), G(a[1], i), G(a[2], i), G(a[3], h), e = 255; e >= 0; --e)
          _(a, b, (d = (c[(e / 8) | 0] >> (7 & e)) & 1)), $(b, a), $(a, a), _(a, b, d);
      }
      function ac(a, b) {
        var c = [d(), d(), d(), d()];
        G(c[0], m), G(c[1], n), G(c[2], i), P(c[3], m, n), ab(a, c, b);
      }
      function ad(a, b, c) {
        var f,
          g = new Uint8Array(64),
          h = [d(), d(), d(), d()];
        for (
          c || e(b, 32),
            Z(g, b, 32),
            g[0] &= 248,
            g[31] &= 127,
            g[31] |= 64,
            ac(h, g),
            aa(a, h),
            f = 0;
          f < 32;
          f++
        )
          b[f + 32] = a[f];
        return 0;
      }
      var ae = new Float64Array([
        237, 211, 245, 92, 26, 99, 18, 88, 214, 156, 247, 162, 222, 249, 222, 20, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 16,
      ]);
      function af(a, b) {
        var c, d, e, f;
        for (d = 63; d >= 32; --d) {
          for (c = 0, e = d - 32, f = d - 12; e < f; ++e)
            (b[e] += c - 16 * b[d] * ae[e - (d - 32)]),
              (c = Math.floor((b[e] + 128) / 256)),
              (b[e] -= 256 * c);
          (b[e] += c), (b[d] = 0);
        }
        for (e = 0, c = 0; e < 32; e++)
          (b[e] += c - (b[31] >> 4) * ae[e]), (c = b[e] >> 8), (b[e] &= 255);
        for (e = 0; e < 32; e++) b[e] -= c * ae[e];
        for (d = 0; d < 32; d++) (b[d + 1] += b[d] >> 8), (a[d] = 255 & b[d]);
      }
      function ag(a) {
        var b,
          c = new Float64Array(64);
        for (b = 0; b < 64; b++) c[b] = a[b];
        for (b = 0; b < 64; b++) a[b] = 0;
        af(a, c);
      }
      function ah(a, b, c, e) {
        var f,
          g,
          h = new Uint8Array(64),
          i = new Uint8Array(64),
          j = new Uint8Array(64),
          k = new Float64Array(64),
          l = [d(), d(), d(), d()];
        for (Z(h, e, 32), h[0] &= 248, h[31] &= 127, h[31] |= 64, f = 0; f < c; f++)
          a[64 + f] = b[f];
        for (f = 0; f < 32; f++) a[32 + f] = h[32 + f];
        for (Z(j, a.subarray(32), c + 32), ag(j), ac(l, j), aa(a, l), f = 32; f < 64; f++)
          a[f] = e[f];
        for (Z(i, a, c + 64), ag(i), f = 0; f < 64; f++) k[f] = 0;
        for (f = 0; f < 32; f++) k[f] = j[f];
        for (f = 0; f < 32; f++) for (g = 0; g < 32; g++) k[f + g] += i[f] * h[g];
        return af(a.subarray(32), k), c + 64;
      }
      function ai(a, b, c, e) {
        var f,
          g,
          j,
          l,
          m,
          n,
          p,
          q,
          s = new Uint8Array(32),
          u = new Uint8Array(64),
          v = [d(), d(), d(), d()],
          w = [d(), d(), d(), d()];
        if (
          c < 64 ||
          ((f = d()),
          (g = d()),
          (j = d()),
          (l = d()),
          (m = d()),
          (n = d()),
          (p = d()),
          (G(w[2], i),
          M(w[1], e),
          Q(j, w[1]),
          P(l, j, k),
          O(j, j, w[2]),
          N(l, w[2], l),
          Q(m, l),
          Q(n, m),
          P(p, n, m),
          P(f, p, j),
          P(f, f, l),
          S(f, f),
          P(f, f, j),
          P(f, f, l),
          P(f, f, l),
          P(w[0], f, l),
          Q(g, w[0]),
          P(g, g, l),
          K(g, j) && P(w[0], w[0], o),
          Q(g, w[0]),
          P(g, g, l),
          K(g, j))
            ? -1
            : (L(w[0]) === e[31] >> 7 && O(w[0], h, w[0]), P(w[3], w[0], w[1]), 0))
        )
          return -1;
        for (q = 0; q < c; q++) a[q] = b[q];
        for (q = 0; q < 32; q++) a[q + 32] = e[q];
        if (
          (Z(u, a, c),
          ag(u),
          ab(v, w, u),
          ac(w, b.subarray(32)),
          $(v, w),
          aa(s, v),
          (c -= 64),
          t(b, 0, s, 0))
        ) {
          for (q = 0; q < c; q++) a[q] = 0;
          return -1;
        }
        for (q = 0; q < c; q++) a[q] = b[q + 64];
        return c;
      }
      function aj(a, b) {
        if (32 !== a.length) throw Error('bad key size');
        if (24 !== b.length) throw Error('bad nonce size');
      }
      function ak() {
        for (var a = 0; a < arguments.length; a++)
          if (!(arguments[a] instanceof Uint8Array))
            throw TypeError('unexpected type, use Uint8Array');
      }
      function al(a) {
        for (var b = 0; b < a.length; b++) a[b] = 0;
      }
      (b.lowlevel = {
        crypto_core_hsalsa20: v,
        crypto_stream_xor: A,
        crypto_stream: z,
        crypto_stream_salsa20_xor: x,
        crypto_stream_salsa20: y,
        crypto_onetimeauth: C,
        crypto_onetimeauth_verify: D,
        crypto_verify_16: s,
        crypto_verify_32: t,
        crypto_secretbox: E,
        crypto_secretbox_open: F,
        crypto_scalarmult: T,
        crypto_scalarmult_base: U,
        crypto_box_beforenm: W,
        crypto_box_afternm: E,
        crypto_box: function (a, b, c, d, e, f) {
          var g = new Uint8Array(32);
          return W(g, e, f), E(a, b, c, d, g);
        },
        crypto_box_open: function (a, b, c, d, e, f) {
          var g = new Uint8Array(32);
          return W(g, e, f), F(a, b, c, d, g);
        },
        crypto_box_keypair: V,
        crypto_hash: Z,
        crypto_sign: ah,
        crypto_sign_keypair: ad,
        crypto_sign_open: ai,
        crypto_secretbox_KEYBYTES: 32,
        crypto_secretbox_NONCEBYTES: 24,
        crypto_secretbox_ZEROBYTES: 32,
        crypto_secretbox_BOXZEROBYTES: 16,
        crypto_scalarmult_BYTES: 32,
        crypto_scalarmult_SCALARBYTES: 32,
        crypto_box_PUBLICKEYBYTES: 32,
        crypto_box_SECRETKEYBYTES: 32,
        crypto_box_BEFORENMBYTES: 32,
        crypto_box_NONCEBYTES: 24,
        crypto_box_ZEROBYTES: 32,
        crypto_box_BOXZEROBYTES: 16,
        crypto_sign_BYTES: 64,
        crypto_sign_PUBLICKEYBYTES: 32,
        crypto_sign_SECRETKEYBYTES: 64,
        crypto_sign_SEEDBYTES: 32,
        crypto_hash_BYTES: 64,
        gf: d,
        D: k,
        L: ae,
        pack25519: J,
        unpack25519: M,
        M: P,
        A: N,
        S: Q,
        Z: O,
        pow2523: S,
        add: $,
        set25519: G,
        modL: af,
        scalarmult: ab,
        scalarbase: ac,
      }),
        (b.randomBytes = function (a) {
          var b = new Uint8Array(a);
          return e(b, a), b;
        }),
        (b.secretbox = function (a, b, c) {
          ak(a, b, c), aj(c, b);
          for (
            var d = new Uint8Array(32 + a.length), e = new Uint8Array(d.length), f = 0;
            f < a.length;
            f++
          )
            d[f + 32] = a[f];
          return E(e, d, d.length, b, c), e.subarray(16);
        }),
        (b.secretbox.open = function (a, b, c) {
          ak(a, b, c), aj(c, b);
          for (
            var d = new Uint8Array(16 + a.length), e = new Uint8Array(d.length), f = 0;
            f < a.length;
            f++
          )
            d[f + 16] = a[f];
          return d.length < 32 || 0 !== F(e, d, d.length, b, c) ? null : e.subarray(32);
        }),
        (b.secretbox.keyLength = 32),
        (b.secretbox.nonceLength = 24),
        (b.secretbox.overheadLength = 16),
        (b.scalarMult = function (a, b) {
          if ((ak(a, b), 32 !== a.length)) throw Error('bad n size');
          if (32 !== b.length) throw Error('bad p size');
          var c = new Uint8Array(32);
          return T(c, a, b), c;
        }),
        (b.scalarMult.base = function (a) {
          if ((ak(a), 32 !== a.length)) throw Error('bad n size');
          var b = new Uint8Array(32);
          return U(b, a), b;
        }),
        (b.scalarMult.scalarLength = 32),
        (b.scalarMult.groupElementLength = 32),
        (b.box = function (a, c, d, e) {
          var f = b.box.before(d, e);
          return b.secretbox(a, c, f);
        }),
        (b.box.before = function (a, b) {
          ak(a, b);
          if (32 !== a.length) throw Error('bad public key size');
          if (32 !== b.length) throw Error('bad secret key size');
          var c = new Uint8Array(32);
          return W(c, a, b), c;
        }),
        (b.box.after = b.secretbox),
        (b.box.open = function (a, c, d, e) {
          var f = b.box.before(d, e);
          return b.secretbox.open(a, c, f);
        }),
        (b.box.open.after = b.secretbox.open),
        (b.box.keyPair = function () {
          var a = new Uint8Array(32),
            b = new Uint8Array(32);
          return V(a, b), { publicKey: a, secretKey: b };
        }),
        (b.box.keyPair.fromSecretKey = function (a) {
          if ((ak(a), 32 !== a.length)) throw Error('bad secret key size');
          var b = new Uint8Array(32);
          return U(b, a), { publicKey: b, secretKey: new Uint8Array(a) };
        }),
        (b.box.publicKeyLength = 32),
        (b.box.secretKeyLength = 32),
        (b.box.sharedKeyLength = 32),
        (b.box.nonceLength = 24),
        (b.box.overheadLength = b.secretbox.overheadLength),
        (b.sign = function (a, b) {
          if ((ak(a, b), 64 !== b.length)) throw Error('bad secret key size');
          var c = new Uint8Array(64 + a.length);
          return ah(c, a, a.length, b), c;
        }),
        (b.sign.open = function (a, b) {
          if ((ak(a, b), 32 !== b.length)) throw Error('bad public key size');
          var c = new Uint8Array(a.length),
            d = ai(c, a, a.length, b);
          if (d < 0) return null;
          for (var e = new Uint8Array(d), f = 0; f < e.length; f++) e[f] = c[f];
          return e;
        }),
        (b.sign.detached = function (a, c) {
          for (var d = b.sign(a, c), e = new Uint8Array(64), f = 0; f < e.length; f++) e[f] = d[f];
          return e;
        }),
        (b.sign.detached.verify = function (a, b, c) {
          if ((ak(a, b, c), 64 !== b.length)) throw Error('bad signature size');
          if (32 !== c.length) throw Error('bad public key size');
          var d,
            e = new Uint8Array(64 + a.length),
            f = new Uint8Array(64 + a.length);
          for (d = 0; d < 64; d++) e[d] = b[d];
          for (d = 0; d < a.length; d++) e[d + 64] = a[d];
          return ai(f, e, e.length, c) >= 0;
        }),
        (b.sign.keyPair = function () {
          var a = new Uint8Array(32),
            b = new Uint8Array(64);
          return ad(a, b), { publicKey: a, secretKey: b };
        }),
        (b.sign.keyPair.fromSecretKey = function (a) {
          if ((ak(a), 64 !== a.length)) throw Error('bad secret key size');
          for (var b = new Uint8Array(32), c = 0; c < b.length; c++) b[c] = a[32 + c];
          return { publicKey: b, secretKey: new Uint8Array(a) };
        }),
        (b.sign.keyPair.fromSeed = function (a) {
          if ((ak(a), 32 !== a.length)) throw Error('bad seed size');
          for (var b = new Uint8Array(32), c = new Uint8Array(64), d = 0; d < 32; d++) c[d] = a[d];
          return ad(b, c, !0), { publicKey: b, secretKey: c };
        }),
        (b.sign.publicKeyLength = 32),
        (b.sign.secretKeyLength = 64),
        (b.sign.seedLength = 32),
        (b.sign.signatureLength = 64),
        (b.hash = function (a) {
          ak(a);
          var b = new Uint8Array(64);
          return Z(b, a, a.length), b;
        }),
        (b.hash.hashLength = 64),
        (b.verify = function (a, b) {
          return (
            ak(a, b),
            0 !== a.length &&
              0 !== b.length &&
              a.length === b.length &&
              0 === q(a, 0, b, 0, a.length)
          );
        }),
        (b.setPRNG = function (a) {
          e = a;
        }),
        (c = 'undefined' != typeof self ? self.crypto || self.msCrypto : null) && c.getRandomValues
          ? b.setPRNG(function (a, b) {
              var d,
                e = new Uint8Array(b);
              for (d = 0; d < b; d += 65536)
                c.getRandomValues(e.subarray(d, d + Math.min(b - d, 65536)));
              for (d = 0; d < b; d++) a[d] = e[d];
              al(e);
            })
          : (c = a.r(54799)) &&
            c.randomBytes &&
            b.setPRNG(function (a, b) {
              var d,
                e = c.randomBytes(b);
              for (d = 0; d < b; d++) a[d] = e[d];
              al(e);
            });
    })(b.exports ? b.exports : (self.nacl = self.nacl || {}));
  },
  45158,
  (a, b, c) => {
    'use strict';
    Object.defineProperty(c, '__esModule', { value: !0 }), (c.bech32m = c.bech32 = void 0);
    let d = 'qpzry9x8gf2tvdw0s3jn54khce6mua7l',
      e = {};
    for (let a = 0; a < d.length; a++) e[d.charAt(a)] = a;
    function f(a) {
      let b = a >> 25;
      return (
        ((0x1ffffff & a) << 5) ^
        (0x3b6a57b2 & -(1 & b)) ^
        (0x26508e6d & -((b >> 1) & 1)) ^
        (0x1ea119fa & -((b >> 2) & 1)) ^
        (0x3d4233dd & -((b >> 3) & 1)) ^
        (0x2a1462b3 & -((b >> 4) & 1))
      );
    }
    function g(a) {
      let b = 1;
      for (let c = 0; c < a.length; ++c) {
        let d = a.charCodeAt(c);
        if (d < 33 || d > 126) return 'Invalid prefix (' + a + ')';
        b = f(b) ^ (d >> 5);
      }
      b = f(b);
      for (let c = 0; c < a.length; ++c) {
        let d = a.charCodeAt(c);
        b = f(b) ^ (31 & d);
      }
      return b;
    }
    function h(a, b, c, d) {
      let e = 0,
        f = 0,
        g = (1 << c) - 1,
        h = [];
      for (let d = 0; d < a.length; ++d)
        for (e = (e << b) | a[d], f += b; f >= c; ) h.push((e >> (f -= c)) & g);
      if (d) f > 0 && h.push((e << (c - f)) & g);
      else {
        if (f >= b) return 'Excess padding';
        if ((e << (c - f)) & g) return 'Non-zero padding';
      }
      return h;
    }
    function i(a) {
      return h(a, 8, 5, !0);
    }
    function j(a) {
      let b = h(a, 5, 8, !1);
      if (Array.isArray(b)) return b;
    }
    function k(a) {
      let b = h(a, 5, 8, !1);
      if (Array.isArray(b)) return b;
      throw Error(b);
    }
    function l(a) {
      let b;
      function c(a, c) {
        if (((c = c || 90), a.length < 8)) return a + ' too short';
        if (a.length > c) return 'Exceeds length limit';
        let d = a.toLowerCase(),
          h = a.toUpperCase();
        if (a !== d && a !== h) return 'Mixed-case string ' + a;
        let i = (a = d).lastIndexOf('1');
        if (-1 === i) return 'No separator character for ' + a;
        if (0 === i) return 'Missing prefix for ' + a;
        let j = a.slice(0, i),
          k = a.slice(i + 1);
        if (k.length < 6) return 'Data too short';
        let l = g(j);
        if ('string' == typeof l) return l;
        let m = [];
        for (let a = 0; a < k.length; ++a) {
          let b = k.charAt(a),
            c = e[b];
          if (void 0 === c) return 'Unknown character ' + b;
          (l = f(l) ^ c), a + 6 >= k.length || m.push(c);
        }
        return l !== b ? 'Invalid checksum for ' + a : { prefix: j, words: m };
      }
      return (
        (b = 'bech32' === a ? 1 : 0x2bc830a3),
        {
          decodeUnsafe: function (a, b) {
            let d = c(a, b);
            if ('object' == typeof d) return d;
          },
          decode: function (a, b) {
            let d = c(a, b);
            if ('object' == typeof d) return d;
            throw Error(d);
          },
          encode: function (a, c, e) {
            if (((e = e || 90), a.length + 7 + c.length > e))
              throw TypeError('Exceeds length limit');
            let h = g((a = a.toLowerCase()));
            if ('string' == typeof h) throw Error(h);
            let i = a + '1';
            for (let a = 0; a < c.length; ++a) {
              let b = c[a];
              if (b >> 5 != 0) throw Error('Non 5-bit word');
              (h = f(h) ^ b), (i += d.charAt(b));
            }
            for (let a = 0; a < 6; ++a) h = f(h);
            h ^= b;
            for (let a = 0; a < 6; ++a) {
              let b = (h >> ((5 - a) * 5)) & 31;
              i += d.charAt(b);
            }
            return i;
          },
          toWords: i,
          fromWordsUnsafe: j,
          fromWords: k,
        }
      );
    }
    (c.bech32 = l('bech32')), (c.bech32m = l('bech32m'));
  },
  73456,
  (a, b, c) => {
    'use strict';
    var d = {}.hasOwnProperty,
      e = function (a, b) {
        if (!a) return b;
        var c = {};
        for (var e in b) c[e] = d.call(a, e) ? a[e] : b[e];
        return c;
      },
      f = /[ -,\.\/:-@\[-\^`\{-~]/,
      g = /[ -,\.\/:-@\[\]\^`\{-~]/,
      h = /(^|\\+)?(\\[A-F0-9]{1,6})\x20(?![a-fA-F0-9\x20])/g,
      i = function a(b, c) {
        'single' != (c = e(c, a.options)).quotes && 'double' != c.quotes && (c.quotes = 'single');
        for (
          var d = 'double' == c.quotes ? '"' : "'",
            i = c.isIdentifier,
            j = b.charAt(0),
            k = '',
            l = 0,
            m = b.length;
          l < m;

        ) {
          var n = b.charAt(l++),
            o = n.charCodeAt(),
            p = void 0;
          if (o < 32 || o > 126) {
            if (o >= 55296 && o <= 56319 && l < m) {
              var q = b.charCodeAt(l++);
              (64512 & q) == 56320 ? (o = ((1023 & o) << 10) + (1023 & q) + 65536) : l--;
            }
            p = '\\' + o.toString(16).toUpperCase() + ' ';
          } else
            p = c.escapeEverything
              ? f.test(n)
                ? '\\' + n
                : '\\' + o.toString(16).toUpperCase() + ' '
              : /[\t\n\f\r\x0B]/.test(n)
              ? '\\' + o.toString(16).toUpperCase() + ' '
              : '\\' == n ||
                (!i && (('"' == n && d == n) || ("'" == n && d == n))) ||
                (i && g.test(n))
              ? '\\' + n
              : n;
          k += p;
        }
        return (i &&
          (/^-[-\d]/.test(k)
            ? (k = '\\-' + k.slice(1))
            : /\d/.test(j) && (k = '\\3' + j + ' ' + k.slice(1))),
        (k = k.replace(h, function (a, b, c) {
          return b && b.length % 2 ? a : (b || '') + c;
        })),
        !i && c.wrap)
          ? d + k + d
          : k;
      };
    (i.options = { escapeEverything: !1, isIdentifier: !1, quotes: 'single', wrap: !1 }),
      (i.version = '3.0.0'),
      (b.exports = i);
  },
  40226,
  (a, b, c) => {
    let d = process || {},
      e = d.argv || [],
      f = d.env || {},
      g =
        !(f.NO_COLOR || e.includes('--no-color')) &&
        (!!f.FORCE_COLOR ||
          e.includes('--color') ||
          'win32' === d.platform ||
          ((d.stdout || {}).isTTY && 'dumb' !== f.TERM) ||
          !!f.CI),
      h =
        (a, b, c = a) =>
        (d) => {
          let e = '' + d,
            f = e.indexOf(b, a.length);
          return ~f ? a + i(e, b, c, f) + b : a + e + b;
        },
      i = (a, b, c, d) => {
        let e = '',
          f = 0;
        do (e += a.substring(f, d) + c), (f = d + b.length), (d = a.indexOf(b, f));
        while (~d);
        return e + a.substring(f);
      },
      j = (a = g) => {
        let b = a ? h : () => String;
        return {
          isColorSupported: a,
          reset: b('\x1b[0m', '\x1b[0m'),
          bold: b('\x1b[1m', '\x1b[22m', '\x1b[22m\x1b[1m'),
          dim: b('\x1b[2m', '\x1b[22m', '\x1b[22m\x1b[2m'),
          italic: b('\x1b[3m', '\x1b[23m'),
          underline: b('\x1b[4m', '\x1b[24m'),
          inverse: b('\x1b[7m', '\x1b[27m'),
          hidden: b('\x1b[8m', '\x1b[28m'),
          strikethrough: b('\x1b[9m', '\x1b[29m'),
          black: b('\x1b[30m', '\x1b[39m'),
          red: b('\x1b[31m', '\x1b[39m'),
          green: b('\x1b[32m', '\x1b[39m'),
          yellow: b('\x1b[33m', '\x1b[39m'),
          blue: b('\x1b[34m', '\x1b[39m'),
          magenta: b('\x1b[35m', '\x1b[39m'),
          cyan: b('\x1b[36m', '\x1b[39m'),
          white: b('\x1b[37m', '\x1b[39m'),
          gray: b('\x1b[90m', '\x1b[39m'),
          bgBlack: b('\x1b[40m', '\x1b[49m'),
          bgRed: b('\x1b[41m', '\x1b[49m'),
          bgGreen: b('\x1b[42m', '\x1b[49m'),
          bgYellow: b('\x1b[43m', '\x1b[49m'),
          bgBlue: b('\x1b[44m', '\x1b[49m'),
          bgMagenta: b('\x1b[45m', '\x1b[49m'),
          bgCyan: b('\x1b[46m', '\x1b[49m'),
          bgWhite: b('\x1b[47m', '\x1b[49m'),
          blackBright: b('\x1b[90m', '\x1b[39m'),
          redBright: b('\x1b[91m', '\x1b[39m'),
          greenBright: b('\x1b[92m', '\x1b[39m'),
          yellowBright: b('\x1b[93m', '\x1b[39m'),
          blueBright: b('\x1b[94m', '\x1b[39m'),
          magentaBright: b('\x1b[95m', '\x1b[39m'),
          cyanBright: b('\x1b[96m', '\x1b[39m'),
          whiteBright: b('\x1b[97m', '\x1b[39m'),
          bgBlackBright: b('\x1b[100m', '\x1b[49m'),
          bgRedBright: b('\x1b[101m', '\x1b[49m'),
          bgGreenBright: b('\x1b[102m', '\x1b[49m'),
          bgYellowBright: b('\x1b[103m', '\x1b[49m'),
          bgBlueBright: b('\x1b[104m', '\x1b[49m'),
          bgMagentaBright: b('\x1b[105m', '\x1b[49m'),
          bgCyanBright: b('\x1b[106m', '\x1b[49m'),
          bgWhiteBright: b('\x1b[107m', '\x1b[49m'),
        };
      };
    (b.exports = j()), (b.exports.createColors = j);
  },
  7054,
  (a, b, c) => {
    'use strict';
    var d = function (a) {
        var b, c, d;
        return (
          !!(b = a) &&
          'object' == typeof b &&
          ((c = a),
          '[object RegExp]' !== (d = Object.prototype.toString.call(c)) &&
            '[object Date]' !== d &&
            c.$$typeof !== e)
        );
      },
      e = 'function' == typeof Symbol && Symbol.for ? Symbol.for('react.element') : 60103;
    function f(a, b) {
      return !1 !== b.clone && b.isMergeableObject(a) ? j(Array.isArray(a) ? [] : {}, a, b) : a;
    }
    function g(a, b, c) {
      return a.concat(b).map(function (a) {
        return f(a, c);
      });
    }
    function h(a) {
      return Object.keys(a).concat(
        Object.getOwnPropertySymbols
          ? Object.getOwnPropertySymbols(a).filter(function (b) {
              return Object.propertyIsEnumerable.call(a, b);
            })
          : []
      );
    }
    function i(a, b) {
      try {
        return b in a;
      } catch (a) {
        return !1;
      }
    }
    function j(a, b, c) {
      ((c = c || {}).arrayMerge = c.arrayMerge || g),
        (c.isMergeableObject = c.isMergeableObject || d),
        (c.cloneUnlessOtherwiseSpecified = f);
      var e,
        k,
        l = Array.isArray(b);
      return l !== Array.isArray(a)
        ? f(b, c)
        : l
        ? c.arrayMerge(a, b, c)
        : ((k = {}),
          (e = c).isMergeableObject(a) &&
            h(a).forEach(function (b) {
              k[b] = f(a[b], e);
            }),
          h(b).forEach(function (c) {
            (i(a, c) &&
              !(Object.hasOwnProperty.call(a, c) && Object.propertyIsEnumerable.call(a, c))) ||
              (i(a, c) && e.isMergeableObject(b[c])
                ? (k[c] = (function (a, b) {
                    if (!b.customMerge) return j;
                    var c = b.customMerge(a);
                    return 'function' == typeof c ? c : j;
                  })(c, e)(a[c], b[c], e))
                : (k[c] = f(b[c], e)));
          }),
          k);
    }
    (j.all = function (a, b) {
      if (!Array.isArray(a)) throw Error('first argument should be an array');
      return a.reduce(function (a, c) {
        return j(a, c, b);
      }, {});
    }),
      (b.exports = j);
  },
  98912,
  7554,
  70121,
  50104,
  92843,
  25152,
  30553,
  96743,
  92616,
  77192,
  18544,
  42871,
  33791,
  99745,
  12552,
  12794,
  37927,
  7827,
  4691,
  76644,
  47934,
  17760,
  63770,
  35110,
  20914,
  13515,
  79716,
  41377,
  74684,
  (a) => {
    'use strict';
    let b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, s, t, u, v, w, x, y, z, A, B, C, D, E;
    var F,
      G,
      H,
      I,
      J,
      K,
      L,
      M,
      N,
      O,
      P,
      Q,
      R,
      S,
      T,
      U,
      V,
      W,
      X,
      Y,
      Z,
      $,
      _,
      aa,
      ab,
      ac,
      ad,
      ae,
      af,
      ag,
      ah,
      ai,
      aj,
      ak,
      al,
      am,
      an,
      ao,
      ap,
      aq,
      ar,
      as,
      at,
      au,
      av,
      aw,
      ax,
      ay,
      az,
      aA,
      aB,
      aC,
      aD,
      aE,
      aF,
      aG,
      aH,
      aI,
      aJ,
      aK,
      aL,
      aM,
      aN,
      aO,
      aP,
      aQ,
      aR,
      aS,
      aT,
      aU,
      aV,
      aW,
      aX = a.i(72131);
    function aY(a, b, { checkForDefaultPrevented: c = !0 } = {}) {
      return function (d) {
        if ((a?.(d), !1 === c || !d.defaultPrevented)) return b?.(d);
      };
    }
    function aZ(a, b) {
      if ('function' == typeof a) return a(b);
      null != a && (a.current = b);
    }
    function a$(...a) {
      return (b) => {
        let c = !1,
          d = a.map((a) => {
            let d = aZ(a, b);
            return c || 'function' != typeof d || (c = !0), d;
          });
        if (c)
          return () => {
            for (let b = 0; b < d.length; b++) {
              let c = d[b];
              'function' == typeof c ? c() : aZ(a[b], null);
            }
          };
      };
    }
    function a_(...a) {
      return aX.useCallback(a$(...a), a);
    }
    a.s(['composeEventHandlers', () => aY], 7554),
      a.s(['composeRefs', () => a$, 'useComposedRefs', () => a_], 70121);
    var a0 = a.i(87924);
    function a1(a, b) {
      let c = aX.createContext(b),
        d = (a) => {
          let { children: b, ...d } = a,
            e = aX.useMemo(() => d, Object.values(d));
          return (0, a0.jsx)(c.Provider, { value: e, children: b });
        };
      return (
        (d.displayName = a + 'Provider'),
        [
          d,
          function (d) {
            let e = aX.useContext(c);
            if (e) return e;
            if (void 0 !== b) return b;
            throw Error(`\`${d}\` must be used within \`${a}\``);
          },
        ]
      );
    }
    function a2(a, b = []) {
      let c = [],
        d = () => {
          let b = c.map((a) => aX.createContext(a));
          return function (c) {
            let d = c?.[a] || b;
            return aX.useMemo(() => ({ [`__scope${a}`]: { ...c, [a]: d } }), [c, d]);
          };
        };
      return (
        (d.scopeName = a),
        [
          function (b, d) {
            let e = aX.createContext(d),
              f = c.length;
            c = [...c, d];
            let g = (b) => {
              let { scope: c, children: d, ...g } = b,
                h = c?.[a]?.[f] || e,
                i = aX.useMemo(() => g, Object.values(g));
              return (0, a0.jsx)(h.Provider, { value: i, children: d });
            };
            return (
              (g.displayName = b + 'Provider'),
              [
                g,
                function (c, g) {
                  let h = g?.[a]?.[f] || e,
                    i = aX.useContext(h);
                  if (i) return i;
                  if (void 0 !== d) return d;
                  throw Error(`\`${c}\` must be used within \`${b}\``);
                },
              ]
            );
          },
          (function (...a) {
            let b = a[0];
            if (1 === a.length) return b;
            let c = () => {
              let c = a.map((a) => ({ useScope: a(), scopeName: a.scopeName }));
              return function (a) {
                let d = c.reduce((b, { useScope: c, scopeName: d }) => {
                  let e = c(a)[`__scope${d}`];
                  return { ...b, ...e };
                }, {});
                return aX.useMemo(() => ({ [`__scope${b.scopeName}`]: d }), [d]);
              };
            };
            return (c.scopeName = b.scopeName), c;
          })(d, ...b),
        ]
      );
    }
    a.s(['createContext', () => a1, 'createContextScope', () => a2], 50104);
    var a3 = globalThis?.document ? aX.useLayoutEffect : () => {},
      a4 = aX[' useId '.trim().toString()] || (() => void 0),
      a5 = 0;
    function a6(a) {
      let [b, c] = aX.useState(a4());
      return (
        a3(() => {
          a || c((a) => a ?? String(a5++));
        }, [a]),
        a || (b ? `radix-${b}` : '')
      );
    }
    a.s(['useId', () => a6], 92843),
      aX[' useEffectEvent '.trim().toString()],
      aX[' useInsertionEffect '.trim().toString()];
    var a7 = aX[' useInsertionEffect '.trim().toString()] || a3;
    function a8({ prop: a, defaultProp: b, onChange: c = () => {}, caller: d }) {
      let [e, f, g] = (function ({ defaultProp: a, onChange: b }) {
          let [c, d] = aX.useState(a),
            e = aX.useRef(c),
            f = aX.useRef(b);
          return (
            a7(() => {
              f.current = b;
            }, [b]),
            aX.useEffect(() => {
              e.current !== c && (f.current?.(c), (e.current = c));
            }, [c, e]),
            [c, d, f]
          );
        })({ defaultProp: b, onChange: c }),
        h = void 0 !== a,
        i = h ? a : e;
      {
        let b = aX.useRef(void 0 !== a);
        aX.useEffect(() => {
          let a = b.current;
          if (a !== h) {
            let b = h ? 'controlled' : 'uncontrolled';
            console.warn(
              `${d} is changing from ${
                a ? 'controlled' : 'uncontrolled'
              } to ${b}. Components should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled value for the lifetime of the component.`
            );
          }
          b.current = h;
        }, [h, d]);
      }
      return [
        i,
        aX.useCallback(
          (b) => {
            if (h) {
              let c = 'function' == typeof b ? b(a) : b;
              c !== a && g.current?.(c);
            } else f(b);
          },
          [h, a, f, g]
        ),
      ];
    }
    Symbol('RADIX:SYNC_STATE'), a.s(['useControllableState', () => a8], 25152);
    var a9 = a.i(35112),
      ba = Symbol('radix.slottable');
    function bb(a) {
      return (
        aX.isValidElement(a) &&
        'function' == typeof a.type &&
        '__radixId' in a.type &&
        a.type.__radixId === ba
      );
    }
    var bc = [
      'a',
      'button',
      'div',
      'form',
      'h2',
      'h3',
      'img',
      'input',
      'label',
      'li',
      'nav',
      'ol',
      'p',
      'select',
      'span',
      'svg',
      'ul',
    ].reduce((a, b) => {
      var c, d;
      let e,
        f,
        g,
        h =
          ((d = c = `Primitive.${b}`),
          ((e = aX.forwardRef((a, b) => {
            let { children: c, ...d } = a;
            if (aX.isValidElement(c)) {
              var e;
              let a,
                f,
                g =
                  ((e = c),
                  (f =
                    (a = Object.getOwnPropertyDescriptor(e.props, 'ref')?.get) &&
                    'isReactWarning' in a &&
                    a.isReactWarning)
                    ? e.ref
                    : (f =
                        (a = Object.getOwnPropertyDescriptor(e, 'ref')?.get) &&
                        'isReactWarning' in a &&
                        a.isReactWarning)
                    ? e.props.ref
                    : e.props.ref || e.ref),
                h = (function (a, b) {
                  let c = { ...b };
                  for (let d in b) {
                    let e = a[d],
                      f = b[d];
                    /^on[A-Z]/.test(d)
                      ? e && f
                        ? (c[d] = (...a) => {
                            let b = f(...a);
                            return e(...a), b;
                          })
                        : e && (c[d] = e)
                      : 'style' === d
                      ? (c[d] = { ...e, ...f })
                      : 'className' === d && (c[d] = [e, f].filter(Boolean).join(' '));
                  }
                  return { ...a, ...c };
                })(d, c.props);
              return c.type !== aX.Fragment && (h.ref = b ? a$(b, g) : g), aX.cloneElement(c, h);
            }
            return aX.Children.count(c) > 1 ? aX.Children.only(null) : null;
          })).displayName = `${d}.SlotClone`),
          (f = e),
          ((g = aX.forwardRef((a, b) => {
            let { children: c, ...d } = a,
              e = aX.Children.toArray(c),
              g = e.find(bb);
            if (g) {
              let a = g.props.children,
                c = e.map((b) =>
                  b !== g
                    ? b
                    : aX.Children.count(a) > 1
                    ? aX.Children.only(null)
                    : aX.isValidElement(a)
                    ? a.props.children
                    : null
                );
              return (0, a0.jsx)(f, {
                ...d,
                ref: b,
                children: aX.isValidElement(a) ? aX.cloneElement(a, void 0, c) : null,
              });
            }
            return (0, a0.jsx)(f, { ...d, ref: b, children: c });
          })).displayName = `${c}.Slot`),
          g),
        i = aX.forwardRef((a, c) => {
          let { asChild: d, ...e } = a;
          return (0, a0.jsx)(d ? h : b, { ...e, ref: c });
        });
      return (i.displayName = `Primitive.${b}`), { ...a, [b]: i };
    }, {});
    function bd(a, b) {
      a && a9.flushSync(() => a.dispatchEvent(b));
    }
    function be(a) {
      let b = aX.useRef(a);
      return (
        aX.useEffect(() => {
          b.current = a;
        }),
        aX.useMemo(
          () =>
            (...a) =>
              b.current?.(...a),
          []
        )
      );
    }
    a.s(['Primitive', () => bc, 'dispatchDiscreteCustomEvent', () => bd], 30553);
    var bf = 'dismissableLayer.update',
      bg = aX.createContext({
        layers: new Set(),
        layersWithOutsidePointerEventsDisabled: new Set(),
        branches: new Set(),
      }),
      bh = aX.forwardRef((a, b) => {
        let {
            disableOutsidePointerEvents: c = !1,
            onEscapeKeyDown: d,
            onPointerDownOutside: e,
            onFocusOutside: f,
            onInteractOutside: g,
            onDismiss: h,
            ...i
          } = a,
          j = aX.useContext(bg),
          [k, l] = aX.useState(null),
          m = k?.ownerDocument ?? globalThis?.document,
          [, n] = aX.useState({}),
          o = a_(b, (a) => l(a)),
          p = Array.from(j.layers),
          [q] = [...j.layersWithOutsidePointerEventsDisabled].slice(-1),
          s = p.indexOf(q),
          t = k ? p.indexOf(k) : -1,
          u = j.layersWithOutsidePointerEventsDisabled.size > 0,
          v = t >= s,
          w = (function (a, b = globalThis?.document) {
            let c = be(a),
              d = aX.useRef(!1),
              e = aX.useRef(() => {});
            return (
              aX.useEffect(() => {
                let a = (a) => {
                    if (a.target && !d.current) {
                      let d = function () {
                          bj('dismissableLayer.pointerDownOutside', c, f, { discrete: !0 });
                        },
                        f = { originalEvent: a };
                      'touch' === a.pointerType
                        ? (b.removeEventListener('click', e.current),
                          (e.current = d),
                          b.addEventListener('click', e.current, { once: !0 }))
                        : d();
                    } else b.removeEventListener('click', e.current);
                    d.current = !1;
                  },
                  f = window.setTimeout(() => {
                    b.addEventListener('pointerdown', a);
                  }, 0);
                return () => {
                  window.clearTimeout(f),
                    b.removeEventListener('pointerdown', a),
                    b.removeEventListener('click', e.current);
                };
              }, [b, c]),
              { onPointerDownCapture: () => (d.current = !0) }
            );
          })((a) => {
            let b = a.target,
              c = [...j.branches].some((a) => a.contains(b));
            v && !c && (e?.(a), g?.(a), a.defaultPrevented || h?.());
          }, m),
          x = (function (a, b = globalThis?.document) {
            let c = be(a),
              d = aX.useRef(!1);
            return (
              aX.useEffect(() => {
                let a = (a) => {
                  a.target &&
                    !d.current &&
                    bj('dismissableLayer.focusOutside', c, { originalEvent: a }, { discrete: !1 });
                };
                return b.addEventListener('focusin', a), () => b.removeEventListener('focusin', a);
              }, [b, c]),
              { onFocusCapture: () => (d.current = !0), onBlurCapture: () => (d.current = !1) }
            );
          })((a) => {
            let b = a.target;
            ![...j.branches].some((a) => a.contains(b)) &&
              (f?.(a), g?.(a), a.defaultPrevented || h?.());
          }, m);
        return (
          !(function (a, b = globalThis?.document) {
            let c = be(a);
            aX.useEffect(() => {
              let a = (a) => {
                'Escape' === a.key && c(a);
              };
              return (
                b.addEventListener('keydown', a, { capture: !0 }),
                () => b.removeEventListener('keydown', a, { capture: !0 })
              );
            }, [c, b]);
          })((a) => {
            t === j.layers.size - 1 &&
              (d?.(a), !a.defaultPrevented && h && (a.preventDefault(), h()));
          }, m),
          aX.useEffect(() => {
            if (k)
              return (
                c &&
                  (0 === j.layersWithOutsidePointerEventsDisabled.size &&
                    ((Y = m.body.style.pointerEvents), (m.body.style.pointerEvents = 'none')),
                  j.layersWithOutsidePointerEventsDisabled.add(k)),
                j.layers.add(k),
                bi(),
                () => {
                  c &&
                    1 === j.layersWithOutsidePointerEventsDisabled.size &&
                    (m.body.style.pointerEvents = Y);
                }
              );
          }, [k, m, c, j]),
          aX.useEffect(
            () => () => {
              k && (j.layers.delete(k), j.layersWithOutsidePointerEventsDisabled.delete(k), bi());
            },
            [k, j]
          ),
          aX.useEffect(() => {
            let a = () => n({});
            return document.addEventListener(bf, a), () => document.removeEventListener(bf, a);
          }, []),
          (0, a0.jsx)(bc.div, {
            ...i,
            ref: o,
            style: { pointerEvents: u ? (v ? 'auto' : 'none') : void 0, ...a.style },
            onFocusCapture: aY(a.onFocusCapture, x.onFocusCapture),
            onBlurCapture: aY(a.onBlurCapture, x.onBlurCapture),
            onPointerDownCapture: aY(a.onPointerDownCapture, w.onPointerDownCapture),
          })
        );
      });
    function bi() {
      let a = new CustomEvent(bf);
      document.dispatchEvent(a);
    }
    function bj(a, b, c, { discrete: d }) {
      let e = c.originalEvent.target,
        f = new CustomEvent(a, { bubbles: !1, cancelable: !0, detail: c });
      b && e.addEventListener(a, b, { once: !0 }), d ? bd(e, f) : e.dispatchEvent(f);
    }
    (bh.displayName = 'DismissableLayer'),
      (aX.forwardRef((a, b) => {
        let c = aX.useContext(bg),
          d = aX.useRef(null),
          e = a_(b, d);
        return (
          aX.useEffect(() => {
            let a = d.current;
            if (a)
              return (
                c.branches.add(a),
                () => {
                  c.branches.delete(a);
                }
              );
          }, [c.branches]),
          (0, a0.jsx)(bc.div, { ...a, ref: e })
        );
      }).displayName = 'DismissableLayerBranch'),
      a.s(['DismissableLayer', () => bh], 96743);
    var bk = 'focusScope.autoFocusOnMount',
      bl = 'focusScope.autoFocusOnUnmount',
      bm = { bubbles: !1, cancelable: !0 },
      bn = aX.forwardRef((a, b) => {
        let { loop: c = !1, trapped: d = !1, onMountAutoFocus: e, onUnmountAutoFocus: f, ...g } = a,
          [h, i] = aX.useState(null),
          j = be(e),
          k = be(f),
          l = aX.useRef(null),
          m = a_(b, (a) => i(a)),
          n = aX.useRef({
            paused: !1,
            pause() {
              this.paused = !0;
            },
            resume() {
              this.paused = !1;
            },
          }).current;
        aX.useEffect(() => {
          if (d) {
            let a = function (a) {
                if (n.paused || !h) return;
                let b = a.target;
                h.contains(b) ? (l.current = b) : bq(l.current, { select: !0 });
              },
              b = function (a) {
                if (n.paused || !h) return;
                let b = a.relatedTarget;
                null !== b && (h.contains(b) || bq(l.current, { select: !0 }));
              };
            document.addEventListener('focusin', a), document.addEventListener('focusout', b);
            let c = new MutationObserver(function (a) {
              if (document.activeElement === document.body)
                for (let b of a) b.removedNodes.length > 0 && bq(h);
            });
            return (
              h && c.observe(h, { childList: !0, subtree: !0 }),
              () => {
                document.removeEventListener('focusin', a),
                  document.removeEventListener('focusout', b),
                  c.disconnect();
              }
            );
          }
        }, [d, h, n.paused]),
          aX.useEffect(() => {
            if (h) {
              br.add(n);
              let a = document.activeElement;
              if (!h.contains(a)) {
                let b = new CustomEvent(bk, bm);
                h.addEventListener(bk, j),
                  h.dispatchEvent(b),
                  b.defaultPrevented ||
                    ((function (a, { select: b = !1 } = {}) {
                      let c = document.activeElement;
                      for (let d of a)
                        if ((bq(d, { select: b }), document.activeElement !== c)) return;
                    })(
                      bo(h).filter((a) => 'A' !== a.tagName),
                      { select: !0 }
                    ),
                    document.activeElement === a && bq(h));
              }
              return () => {
                h.removeEventListener(bk, j),
                  setTimeout(() => {
                    let b = new CustomEvent(bl, bm);
                    h.addEventListener(bl, k),
                      h.dispatchEvent(b),
                      b.defaultPrevented || bq(a ?? document.body, { select: !0 }),
                      h.removeEventListener(bl, k),
                      br.remove(n);
                  }, 0);
              };
            }
          }, [h, j, k, n]);
        let o = aX.useCallback(
          (a) => {
            if ((!c && !d) || n.paused) return;
            let b = 'Tab' === a.key && !a.altKey && !a.ctrlKey && !a.metaKey,
              e = document.activeElement;
            if (b && e) {
              var f;
              let b,
                d = a.currentTarget,
                [g, h] = [bp((b = bo((f = d))), f), bp(b.reverse(), f)];
              g && h
                ? a.shiftKey || e !== h
                  ? a.shiftKey && e === g && (a.preventDefault(), c && bq(h, { select: !0 }))
                  : (a.preventDefault(), c && bq(g, { select: !0 }))
                : e === d && a.preventDefault();
            }
          },
          [c, d, n.paused]
        );
        return (0, a0.jsx)(bc.div, { tabIndex: -1, ...g, ref: m, onKeyDown: o });
      });
    function bo(a) {
      let b = [],
        c = document.createTreeWalker(a, NodeFilter.SHOW_ELEMENT, {
          acceptNode: (a) => {
            let b = 'INPUT' === a.tagName && 'hidden' === a.type;
            return a.disabled || a.hidden || b
              ? NodeFilter.FILTER_SKIP
              : a.tabIndex >= 0
              ? NodeFilter.FILTER_ACCEPT
              : NodeFilter.FILTER_SKIP;
          },
        });
      for (; c.nextNode(); ) b.push(c.currentNode);
      return b;
    }
    function bp(a, b) {
      for (let c of a)
        if (
          !(function (a, { upTo: b }) {
            if ('hidden' === getComputedStyle(a).visibility) return !0;
            for (; a && (void 0 === b || a !== b); ) {
              if ('none' === getComputedStyle(a).display) return !0;
              a = a.parentElement;
            }
            return !1;
          })(c, { upTo: b })
        )
          return c;
    }
    function bq(a, { select: b = !1 } = {}) {
      if (a && a.focus) {
        var c;
        let d = document.activeElement;
        a.focus({ preventScroll: !0 }),
          a !== d && (c = a) instanceof HTMLInputElement && 'select' in c && b && a.select();
      }
    }
    bn.displayName = 'FocusScope';
    var br =
      ((B = []),
      {
        add(a) {
          let b = B[0];
          a !== b && b?.pause(), (B = bs(B, a)).unshift(a);
        },
        remove(a) {
          (B = bs(B, a)), B[0]?.resume();
        },
      });
    function bs(a, b) {
      let c = [...a],
        d = c.indexOf(b);
      return -1 !== d && c.splice(d, 1), c;
    }
    var bt = aX.forwardRef((a, b) => {
      let { container: c, ...d } = a,
        [e, f] = aX.useState(!1);
      a3(() => f(!0), []);
      let g = c || (e && globalThis?.document?.body);
      return g ? a9.default.createPortal((0, a0.jsx)(bc.div, { ...d, ref: b }), g) : null;
    });
    (bt.displayName = 'Portal'), a.s(['Portal', () => bt], 92616);
    var bu = (a) => {
      var b;
      let c,
        d,
        { present: e, children: f } = a,
        g = (function (a) {
          var b, c;
          let [d, e] = aX.useState(),
            f = aX.useRef(null),
            g = aX.useRef(a),
            h = aX.useRef('none'),
            [i, j] =
              ((b = a ? 'mounted' : 'unmounted'),
              (c = {
                mounted: { UNMOUNT: 'unmounted', ANIMATION_OUT: 'unmountSuspended' },
                unmountSuspended: { MOUNT: 'mounted', ANIMATION_END: 'unmounted' },
                unmounted: { MOUNT: 'mounted' },
              }),
              aX.useReducer((a, b) => c[a][b] ?? a, b));
          return (
            aX.useEffect(() => {
              let a = bv(f.current);
              h.current = 'mounted' === i ? a : 'none';
            }, [i]),
            a3(() => {
              let b = f.current,
                c = g.current;
              if (c !== a) {
                let d = h.current,
                  e = bv(b);
                a
                  ? j('MOUNT')
                  : 'none' === e || b?.display === 'none'
                  ? j('UNMOUNT')
                  : c && d !== e
                  ? j('ANIMATION_OUT')
                  : j('UNMOUNT'),
                  (g.current = a);
              }
            }, [a, j]),
            a3(() => {
              if (d) {
                let a,
                  b = d.ownerDocument.defaultView ?? window,
                  c = (c) => {
                    let e = bv(f.current).includes(CSS.escape(c.animationName));
                    if (c.target === d && e && (j('ANIMATION_END'), !g.current)) {
                      let c = d.style.animationFillMode;
                      (d.style.animationFillMode = 'forwards'),
                        (a = b.setTimeout(() => {
                          'forwards' === d.style.animationFillMode &&
                            (d.style.animationFillMode = c);
                        }));
                    }
                  },
                  e = (a) => {
                    a.target === d && (h.current = bv(f.current));
                  };
                return (
                  d.addEventListener('animationstart', e),
                  d.addEventListener('animationcancel', c),
                  d.addEventListener('animationend', c),
                  () => {
                    b.clearTimeout(a),
                      d.removeEventListener('animationstart', e),
                      d.removeEventListener('animationcancel', c),
                      d.removeEventListener('animationend', c);
                  }
                );
              }
              j('ANIMATION_END');
            }, [d, j]),
            {
              isPresent: ['mounted', 'unmountSuspended'].includes(i),
              ref: aX.useCallback((a) => {
                (f.current = a ? getComputedStyle(a) : null), e(a);
              }, []),
            }
          );
        })(e),
        h = 'function' == typeof f ? f({ present: g.isPresent }) : aX.Children.only(f),
        i = a_(
          g.ref,
          ((b = h),
          (d =
            (c = Object.getOwnPropertyDescriptor(b.props, 'ref')?.get) &&
            'isReactWarning' in c &&
            c.isReactWarning)
            ? b.ref
            : (d =
                (c = Object.getOwnPropertyDescriptor(b, 'ref')?.get) &&
                'isReactWarning' in c &&
                c.isReactWarning)
            ? b.props.ref
            : b.props.ref || b.ref)
        );
      return 'function' == typeof f || g.isPresent ? aX.cloneElement(h, { ref: i }) : null;
    };
    function bv(a) {
      return a?.animationName || 'none';
    }
    (bu.displayName = 'Presence'), a.s(['Presence', () => bu], 77192);
    var bw = 0;
    function bx() {
      aX.useEffect(() => {
        let a = document.querySelectorAll('[data-radix-focus-guard]');
        return (
          document.body.insertAdjacentElement('afterbegin', a[0] ?? by()),
          document.body.insertAdjacentElement('beforeend', a[1] ?? by()),
          bw++,
          () => {
            1 === bw &&
              document.querySelectorAll('[data-radix-focus-guard]').forEach((a) => a.remove()),
              bw--;
          }
        );
      }, []);
    }
    function by() {
      let a = document.createElement('span');
      return (
        a.setAttribute('data-radix-focus-guard', ''),
        (a.tabIndex = 0),
        (a.style.outline = 'none'),
        (a.style.opacity = '0'),
        (a.style.position = 'fixed'),
        (a.style.pointerEvents = 'none'),
        a
      );
    }
    var bz = function () {
      return (bz =
        Object.assign ||
        function (a) {
          for (var b, c = 1, d = arguments.length; c < d; c++)
            for (var e in (b = arguments[c]))
              Object.prototype.hasOwnProperty.call(b, e) && (a[e] = b[e]);
          return a;
        }).apply(this, arguments);
    };
    function bA(a, b) {
      var c = {};
      for (var d in a)
        Object.prototype.hasOwnProperty.call(a, d) && 0 > b.indexOf(d) && (c[d] = a[d]);
      if (null != a && 'function' == typeof Object.getOwnPropertySymbols)
        for (var e = 0, d = Object.getOwnPropertySymbols(a); e < d.length; e++)
          0 > b.indexOf(d[e]) &&
            Object.prototype.propertyIsEnumerable.call(a, d[e]) &&
            (c[d[e]] = a[d[e]]);
      return c;
    }
    var bB = ('function' == typeof SuppressedError && SuppressedError, 'right-scroll-bar-position'),
      bC = 'width-before-scroll-bar';
    function bD(a, b) {
      return 'function' == typeof a ? a(b) : a && (a.current = b), a;
    }
    var bE = aX.useEffect,
      bF = new WeakMap(),
      bG =
        (void 0 === F && (F = {}),
        ((void 0 === G &&
          (G = function (a) {
            return a;
          }),
        (H = []),
        (I = !1),
        (J = {
          read: function () {
            if (I)
              throw Error(
                'Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.'
              );
            return H.length ? H[H.length - 1] : null;
          },
          useMedium: function (a) {
            var b = G(a, I);
            return (
              H.push(b),
              function () {
                H = H.filter(function (a) {
                  return a !== b;
                });
              }
            );
          },
          assignSyncMedium: function (a) {
            for (I = !0; H.length; ) {
              var b = H;
              (H = []), b.forEach(a);
            }
            H = {
              push: function (b) {
                return a(b);
              },
              filter: function () {
                return H;
              },
            };
          },
          assignMedium: function (a) {
            I = !0;
            var b = [];
            if (H.length) {
              var c = H;
              (H = []), c.forEach(a), (b = H);
            }
            var d = function () {
                var c = b;
                (b = []), c.forEach(a);
              },
              e = function () {
                return Promise.resolve().then(d);
              };
            e(),
              (H = {
                push: function (a) {
                  b.push(a), e();
                },
                filter: function (a) {
                  return (b = b.filter(a)), H;
                },
              });
          },
        })).options = bz({ async: !0, ssr: !1 }, F)),
        J),
      bH = function () {},
      bI = aX.forwardRef(function (a, b) {
        var c,
          d,
          e,
          f,
          g = aX.useRef(null),
          h = aX.useState({ onScrollCapture: bH, onWheelCapture: bH, onTouchMoveCapture: bH }),
          i = h[0],
          j = h[1],
          k = a.forwardProps,
          l = a.children,
          m = a.className,
          n = a.removeScrollBar,
          o = a.enabled,
          p = a.shards,
          q = a.sideCar,
          s = a.noRelative,
          t = a.noIsolation,
          u = a.inert,
          v = a.allowPinchZoom,
          w = a.as,
          x = a.gapMode,
          y = bA(a, [
            'forwardProps',
            'children',
            'className',
            'removeScrollBar',
            'enabled',
            'shards',
            'sideCar',
            'noRelative',
            'noIsolation',
            'inert',
            'allowPinchZoom',
            'as',
            'gapMode',
          ]),
          z =
            ((c = [g, b]),
            (d = function (a) {
              return c.forEach(function (b) {
                return bD(b, a);
              });
            }),
            ((e = (0, aX.useState)(function () {
              return {
                value: null,
                callback: d,
                facade: {
                  get current() {
                    return e.value;
                  },
                  set current(value) {
                    var a = e.value;
                    a !== value && ((e.value = value), e.callback(value, a));
                  },
                },
              };
            })[0]).callback = d),
            (f = e.facade),
            bE(
              function () {
                var a = bF.get(f);
                if (a) {
                  var b = new Set(a),
                    d = new Set(c),
                    e = f.current;
                  b.forEach(function (a) {
                    d.has(a) || bD(a, null);
                  }),
                    d.forEach(function (a) {
                      b.has(a) || bD(a, e);
                    });
                }
                bF.set(f, c);
              },
              [c]
            ),
            f),
          A = bz(bz({}, y), i);
        return aX.createElement(
          aX.Fragment,
          null,
          o &&
            aX.createElement(q, {
              sideCar: bG,
              removeScrollBar: n,
              shards: p,
              noRelative: s,
              noIsolation: t,
              inert: u,
              setCallbacks: j,
              allowPinchZoom: !!v,
              lockRef: g,
              gapMode: x,
            }),
          k
            ? aX.cloneElement(aX.Children.only(l), bz(bz({}, A), { ref: z }))
            : aX.createElement(void 0 === w ? 'div' : w, bz({}, A, { className: m, ref: z }), l)
        );
      });
    (bI.defaultProps = { enabled: !0, removeScrollBar: !0, inert: !1 }),
      (bI.classNames = { fullWidth: bC, zeroRight: bB });
    var bJ = function (a) {
      var b = a.sideCar,
        c = bA(a, ['sideCar']);
      if (!b) throw Error('Sidecar: please provide `sideCar` property to import the right car');
      var d = b.read();
      if (!d) throw Error('Sidecar medium not found');
      return aX.createElement(d, bz({}, c));
    };
    bJ.isSideCarExport = !0;
    var bK = function () {
        var a = 0,
          b = null;
        return {
          add: function (c) {
            if (
              0 == a &&
              (b = (function () {
                if (!document) return null;
                var a = document.createElement('style');
                a.type = 'text/css';
                var b = Z || ('undefined' != typeof __webpack_nonce__ ? __webpack_nonce__ : void 0);
                return b && a.setAttribute('nonce', b), a;
              })())
            ) {
              var d, e;
              (d = b).styleSheet
                ? (d.styleSheet.cssText = c)
                : d.appendChild(document.createTextNode(c)),
                (e = b),
                (document.head || document.getElementsByTagName('head')[0]).appendChild(e);
            }
            a++;
          },
          remove: function () {
            --a || !b || (b.parentNode && b.parentNode.removeChild(b), (b = null));
          },
        };
      },
      bL = function () {
        var a = bK();
        return function (b, c) {
          aX.useEffect(
            function () {
              return (
                a.add(b),
                function () {
                  a.remove();
                }
              );
            },
            [b && c]
          );
        };
      },
      bM = function () {
        var a = bL();
        return function (b) {
          return a(b.styles, b.dynamic), null;
        };
      },
      bN = { left: 0, top: 0, right: 0, gap: 0 },
      bO = bM(),
      bP = 'data-scroll-locked',
      bQ = function (a, b, c, d) {
        var e = a.left,
          f = a.top,
          g = a.right,
          h = a.gap;
        return (
          void 0 === c && (c = 'margin'),
          '\n  .'
            .concat('with-scroll-bars-hidden', ' {\n   overflow: hidden ')
            .concat(d, ';\n   padding-right: ')
            .concat(h, 'px ')
            .concat(d, ';\n  }\n  body[')
            .concat(bP, '] {\n    overflow: hidden ')
            .concat(d, ';\n    overscroll-behavior: contain;\n    ')
            .concat(
              [
                b && 'position: relative '.concat(d, ';'),
                'margin' === c &&
                  '\n    padding-left: '
                    .concat(e, 'px;\n    padding-top: ')
                    .concat(f, 'px;\n    padding-right: ')
                    .concat(g, 'px;\n    margin-left:0;\n    margin-top:0;\n    margin-right: ')
                    .concat(h, 'px ')
                    .concat(d, ';\n    '),
                'padding' === c && 'padding-right: '.concat(h, 'px ').concat(d, ';'),
              ]
                .filter(Boolean)
                .join(''),
              '\n  }\n  \n  .'
            )
            .concat(bB, ' {\n    right: ')
            .concat(h, 'px ')
            .concat(d, ';\n  }\n  \n  .')
            .concat(bC, ' {\n    margin-right: ')
            .concat(h, 'px ')
            .concat(d, ';\n  }\n  \n  .')
            .concat(bB, ' .')
            .concat(bB, ' {\n    right: 0 ')
            .concat(d, ';\n  }\n  \n  .')
            .concat(bC, ' .')
            .concat(bC, ' {\n    margin-right: 0 ')
            .concat(d, ';\n  }\n  \n  body[')
            .concat(bP, '] {\n    ')
            .concat('--removed-body-scroll-bar-size', ': ')
            .concat(h, 'px;\n  }\n')
        );
      },
      bR = function () {
        var a = parseInt(document.body.getAttribute(bP) || '0', 10);
        return isFinite(a) ? a : 0;
      },
      bS = function () {
        aX.useEffect(function () {
          return (
            document.body.setAttribute(bP, (bR() + 1).toString()),
            function () {
              var a = bR() - 1;
              a <= 0
                ? document.body.removeAttribute(bP)
                : document.body.setAttribute(bP, a.toString());
            }
          );
        }, []);
      },
      bT = function (a) {
        var b = a.noRelative,
          c = a.noImportant,
          d = a.gapMode,
          e = void 0 === d ? 'margin' : d;
        bS();
        var f = aX.useMemo(
          function () {
            return void 0 === e, bN;
          },
          [e]
        );
        return aX.createElement(bO, { styles: bQ(f, !b, e, c ? '' : '!important') });
      },
      bU = function (a, b) {
        if (!(a instanceof Element)) return !1;
        var c = window.getComputedStyle(a);
        return (
          'hidden' !== c[b] &&
          (c.overflowY !== c.overflowX || 'TEXTAREA' === a.tagName || 'visible' !== c[b])
        );
      },
      bV = function (a, b) {
        var c = b.ownerDocument,
          d = b;
        do {
          if (
            ('undefined' != typeof ShadowRoot && d instanceof ShadowRoot && (d = d.host), bW(a, d))
          ) {
            var e = bX(a, d);
            if (e[1] > e[2]) return !0;
          }
          d = d.parentNode;
        } while (d && d !== c.body);
        return !1;
      },
      bW = function (a, b) {
        return 'v' === a ? bU(b, 'overflowY') : bU(b, 'overflowX');
      },
      bX = function (a, b) {
        return 'v' === a
          ? [b.scrollTop, b.scrollHeight, b.clientHeight]
          : [b.scrollLeft, b.scrollWidth, b.clientWidth];
      },
      bY = function (a, b, c, d, e) {
        var f,
          g = ((f = window.getComputedStyle(b).direction), 'h' === a && 'rtl' === f ? -1 : 1),
          h = g * d,
          i = c.target,
          j = b.contains(i),
          k = !1,
          l = h > 0,
          m = 0,
          n = 0;
        do {
          if (!i) break;
          var o = bX(a, i),
            p = o[0],
            q = o[1] - o[2] - g * p;
          (p || q) && bW(a, i) && ((m += q), (n += p));
          var s = i.parentNode;
          i = s && s.nodeType === Node.DOCUMENT_FRAGMENT_NODE ? s.host : s;
        } while ((!j && i !== document.body) || (j && (b.contains(i) || b === i)));
        return (
          l && ((e && 1 > Math.abs(m)) || (!e && h > m))
            ? (k = !0)
            : !l && ((e && 1 > Math.abs(n)) || (!e && -h > n)) && (k = !0),
          k
        );
      },
      bZ = function (a) {
        return 'changedTouches' in a
          ? [a.changedTouches[0].clientX, a.changedTouches[0].clientY]
          : [0, 0];
      },
      b$ = function (a) {
        return [a.deltaX, a.deltaY];
      },
      b_ = function (a) {
        return a && 'current' in a ? a.current : a;
      },
      b0 = 0,
      b1 = [];
    let b2 =
      ((K = function (a) {
        var b = aX.useRef([]),
          c = aX.useRef([0, 0]),
          d = aX.useRef(),
          e = aX.useState(b0++)[0],
          f = aX.useState(bM)[0],
          g = aX.useRef(a);
        aX.useEffect(
          function () {
            g.current = a;
          },
          [a]
        ),
          aX.useEffect(
            function () {
              if (a.inert) {
                document.body.classList.add('block-interactivity-'.concat(e));
                var b = (function (a, b, c) {
                  if (c || 2 == arguments.length)
                    for (var d, e = 0, f = b.length; e < f; e++)
                      (!d && e in b) ||
                        (d || (d = Array.prototype.slice.call(b, 0, e)), (d[e] = b[e]));
                  return a.concat(d || Array.prototype.slice.call(b));
                })([a.lockRef.current], (a.shards || []).map(b_), !0).filter(Boolean);
                return (
                  b.forEach(function (a) {
                    return a.classList.add('allow-interactivity-'.concat(e));
                  }),
                  function () {
                    document.body.classList.remove('block-interactivity-'.concat(e)),
                      b.forEach(function (a) {
                        return a.classList.remove('allow-interactivity-'.concat(e));
                      });
                  }
                );
              }
            },
            [a.inert, a.lockRef.current, a.shards]
          );
        var h = aX.useCallback(function (a, b) {
            if (('touches' in a && 2 === a.touches.length) || ('wheel' === a.type && a.ctrlKey))
              return !g.current.allowPinchZoom;
            var e,
              f = bZ(a),
              h = c.current,
              i = 'deltaX' in a ? a.deltaX : h[0] - f[0],
              j = 'deltaY' in a ? a.deltaY : h[1] - f[1],
              k = a.target,
              l = Math.abs(i) > Math.abs(j) ? 'h' : 'v';
            if ('touches' in a && 'h' === l && 'range' === k.type) return !1;
            var m = window.getSelection(),
              n = m && m.anchorNode;
            if (n && (n === k || n.contains(k))) return !1;
            var o = bV(l, k);
            if (!o) return !0;
            if ((o ? (e = l) : ((e = 'v' === l ? 'h' : 'v'), (o = bV(l, k))), !o)) return !1;
            if ((!d.current && 'changedTouches' in a && (i || j) && (d.current = e), !e)) return !0;
            var p = d.current || e;
            return bY(p, b, a, 'h' === p ? i : j, !0);
          }, []),
          i = aX.useCallback(function (a) {
            if (b1.length && b1[b1.length - 1] === f) {
              var c = 'deltaY' in a ? b$(a) : bZ(a),
                d = b.current.filter(function (b) {
                  var d;
                  return (
                    b.name === a.type &&
                    (b.target === a.target || a.target === b.shadowParent) &&
                    ((d = b.delta), d[0] === c[0] && d[1] === c[1])
                  );
                })[0];
              if (d && d.should) {
                a.cancelable && a.preventDefault();
                return;
              }
              if (!d) {
                var e = (g.current.shards || [])
                  .map(b_)
                  .filter(Boolean)
                  .filter(function (b) {
                    return b.contains(a.target);
                  });
                (e.length > 0 ? h(a, e[0]) : !g.current.noIsolation) &&
                  a.cancelable &&
                  a.preventDefault();
              }
            }
          }, []),
          j = aX.useCallback(function (a, c, d, e) {
            var f = {
              name: a,
              delta: c,
              target: d,
              should: e,
              shadowParent: (function (a) {
                for (var b = null; null !== a; )
                  a instanceof ShadowRoot && ((b = a.host), (a = a.host)), (a = a.parentNode);
                return b;
              })(d),
            };
            b.current.push(f),
              setTimeout(function () {
                b.current = b.current.filter(function (a) {
                  return a !== f;
                });
              }, 1);
          }, []),
          k = aX.useCallback(function (a) {
            (c.current = bZ(a)), (d.current = void 0);
          }, []),
          l = aX.useCallback(function (b) {
            j(b.type, b$(b), b.target, h(b, a.lockRef.current));
          }, []),
          m = aX.useCallback(function (b) {
            j(b.type, bZ(b), b.target, h(b, a.lockRef.current));
          }, []);
        aX.useEffect(function () {
          return (
            b1.push(f),
            a.setCallbacks({ onScrollCapture: l, onWheelCapture: l, onTouchMoveCapture: m }),
            document.addEventListener('wheel', i, !1),
            document.addEventListener('touchmove', i, !1),
            document.addEventListener('touchstart', k, !1),
            function () {
              (b1 = b1.filter(function (a) {
                return a !== f;
              })),
                document.removeEventListener('wheel', i, !1),
                document.removeEventListener('touchmove', i, !1),
                document.removeEventListener('touchstart', k, !1);
            }
          );
        }, []);
        var n = a.removeScrollBar,
          o = a.inert;
        return aX.createElement(
          aX.Fragment,
          null,
          o
            ? aX.createElement(f, {
                styles: '\n  .block-interactivity-'
                  .concat(e, ' {pointer-events: none;}\n  .allow-interactivity-')
                  .concat(e, ' {pointer-events: all;}\n'),
              })
            : null,
          n ? aX.createElement(bT, { noRelative: a.noRelative, gapMode: a.gapMode }) : null
        );
      }),
      bG.useMedium(K),
      bJ);
    var b3 = aX.forwardRef(function (a, b) {
      return aX.createElement(bI, bz({}, a, { ref: b, sideCar: b2 }));
    });
    b3.classNames = bI.classNames;
    var b4 = new WeakMap(),
      b5 = new WeakMap(),
      b6 = {},
      b7 = 0,
      b8 = function (a) {
        return a && (a.host || b8(a.parentNode));
      },
      b9 = function (a, b, c, d) {
        var e = (Array.isArray(a) ? a : [a])
          .map(function (a) {
            if (b.contains(a)) return a;
            var c = b8(a);
            return c && b.contains(c)
              ? c
              : (console.error('aria-hidden', a, 'in not contained inside', b, '. Doing nothing'),
                null);
          })
          .filter(function (a) {
            return !!a;
          });
        b6[c] || (b6[c] = new WeakMap());
        var f = b6[c],
          g = [],
          h = new Set(),
          i = new Set(e),
          j = function (a) {
            !a || h.has(a) || (h.add(a), j(a.parentNode));
          };
        e.forEach(j);
        var k = function (a) {
          !a ||
            i.has(a) ||
            Array.prototype.forEach.call(a.children, function (a) {
              if (h.has(a)) k(a);
              else
                try {
                  var b = a.getAttribute(d),
                    e = null !== b && 'false' !== b,
                    i = (b4.get(a) || 0) + 1,
                    j = (f.get(a) || 0) + 1;
                  b4.set(a, i),
                    f.set(a, j),
                    g.push(a),
                    1 === i && e && b5.set(a, !0),
                    1 === j && a.setAttribute(c, 'true'),
                    e || a.setAttribute(d, 'true');
                } catch (b) {
                  console.error('aria-hidden: cannot operate on ', a, b);
                }
            });
        };
        return (
          k(b),
          h.clear(),
          b7++,
          function () {
            g.forEach(function (a) {
              var b = b4.get(a) - 1,
                e = f.get(a) - 1;
              b4.set(a, b),
                f.set(a, e),
                b || (b5.has(a) || a.removeAttribute(d), b5.delete(a)),
                e || a.removeAttribute(c);
            }),
              --b7 || ((b4 = new WeakMap()), (b4 = new WeakMap()), (b5 = new WeakMap()), (b6 = {}));
          }
        );
      },
      ca = function (a, b, c) {
        void 0 === c && (c = 'data-aria-hidden');
        var d = Array.from(Array.isArray(a) ? a : [a]),
          e =
            b ||
            ('undefined' == typeof document
              ? null
              : (Array.isArray(a) ? a[0] : a).ownerDocument.body);
        return e
          ? (d.push.apply(d, Array.from(e.querySelectorAll('[aria-live], script'))),
            b9(d, e, c, 'aria-hidden'))
          : function () {
              return null;
            };
      },
      cb = Symbol('radix.slottable');
    function cc(a) {
      return (
        aX.isValidElement(a) &&
        'function' == typeof a.type &&
        '__radixId' in a.type &&
        a.type.__radixId === cb
      );
    }
    var cd = 'Dialog',
      [ce, cf] = a2(cd),
      [cg, ch] = ce(cd),
      ci = (a) => {
        let {
            __scopeDialog: b,
            children: c,
            open: d,
            defaultOpen: e,
            onOpenChange: f,
            modal: g = !0,
          } = a,
          h = aX.useRef(null),
          i = aX.useRef(null),
          [j, k] = a8({ prop: d, defaultProp: e ?? !1, onChange: f, caller: cd });
        return (0, a0.jsx)(cg, {
          scope: b,
          triggerRef: h,
          contentRef: i,
          contentId: a6(),
          titleId: a6(),
          descriptionId: a6(),
          open: j,
          onOpenChange: k,
          onOpenToggle: aX.useCallback(() => k((a) => !a), [k]),
          modal: g,
          children: c,
        });
      };
    ci.displayName = cd;
    var cj = 'DialogTrigger',
      ck = aX.forwardRef((a, b) => {
        let { __scopeDialog: c, ...d } = a,
          e = ch(cj, c),
          f = a_(b, e.triggerRef);
        return (0, a0.jsx)(bc.button, {
          type: 'button',
          'aria-haspopup': 'dialog',
          'aria-expanded': e.open,
          'aria-controls': e.contentId,
          'data-state': cD(e.open),
          ...d,
          ref: f,
          onClick: aY(a.onClick, e.onOpenToggle),
        });
      });
    ck.displayName = cj;
    var cl = 'DialogPortal',
      [cm, cn] = ce(cl, { forceMount: void 0 }),
      co = (a) => {
        let { __scopeDialog: b, forceMount: c, children: d, container: e } = a,
          f = ch(cl, b);
        return (0, a0.jsx)(cm, {
          scope: b,
          forceMount: c,
          children: aX.Children.map(d, (a) =>
            (0, a0.jsx)(bu, {
              present: c || f.open,
              children: (0, a0.jsx)(bt, { asChild: !0, container: e, children: a }),
            })
          ),
        });
      };
    co.displayName = cl;
    var cp = 'DialogOverlay',
      cq = aX.forwardRef((a, b) => {
        let c = cn(cp, a.__scopeDialog),
          { forceMount: d = c.forceMount, ...e } = a,
          f = ch(cp, a.__scopeDialog);
        return f.modal
          ? (0, a0.jsx)(bu, { present: d || f.open, children: (0, a0.jsx)(cs, { ...e, ref: b }) })
          : null;
      });
    cq.displayName = cp;
    var cr =
        (((C = aX.forwardRef((a, b) => {
          let { children: c, ...d } = a;
          if (aX.isValidElement(c)) {
            var e;
            let a,
              f,
              g =
                ((e = c),
                (f =
                  (a = Object.getOwnPropertyDescriptor(e.props, 'ref')?.get) &&
                  'isReactWarning' in a &&
                  a.isReactWarning)
                  ? e.ref
                  : (f =
                      (a = Object.getOwnPropertyDescriptor(e, 'ref')?.get) &&
                      'isReactWarning' in a &&
                      a.isReactWarning)
                  ? e.props.ref
                  : e.props.ref || e.ref),
              h = (function (a, b) {
                let c = { ...b };
                for (let d in b) {
                  let e = a[d],
                    f = b[d];
                  /^on[A-Z]/.test(d)
                    ? e && f
                      ? (c[d] = (...a) => {
                          let b = f(...a);
                          return e(...a), b;
                        })
                      : e && (c[d] = e)
                    : 'style' === d
                    ? (c[d] = { ...e, ...f })
                    : 'className' === d && (c[d] = [e, f].filter(Boolean).join(' '));
                }
                return { ...a, ...c };
              })(d, c.props);
            return c.type !== aX.Fragment && (h.ref = b ? a$(b, g) : g), aX.cloneElement(c, h);
          }
          return aX.Children.count(c) > 1 ? aX.Children.only(null) : null;
        })).displayName = 'DialogOverlay.RemoveScroll.SlotClone'),
        (c = C),
        ((d = aX.forwardRef((a, b) => {
          let { children: d, ...e } = a,
            f = aX.Children.toArray(d),
            g = f.find(cc);
          if (g) {
            let a = g.props.children,
              d = f.map((b) =>
                b !== g
                  ? b
                  : aX.Children.count(a) > 1
                  ? aX.Children.only(null)
                  : aX.isValidElement(a)
                  ? a.props.children
                  : null
              );
            return (0, a0.jsx)(c, {
              ...e,
              ref: b,
              children: aX.isValidElement(a) ? aX.cloneElement(a, void 0, d) : null,
            });
          }
          return (0, a0.jsx)(c, { ...e, ref: b, children: d });
        })).displayName = 'DialogOverlay.RemoveScroll.Slot'),
        d),
      cs = aX.forwardRef((a, b) => {
        let { __scopeDialog: c, ...d } = a,
          e = ch(cp, c);
        return (0, a0.jsx)(b3, {
          as: cr,
          allowPinchZoom: !0,
          shards: [e.contentRef],
          children: (0, a0.jsx)(bc.div, {
            'data-state': cD(e.open),
            ...d,
            ref: b,
            style: { pointerEvents: 'auto', ...d.style },
          }),
        });
      }),
      ct = 'DialogContent',
      cu = aX.forwardRef((a, b) => {
        let c = cn(ct, a.__scopeDialog),
          { forceMount: d = c.forceMount, ...e } = a,
          f = ch(ct, a.__scopeDialog);
        return (0, a0.jsx)(bu, {
          present: d || f.open,
          children: f.modal ? (0, a0.jsx)(cv, { ...e, ref: b }) : (0, a0.jsx)(cw, { ...e, ref: b }),
        });
      });
    cu.displayName = ct;
    var cv = aX.forwardRef((a, b) => {
        let c = ch(ct, a.__scopeDialog),
          d = aX.useRef(null),
          e = a_(b, c.contentRef, d);
        return (
          aX.useEffect(() => {
            let a = d.current;
            if (a) return ca(a);
          }, []),
          (0, a0.jsx)(cx, {
            ...a,
            ref: e,
            trapFocus: c.open,
            disableOutsidePointerEvents: !0,
            onCloseAutoFocus: aY(a.onCloseAutoFocus, (a) => {
              a.preventDefault(), c.triggerRef.current?.focus();
            }),
            onPointerDownOutside: aY(a.onPointerDownOutside, (a) => {
              let b = a.detail.originalEvent,
                c = 0 === b.button && !0 === b.ctrlKey;
              (2 === b.button || c) && a.preventDefault();
            }),
            onFocusOutside: aY(a.onFocusOutside, (a) => a.preventDefault()),
          })
        );
      }),
      cw = aX.forwardRef((a, b) => {
        let c = ch(ct, a.__scopeDialog),
          d = aX.useRef(!1),
          e = aX.useRef(!1);
        return (0, a0.jsx)(cx, {
          ...a,
          ref: b,
          trapFocus: !1,
          disableOutsidePointerEvents: !1,
          onCloseAutoFocus: (b) => {
            a.onCloseAutoFocus?.(b),
              b.defaultPrevented ||
                (d.current || c.triggerRef.current?.focus(), b.preventDefault()),
              (d.current = !1),
              (e.current = !1);
          },
          onInteractOutside: (b) => {
            a.onInteractOutside?.(b),
              b.defaultPrevented ||
                ((d.current = !0),
                'pointerdown' === b.detail.originalEvent.type && (e.current = !0));
            let f = b.target;
            c.triggerRef.current?.contains(f) && b.preventDefault(),
              'focusin' === b.detail.originalEvent.type && e.current && b.preventDefault();
          },
        });
      }),
      cx = aX.forwardRef((a, b) => {
        let { __scopeDialog: c, trapFocus: d, onOpenAutoFocus: e, onCloseAutoFocus: f, ...g } = a,
          h = ch(ct, c),
          i = aX.useRef(null),
          j = a_(b, i);
        return (
          bx(),
          (0, a0.jsxs)(a0.Fragment, {
            children: [
              (0, a0.jsx)(bn, {
                asChild: !0,
                loop: !0,
                trapped: d,
                onMountAutoFocus: e,
                onUnmountAutoFocus: f,
                children: (0, a0.jsx)(bh, {
                  role: 'dialog',
                  id: h.contentId,
                  'aria-describedby': h.descriptionId,
                  'aria-labelledby': h.titleId,
                  'data-state': cD(h.open),
                  ...g,
                  ref: j,
                  onDismiss: () => h.onOpenChange(!1),
                }),
              }),
              (0, a0.jsxs)(a0.Fragment, {
                children: [
                  (0, a0.jsx)(cH, { titleId: h.titleId }),
                  (0, a0.jsx)(cI, { contentRef: i, descriptionId: h.descriptionId }),
                ],
              }),
            ],
          })
        );
      }),
      cy = 'DialogTitle',
      cz = aX.forwardRef((a, b) => {
        let { __scopeDialog: c, ...d } = a,
          e = ch(cy, c);
        return (0, a0.jsx)(bc.h2, { id: e.titleId, ...d, ref: b });
      });
    cz.displayName = cy;
    var cA = 'DialogDescription';
    aX.forwardRef((a, b) => {
      let { __scopeDialog: c, ...d } = a,
        e = ch(cA, c);
      return (0, a0.jsx)(bc.p, { id: e.descriptionId, ...d, ref: b });
    }).displayName = cA;
    var cB = 'DialogClose',
      cC = aX.forwardRef((a, b) => {
        let { __scopeDialog: c, ...d } = a,
          e = ch(cB, c);
        return (0, a0.jsx)(bc.button, {
          type: 'button',
          ...d,
          ref: b,
          onClick: aY(a.onClick, () => e.onOpenChange(!1)),
        });
      });
    function cD(a) {
      return a ? 'open' : 'closed';
    }
    cC.displayName = cB;
    var cE = 'DialogTitleWarning',
      [cF, cG] = a1(cE, { contentName: ct, titleName: cy, docsSlug: 'dialog' }),
      cH = ({ titleId: a }) => {
        let b = cG(cE),
          c = `\`${b.contentName}\` requires a \`${b.titleName}\` for the component to be accessible for screen reader users.

If you want to hide the \`${b.titleName}\`, you can wrap it with our VisuallyHidden component.

For more information, see https://radix-ui.com/primitives/docs/components/${b.docsSlug}`;
        return (
          aX.useEffect(() => {
            a && (document.getElementById(a) || console.error(c));
          }, [c, a]),
          null
        );
      },
      cI = ({ contentRef: a, descriptionId: b }) => {
        let c = cG('DialogDescriptionWarning'),
          d = `Warning: Missing \`Description\` or \`aria-describedby={undefined}\` for {${c.contentName}}.`;
        return (
          aX.useEffect(() => {
            let c = a.current?.getAttribute('aria-describedby');
            b && c && (document.getElementById(b) || console.warn(d));
          }, [d, a, b]),
          null
        );
      };
    function cJ() {
      for (var a, b, c = 0, d = '', e = arguments.length; c < e; c++)
        (a = arguments[c]) &&
          (b = (function a(b) {
            var c,
              d,
              e = '';
            if ('string' == typeof b || 'number' == typeof b) e += b;
            else if ('object' == typeof b)
              if (Array.isArray(b)) {
                var f = b.length;
                for (c = 0; c < f; c++) b[c] && (d = a(b[c])) && (e && (e += ' '), (e += d));
              } else for (d in b) b[d] && (e && (e += ' '), (e += d));
            return e;
          })(a)) &&
          (d && (d += ' '), (d += b));
      return d;
    }
    var cK =
      (((L = cK || {}).Mainnet = 'mainnet'),
      (L.Devnet = 'devnet'),
      (L.Testnet = 'testnet'),
      (L.Localnet = 'localnet'),
      (L.Custom = 'custom'),
      L);
    let cL = Object.values(
      (function () {
        let a;
        try {
          a = JSON.parse(
            '{\n    "mainnet": {\n        "id": "mainnet",\n        "name": "Mainnet",\n        "url": "https://api.mainnet.iota.cafe",\n        "graphql": "https://graphql.mainnet.iota.cafe",\n        "explorer": "https://explorer.rebased.iota.org",\n        "chain": "iota:mainnet"\n    },\n    "testnet": {\n        "id": "testnet",\n        "name": "Testnet",\n        "url": "https://api.testnet.iota.cafe",\n        "graphql": "https://graphql.testnet.iota.cafe",\n        "explorer": "https://explorer.rebased.iota.org",\n        "chain": "iota:testnet",\n        "faucet": "https://faucet.testnet.iota.cafe",\n        "kiosk": {\n            "royaltyRulePackageId": "0x975f749f57701209454e4b9b9e33825ccb6a9abf57de2ce86979e5fa86c343f2",\n            "kioskLockRulePackageId": "0x975f749f57701209454e4b9b9e33825ccb6a9abf57de2ce86979e5fa86c343f2",\n            "floorPriceRulePackageId": "0x975f749f57701209454e4b9b9e33825ccb6a9abf57de2ce86979e5fa86c343f2",\n            "personalKioskRulePackageId": "0x975f749f57701209454e4b9b9e33825ccb6a9abf57de2ce86979e5fa86c343f2"\n        }\n    },\n    "devnet": {\n        "id": "devnet",\n        "name": "Devnet",\n        "url": "https://api.devnet.iota.cafe",\n        "graphql": "https://graphql.devnet.iota.cafe",\n        "explorer": "https://explorer.rebased.iota.org",\n        "chain": "iota:devnet",\n        "faucet": "https://faucet.devnet.iota.cafe"\n    },\n    "localnet": {\n        "id": "localnet",\n        "name": "Localnet",\n        "url": "http://localhost:9000",\n        "graphql": "http://localhost:9125",\n        "explorer": "http://localhost:3000",\n        "chain": "iota:local",\n        "faucet": "http://localhost:9123"\n    }\n}'
          );
        } catch {
          throw Error('Failed to parse env var "IOTA_NETWORKS".');
        }
        return a;
      })()
    ).map((a) => a.chain);
    function cM(a) {
      return cL.includes(a) || 'iota' === a.split(':')[0];
    }
    var cN = {
        setTimeout: (a, b) => setTimeout(a, b),
        clearTimeout: (a) => clearTimeout(a),
        setInterval: (a, b) => setInterval(a, b),
        clearInterval: (a) => clearInterval(a),
      },
      cO = new (class {
        #a = cN;
        #b = !1;
        setTimeoutProvider(a) {
          this.#a = a;
        }
        setTimeout(a, b) {
          return this.#a.setTimeout(a, b);
        }
        clearTimeout(a) {
          this.#a.clearTimeout(a);
        }
        setInterval(a, b) {
          return this.#a.setInterval(a, b);
        }
        clearInterval(a) {
          this.#a.clearInterval(a);
        }
      })(),
      cP =
        ((e = []),
        (f = 0),
        (g = (a) => {
          a();
        }),
        (h = (a) => {
          a();
        }),
        (i = function (a) {
          setTimeout(a, 0);
        }),
        {
          batch: (a) => {
            let b;
            f++;
            try {
              b = a();
            } finally {
              let a;
              --f ||
                ((a = e),
                (e = []),
                a.length &&
                  i(() => {
                    h(() => {
                      a.forEach((a) => {
                        g(a);
                      });
                    });
                  }));
            }
            return b;
          },
          batchCalls:
            (a) =>
            (...b) => {
              j(() => {
                a(...b);
              });
            },
          schedule: (j = (a) => {
            f
              ? e.push(a)
              : i(() => {
                  g(a);
                });
          }),
          setNotifyFunction: (a) => {
            g = a;
          },
          setBatchNotifyFunction: (a) => {
            h = a;
          },
          setScheduler: (a) => {
            i = a;
          },
        });
    function cQ() {}
    function cR(a, b) {
      return 'function' == typeof a ? a(b) : a;
    }
    function cS(a) {
      return 'number' == typeof a && a >= 0 && a !== 1 / 0;
    }
    function cT(a, b) {
      return Math.max(a + (b || 0) - Date.now(), 0);
    }
    function cU(a, b) {
      return 'function' == typeof a ? a(b) : a;
    }
    function cV(a, b) {
      return 'function' == typeof a ? a(b) : a;
    }
    function cW(a, b) {
      let { type: c = 'all', exact: d, fetchStatus: e, predicate: f, queryKey: g, stale: h } = a;
      if (g) {
        if (d) {
          if (b.queryHash !== cY(g, b.options)) return !1;
        } else if (!c$(b.queryKey, g)) return !1;
      }
      if ('all' !== c) {
        let a = b.isActive();
        if (('active' === c && !a) || ('inactive' === c && a)) return !1;
      }
      return (
        ('boolean' != typeof h || b.isStale() === h) &&
        (!e || e === b.state.fetchStatus) &&
        (!f || !!f(b))
      );
    }
    function cX(a, b) {
      let { exact: c, status: d, predicate: e, mutationKey: f } = a;
      if (f) {
        if (!b.options.mutationKey) return !1;
        if (c) {
          if (cZ(b.options.mutationKey) !== cZ(f)) return !1;
        } else if (!c$(b.options.mutationKey, f)) return !1;
      }
      return (!d || b.state.status === d) && (!e || !!e(b));
    }
    function cY(a, b) {
      return (b?.queryKeyHashFn || cZ)(a);
    }
    function cZ(a) {
      return JSON.stringify(a, (a, b) =>
        c3(b)
          ? Object.keys(b)
              .sort()
              .reduce((a, c) => ((a[c] = b[c]), a), {})
          : b
      );
    }
    function c$(a, b) {
      return (
        a === b ||
        (typeof a == typeof b &&
          !!a &&
          !!b &&
          'object' == typeof a &&
          'object' == typeof b &&
          Object.keys(b).every((c) => c$(a[c], b[c])))
      );
    }
    a.s(['notifyManager', () => cP], 18544);
    var c_ = Object.prototype.hasOwnProperty;
    function c0(a, b) {
      if (a === b) return a;
      let c = c2(a) && c2(b);
      if (!c && !(c3(a) && c3(b))) return b;
      let d = (c ? a : Object.keys(a)).length,
        e = c ? b : Object.keys(b),
        f = e.length,
        g = c ? Array(f) : {},
        h = 0;
      for (let i = 0; i < f; i++) {
        let f = c ? i : e[i],
          j = a[f],
          k = b[f];
        if (j === k) {
          (g[f] = j), (c ? i < d : c_.call(a, f)) && h++;
          continue;
        }
        if (null === j || null === k || 'object' != typeof j || 'object' != typeof k) {
          g[f] = k;
          continue;
        }
        let l = c0(j, k);
        (g[f] = l), l === j && h++;
      }
      return d === f && h === d ? a : g;
    }
    function c1(a, b) {
      if (!b || Object.keys(a).length !== Object.keys(b).length) return !1;
      for (let c in a) if (a[c] !== b[c]) return !1;
      return !0;
    }
    function c2(a) {
      return Array.isArray(a) && a.length === Object.keys(a).length;
    }
    function c3(a) {
      if (!c4(a)) return !1;
      let b = a.constructor;
      if (void 0 === b) return !0;
      let c = b.prototype;
      return (
        !!c4(c) &&
        !!c.hasOwnProperty('isPrototypeOf') &&
        Object.getPrototypeOf(a) === Object.prototype
      );
    }
    function c4(a) {
      return '[object Object]' === Object.prototype.toString.call(a);
    }
    function c5(a) {
      return new Promise((b) => {
        cO.setTimeout(b, a);
      });
    }
    function c6(a, b, c) {
      return 'function' == typeof c.structuralSharing
        ? c.structuralSharing(a, b)
        : !1 !== c.structuralSharing
        ? c0(a, b)
        : b;
    }
    function c7(a, b, c = 0) {
      let d = [...a, b];
      return c && d.length > c ? d.slice(1) : d;
    }
    function c8(a, b, c = 0) {
      let d = [b, ...a];
      return c && d.length > c ? d.slice(0, -1) : d;
    }
    var c9 = Symbol();
    function da(a, b) {
      return !a.queryFn && b?.initialPromise
        ? () => b.initialPromise
        : a.queryFn && a.queryFn !== c9
        ? a.queryFn
        : () => Promise.reject(Error(`Missing queryFn: '${a.queryHash}'`));
    }
    function db(a, b) {
      return 'function' == typeof a ? a(...b) : !!a;
    }
    a.s(
      [
        'addToEnd',
        () => c7,
        'addToStart',
        () => c8,
        'ensureQueryFn',
        () => da,
        'functionalUpdate',
        () => cR,
        'hashKey',
        () => cZ,
        'hashQueryKeyByOptions',
        () => cY,
        'isServer',
        () => !0,
        'isValidTimeout',
        () => cS,
        'matchMutation',
        () => cX,
        'matchQuery',
        () => cW,
        'noop',
        () => cQ,
        'partialMatchKey',
        () => c$,
        'replaceData',
        () => c6,
        'replaceEqualDeep',
        () => c0,
        'resolveEnabled',
        () => cV,
        'resolveStaleTime',
        () => cU,
        'shallowEqualObjects',
        () => c1,
        'shouldThrowError',
        () => db,
        'skipToken',
        () => c9,
        'sleep',
        () => c5,
        'timeUntilStale',
        () => cT,
      ],
      42871
    );
    var dc = class {
        #c;
        destroy() {
          this.clearGcTimeout();
        }
        scheduleGc() {
          this.clearGcTimeout(),
            cS(this.gcTime) &&
              (this.#c = cO.setTimeout(() => {
                this.optionalRemove();
              }, this.gcTime));
        }
        updateGcTime(a) {
          this.gcTime = Math.max(this.gcTime || 0, a ?? 1 / 0);
        }
        clearGcTimeout() {
          this.#c && (cO.clearTimeout(this.#c), (this.#c = void 0));
        }
      },
      dd = class {
        constructor() {
          (this.listeners = new Set()), (this.subscribe = this.subscribe.bind(this));
        }
        subscribe(a) {
          return (
            this.listeners.add(a),
            this.onSubscribe(),
            () => {
              this.listeners.delete(a), this.onUnsubscribe();
            }
          );
        }
        hasListeners() {
          return this.listeners.size > 0;
        }
        onSubscribe() {}
        onUnsubscribe() {}
      };
    a.s(['Subscribable', () => dd], 33791);
    var de = new (class extends dd {
      #d;
      #e;
      #f;
      constructor() {
        super(), (this.#f = (a) => {});
      }
      onSubscribe() {
        this.#e || this.setEventListener(this.#f);
      }
      onUnsubscribe() {
        this.hasListeners() || (this.#e?.(), (this.#e = void 0));
      }
      setEventListener(a) {
        (this.#f = a),
          this.#e?.(),
          (this.#e = a((a) => {
            'boolean' == typeof a ? this.setFocused(a) : this.onFocus();
          }));
      }
      setFocused(a) {
        this.#d !== a && ((this.#d = a), this.onFocus());
      }
      onFocus() {
        let a = this.isFocused();
        this.listeners.forEach((b) => {
          b(a);
        });
      }
      isFocused() {
        return 'boolean' == typeof this.#d
          ? this.#d
          : globalThis.document?.visibilityState !== 'hidden';
      }
    })();
    a.s(['focusManager', () => de], 99745);
    var df = new (class extends dd {
      #g = !0;
      #e;
      #f;
      constructor() {
        super(), (this.#f = (a) => {});
      }
      onSubscribe() {
        this.#e || this.setEventListener(this.#f);
      }
      onUnsubscribe() {
        this.hasListeners() || (this.#e?.(), (this.#e = void 0));
      }
      setEventListener(a) {
        (this.#f = a), this.#e?.(), (this.#e = a(this.setOnline.bind(this)));
      }
      setOnline(a) {
        this.#g !== a &&
          ((this.#g = a),
          this.listeners.forEach((b) => {
            b(a);
          }));
      }
      isOnline() {
        return this.#g;
      }
    })();
    function dg() {
      let a,
        b,
        c = new Promise((c, d) => {
          (a = c), (b = d);
        });
      function d(a) {
        Object.assign(c, a), delete c.resolve, delete c.reject;
      }
      return (
        (c.status = 'pending'),
        c.catch(() => {}),
        (c.resolve = (b) => {
          d({ status: 'fulfilled', value: b }), a(b);
        }),
        (c.reject = (a) => {
          d({ status: 'rejected', reason: a }), b(a);
        }),
        c
      );
    }
    function dh(a) {
      return Math.min(1e3 * 2 ** a, 3e4);
    }
    function di(a) {
      return (a ?? 'online') !== 'online' || df.isOnline();
    }
    a.s(['onlineManager', () => df], 12552);
    var dj = class extends Error {
      constructor(a) {
        super('CancelledError'), (this.revert = a?.revert), (this.silent = a?.silent);
      }
    };
    function dk(a) {
      let b,
        c = !1,
        d = 0,
        e = dg(),
        f = () => de.isFocused() && ('always' === a.networkMode || df.isOnline()) && a.canRun(),
        g = () => di(a.networkMode) && a.canRun(),
        h = (a) => {
          'pending' === e.status && (b?.(), e.resolve(a));
        },
        i = (a) => {
          'pending' === e.status && (b?.(), e.reject(a));
        },
        j = () =>
          new Promise((c) => {
            (b = (a) => {
              ('pending' !== e.status || f()) && c(a);
            }),
              a.onPause?.();
          }).then(() => {
            (b = void 0), 'pending' === e.status && a.onContinue?.();
          }),
        k = () => {
          let b;
          if ('pending' !== e.status) return;
          let g = 0 === d ? a.initialPromise : void 0;
          try {
            b = g ?? a.fn();
          } catch (a) {
            b = Promise.reject(a);
          }
          Promise.resolve(b)
            .then(h)
            .catch((b) => {
              if ('pending' !== e.status) return;
              let g = a.retry ?? 0,
                h = a.retryDelay ?? dh,
                l = 'function' == typeof h ? h(d, b) : h,
                m =
                  !0 === g ||
                  ('number' == typeof g && d < g) ||
                  ('function' == typeof g && g(d, b));
              c || !m
                ? i(b)
                : (d++,
                  a.onFail?.(d, b),
                  c5(l)
                    .then(() => (f() ? void 0 : j()))
                    .then(() => {
                      c ? i(b) : k();
                    }));
            });
        };
      return {
        promise: e,
        status: () => e.status,
        cancel: (b) => {
          if ('pending' === e.status) {
            let c = new dj(b);
            i(c), a.onCancel?.(c);
          }
        },
        continue: () => (b?.(), e),
        cancelRetry: () => {
          c = !0;
        },
        continueRetry: () => {
          c = !1;
        },
        canStart: g,
        start: () => (g() ? k() : j().then(k), e),
      };
    }
    var dl = class extends dc {
      #h;
      #i;
      #j;
      #k;
      constructor(a) {
        super(),
          (this.#h = a.client),
          (this.mutationId = a.mutationId),
          (this.#j = a.mutationCache),
          (this.#i = []),
          (this.state = a.state || dm()),
          this.setOptions(a.options),
          this.scheduleGc();
      }
      setOptions(a) {
        (this.options = a), this.updateGcTime(this.options.gcTime);
      }
      get meta() {
        return this.options.meta;
      }
      addObserver(a) {
        this.#i.includes(a) ||
          (this.#i.push(a),
          this.clearGcTimeout(),
          this.#j.notify({ type: 'observerAdded', mutation: this, observer: a }));
      }
      removeObserver(a) {
        (this.#i = this.#i.filter((b) => b !== a)),
          this.scheduleGc(),
          this.#j.notify({ type: 'observerRemoved', mutation: this, observer: a });
      }
      optionalRemove() {
        this.#i.length ||
          ('pending' === this.state.status ? this.scheduleGc() : this.#j.remove(this));
      }
      continue() {
        return this.#k?.continue() ?? this.execute(this.state.variables);
      }
      async execute(a) {
        let b = () => {
            this.#l({ type: 'continue' });
          },
          c = { client: this.#h, meta: this.options.meta, mutationKey: this.options.mutationKey };
        this.#k = dk({
          fn: () =>
            this.options.mutationFn
              ? this.options.mutationFn(a, c)
              : Promise.reject(Error('No mutationFn found')),
          onFail: (a, b) => {
            this.#l({ type: 'failed', failureCount: a, error: b });
          },
          onPause: () => {
            this.#l({ type: 'pause' });
          },
          onContinue: b,
          retry: this.options.retry ?? 0,
          retryDelay: this.options.retryDelay,
          networkMode: this.options.networkMode,
          canRun: () => this.#j.canRun(this),
        });
        let d = 'pending' === this.state.status,
          e = !this.#k.canStart();
        try {
          if (d) b();
          else {
            this.#l({ type: 'pending', variables: a, isPaused: e }),
              await this.#j.config.onMutate?.(a, this, c);
            let b = await this.options.onMutate?.(a, c);
            b !== this.state.context &&
              this.#l({ type: 'pending', context: b, variables: a, isPaused: e });
          }
          let f = await this.#k.start();
          return (
            await this.#j.config.onSuccess?.(f, a, this.state.context, this, c),
            await this.options.onSuccess?.(f, a, this.state.context, c),
            await this.#j.config.onSettled?.(
              f,
              null,
              this.state.variables,
              this.state.context,
              this,
              c
            ),
            await this.options.onSettled?.(f, null, a, this.state.context, c),
            this.#l({ type: 'success', data: f }),
            f
          );
        } catch (b) {
          try {
            throw (
              (await this.#j.config.onError?.(b, a, this.state.context, this, c),
              await this.options.onError?.(b, a, this.state.context, c),
              await this.#j.config.onSettled?.(
                void 0,
                b,
                this.state.variables,
                this.state.context,
                this,
                c
              ),
              await this.options.onSettled?.(void 0, b, a, this.state.context, c),
              b)
            );
          } finally {
            this.#l({ type: 'error', error: b });
          }
        } finally {
          this.#j.runNext(this);
        }
      }
      #l(a) {
        (this.state = ((b) => {
          switch (a.type) {
            case 'failed':
              return { ...b, failureCount: a.failureCount, failureReason: a.error };
            case 'pause':
              return { ...b, isPaused: !0 };
            case 'continue':
              return { ...b, isPaused: !1 };
            case 'pending':
              return {
                ...b,
                context: a.context,
                data: void 0,
                failureCount: 0,
                failureReason: null,
                error: null,
                isPaused: a.isPaused,
                status: 'pending',
                variables: a.variables,
                submittedAt: Date.now(),
              };
            case 'success':
              return {
                ...b,
                data: a.data,
                failureCount: 0,
                failureReason: null,
                error: null,
                status: 'success',
                isPaused: !1,
              };
            case 'error':
              return {
                ...b,
                data: void 0,
                error: a.error,
                failureCount: b.failureCount + 1,
                failureReason: a.error,
                isPaused: !1,
                status: 'error',
              };
          }
        })(this.state)),
          cP.batch(() => {
            this.#i.forEach((b) => {
              b.onMutationUpdate(a);
            }),
              this.#j.notify({ mutation: this, type: 'updated', action: a });
          });
      }
    };
    function dm() {
      return {
        context: void 0,
        data: void 0,
        error: null,
        failureCount: 0,
        failureReason: null,
        isPaused: !1,
        status: 'idle',
        variables: void 0,
        submittedAt: 0,
      };
    }
    a.s(['Mutation', () => dl, 'getDefaultState', () => dm], 12794);
    var dn = class extends dd {
        #h;
        #m = void 0;
        #n;
        #o;
        constructor(a, b) {
          super(), (this.#h = a), this.setOptions(b), this.bindMethods(), this.#p();
        }
        bindMethods() {
          (this.mutate = this.mutate.bind(this)), (this.reset = this.reset.bind(this));
        }
        setOptions(a) {
          let b = this.options;
          (this.options = this.#h.defaultMutationOptions(a)),
            c1(this.options, b) ||
              this.#h
                .getMutationCache()
                .notify({ type: 'observerOptionsUpdated', mutation: this.#n, observer: this }),
            b?.mutationKey &&
            this.options.mutationKey &&
            cZ(b.mutationKey) !== cZ(this.options.mutationKey)
              ? this.reset()
              : this.#n?.state.status === 'pending' && this.#n.setOptions(this.options);
        }
        onUnsubscribe() {
          this.hasListeners() || this.#n?.removeObserver(this);
        }
        onMutationUpdate(a) {
          this.#p(), this.#q(a);
        }
        getCurrentResult() {
          return this.#m;
        }
        reset() {
          this.#n?.removeObserver(this), (this.#n = void 0), this.#p(), this.#q();
        }
        mutate(a, b) {
          return (
            (this.#o = b),
            this.#n?.removeObserver(this),
            (this.#n = this.#h.getMutationCache().build(this.#h, this.options)),
            this.#n.addObserver(this),
            this.#n.execute(a)
          );
        }
        #p() {
          let a = this.#n?.state ?? dm();
          this.#m = {
            ...a,
            isPending: 'pending' === a.status,
            isSuccess: 'success' === a.status,
            isError: 'error' === a.status,
            isIdle: 'idle' === a.status,
            mutate: this.mutate,
            reset: this.reset,
          };
        }
        #q(a) {
          cP.batch(() => {
            if (this.#o && this.hasListeners()) {
              let b = this.#m.variables,
                c = this.#m.context,
                d = {
                  client: this.#h,
                  meta: this.options.meta,
                  mutationKey: this.options.mutationKey,
                };
              a?.type === 'success'
                ? (this.#o.onSuccess?.(a.data, b, c, d), this.#o.onSettled?.(a.data, null, b, c, d))
                : a?.type === 'error' &&
                  (this.#o.onError?.(a.error, b, c, d),
                  this.#o.onSettled?.(void 0, a.error, b, c, d));
            }
            this.listeners.forEach((a) => {
              a(this.#m);
            });
          });
        }
      },
      dp = aX.createContext(void 0),
      dq = (a) => {
        let b = aX.useContext(dp);
        if (a) return a;
        if (!b) throw Error('No QueryClient set, use QueryClientProvider to set one');
        return b;
      },
      dr = ({ client: a, children: b }) => (
        aX.useEffect(
          () => (
            a.mount(),
            () => {
              a.unmount();
            }
          ),
          [a]
        ),
        (0, a0.jsx)(dp.Provider, { value: a, children: b })
      );
    function ds(a, b) {
      let c = dq(b),
        [d] = aX.useState(() => new dn(c, a));
      aX.useEffect(() => {
        d.setOptions(a);
      }, [d, a]);
      let e = aX.useSyncExternalStore(
          aX.useCallback((a) => d.subscribe(cP.batchCalls(a)), [d]),
          () => d.getCurrentResult(),
          () => d.getCurrentResult()
        ),
        f = aX.useCallback(
          (a, b) => {
            d.mutate(a, b).catch(cQ);
          },
          [d]
        );
      if (e.error && db(d.options.throwOnError, [e.error])) throw e.error;
      return { ...e, mutate: f, mutateAsync: e.mutate };
    }
    a.s(['QueryClientProvider', () => dr, 'useQueryClient', () => dq], 37927);
    let dt = {
        get url() {
          return `file://${a.P('node_modules/zustand/esm/vanilla.mjs')}`;
        },
      },
      du = (a) => {
        let b,
          c = new Set(),
          d = (a, d) => {
            let e = 'function' == typeof a ? a(b) : a;
            if (!Object.is(e, b)) {
              let a = b;
              (b = (null != d ? d : 'object' != typeof e || null === e)
                ? e
                : Object.assign({}, b, e)),
                c.forEach((c) => c(b, a));
            }
          },
          e = () => b,
          f = {
            setState: d,
            getState: e,
            getInitialState: () => g,
            subscribe: (a) => (c.add(a), () => c.delete(a)),
            destroy: () => {
              (dt.env ? dt.env.MODE : void 0) !== 'production' &&
                console.warn(
                  '[DEPRECATED] The `destroy` method will be unsupported in a future version. Instead use unsubscribe function returned by subscribe. Everything will be garbage-collected if store is garbage-collected.'
                ),
                c.clear();
            },
          },
          g = (b = a(d, e, f));
        return f;
      };
    var dv = a.i(64442);
    let dw = {
        get url() {
          return `file://${a.P('node_modules/zustand/esm/index.mjs')}`;
        },
      },
      { useDebugValue: dx } = aX.default,
      { useSyncExternalStoreWithSelector: dy } = dv.default,
      dz = new Set(),
      dA = {};
    function dB() {
      return k || (k = Object.freeze({ register: dC, get: dD, on: dE }));
    }
    function dC(...a) {
      return (a = a.filter((a) => !dz.has(a))).length
        ? (a.forEach((a) => {
            (b = void 0), dz.add(a);
          }),
          dA.register?.forEach((b) => dF(() => b(...a))),
          function () {
            a.forEach((a) => {
              (b = void 0), dz.delete(a);
            }),
              dA.unregister?.forEach((b) => dF(() => b(...a)));
          })
        : () => {};
    }
    function dD() {
      return b || (b = [...dz]), b;
    }
    function dE(a, b) {
      return (
        dA[a]?.push(b) || (dA[a] = [b]),
        function () {
          dA[a] = dA[a]?.filter((a) => b !== a);
        }
      );
    }
    function dF(a) {
      try {
        a();
      } catch (a) {
        console.error(a);
      }
    }
    Event, new WeakMap();
    let dG = ['standard:connect', 'standard:events'];
    var dH = Symbol.for('react.lazy'),
      dI = aX[' use '.trim().toString()];
    function dJ(a) {
      var b;
      return (
        null != a &&
        'object' == typeof a &&
        '$$typeof' in a &&
        a.$$typeof === dH &&
        '_payload' in a &&
        'object' == typeof (b = a._payload) &&
        null !== b &&
        'then' in b
      );
    }
    var dK =
        (((D = aX.forwardRef((a, b) => {
          let { children: c, ...d } = a;
          if ((dJ(c) && 'function' == typeof dI && (c = dI(c._payload)), aX.isValidElement(c))) {
            var e;
            let a,
              f,
              g =
                ((e = c),
                (f =
                  (a = Object.getOwnPropertyDescriptor(e.props, 'ref')?.get) &&
                  'isReactWarning' in a &&
                  a.isReactWarning)
                  ? e.ref
                  : (f =
                      (a = Object.getOwnPropertyDescriptor(e, 'ref')?.get) &&
                      'isReactWarning' in a &&
                      a.isReactWarning)
                  ? e.props.ref
                  : e.props.ref || e.ref),
              h = (function (a, b) {
                let c = { ...b };
                for (let d in b) {
                  let e = a[d],
                    f = b[d];
                  /^on[A-Z]/.test(d)
                    ? e && f
                      ? (c[d] = (...a) => {
                          let b = f(...a);
                          return e(...a), b;
                        })
                      : e && (c[d] = e)
                    : 'style' === d
                    ? (c[d] = { ...e, ...f })
                    : 'className' === d && (c[d] = [e, f].filter(Boolean).join(' '));
                }
                return { ...a, ...c };
              })(d, c.props);
            return c.type !== aX.Fragment && (h.ref = b ? a$(b, g) : g), aX.cloneElement(c, h);
          }
          return aX.Children.count(c) > 1 ? aX.Children.only(null) : null;
        })).displayName = 'Slot.SlotClone'),
        (l = D),
        ((m = aX.forwardRef((a, b) => {
          let { children: c, ...d } = a;
          dJ(c) && 'function' == typeof dI && (c = dI(c._payload));
          let e = aX.Children.toArray(c),
            f = e.find(dM);
          if (f) {
            let a = f.props.children,
              c = e.map((b) =>
                b !== f
                  ? b
                  : aX.Children.count(a) > 1
                  ? aX.Children.only(null)
                  : aX.isValidElement(a)
                  ? a.props.children
                  : null
              );
            return (0, a0.jsx)(l, {
              ...d,
              ref: b,
              children: aX.isValidElement(a) ? aX.cloneElement(a, void 0, c) : null,
            });
          }
          return (0, a0.jsx)(l, { ...d, ref: b, children: c });
        })).displayName = 'Slot.Slot'),
        m),
      dL = Symbol('radix.slottable');
    function dM(a) {
      return (
        aX.isValidElement(a) &&
        'function' == typeof a.type &&
        '__radixId' in a.type &&
        a.type.__radixId === dL
      );
    }
    function dN(a, b) {
      var c = Object.keys(a);
      if (Object.getOwnPropertySymbols) {
        var d = Object.getOwnPropertySymbols(a);
        b &&
          (d = d.filter(function (b) {
            return Object.getOwnPropertyDescriptor(a, b).enumerable;
          })),
          c.push.apply(c, d);
      }
      return c;
    }
    function dO(a) {
      for (var b = 1; b < arguments.length; b++) {
        var c = null != arguments[b] ? arguments[b] : {};
        b % 2
          ? dN(Object(c), !0).forEach(function (b) {
              !(function (a, b, c) {
                var d;
                (b =
                  'symbol' ==
                  typeof (d = (function (a, b) {
                    if ('object' != typeof a || !a) return a;
                    var c = a[Symbol.toPrimitive];
                    if (void 0 !== c) {
                      var d = c.call(a, b || 'default');
                      if ('object' != typeof d) return d;
                      throw TypeError('@@toPrimitive must return a primitive value.');
                    }
                    return ('string' === b ? String : Number)(a);
                  })(b, 'string'))
                    ? d
                    : String(d)) in a
                  ? Object.defineProperty(a, b, {
                      value: c,
                      enumerable: !0,
                      configurable: !0,
                      writable: !0,
                    })
                  : (a[b] = c);
              })(a, b, c[b]);
            })
          : Object.getOwnPropertyDescriptors
          ? Object.defineProperties(a, Object.getOwnPropertyDescriptors(c))
          : dN(Object(c)).forEach(function (b) {
              Object.defineProperty(a, b, Object.getOwnPropertyDescriptor(c, b));
            });
      }
      return a;
    }
    function dP(a, b) {
      var c = {};
      for (var d in a) c[d] = b(a[d], d);
      return c;
    }
    var dQ = (a, b, c) => {
        for (var d of Object.keys(a)) {
          var e;
          if (a[d] !== (null != (e = b[d]) ? e : c[d])) return !1;
        }
        return !0;
      },
      dR = (a) => {
        var b = (b) => {
          var c = a.defaultClassName,
            d = dO(dO({}, a.defaultVariants), b);
          for (var e in d) {
            var f,
              g = null != (f = d[e]) ? f : a.defaultVariants[e];
            if (null != g) {
              var h = g;
              'boolean' == typeof h && (h = !0 === h ? 'true' : 'false');
              var i = a.variantClassNames[e][h];
              i && (c += ' ' + i);
            }
          }
          for (var [j, k] of a.compoundVariants) dQ(j, d, a.defaultVariants) && (c += ' ' + k);
          return c;
        };
        return (
          (b.variants = () => Object.keys(a.variantClassNames)),
          (b.classNames = {
            get base() {
              return a.defaultClassName.split(' ')[0];
            },
            get variants() {
              return dP(a.variantClassNames, (a) => dP(a, (a) => a.split(' ')[0]));
            },
          }),
          b
        );
      };
    let dS = (function (a) {
      if (a.length >= 255) throw TypeError('Alphabet too long');
      let b = new Uint8Array(256);
      for (let a = 0; a < b.length; a++) b[a] = 255;
      for (let c = 0; c < a.length; c++) {
        let d = a.charAt(c),
          e = d.charCodeAt(0);
        if (255 !== b[e]) throw TypeError(d + ' is ambiguous');
        b[e] = c;
      }
      let c = a.length,
        d = a.charAt(0),
        e = Math.log(c) / Math.log(256),
        f = Math.log(256) / Math.log(c);
      function g(a) {
        if ('string' != typeof a) throw TypeError('Expected String');
        if (0 === a.length) return new Uint8Array();
        let f = 0,
          g = 0,
          h = 0;
        for (; a[f] === d; ) g++, f++;
        let i = ((a.length - f) * e + 1) >>> 0,
          j = new Uint8Array(i);
        for (; f < a.length; ) {
          let d = a.charCodeAt(f);
          if (d > 255) return;
          let e = b[d];
          if (255 === e) return;
          let g = 0;
          for (let a = i - 1; (0 !== e || g < h) && -1 !== a; a--, g++)
            (e += (c * j[a]) >>> 0), (j[a] = e % 256 >>> 0), (e = (e / 256) >>> 0);
          if (0 !== e) throw Error('Non-zero carry');
          (h = g), f++;
        }
        let k = i - h;
        for (; k !== i && 0 === j[k]; ) k++;
        let l = new Uint8Array(g + (i - k)),
          m = g;
        for (; k !== i; ) l[m++] = j[k++];
        return l;
      }
      return {
        encode: function (b) {
          if (
            (b instanceof Uint8Array ||
              (ArrayBuffer.isView(b)
                ? (b = new Uint8Array(b.buffer, b.byteOffset, b.byteLength))
                : Array.isArray(b) && (b = Uint8Array.from(b))),
            !(b instanceof Uint8Array))
          )
            throw TypeError('Expected Uint8Array');
          if (0 === b.length) return '';
          let e = 0,
            g = 0,
            h = 0,
            i = b.length;
          for (; h !== i && 0 === b[h]; ) h++, e++;
          let j = ((i - h) * f + 1) >>> 0,
            k = new Uint8Array(j);
          for (; h !== i; ) {
            let a = b[h],
              d = 0;
            for (let b = j - 1; (0 !== a || d < g) && -1 !== b; b--, d++)
              (a += (256 * k[b]) >>> 0), (k[b] = a % c >>> 0), (a = (a / c) >>> 0);
            if (0 !== a) throw Error('Non-zero carry');
            (g = d), h++;
          }
          let l = j - g;
          for (; l !== j && 0 === k[l]; ) l++;
          let m = d.repeat(e);
          for (; l < j; ++l) m += a.charAt(k[l]);
          return m;
        },
        decodeUnsafe: g,
        decode: function (a) {
          let b = g(a);
          if (b) return b;
          throw Error('Non-base' + c + ' character');
        },
      };
    })('123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz');
    function dT(a) {
      return Uint8Array.from(atob(a), (a) => a.charCodeAt(0));
    }
    function dU(a) {
      if (a.length < 8192) return btoa(String.fromCharCode(...a));
      let b = '';
      for (let c = 0; c < a.length; c += 8192) b += String.fromCharCode(...a.slice(c, c + 8192));
      return btoa(b);
    }
    function dV(a) {
      let b = a.startsWith('0x') ? a.slice(2) : a,
        c = b.length % 2 == 0 ? b : `0${b}}`,
        d = c.match(/.{2}/g)?.map((a) => parseInt(a, 16)) ?? [];
      return Uint8Array.from(d);
    }
    function dW(a) {
      return a.reduce((a, b) => a + b.toString(16).padStart(2, '0'), '');
    }
    function dX(a) {
      try {
        let b;
        return 32 === ((b = a), dS.decode(b)).length;
      } catch (a) {
        return !1;
      }
    }
    function dY(a) {
      var b, c;
      return (
        (b = a),
        /^(0x|0X)?[a-fA-F0-9]+$/.test(b) &&
          b.length % 2 == 0 &&
          32 == ((c = a), /^(0x|0X)/.test(c) ? (c.length - 2) / 2 : c.length / 2)
      );
    }
    function dZ(a, b = !1, c = !1) {
      let d = a.toLowerCase().replace(/ /g, '');
      if (
        (!b && d.startsWith('0x') && (d = d.slice(2)),
        (d = `0x${d.padStart(64, '0')}`),
        !c || dY(d))
      )
        return d;
      throw Error(`Invalid IOTA address: ${a}`);
    }
    function d$(a, b = !1, c = !1) {
      return dZ(a, b, c);
    }
    function d_(a) {
      if (a.length <= 6) return a;
      let b = 2 * !!a.startsWith('0x');
      return `0x${a.slice(b, b + 4)}\u2026${a.slice(-4)}`;
    }
    function d0(a) {
      var b;
      let c,
        d =
          ((b = a),
          ((c = aX.forwardRef((a, b) => {
            let { children: c, ...d } = a;
            if (aX.isValidElement(c)) {
              var e;
              let a,
                f,
                g =
                  ((e = c),
                  (f =
                    (a = Object.getOwnPropertyDescriptor(e.props, 'ref')?.get) &&
                    'isReactWarning' in a &&
                    a.isReactWarning)
                    ? e.ref
                    : (f =
                        (a = Object.getOwnPropertyDescriptor(e, 'ref')?.get) &&
                        'isReactWarning' in a &&
                        a.isReactWarning)
                    ? e.props.ref
                    : e.props.ref || e.ref),
                h = (function (a, b) {
                  let c = { ...b };
                  for (let d in b) {
                    let e = a[d],
                      f = b[d];
                    /^on[A-Z]/.test(d)
                      ? e && f
                        ? (c[d] = (...a) => {
                            let b = f(...a);
                            return e(...a), b;
                          })
                        : e && (c[d] = e)
                      : 'style' === d
                      ? (c[d] = { ...e, ...f })
                      : 'className' === d && (c[d] = [e, f].filter(Boolean).join(' '));
                  }
                  return { ...a, ...c };
                })(d, c.props);
              return c.type !== aX.Fragment && (h.ref = b ? a$(b, g) : g), aX.cloneElement(c, h);
            }
            return aX.Children.count(c) > 1 ? aX.Children.only(null) : null;
          })).displayName = `${b}.SlotClone`),
          c),
        e = aX.forwardRef((a, b) => {
          let { children: c, ...e } = a,
            f = aX.Children.toArray(c),
            g = f.find(d2);
          if (g) {
            let a = g.props.children,
              c = f.map((b) =>
                b !== g
                  ? b
                  : aX.Children.count(a) > 1
                  ? aX.Children.only(null)
                  : aX.isValidElement(a)
                  ? a.props.children
                  : null
              );
            return (0, a0.jsx)(d, {
              ...e,
              ref: b,
              children: aX.isValidElement(a) ? aX.cloneElement(a, void 0, c) : null,
            });
          }
          return (0, a0.jsx)(d, { ...e, ref: b, children: c });
        });
      return (e.displayName = `${a}.Slot`), e;
    }
    var d1 = Symbol('radix.slottable');
    function d2(a) {
      return (
        aX.isValidElement(a) &&
        'function' == typeof a.type &&
        '__radixId' in a.type &&
        a.type.__radixId === d1
      );
    }
    function d3(a) {
      let b = a + 'CollectionProvider',
        [c, d] = a2(b),
        [e, f] = c(b, { collectionRef: { current: null }, itemMap: new Map() }),
        g = (a) => {
          let { scope: b, children: c } = a,
            d = aX.default.useRef(null),
            f = aX.default.useRef(new Map()).current;
          return (0, a0.jsx)(e, { scope: b, itemMap: f, collectionRef: d, children: c });
        };
      g.displayName = b;
      let h = a + 'CollectionSlot',
        i = d0(h),
        j = aX.default.forwardRef((a, b) => {
          let { scope: c, children: d } = a,
            e = a_(b, f(h, c).collectionRef);
          return (0, a0.jsx)(i, { ref: e, children: d });
        });
      j.displayName = h;
      let k = a + 'CollectionItemSlot',
        l = 'data-radix-collection-item',
        m = d0(k),
        n = aX.default.forwardRef((a, b) => {
          let { scope: c, children: d, ...e } = a,
            g = aX.default.useRef(null),
            h = a_(b, g),
            i = f(k, c);
          return (
            aX.default.useEffect(
              () => (i.itemMap.set(g, { ref: g, ...e }), () => void i.itemMap.delete(g))
            ),
            (0, a0.jsx)(m, { ...{ [l]: '' }, ref: h, children: d })
          );
        });
      return (
        (n.displayName = k),
        [
          { Provider: g, Slot: j, ItemSlot: n },
          function (b) {
            let c = f(a + 'CollectionConsumer', b);
            return aX.default.useCallback(() => {
              let a = c.collectionRef.current;
              if (!a) return [];
              let b = Array.from(a.querySelectorAll(`[${l}]`));
              return Array.from(c.itemMap.values()).sort(
                (a, c) => b.indexOf(a.ref.current) - b.indexOf(c.ref.current)
              );
            }, [c.collectionRef, c.itemMap]);
          },
          d,
        ]
      );
    }
    var d4 = new WeakMap();
    function d5(a, b) {
      var c, d;
      let e, f, g;
      if ('at' in Array.prototype) return Array.prototype.at.call(a, b);
      let h =
        ((c = a),
        (d = b),
        (e = c.length),
        (g = (f = d6(d)) >= 0 ? f : e + f) < 0 || g >= e ? -1 : g);
      return -1 === h ? void 0 : a[h];
    }
    function d6(a) {
      return a != a || 0 === a ? 0 : Math.trunc(a);
    }
    (class a extends Map {
      #r;
      constructor(a) {
        super(a), (this.#r = [...super.keys()]), d4.set(this, !0);
      }
      set(a, b) {
        return (
          d4.get(this) && (this.has(a) ? (this.#r[this.#r.indexOf(a)] = a) : this.#r.push(a)),
          super.set(a, b),
          this
        );
      }
      insert(a, b, c) {
        let d,
          e = this.has(b),
          f = this.#r.length,
          g = d6(a),
          h = g >= 0 ? g : f + g,
          i = h < 0 || h >= f ? -1 : h;
        if (i === this.size || (e && i === this.size - 1) || -1 === i) return this.set(b, c), this;
        let j = this.size + +!e;
        g < 0 && h++;
        let k = [...this.#r],
          l = !1;
        for (let a = h; a < j; a++)
          if (h === a) {
            let f = k[a];
            k[a] === b && (f = k[a + 1]), e && this.delete(b), (d = this.get(f)), this.set(b, c);
          } else {
            l || k[a - 1] !== b || (l = !0);
            let c = k[l ? a : a - 1],
              e = d;
            (d = this.get(c)), this.delete(c), this.set(c, e);
          }
        return this;
      }
      with(b, c, d) {
        let e = new a(this);
        return e.insert(b, c, d), e;
      }
      before(a) {
        let b = this.#r.indexOf(a) - 1;
        if (!(b < 0)) return this.entryAt(b);
      }
      setBefore(a, b, c) {
        let d = this.#r.indexOf(a);
        return -1 === d ? this : this.insert(d, b, c);
      }
      after(a) {
        let b = this.#r.indexOf(a);
        if (-1 !== (b = -1 === b || b === this.size - 1 ? -1 : b + 1)) return this.entryAt(b);
      }
      setAfter(a, b, c) {
        let d = this.#r.indexOf(a);
        return -1 === d ? this : this.insert(d + 1, b, c);
      }
      first() {
        return this.entryAt(0);
      }
      last() {
        return this.entryAt(-1);
      }
      clear() {
        return (this.#r = []), super.clear();
      }
      delete(a) {
        let b = super.delete(a);
        return b && this.#r.splice(this.#r.indexOf(a), 1), b;
      }
      deleteAt(a) {
        let b = this.keyAt(a);
        return void 0 !== b && this.delete(b);
      }
      at(a) {
        let b = d5(this.#r, a);
        if (void 0 !== b) return this.get(b);
      }
      entryAt(a) {
        let b = d5(this.#r, a);
        if (void 0 !== b) return [b, this.get(b)];
      }
      indexOf(a) {
        return this.#r.indexOf(a);
      }
      keyAt(a) {
        return d5(this.#r, a);
      }
      from(a, b) {
        let c = this.indexOf(a);
        if (-1 === c) return;
        let d = c + b;
        return d < 0 && (d = 0), d >= this.size && (d = this.size - 1), this.at(d);
      }
      keyFrom(a, b) {
        let c = this.indexOf(a);
        if (-1 === c) return;
        let d = c + b;
        return d < 0 && (d = 0), d >= this.size && (d = this.size - 1), this.keyAt(d);
      }
      find(a, b) {
        let c = 0;
        for (let d of this) {
          if (Reflect.apply(a, b, [d, c, this])) return d;
          c++;
        }
      }
      findIndex(a, b) {
        let c = 0;
        for (let d of this) {
          if (Reflect.apply(a, b, [d, c, this])) return c;
          c++;
        }
        return -1;
      }
      filter(b, c) {
        let d = [],
          e = 0;
        for (let a of this) Reflect.apply(b, c, [a, e, this]) && d.push(a), e++;
        return new a(d);
      }
      map(b, c) {
        let d = [],
          e = 0;
        for (let a of this) d.push([a[0], Reflect.apply(b, c, [a, e, this])]), e++;
        return new a(d);
      }
      reduce(...a) {
        let [b, c] = a,
          d = 0,
          e = c ?? this.at(0);
        for (let c of this)
          (e = 0 === d && 1 === a.length ? c : Reflect.apply(b, this, [e, c, d, this])), d++;
        return e;
      }
      reduceRight(...a) {
        let [b, c] = a,
          d = c ?? this.at(-1);
        for (let c = this.size - 1; c >= 0; c--) {
          let e = this.at(c);
          d = c === this.size - 1 && 1 === a.length ? e : Reflect.apply(b, this, [d, e, c, this]);
        }
        return d;
      }
      toSorted(b) {
        return new a([...this.entries()].sort(b));
      }
      toReversed() {
        let b = new a();
        for (let a = this.size - 1; a >= 0; a--) {
          let c = this.keyAt(a),
            d = this.get(c);
          b.set(c, d);
        }
        return b;
      }
      toSpliced(...b) {
        let c = [...this.entries()];
        return c.splice(...b), new a(c);
      }
      slice(b, c) {
        let d = new a(),
          e = this.size - 1;
        if (void 0 === b) return d;
        b < 0 && (b += this.size), void 0 !== c && c > 0 && (e = c - 1);
        for (let a = b; a <= e; a++) {
          let b = this.keyAt(a),
            c = this.get(b);
          d.set(b, c);
        }
        return d;
      }
      every(a, b) {
        let c = 0;
        for (let d of this) {
          if (!Reflect.apply(a, b, [d, c, this])) return !1;
          c++;
        }
        return !0;
      }
      some(a, b) {
        let c = 0;
        for (let d of this) {
          if (Reflect.apply(a, b, [d, c, this])) return !0;
          c++;
        }
        return !1;
      }
    });
    var d7 = aX.createContext(void 0),
      d8 = (a) => {
        let { dir: b, children: c } = a;
        return (0, a0.jsx)(d7.Provider, { value: b, children: c });
      };
    function d9(a) {
      let b = aX.useContext(d7);
      return a || b || 'ltr';
    }
    a.s(['DirectionProvider', () => d8, 'Provider', () => d8, 'useDirection', () => d9], 7827);
    let ea = ['top', 'right', 'bottom', 'left'],
      eb = Math.min,
      ec = Math.max,
      ed = Math.round,
      ee = Math.floor,
      ef = (a) => ({ x: a, y: a }),
      eg = { left: 'right', right: 'left', bottom: 'top', top: 'bottom' },
      eh = { start: 'end', end: 'start' };
    function ei(a, b) {
      return 'function' == typeof a ? a(b) : a;
    }
    function ej(a) {
      return a.split('-')[0];
    }
    function ek(a) {
      return a.split('-')[1];
    }
    function el(a) {
      return 'x' === a ? 'y' : 'x';
    }
    function em(a) {
      return 'y' === a ? 'height' : 'width';
    }
    let en = new Set(['top', 'bottom']);
    function eo(a) {
      return en.has(ej(a)) ? 'y' : 'x';
    }
    function ep(a) {
      return a.replace(/start|end/g, (a) => eh[a]);
    }
    let eq = ['left', 'right'],
      er = ['right', 'left'],
      es = ['top', 'bottom'],
      et = ['bottom', 'top'];
    function eu(a) {
      return a.replace(/left|right|bottom|top/g, (a) => eg[a]);
    }
    function ev(a) {
      return 'number' != typeof a
        ? { top: 0, right: 0, bottom: 0, left: 0, ...a }
        : { top: a, right: a, bottom: a, left: a };
    }
    function ew(a) {
      let { x: b, y: c, width: d, height: e } = a;
      return { width: d, height: e, top: c, left: b, right: b + d, bottom: c + e, x: b, y: c };
    }
    function ex(a, b, c) {
      let d,
        { reference: e, floating: f } = a,
        g = eo(b),
        h = el(eo(b)),
        i = em(h),
        j = ej(b),
        k = 'y' === g,
        l = e.x + e.width / 2 - f.width / 2,
        m = e.y + e.height / 2 - f.height / 2,
        n = e[i] / 2 - f[i] / 2;
      switch (j) {
        case 'top':
          d = { x: l, y: e.y - f.height };
          break;
        case 'bottom':
          d = { x: l, y: e.y + e.height };
          break;
        case 'right':
          d = { x: e.x + e.width, y: m };
          break;
        case 'left':
          d = { x: e.x - f.width, y: m };
          break;
        default:
          d = { x: e.x, y: e.y };
      }
      switch (ek(b)) {
        case 'start':
          d[h] -= n * (c && k ? -1 : 1);
          break;
        case 'end':
          d[h] += n * (c && k ? -1 : 1);
      }
      return d;
    }
    let ey = async (a, b, c) => {
      let {
          placement: d = 'bottom',
          strategy: e = 'absolute',
          middleware: f = [],
          platform: g,
        } = c,
        h = f.filter(Boolean),
        i = await (null == g.isRTL ? void 0 : g.isRTL(b)),
        j = await g.getElementRects({ reference: a, floating: b, strategy: e }),
        { x: k, y: l } = ex(j, d, i),
        m = d,
        n = {},
        o = 0;
      for (let c = 0; c < h.length; c++) {
        let { name: f, fn: p } = h[c],
          {
            x: q,
            y: s,
            data: t,
            reset: u,
          } = await p({
            x: k,
            y: l,
            initialPlacement: d,
            placement: m,
            strategy: e,
            middlewareData: n,
            rects: j,
            platform: g,
            elements: { reference: a, floating: b },
          });
        (k = null != q ? q : k),
          (l = null != s ? s : l),
          (n = { ...n, [f]: { ...n[f], ...t } }),
          u &&
            o <= 50 &&
            (o++,
            'object' == typeof u &&
              (u.placement && (m = u.placement),
              u.rects &&
                (j =
                  !0 === u.rects
                    ? await g.getElementRects({ reference: a, floating: b, strategy: e })
                    : u.rects),
              ({ x: k, y: l } = ex(j, m, i))),
            (c = -1));
      }
      return { x: k, y: l, placement: m, strategy: e, middlewareData: n };
    };
    async function ez(a, b) {
      var c;
      void 0 === b && (b = {});
      let { x: d, y: e, platform: f, rects: g, elements: h, strategy: i } = a,
        {
          boundary: j = 'clippingAncestors',
          rootBoundary: k = 'viewport',
          elementContext: l = 'floating',
          altBoundary: m = !1,
          padding: n = 0,
        } = ei(b, a),
        o = ev(n),
        p = h[m ? ('floating' === l ? 'reference' : 'floating') : l],
        q = ew(
          await f.getClippingRect({
            element:
              null == (c = await (null == f.isElement ? void 0 : f.isElement(p))) || c
                ? p
                : p.contextElement ||
                  (await (null == f.getDocumentElement
                    ? void 0
                    : f.getDocumentElement(h.floating))),
            boundary: j,
            rootBoundary: k,
            strategy: i,
          })
        ),
        s =
          'floating' === l
            ? { x: d, y: e, width: g.floating.width, height: g.floating.height }
            : g.reference,
        t = await (null == f.getOffsetParent ? void 0 : f.getOffsetParent(h.floating)),
        u = ((await (null == f.isElement ? void 0 : f.isElement(t))) &&
          (await (null == f.getScale ? void 0 : f.getScale(t)))) || { x: 1, y: 1 },
        v = ew(
          f.convertOffsetParentRelativeRectToViewportRelativeRect
            ? await f.convertOffsetParentRelativeRectToViewportRelativeRect({
                elements: h,
                rect: s,
                offsetParent: t,
                strategy: i,
              })
            : s
        );
      return {
        top: (q.top - v.top + o.top) / u.y,
        bottom: (v.bottom - q.bottom + o.bottom) / u.y,
        left: (q.left - v.left + o.left) / u.x,
        right: (v.right - q.right + o.right) / u.x,
      };
    }
    function eA(a, b) {
      return {
        top: a.top - b.height,
        right: a.right - b.width,
        bottom: a.bottom - b.height,
        left: a.left - b.width,
      };
    }
    function eB(a) {
      return ea.some((b) => a[b] >= 0);
    }
    let eC = new Set(['left', 'top']);
    async function eD(a, b) {
      let { placement: c, platform: d, elements: e } = a,
        f = await (null == d.isRTL ? void 0 : d.isRTL(e.floating)),
        g = ej(c),
        h = ek(c),
        i = 'y' === eo(c),
        j = eC.has(g) ? -1 : 1,
        k = f && i ? -1 : 1,
        l = ei(b, a),
        {
          mainAxis: m,
          crossAxis: n,
          alignmentAxis: o,
        } = 'number' == typeof l
          ? { mainAxis: l, crossAxis: 0, alignmentAxis: null }
          : {
              mainAxis: l.mainAxis || 0,
              crossAxis: l.crossAxis || 0,
              alignmentAxis: l.alignmentAxis,
            };
      return (
        h && 'number' == typeof o && (n = 'end' === h ? -1 * o : o),
        i ? { x: n * k, y: m * j } : { x: m * j, y: n * k }
      );
    }
    function eE(a) {
      return (function (a) {
        return !1;
      })(a)
        ? (a.nodeName || '').toLowerCase()
        : '#document';
    }
    function eF(a) {
      var b;
      return (null == a || null == (b = a.ownerDocument) ? void 0 : b.defaultView) || window;
    }
    function eG(a) {
      var b;
      return null ==
        (b =
          ((function (a) {
            return !1;
          })(a)
            ? a.ownerDocument
            : a.document) || window.document)
        ? void 0
        : b.documentElement;
    }
    function eH(a) {
      return !1;
    }
    let eI = new Set(['inline', 'contents']);
    function eJ(a) {
      let { overflow: b, overflowX: c, overflowY: d, display: e } = eU(a);
      return /auto|scroll|overlay|hidden|clip/.test(b + d + c) && !eI.has(e);
    }
    let eK = new Set(['table', 'td', 'th']),
      eL = [':popover-open', ':modal'];
    function eM(a) {
      return eL.some((b) => {
        try {
          return a.matches(b);
        } catch (a) {
          return !1;
        }
      });
    }
    let eN = ['transform', 'translate', 'scale', 'rotate', 'perspective'],
      eO = ['transform', 'translate', 'scale', 'rotate', 'perspective', 'filter'],
      eP = ['paint', 'layout', 'strict', 'content'];
    function eQ(a) {
      let b = eR(),
        c = a;
      return (
        eN.some((a) => !!c[a] && 'none' !== c[a]) ||
        (!!c.containerType && 'normal' !== c.containerType) ||
        (!b && !!c.backdropFilter && 'none' !== c.backdropFilter) ||
        (!b && !!c.filter && 'none' !== c.filter) ||
        eO.some((a) => (c.willChange || '').includes(a)) ||
        eP.some((a) => (c.contain || '').includes(a))
      );
    }
    function eR() {
      return (
        'undefined' != typeof CSS &&
        !!CSS.supports &&
        CSS.supports('-webkit-backdrop-filter', 'none')
      );
    }
    let eS = new Set(['html', 'body', '#document']);
    function eT(a) {
      return eS.has(eE(a));
    }
    function eU(a) {
      return eF(a).getComputedStyle(a);
    }
    function eV(a) {
      return { scrollLeft: a.scrollX, scrollTop: a.scrollY };
    }
    function eW(a) {
      if ('html' === eE(a)) return a;
      let b = a.assignedSlot || a.parentNode || !1 || eG(a);
      return b;
    }
    function eX(a, b, c) {
      var d;
      void 0 === b && (b = []), void 0 === c && (c = !0);
      let e = (function a(b) {
          let c = eW(b);
          return eT(c) ? (b.ownerDocument ? b.ownerDocument.body : b.body) : a(c);
        })(a),
        f = e === (null == (d = a.ownerDocument) ? void 0 : d.body),
        g = eF(e);
      if (f) {
        let a = eY(g);
        return b.concat(g, g.visualViewport || [], eJ(e) ? e : [], a && c ? eX(a) : []);
      }
      return b.concat(e, eX(e, [], c));
    }
    function eY(a) {
      return a.parent && Object.getPrototypeOf(a.parent) ? a.frameElement : null;
    }
    function eZ(a) {
      let b = eU(a),
        c = parseFloat(b.width) || 0,
        d = parseFloat(b.height) || 0,
        e = !1,
        f = e ? a.offsetWidth : c,
        g = e ? a.offsetHeight : d,
        h = ed(c) !== f || ed(d) !== g;
      return h && ((c = f), (d = g)), { width: c, height: d, $: h };
    }
    function e$(a) {
      return 0, a.contextElement;
    }
    function e_(a) {
      let b = e$(a);
      1;
      return ef(1);
    }
    let e0 = ef(0);
    function e1(a) {
      let b = eF(a);
      return eR() && b.visualViewport
        ? { x: b.visualViewport.offsetLeft, y: b.visualViewport.offsetTop }
        : e0;
    }
    function e2(a, b, c, d) {
      var e;
      void 0 === b && (b = !1), void 0 === c && (c = !1);
      let f = a.getBoundingClientRect(),
        g = e$(a),
        h = ef(1);
      b && (d || (h = e_(a)));
      let i = (void 0 === (e = c) && (e = !1), d && (!e || d === eF(g)) && e) ? e1(g) : ef(0),
        j = (f.left + i.x) / h.x,
        k = (f.top + i.y) / h.y,
        l = f.width / h.x,
        m = f.height / h.y;
      if (g) {
        let a = eF(g),
          b = d,
          c = a,
          e = eY(c);
        for (; e && d && b !== c; ) {
          let a = e_(e),
            b = e.getBoundingClientRect(),
            d = eU(e),
            f = b.left + (e.clientLeft + parseFloat(d.paddingLeft)) * a.x,
            g = b.top + (e.clientTop + parseFloat(d.paddingTop)) * a.y;
          (j *= a.x), (k *= a.y), (l *= a.x), (m *= a.y), (j += f), (k += g), (e = eY((c = eF(e))));
        }
      }
      return ew({ width: l, height: m, x: j, y: k });
    }
    function e3(a, b) {
      let c = eV(a).scrollLeft;
      return b ? b.left + c : e2(eG(a)).left + c;
    }
    function e4(a, b) {
      let c = a.getBoundingClientRect();
      return { x: c.left + b.scrollLeft - e3(a, c), y: c.top + b.scrollTop };
    }
    function e5(a, b, c) {
      var d;
      let e;
      if ('viewport' === b)
        e = (function (a, b) {
          let c = eF(a),
            d = eG(a),
            e = c.visualViewport,
            f = d.clientWidth,
            g = d.clientHeight,
            h = 0,
            i = 0;
          if (e) {
            (f = e.width), (g = e.height);
            let a = eR();
            (!a || (a && 'fixed' === b)) && ((h = e.offsetLeft), (i = e.offsetTop));
          }
          let j = e3(d);
          if (j <= 0) {
            let a = d.ownerDocument,
              b = a.body,
              c = getComputedStyle(b),
              e =
                ('CSS1Compat' === a.compatMode &&
                  parseFloat(c.marginLeft) + parseFloat(c.marginRight)) ||
                0,
              g = Math.abs(d.clientWidth - b.clientWidth - e);
            g <= 25 && (f -= g);
          } else j <= 25 && (f += j);
          return { width: f, height: g, x: h, y: i };
        })(a, c);
      else if ('document' === b) {
        let b, c, f, g, h, i, j;
        (d = eG(a)),
          (b = eG(d)),
          (c = eV(d)),
          (f = d.ownerDocument.body),
          (g = ec(b.scrollWidth, b.clientWidth, f.scrollWidth, f.clientWidth)),
          (h = ec(b.scrollHeight, b.clientHeight, f.scrollHeight, f.clientHeight)),
          (i = -c.scrollLeft + e3(d)),
          (j = -c.scrollTop),
          'rtl' === eU(f).direction && (i += ec(b.clientWidth, f.clientWidth) - g),
          (e = { width: g, height: h, x: i, y: j });
      } else {
        1;
        {
          let c = e1(a);
          e = { x: b.x - c.x, y: b.y - c.y, width: b.width, height: b.height };
        }
      }
      return ew(e);
    }
    function e6(a) {
      return 'static' === eU(a).position;
    }
    function e7(a, b) {
      1;
      return null;
    }
    function e8(a, b) {
      var c;
      let d = eF(a);
      if (eM(a)) return d;
      1;
      {
        let b = eW(a);
        for (; b && !eT(b); ) {
          0;
          b = eW(b);
        }
        return d;
      }
    }
    let e9 = async function (a) {
        let b = this.getOffsetParent || e8,
          c = this.getDimensions,
          d = await c(a.floating);
        return {
          reference: (function (a, b, c) {
            var d;
            let e = ((d = 0), !1),
              f = eG(b),
              g = 'fixed' === c,
              h = e2(a, !0, g, b),
              i = { scrollLeft: 0, scrollTop: 0 },
              j = ef(0);
            if (e || (!e && !g))
              if ((('body' !== eE(b) || eJ(f)) && (i = eV(b)), e)) {
                let a = e2(b, !0, g, b);
                (j.x = a.x + b.clientLeft), (j.y = a.y + b.clientTop);
              } else f && (j.x = e3(f));
            g && !e && f && (j.x = e3(f));
            let k = !f || e || g ? ef(0) : e4(f, i);
            return {
              x: h.left + i.scrollLeft - j.x - k.x,
              y: h.top + i.scrollTop - j.y - k.y,
              width: h.width,
              height: h.height,
            };
          })(a.reference, await b(a.floating), a.strategy),
          floating: { x: 0, y: 0, width: d.width, height: d.height },
        };
      },
      fa = {
        convertOffsetParentRelativeRectToViewportRelativeRect: function (a) {
          var b, c;
          let { elements: d, rect: e, offsetParent: f, strategy: g } = a,
            h = 'fixed' === g,
            i = eG(f),
            j = !!d && eM(d.floating);
          if (f === i || (j && h)) return e;
          let k = { scrollLeft: 0, scrollTop: 0 },
            l = ef(1),
            m = ef(0),
            n = ((b = 0), !1);
          (n || (!n && !h)) && (('body' !== eE(f) || eJ(i)) && (k = eV(f)), (c = 0), 0);
          let o = !i || n || h ? ef(0) : e4(i, k);
          return {
            width: e.width * l.x,
            height: e.height * l.y,
            x: e.x * l.x - k.scrollLeft * l.x + m.x + o.x,
            y: e.y * l.y - k.scrollTop * l.y + m.y + o.y,
          };
        },
        getDocumentElement: eG,
        getClippingRect: function (a) {
          let { element: b, boundary: c, rootBoundary: d, strategy: e } = a,
            f = [
              ...('clippingAncestors' === c
                ? eM(b)
                  ? []
                  : (function (a, b) {
                      var c;
                      let d = b.get(a);
                      if (d) return d;
                      let e = eX(a, [], !1).filter((a) => {
                          var b;
                          return (b = 0), !1;
                        }),
                        f = 'fixed' === eU(a).position,
                        g = f ? eW(a) : a;
                      return (c = 0), b.set(a, e), e;
                    })(b, this._c)
                : [].concat(c)),
              d,
            ],
            g = f[0],
            h = f.reduce((a, c) => {
              let d = e5(b, c, e);
              return (
                (a.top = ec(d.top, a.top)),
                (a.right = eb(d.right, a.right)),
                (a.bottom = eb(d.bottom, a.bottom)),
                (a.left = ec(d.left, a.left)),
                a
              );
            }, e5(b, g, e));
          return { width: h.right - h.left, height: h.bottom - h.top, x: h.left, y: h.top };
        },
        getOffsetParent: e8,
        getElementRects: e9,
        getClientRects: function (a) {
          return Array.from(a.getClientRects());
        },
        getDimensions: function (a) {
          let { width: b, height: c } = eZ(a);
          return { width: b, height: c };
        },
        getScale: e_,
        isElement: eH,
        isRTL: function (a) {
          return 'rtl' === eU(a).direction;
        },
      };
    function fb(a, b) {
      return a.x === b.x && a.y === b.y && a.width === b.width && a.height === b.height;
    }
    let fc = (a) => ({
      name: 'arrow',
      options: a,
      async fn(b) {
        let { x: c, y: d, placement: e, rects: f, platform: g, elements: h, middlewareData: i } = b,
          { element: j, padding: k = 0 } = ei(a, b) || {};
        if (null == j) return {};
        let l = ev(k),
          m = { x: c, y: d },
          n = el(eo(e)),
          o = em(n),
          p = await g.getDimensions(j),
          q = 'y' === n,
          s = q ? 'clientHeight' : 'clientWidth',
          t = f.reference[o] + f.reference[n] - m[n] - f.floating[o],
          u = m[n] - f.reference[n],
          v = await (null == g.getOffsetParent ? void 0 : g.getOffsetParent(j)),
          w = v ? v[s] : 0;
        (w && (await (null == g.isElement ? void 0 : g.isElement(v)))) ||
          (w = h.floating[s] || f.floating[o]);
        let x = w / 2 - p[o] / 2 - 1,
          y = eb(l[q ? 'top' : 'left'], x),
          z = eb(l[q ? 'bottom' : 'right'], x),
          A = w - p[o] - z,
          B = w / 2 - p[o] / 2 + (t / 2 - u / 2),
          C = ec(y, eb(B, A)),
          D =
            !i.arrow &&
            null != ek(e) &&
            B !== C &&
            f.reference[o] / 2 - (B < y ? y : z) - p[o] / 2 < 0,
          E = D ? (B < y ? B - y : B - A) : 0;
        return {
          [n]: m[n] + E,
          data: { [n]: C, centerOffset: B - C - E, ...(D && { alignmentOffset: E }) },
          reset: D,
        };
      },
    });
    var fd = 'undefined' != typeof document ? aX.useLayoutEffect : function () {};
    function fe(a, b) {
      let c, d, e;
      if (a === b) return !0;
      if (typeof a != typeof b) return !1;
      if ('function' == typeof a && a.toString() === b.toString()) return !0;
      if (a && b && 'object' == typeof a) {
        if (Array.isArray(a)) {
          if ((c = a.length) !== b.length) return !1;
          for (d = c; 0 != d--; ) if (!fe(a[d], b[d])) return !1;
          return !0;
        }
        if ((c = (e = Object.keys(a)).length) !== Object.keys(b).length) return !1;
        for (d = c; 0 != d--; ) if (!{}.hasOwnProperty.call(b, e[d])) return !1;
        for (d = c; 0 != d--; ) {
          let c = e[d];
          if (('_owner' !== c || !a.$$typeof) && !fe(a[c], b[c])) return !1;
        }
        return !0;
      }
      return a != a && b != b;
    }
    function ff(a, b) {
      let c = 1;
      return Math.round(b * c) / c;
    }
    function fg(a) {
      let b = aX.useRef(a);
      return (
        fd(() => {
          b.current = a;
        }),
        b
      );
    }
    var fh = aX.forwardRef((a, b) => {
      let { children: c, width: d = 10, height: e = 5, ...f } = a;
      return (0, a0.jsx)(bc.svg, {
        ...f,
        ref: b,
        width: d,
        height: e,
        viewBox: '0 0 30 10',
        preserveAspectRatio: 'none',
        children: a.asChild ? c : (0, a0.jsx)('polygon', { points: '0,0 30,0 15,10' }),
      });
    });
    fh.displayName = 'Arrow';
    var fi = 'Popper',
      [fj, fk] = a2(fi),
      [fl, fm] = fj(fi),
      fn = (a) => {
        let { __scopePopper: b, children: c } = a,
          [d, e] = aX.useState(null);
        return (0, a0.jsx)(fl, { scope: b, anchor: d, onAnchorChange: e, children: c });
      };
    fn.displayName = fi;
    var fo = 'PopperAnchor',
      fp = aX.forwardRef((a, b) => {
        let { __scopePopper: c, virtualRef: d, ...e } = a,
          f = fm(fo, c),
          g = aX.useRef(null),
          h = a_(b, g),
          i = aX.useRef(null);
        return (
          aX.useEffect(() => {
            let a = i.current;
            (i.current = d?.current || g.current), a !== i.current && f.onAnchorChange(i.current);
          }),
          d ? null : (0, a0.jsx)(bc.div, { ...e, ref: h })
        );
      });
    fp.displayName = fo;
    var fq = 'PopperContent',
      [fr, fs] = fj(fq),
      ft = aX.forwardRef((a, b) => {
        var c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, s, t, u, v, w, x;
        let {
            __scopePopper: y,
            side: z = 'bottom',
            sideOffset: A = 0,
            align: B = 'center',
            alignOffset: C = 0,
            arrowPadding: D = 0,
            avoidCollisions: E = !0,
            collisionBoundary: F = [],
            collisionPadding: G = 0,
            sticky: H = 'partial',
            hideWhenDetached: I = !1,
            updatePositionStrategy: J = 'optimized',
            onPlaced: K,
            ...L
          } = a,
          M = fm(fq, y),
          [N, O] = aX.useState(null),
          P = a_(b, (a) => O(a)),
          [Q, R] = aX.useState(null),
          S = (function (a) {
            let [b, c] = aX.useState(void 0);
            return (
              a3(() => {
                if (a) {
                  c({ width: a.offsetWidth, height: a.offsetHeight });
                  let b = new ResizeObserver((b) => {
                    let d, e;
                    if (!Array.isArray(b) || !b.length) return;
                    let f = b[0];
                    if ('borderBoxSize' in f) {
                      let a = f.borderBoxSize,
                        b = Array.isArray(a) ? a[0] : a;
                      (d = b.inlineSize), (e = b.blockSize);
                    } else (d = a.offsetWidth), (e = a.offsetHeight);
                    c({ width: d, height: e });
                  });
                  return b.observe(a, { box: 'border-box' }), () => b.unobserve(a);
                }
                c(void 0);
              }, [a]),
              b
            );
          })(Q),
          T = S?.width ?? 0,
          U = S?.height ?? 0,
          V = 'number' == typeof G ? G : { top: 0, right: 0, bottom: 0, left: 0, ...G },
          W = Array.isArray(F) ? F : [F],
          X = W.length > 0,
          Y = { padding: V, boundary: W.filter(fx), altBoundary: X },
          {
            refs: Z,
            floatingStyles: $,
            placement: _,
            isPositioned: aa,
            middlewareData: ab,
          } = (function (a) {
            void 0 === a && (a = {});
            let {
                placement: b = 'bottom',
                strategy: c = 'absolute',
                middleware: d = [],
                platform: e,
                elements: { reference: f, floating: g } = {},
                transform: h = !0,
                whileElementsMounted: i,
                open: j,
              } = a,
              [k, l] = aX.useState({
                x: 0,
                y: 0,
                strategy: c,
                placement: b,
                middlewareData: {},
                isPositioned: !1,
              }),
              [m, n] = aX.useState(d);
            fe(m, d) || n(d);
            let [o, p] = aX.useState(null),
              [q, s] = aX.useState(null),
              t = aX.useCallback((a) => {
                a !== x.current && ((x.current = a), p(a));
              }, []),
              u = aX.useCallback((a) => {
                a !== y.current && ((y.current = a), s(a));
              }, []),
              v = f || o,
              w = g || q,
              x = aX.useRef(null),
              y = aX.useRef(null),
              z = aX.useRef(k),
              A = null != i,
              B = fg(i),
              C = fg(e),
              D = fg(j),
              E = aX.useCallback(() => {
                var a, d;
                let e, f, g;
                if (!x.current || !y.current) return;
                let h = { placement: b, strategy: c, middleware: m };
                C.current && (h.platform = C.current),
                  ((a = x.current),
                  (d = y.current),
                  (e = new Map()),
                  (g = { ...(f = { platform: fa, ...h }).platform, _c: e }),
                  ey(a, d, { ...f, platform: g })).then((a) => {
                    let b = { ...a, isPositioned: !1 !== D.current };
                    F.current &&
                      !fe(z.current, b) &&
                      ((z.current = b),
                      a9.flushSync(() => {
                        l(b);
                      }));
                  });
              }, [m, b, c, C, D]);
            fd(() => {
              !1 === j &&
                z.current.isPositioned &&
                ((z.current.isPositioned = !1), l((a) => ({ ...a, isPositioned: !1 })));
            }, [j]);
            let F = aX.useRef(!1);
            fd(
              () => (
                (F.current = !0),
                () => {
                  F.current = !1;
                }
              ),
              []
            ),
              fd(() => {
                if ((v && (x.current = v), w && (y.current = w), v && w)) {
                  if (B.current) return B.current(v, w, E);
                  E();
                }
              }, [v, w, E, B, A]);
            let G = aX.useMemo(
                () => ({ reference: x, floating: y, setReference: t, setFloating: u }),
                [t, u]
              ),
              H = aX.useMemo(() => ({ reference: v, floating: w }), [v, w]),
              I = aX.useMemo(() => {
                let a = { position: c, left: 0, top: 0 };
                if (!H.floating) return a;
                let b = ff(H.floating, k.x),
                  d = ff(H.floating, k.y);
                if (h)
                  return {
                    ...a,
                    transform: 'translate(' + b + 'px, ' + d + 'px)',
                    ...(H.floating, false),
                  };
                return { position: c, left: b, top: d };
              }, [c, h, H.floating, k.x, k.y]);
            return aX.useMemo(
              () => ({ ...k, update: E, refs: G, elements: H, floatingStyles: I }),
              [k, E, G, H, I]
            );
          })({
            strategy: 'fixed',
            placement: z + ('center' !== B ? '-' + B : ''),
            whileElementsMounted: (...a) =>
              (function (a, b, c, d) {
                let e;
                void 0 === d && (d = {});
                let {
                    ancestorScroll: f = !0,
                    ancestorResize: g = !0,
                    elementResize: h = 'function' == typeof ResizeObserver,
                    layoutShift: i = 'function' == typeof IntersectionObserver,
                    animationFrame: j = !1,
                  } = d,
                  k = e$(a),
                  l = f || g ? [...(k ? eX(k) : []), ...eX(b)] : [];
                l.forEach((a) => {
                  f && a.addEventListener('scroll', c, { passive: !0 }),
                    g && a.addEventListener('resize', c);
                });
                let m =
                    k && i
                      ? (function (a, b) {
                          let c,
                            d = null,
                            e = eG(a);
                          function f() {
                            var a;
                            clearTimeout(c), null == (a = d) || a.disconnect(), (d = null);
                          }
                          return (
                            !(function g(h, i) {
                              void 0 === h && (h = !1), void 0 === i && (i = 1), f();
                              let j = a.getBoundingClientRect(),
                                { left: k, top: l, width: m, height: n } = j;
                              if ((h || b(), !m || !n)) return;
                              let o = {
                                  rootMargin:
                                    -ee(l) +
                                    'px ' +
                                    -ee(e.clientWidth - (k + m)) +
                                    'px ' +
                                    -ee(e.clientHeight - (l + n)) +
                                    'px ' +
                                    -ee(k) +
                                    'px',
                                  threshold: ec(0, eb(1, i)) || 1,
                                },
                                p = !0;
                              function q(b) {
                                let d = b[0].intersectionRatio;
                                if (d !== i) {
                                  if (!p) return g();
                                  d
                                    ? g(!1, d)
                                    : (c = setTimeout(() => {
                                        g(!1, 1e-7);
                                      }, 1e3));
                                }
                                1 !== d || fb(j, a.getBoundingClientRect()) || g(), (p = !1);
                              }
                              try {
                                d = new IntersectionObserver(q, { ...o, root: e.ownerDocument });
                              } catch (a) {
                                d = new IntersectionObserver(q, o);
                              }
                              d.observe(a);
                            })(!0),
                            f
                          );
                        })(k, c)
                      : null,
                  n = -1,
                  o = null;
                h &&
                  ((o = new ResizeObserver((a) => {
                    let [d] = a;
                    d &&
                      d.target === k &&
                      o &&
                      (o.unobserve(b),
                      cancelAnimationFrame(n),
                      (n = requestAnimationFrame(() => {
                        var a;
                        null == (a = o) || a.observe(b);
                      }))),
                      c();
                  })),
                  k && !j && o.observe(k),
                  o.observe(b));
                let p = j ? e2(a) : null;
                return (
                  j &&
                    (function b() {
                      let d = e2(a);
                      p && !fb(p, d) && c(), (p = d), (e = requestAnimationFrame(b));
                    })(),
                  c(),
                  () => {
                    var a;
                    l.forEach((a) => {
                      f && a.removeEventListener('scroll', c),
                        g && a.removeEventListener('resize', c);
                    }),
                      null == m || m(),
                      null == (a = o) || a.disconnect(),
                      (o = null),
                      j && cancelAnimationFrame(e);
                  }
                );
              })(...a, { animationFrame: 'always' === J }),
            elements: { reference: M.anchor },
            middleware: [
              {
                ...{
                  name: 'offset',
                  options: (e = c = { mainAxis: A + U, alignmentAxis: C }),
                  async fn(a) {
                    var b, c;
                    let { x: d, y: f, placement: g, middlewareData: h } = a,
                      i = await eD(a, e);
                    return g === (null == (b = h.offset) ? void 0 : b.placement) &&
                      null != (c = h.arrow) &&
                      c.alignmentOffset
                      ? {}
                      : { x: d + i.x, y: f + i.y, data: { ...i, placement: g } };
                  },
                },
                options: [c, d],
              },
              E && {
                ...{
                  name: 'shift',
                  options:
                    (k = i =
                      {
                        mainAxis: !0,
                        crossAxis: !1,
                        limiter:
                          'partial' === H
                            ? {
                                ...(void 0 === (h = f) && (h = {}),
                                {
                                  options: h,
                                  fn(a) {
                                    let {
                                        x: b,
                                        y: c,
                                        placement: d,
                                        rects: e,
                                        middlewareData: f,
                                      } = a,
                                      {
                                        offset: g = 0,
                                        mainAxis: i = !0,
                                        crossAxis: j = !0,
                                      } = ei(h, a),
                                      k = { x: b, y: c },
                                      l = eo(d),
                                      m = el(l),
                                      n = k[m],
                                      o = k[l],
                                      p = ei(g, a),
                                      q =
                                        'number' == typeof p
                                          ? { mainAxis: p, crossAxis: 0 }
                                          : { mainAxis: 0, crossAxis: 0, ...p };
                                    if (i) {
                                      let a = 'y' === m ? 'height' : 'width',
                                        b = e.reference[m] - e.floating[a] + q.mainAxis,
                                        c = e.reference[m] + e.reference[a] - q.mainAxis;
                                      n < b ? (n = b) : n > c && (n = c);
                                    }
                                    if (j) {
                                      var s, t;
                                      let a = 'y' === m ? 'width' : 'height',
                                        b = eC.has(ej(d)),
                                        c =
                                          e.reference[l] -
                                          e.floating[a] +
                                          ((b && (null == (s = f.offset) ? void 0 : s[l])) || 0) +
                                          (b ? 0 : q.crossAxis),
                                        g =
                                          e.reference[l] +
                                          e.reference[a] +
                                          (b ? 0 : (null == (t = f.offset) ? void 0 : t[l]) || 0) -
                                          (b ? q.crossAxis : 0);
                                      o < c ? (o = c) : o > g && (o = g);
                                    }
                                    return { [m]: n, [l]: o };
                                  },
                                }),
                                options: [f, g],
                              }
                            : void 0,
                        ...Y,
                      }),
                  async fn(a) {
                    let { x: b, y: c, placement: d } = a,
                      {
                        mainAxis: e = !0,
                        crossAxis: f = !1,
                        limiter: g = {
                          fn: (a) => {
                            let { x: b, y: c } = a;
                            return { x: b, y: c };
                          },
                        },
                        ...h
                      } = ei(k, a),
                      i = { x: b, y: c },
                      j = await ez(a, h),
                      l = eo(ej(d)),
                      m = el(l),
                      n = i[m],
                      o = i[l];
                    if (e) {
                      let a = 'y' === m ? 'top' : 'left',
                        b = 'y' === m ? 'bottom' : 'right',
                        c = n + j[a],
                        d = n - j[b];
                      n = ec(c, eb(n, d));
                    }
                    if (f) {
                      let a = 'y' === l ? 'top' : 'left',
                        b = 'y' === l ? 'bottom' : 'right',
                        c = o + j[a],
                        d = o - j[b];
                      o = ec(c, eb(o, d));
                    }
                    let p = g.fn({ ...a, [m]: n, [l]: o });
                    return { ...p, data: { x: p.x - b, y: p.y - c, enabled: { [m]: e, [l]: f } } };
                  },
                },
                options: [i, j],
              },
              E && {
                ...{
                  name: 'flip',
                  options: (n = l = { ...Y }),
                  async fn(a) {
                    var b, c, d, e, f, g, h, i;
                    let j,
                      k,
                      l,
                      {
                        placement: m,
                        middlewareData: o,
                        rects: p,
                        initialPlacement: q,
                        platform: s,
                        elements: t,
                      } = a,
                      {
                        mainAxis: u = !0,
                        crossAxis: v = !0,
                        fallbackPlacements: w,
                        fallbackStrategy: x = 'bestFit',
                        fallbackAxisSideDirection: y = 'none',
                        flipAlignment: z = !0,
                        ...A
                      } = ei(n, a);
                    if (null != (b = o.arrow) && b.alignmentOffset) return {};
                    let B = ej(m),
                      C = eo(q),
                      D = ej(q) === q,
                      E = await (null == s.isRTL ? void 0 : s.isRTL(t.floating)),
                      F = w || (D || !z ? [eu(q)] : ((j = eu(q)), [ep(q), j, ep(j)])),
                      G = 'none' !== y;
                    !w &&
                      G &&
                      F.push(
                        ...((k = ek(q)),
                        (l = (function (a, b, c) {
                          switch (a) {
                            case 'top':
                            case 'bottom':
                              if (c) return b ? er : eq;
                              return b ? eq : er;
                            case 'left':
                            case 'right':
                              return b ? es : et;
                            default:
                              return [];
                          }
                        })(ej(q), 'start' === y, E)),
                        k && ((l = l.map((a) => a + '-' + k)), z && (l = l.concat(l.map(ep)))),
                        l)
                      );
                    let H = [q, ...F],
                      I = await ez(a, A),
                      J = [],
                      K = (null == (c = o.flip) ? void 0 : c.overflows) || [];
                    if ((u && J.push(I[B]), v)) {
                      let a,
                        b,
                        c,
                        d,
                        e =
                          ((g = m),
                          (h = p),
                          void 0 === (i = E) && (i = !1),
                          (a = ek(g)),
                          (c = em((b = el(eo(g))))),
                          (d =
                            'x' === b
                              ? a === (i ? 'end' : 'start')
                                ? 'right'
                                : 'left'
                              : 'start' === a
                              ? 'bottom'
                              : 'top'),
                          h.reference[c] > h.floating[c] && (d = eu(d)),
                          [d, eu(d)]);
                      J.push(I[e[0]], I[e[1]]);
                    }
                    if (((K = [...K, { placement: m, overflows: J }]), !J.every((a) => a <= 0))) {
                      let a = ((null == (d = o.flip) ? void 0 : d.index) || 0) + 1,
                        b = H[a];
                      if (
                        b &&
                        ('alignment' !== v ||
                          C === eo(b) ||
                          K.every((a) => eo(a.placement) !== C || a.overflows[0] > 0))
                      )
                        return { data: { index: a, overflows: K }, reset: { placement: b } };
                      let c =
                        null ==
                        (e = K.filter((a) => a.overflows[0] <= 0).sort(
                          (a, b) => a.overflows[1] - b.overflows[1]
                        )[0])
                          ? void 0
                          : e.placement;
                      if (!c)
                        switch (x) {
                          case 'bestFit': {
                            let a =
                              null ==
                              (f = K.filter((a) => {
                                if (G) {
                                  let b = eo(a.placement);
                                  return b === C || 'y' === b;
                                }
                                return !0;
                              })
                                .map((a) => [
                                  a.placement,
                                  a.overflows.filter((a) => a > 0).reduce((a, b) => a + b, 0),
                                ])
                                .sort((a, b) => a[1] - b[1])[0])
                                ? void 0
                                : f[0];
                            a && (c = a);
                            break;
                          }
                          case 'initialPlacement':
                            c = q;
                        }
                      if (m !== c) return { reset: { placement: c } };
                    }
                    return {};
                  },
                },
                options: [l, m],
              },
              {
                ...{
                  name: 'size',
                  options:
                    (q = o =
                      {
                        ...Y,
                        apply: ({
                          elements: a,
                          rects: b,
                          availableWidth: c,
                          availableHeight: d,
                        }) => {
                          let { width: e, height: f } = b.reference,
                            g = a.floating.style;
                          g.setProperty('--radix-popper-available-width', `${c}px`),
                            g.setProperty('--radix-popper-available-height', `${d}px`),
                            g.setProperty('--radix-popper-anchor-width', `${e}px`),
                            g.setProperty('--radix-popper-anchor-height', `${f}px`);
                        },
                      }),
                  async fn(a) {
                    var b, c;
                    let d,
                      e,
                      { placement: f, rects: g, platform: h, elements: i } = a,
                      { apply: j = () => {}, ...k } = ei(q, a),
                      l = await ez(a, k),
                      m = ej(f),
                      n = ek(f),
                      o = 'y' === eo(f),
                      { width: p, height: s } = g.floating;
                    'top' === m || 'bottom' === m
                      ? ((d = m),
                        (e =
                          n ===
                          ((await (null == h.isRTL ? void 0 : h.isRTL(i.floating)))
                            ? 'start'
                            : 'end')
                            ? 'left'
                            : 'right'))
                      : ((e = m), (d = 'end' === n ? 'top' : 'bottom'));
                    let t = s - l.top - l.bottom,
                      u = p - l.left - l.right,
                      v = eb(s - l[d], t),
                      w = eb(p - l[e], u),
                      x = !a.middlewareData.shift,
                      y = v,
                      z = w;
                    if (
                      (null != (b = a.middlewareData.shift) && b.enabled.x && (z = u),
                      null != (c = a.middlewareData.shift) && c.enabled.y && (y = t),
                      x && !n)
                    ) {
                      let a = ec(l.left, 0),
                        b = ec(l.right, 0),
                        c = ec(l.top, 0),
                        d = ec(l.bottom, 0);
                      o
                        ? (z = p - 2 * (0 !== a || 0 !== b ? a + b : ec(l.left, l.right)))
                        : (y = s - 2 * (0 !== c || 0 !== d ? c + d : ec(l.top, l.bottom)));
                    }
                    await j({ ...a, availableWidth: z, availableHeight: y });
                    let A = await h.getDimensions(i.floating);
                    return p !== A.width || s !== A.height ? { reset: { rects: !0 } } : {};
                  },
                },
                options: [o, p],
              },
              Q && {
                ...{
                  name: 'arrow',
                  options: (u = s = { element: Q, padding: D }),
                  fn(a) {
                    let { element: b, padding: c } = 'function' == typeof u ? u(a) : u;
                    return b && {}.hasOwnProperty.call(b, 'current')
                      ? null != b.current
                        ? fc({ element: b.current, padding: c }).fn(a)
                        : {}
                      : b
                      ? fc({ element: b, padding: c }).fn(a)
                      : {};
                  },
                },
                options: [s, t],
              },
              fy({ arrowWidth: T, arrowHeight: U }),
              I && {
                ...{
                  name: 'hide',
                  options: (x = v = { strategy: 'referenceHidden', ...Y }),
                  async fn(a) {
                    let { rects: b } = a,
                      { strategy: c = 'referenceHidden', ...d } = ei(x, a);
                    switch (c) {
                      case 'referenceHidden': {
                        let c = eA(await ez(a, { ...d, elementContext: 'reference' }), b.reference);
                        return { data: { referenceHiddenOffsets: c, referenceHidden: eB(c) } };
                      }
                      case 'escaped': {
                        let c = eA(await ez(a, { ...d, altBoundary: !0 }), b.floating);
                        return { data: { escapedOffsets: c, escaped: eB(c) } };
                      }
                      default:
                        return {};
                    }
                  },
                },
                options: [v, w],
              },
            ],
          }),
          [ac, ad] = fz(_),
          ae = be(K);
        a3(() => {
          aa && ae?.();
        }, [aa, ae]);
        let af = ab.arrow?.x,
          ag = ab.arrow?.y,
          ah = ab.arrow?.centerOffset !== 0,
          [ai, aj] = aX.useState();
        return (
          a3(() => {
            N && aj(window.getComputedStyle(N).zIndex);
          }, [N]),
          (0, a0.jsx)('div', {
            ref: Z.setFloating,
            'data-radix-popper-content-wrapper': '',
            style: {
              ...$,
              transform: aa ? $.transform : 'translate(0, -200%)',
              minWidth: 'max-content',
              zIndex: ai,
              '--radix-popper-transform-origin': [
                ab.transformOrigin?.x,
                ab.transformOrigin?.y,
              ].join(' '),
              ...(ab.hide?.referenceHidden && { visibility: 'hidden', pointerEvents: 'none' }),
            },
            dir: a.dir,
            children: (0, a0.jsx)(fr, {
              scope: y,
              placedSide: ac,
              onArrowChange: R,
              arrowX: af,
              arrowY: ag,
              shouldHideArrow: ah,
              children: (0, a0.jsx)(bc.div, {
                'data-side': ac,
                'data-align': ad,
                ...L,
                ref: P,
                style: { ...L.style, animation: aa ? void 0 : 'none' },
              }),
            }),
          })
        );
      });
    ft.displayName = fq;
    var fu = 'PopperArrow',
      fv = { top: 'bottom', right: 'left', bottom: 'top', left: 'right' },
      fw = aX.forwardRef(function (a, b) {
        let { __scopePopper: c, ...d } = a,
          e = fs(fu, c),
          f = fv[e.placedSide];
        return (0,
        a0.jsx)('span', { ref: e.onArrowChange, style: { position: 'absolute', left: e.arrowX, top: e.arrowY, [f]: 0, transformOrigin: { top: '', right: '0 0', bottom: 'center 0', left: '100% 0' }[e.placedSide], transform: { top: 'translateY(100%)', right: 'translateY(50%) rotate(90deg) translateX(-50%)', bottom: 'rotate(180deg)', left: 'translateY(50%) rotate(-90deg) translateX(50%)' }[e.placedSide], visibility: e.shouldHideArrow ? 'hidden' : void 0 }, children: (0, a0.jsx)(fh, { ...d, ref: b, style: { ...d.style, display: 'block' } }) });
      });
    function fx(a) {
      return null !== a;
    }
    fw.displayName = fu;
    var fy = (a) => ({
      name: 'transformOrigin',
      options: a,
      fn(b) {
        let { placement: c, rects: d, middlewareData: e } = b,
          f = e.arrow?.centerOffset !== 0,
          g = f ? 0 : a.arrowWidth,
          h = f ? 0 : a.arrowHeight,
          [i, j] = fz(c),
          k = { start: '0%', center: '50%', end: '100%' }[j],
          l = (e.arrow?.x ?? 0) + g / 2,
          m = (e.arrow?.y ?? 0) + h / 2,
          n = '',
          o = '';
        return (
          'bottom' === i
            ? ((n = f ? k : `${l}px`), (o = `${-h}px`))
            : 'top' === i
            ? ((n = f ? k : `${l}px`), (o = `${d.floating.height + h}px`))
            : 'right' === i
            ? ((n = `${-h}px`), (o = f ? k : `${m}px`))
            : 'left' === i && ((n = `${d.floating.width + h}px`), (o = f ? k : `${m}px`)),
          { data: { x: n, y: o } }
        );
      },
    });
    function fz(a) {
      let [b, c = 'center'] = a.split('-');
      return [b, c];
    }
    a.s(
      [
        'Anchor',
        () => fp,
        'Arrow',
        () => fw,
        'Content',
        () => ft,
        'Root',
        () => fn,
        'createPopperScope',
        () => fk,
      ],
      4691
    );
    var fA = 'rovingFocusGroup.onEntryFocus',
      fB = { bubbles: !1, cancelable: !0 },
      fC = 'RovingFocusGroup',
      [fD, fE, fF] = d3(fC),
      [fG, fH] = a2(fC, [fF]),
      [fI, fJ] = fG(fC),
      fK = aX.forwardRef((a, b) =>
        (0, a0.jsx)(fD.Provider, {
          scope: a.__scopeRovingFocusGroup,
          children: (0, a0.jsx)(fD.Slot, {
            scope: a.__scopeRovingFocusGroup,
            children: (0, a0.jsx)(fL, { ...a, ref: b }),
          }),
        })
      );
    fK.displayName = fC;
    var fL = aX.forwardRef((a, b) => {
        let {
            __scopeRovingFocusGroup: c,
            orientation: d,
            loop: e = !1,
            dir: f,
            currentTabStopId: g,
            defaultCurrentTabStopId: h,
            onCurrentTabStopIdChange: i,
            onEntryFocus: j,
            preventScrollOnEntryFocus: k = !1,
            ...l
          } = a,
          m = aX.useRef(null),
          n = a_(b, m),
          o = d9(f),
          [p, q] = a8({ prop: g, defaultProp: h ?? null, onChange: i, caller: fC }),
          [s, t] = aX.useState(!1),
          u = be(j),
          v = fE(c),
          w = aX.useRef(!1),
          [x, y] = aX.useState(0);
        return (
          aX.useEffect(() => {
            let a = m.current;
            if (a) return a.addEventListener(fA, u), () => a.removeEventListener(fA, u);
          }, [u]),
          (0, a0.jsx)(fI, {
            scope: c,
            orientation: d,
            dir: o,
            loop: e,
            currentTabStopId: p,
            onItemFocus: aX.useCallback((a) => q(a), [q]),
            onItemShiftTab: aX.useCallback(() => t(!0), []),
            onFocusableItemAdd: aX.useCallback(() => y((a) => a + 1), []),
            onFocusableItemRemove: aX.useCallback(() => y((a) => a - 1), []),
            children: (0, a0.jsx)(bc.div, {
              tabIndex: s || 0 === x ? -1 : 0,
              'data-orientation': d,
              ...l,
              ref: n,
              style: { outline: 'none', ...a.style },
              onMouseDown: aY(a.onMouseDown, () => {
                w.current = !0;
              }),
              onFocus: aY(a.onFocus, (a) => {
                let b = !w.current;
                if (a.target === a.currentTarget && b && !s) {
                  let b = new CustomEvent(fA, fB);
                  if ((a.currentTarget.dispatchEvent(b), !b.defaultPrevented)) {
                    let a = v().filter((a) => a.focusable);
                    fP(
                      [a.find((a) => a.active), a.find((a) => a.id === p), ...a]
                        .filter(Boolean)
                        .map((a) => a.ref.current),
                      k
                    );
                  }
                }
                w.current = !1;
              }),
              onBlur: aY(a.onBlur, () => t(!1)),
            }),
          })
        );
      }),
      fM = 'RovingFocusGroupItem',
      fN = aX.forwardRef((a, b) => {
        let {
            __scopeRovingFocusGroup: c,
            focusable: d = !0,
            active: e = !1,
            tabStopId: f,
            children: g,
            ...h
          } = a,
          i = a6(),
          j = f || i,
          k = fJ(fM, c),
          l = k.currentTabStopId === j,
          m = fE(c),
          { onFocusableItemAdd: n, onFocusableItemRemove: o, currentTabStopId: p } = k;
        return (
          aX.useEffect(() => {
            if (d) return n(), () => o();
          }, [d, n, o]),
          (0, a0.jsx)(fD.ItemSlot, {
            scope: c,
            id: j,
            focusable: d,
            active: e,
            children: (0, a0.jsx)(bc.span, {
              tabIndex: l ? 0 : -1,
              'data-orientation': k.orientation,
              ...h,
              ref: b,
              onMouseDown: aY(a.onMouseDown, (a) => {
                d ? k.onItemFocus(j) : a.preventDefault();
              }),
              onFocus: aY(a.onFocus, () => k.onItemFocus(j)),
              onKeyDown: aY(a.onKeyDown, (a) => {
                if ('Tab' === a.key && a.shiftKey) return void k.onItemShiftTab();
                if (a.target !== a.currentTarget) return;
                let b = (function (a, b, c) {
                  var d;
                  let e =
                    ((d = a.key),
                    'rtl' !== c
                      ? d
                      : 'ArrowLeft' === d
                      ? 'ArrowRight'
                      : 'ArrowRight' === d
                      ? 'ArrowLeft'
                      : d);
                  if (
                    !('vertical' === b && ['ArrowLeft', 'ArrowRight'].includes(e)) &&
                    !('horizontal' === b && ['ArrowUp', 'ArrowDown'].includes(e))
                  )
                    return fO[e];
                })(a, k.orientation, k.dir);
                if (void 0 !== b) {
                  if (a.metaKey || a.ctrlKey || a.altKey || a.shiftKey) return;
                  a.preventDefault();
                  let e = m()
                    .filter((a) => a.focusable)
                    .map((a) => a.ref.current);
                  if ('last' === b) e.reverse();
                  else if ('prev' === b || 'next' === b) {
                    var c, d;
                    'prev' === b && e.reverse();
                    let f = e.indexOf(a.currentTarget);
                    e = k.loop
                      ? ((c = e), (d = f + 1), c.map((a, b) => c[(d + b) % c.length]))
                      : e.slice(f + 1);
                  }
                  setTimeout(() => fP(e));
                }
              }),
              children:
                'function' == typeof g ? g({ isCurrentTabStop: l, hasTabStop: null != p }) : g,
            }),
          })
        );
      });
    fN.displayName = fM;
    var fO = {
      ArrowLeft: 'prev',
      ArrowUp: 'prev',
      ArrowRight: 'next',
      ArrowDown: 'next',
      PageUp: 'first',
      Home: 'first',
      PageDown: 'last',
      End: 'last',
    };
    function fP(a, b = !1) {
      let c = document.activeElement;
      for (let d of a)
        if (d === c || (d.focus({ preventScroll: b }), document.activeElement !== c)) return;
    }
    var fQ = Symbol('radix.slottable');
    function fR(a) {
      return (
        aX.isValidElement(a) &&
        'function' == typeof a.type &&
        '__radixId' in a.type &&
        a.type.__radixId === fQ
      );
    }
    var fS = ['Enter', ' '],
      fT = ['ArrowUp', 'PageDown', 'End'],
      fU = ['ArrowDown', 'PageUp', 'Home', ...fT],
      fV = { ltr: [...fS, 'ArrowRight'], rtl: [...fS, 'ArrowLeft'] },
      fW = { ltr: ['ArrowLeft'], rtl: ['ArrowRight'] },
      fX = 'Menu',
      [fY, fZ, f$] = d3(fX),
      [f_, f0] = a2(fX, [f$, fk, fH]),
      f1 = fk(),
      f2 = fH(),
      [f3, f4] = f_(fX),
      [f5, f6] = f_(fX),
      f7 = (a) => {
        let {
            __scopeMenu: b,
            open: c = !1,
            children: d,
            dir: e,
            onOpenChange: f,
            modal: g = !0,
          } = a,
          h = f1(b),
          [i, j] = aX.useState(null),
          k = aX.useRef(!1),
          l = be(f),
          m = d9(e);
        return (
          aX.useEffect(() => {
            let a = () => {
                (k.current = !0),
                  document.addEventListener('pointerdown', b, { capture: !0, once: !0 }),
                  document.addEventListener('pointermove', b, { capture: !0, once: !0 });
              },
              b = () => (k.current = !1);
            return (
              document.addEventListener('keydown', a, { capture: !0 }),
              () => {
                document.removeEventListener('keydown', a, { capture: !0 }),
                  document.removeEventListener('pointerdown', b, { capture: !0 }),
                  document.removeEventListener('pointermove', b, { capture: !0 });
              }
            );
          }, []),
          (0, a0.jsx)(fn, {
            ...h,
            children: (0, a0.jsx)(f3, {
              scope: b,
              open: c,
              onOpenChange: l,
              content: i,
              onContentChange: j,
              children: (0, a0.jsx)(f5, {
                scope: b,
                onClose: aX.useCallback(() => l(!1), [l]),
                isUsingKeyboardRef: k,
                dir: m,
                modal: g,
                children: d,
              }),
            }),
          })
        );
      };
    f7.displayName = fX;
    var f8 = aX.forwardRef((a, b) => {
      let { __scopeMenu: c, ...d } = a,
        e = f1(c);
      return (0, a0.jsx)(fp, { ...e, ...d, ref: b });
    });
    f8.displayName = 'MenuAnchor';
    var f9 = 'MenuPortal',
      [ga, gb] = f_(f9, { forceMount: void 0 }),
      gc = (a) => {
        let { __scopeMenu: b, forceMount: c, children: d, container: e } = a,
          f = f4(f9, b);
        return (0, a0.jsx)(ga, {
          scope: b,
          forceMount: c,
          children: (0, a0.jsx)(bu, {
            present: c || f.open,
            children: (0, a0.jsx)(bt, { asChild: !0, container: e, children: d }),
          }),
        });
      };
    gc.displayName = f9;
    var gd = 'MenuContent',
      [ge, gf] = f_(gd),
      gg = aX.forwardRef((a, b) => {
        let c = gb(gd, a.__scopeMenu),
          { forceMount: d = c.forceMount, ...e } = a,
          f = f4(gd, a.__scopeMenu),
          g = f6(gd, a.__scopeMenu);
        return (0, a0.jsx)(fY.Provider, {
          scope: a.__scopeMenu,
          children: (0, a0.jsx)(bu, {
            present: d || f.open,
            children: (0, a0.jsx)(fY.Slot, {
              scope: a.__scopeMenu,
              children: g.modal
                ? (0, a0.jsx)(gh, { ...e, ref: b })
                : (0, a0.jsx)(gi, { ...e, ref: b }),
            }),
          }),
        });
      }),
      gh = aX.forwardRef((a, b) => {
        let c = f4(gd, a.__scopeMenu),
          d = aX.useRef(null),
          e = a_(b, d);
        return (
          aX.useEffect(() => {
            let a = d.current;
            if (a) return ca(a);
          }, []),
          (0, a0.jsx)(gk, {
            ...a,
            ref: e,
            trapFocus: c.open,
            disableOutsidePointerEvents: c.open,
            disableOutsideScroll: !0,
            onFocusOutside: aY(a.onFocusOutside, (a) => a.preventDefault(), {
              checkForDefaultPrevented: !1,
            }),
            onDismiss: () => c.onOpenChange(!1),
          })
        );
      }),
      gi = aX.forwardRef((a, b) => {
        let c = f4(gd, a.__scopeMenu);
        return (0, a0.jsx)(gk, {
          ...a,
          ref: b,
          trapFocus: !1,
          disableOutsidePointerEvents: !1,
          disableOutsideScroll: !1,
          onDismiss: () => c.onOpenChange(!1),
        });
      }),
      gj =
        (((E = aX.forwardRef((a, b) => {
          let { children: c, ...d } = a;
          if (aX.isValidElement(c)) {
            var e;
            let a,
              f,
              g =
                ((e = c),
                (f =
                  (a = Object.getOwnPropertyDescriptor(e.props, 'ref')?.get) &&
                  'isReactWarning' in a &&
                  a.isReactWarning)
                  ? e.ref
                  : (f =
                      (a = Object.getOwnPropertyDescriptor(e, 'ref')?.get) &&
                      'isReactWarning' in a &&
                      a.isReactWarning)
                  ? e.props.ref
                  : e.props.ref || e.ref),
              h = (function (a, b) {
                let c = { ...b };
                for (let d in b) {
                  let e = a[d],
                    f = b[d];
                  /^on[A-Z]/.test(d)
                    ? e && f
                      ? (c[d] = (...a) => {
                          let b = f(...a);
                          return e(...a), b;
                        })
                      : e && (c[d] = e)
                    : 'style' === d
                    ? (c[d] = { ...e, ...f })
                    : 'className' === d && (c[d] = [e, f].filter(Boolean).join(' '));
                }
                return { ...a, ...c };
              })(d, c.props);
            return c.type !== aX.Fragment && (h.ref = b ? a$(b, g) : g), aX.cloneElement(c, h);
          }
          return aX.Children.count(c) > 1 ? aX.Children.only(null) : null;
        })).displayName = 'MenuContent.ScrollLock.SlotClone'),
        (n = E),
        ((o = aX.forwardRef((a, b) => {
          let { children: c, ...d } = a,
            e = aX.Children.toArray(c),
            f = e.find(fR);
          if (f) {
            let a = f.props.children,
              c = e.map((b) =>
                b !== f
                  ? b
                  : aX.Children.count(a) > 1
                  ? aX.Children.only(null)
                  : aX.isValidElement(a)
                  ? a.props.children
                  : null
              );
            return (0, a0.jsx)(n, {
              ...d,
              ref: b,
              children: aX.isValidElement(a) ? aX.cloneElement(a, void 0, c) : null,
            });
          }
          return (0, a0.jsx)(n, { ...d, ref: b, children: c });
        })).displayName = 'MenuContent.ScrollLock.Slot'),
        o),
      gk = aX.forwardRef((a, b) => {
        let {
            __scopeMenu: c,
            loop: d = !1,
            trapFocus: e,
            onOpenAutoFocus: f,
            onCloseAutoFocus: g,
            disableOutsidePointerEvents: h,
            onEntryFocus: i,
            onEscapeKeyDown: j,
            onPointerDownOutside: k,
            onFocusOutside: l,
            onInteractOutside: m,
            onDismiss: n,
            disableOutsideScroll: o,
            ...p
          } = a,
          q = f4(gd, c),
          s = f6(gd, c),
          t = f1(c),
          u = f2(c),
          v = fZ(c),
          [w, x] = aX.useState(null),
          y = aX.useRef(null),
          z = a_(b, y, q.onContentChange),
          A = aX.useRef(0),
          B = aX.useRef(''),
          C = aX.useRef(0),
          D = aX.useRef(null),
          E = aX.useRef('right'),
          F = aX.useRef(0),
          G = o ? b3 : aX.Fragment;
        aX.useEffect(() => () => window.clearTimeout(A.current), []), bx();
        let H = aX.useCallback((a) => {
          var b, c;
          return (
            E.current === D.current?.side &&
            ((b = a),
            !!(c = D.current?.area) &&
              (function (a, b) {
                let { x: c, y: d } = a,
                  e = !1;
                for (let a = 0, f = b.length - 1; a < b.length; f = a++) {
                  let g = b[a],
                    h = b[f],
                    i = g.x,
                    j = g.y,
                    k = h.x,
                    l = h.y;
                  j > d != l > d && c < ((k - i) * (d - j)) / (l - j) + i && (e = !e);
                }
                return e;
              })({ x: b.clientX, y: b.clientY }, c))
          );
        }, []);
        return (0, a0.jsx)(ge, {
          scope: c,
          searchRef: B,
          onItemEnter: aX.useCallback(
            (a) => {
              H(a) && a.preventDefault();
            },
            [H]
          ),
          onItemLeave: aX.useCallback(
            (a) => {
              H(a) || (y.current?.focus(), x(null));
            },
            [H]
          ),
          onTriggerLeave: aX.useCallback(
            (a) => {
              H(a) && a.preventDefault();
            },
            [H]
          ),
          pointerGraceTimerRef: C,
          onPointerGraceIntentChange: aX.useCallback((a) => {
            D.current = a;
          }, []),
          children: (0, a0.jsx)(G, {
            ...(o ? { as: gj, allowPinchZoom: !0 } : void 0),
            children: (0, a0.jsx)(bn, {
              asChild: !0,
              trapped: e,
              onMountAutoFocus: aY(f, (a) => {
                a.preventDefault(), y.current?.focus({ preventScroll: !0 });
              }),
              onUnmountAutoFocus: g,
              children: (0, a0.jsx)(bh, {
                asChild: !0,
                disableOutsidePointerEvents: h,
                onEscapeKeyDown: j,
                onPointerDownOutside: k,
                onFocusOutside: l,
                onInteractOutside: m,
                onDismiss: n,
                children: (0, a0.jsx)(fK, {
                  asChild: !0,
                  ...u,
                  dir: s.dir,
                  orientation: 'vertical',
                  loop: d,
                  currentTabStopId: w,
                  onCurrentTabStopIdChange: x,
                  onEntryFocus: aY(i, (a) => {
                    s.isUsingKeyboardRef.current || a.preventDefault();
                  }),
                  preventScrollOnEntryFocus: !0,
                  children: (0, a0.jsx)(ft, {
                    role: 'menu',
                    'aria-orientation': 'vertical',
                    'data-state': gK(q.open),
                    'data-radix-menu-content': '',
                    dir: s.dir,
                    ...t,
                    ...p,
                    ref: z,
                    style: { outline: 'none', ...p.style },
                    onKeyDown: aY(p.onKeyDown, (a) => {
                      let b = a.target.closest('[data-radix-menu-content]') === a.currentTarget,
                        c = a.ctrlKey || a.altKey || a.metaKey,
                        d = 1 === a.key.length;
                      if (b) {
                        var e;
                        let b, f, g, h, i, j;
                        'Tab' === a.key && a.preventDefault(),
                          !c &&
                            d &&
                            ((e = a.key),
                            (b = B.current + e),
                            (f = v().filter((a) => !a.disabled)),
                            (g = document.activeElement),
                            (h = f.find((a) => a.ref.current === g)?.textValue),
                            (i = (function (a, b, c) {
                              var d;
                              let e =
                                  b.length > 1 && Array.from(b).every((a) => a === b[0]) ? b[0] : b,
                                f = c ? a.indexOf(c) : -1,
                                g = ((d = Math.max(f, 0)), a.map((b, c) => a[(d + c) % a.length]));
                              1 === e.length && (g = g.filter((a) => a !== c));
                              let h = g.find((a) => a.toLowerCase().startsWith(e.toLowerCase()));
                              return h !== c ? h : void 0;
                            })(
                              f.map((a) => a.textValue),
                              b,
                              h
                            )),
                            (j = f.find((a) => a.textValue === i)?.ref.current),
                            (function a(b) {
                              (B.current = b),
                                window.clearTimeout(A.current),
                                '' !== b && (A.current = window.setTimeout(() => a(''), 1e3));
                            })(b),
                            j && setTimeout(() => j.focus()));
                      }
                      let f = y.current;
                      if (a.target !== f || !fU.includes(a.key)) return;
                      a.preventDefault();
                      let g = v()
                        .filter((a) => !a.disabled)
                        .map((a) => a.ref.current);
                      fT.includes(a.key) && g.reverse(),
                        (function (a) {
                          let b = document.activeElement;
                          for (let c of a)
                            if (c === b || (c.focus(), document.activeElement !== b)) return;
                        })(g);
                    }),
                    onBlur: aY(a.onBlur, (a) => {
                      a.currentTarget.contains(a.target) ||
                        (window.clearTimeout(A.current), (B.current = ''));
                    }),
                    onPointerMove: aY(
                      a.onPointerMove,
                      gN((a) => {
                        let b = a.target,
                          c = F.current !== a.clientX;
                        a.currentTarget.contains(b) &&
                          c &&
                          ((E.current = a.clientX > F.current ? 'right' : 'left'),
                          (F.current = a.clientX));
                      })
                    ),
                  }),
                }),
              }),
            }),
          }),
        });
      });
    gg.displayName = gd;
    var gl = aX.forwardRef((a, b) => {
      let { __scopeMenu: c, ...d } = a;
      return (0, a0.jsx)(bc.div, { role: 'group', ...d, ref: b });
    });
    gl.displayName = 'MenuGroup';
    var gm = aX.forwardRef((a, b) => {
      let { __scopeMenu: c, ...d } = a;
      return (0, a0.jsx)(bc.div, { ...d, ref: b });
    });
    gm.displayName = 'MenuLabel';
    var gn = 'MenuItem',
      go = 'menu.itemSelect',
      gp = aX.forwardRef((a, b) => {
        let { disabled: c = !1, onSelect: d, ...e } = a,
          f = aX.useRef(null),
          g = f6(gn, a.__scopeMenu),
          h = gf(gn, a.__scopeMenu),
          i = a_(b, f),
          j = aX.useRef(!1);
        return (0, a0.jsx)(gq, {
          ...e,
          ref: i,
          disabled: c,
          onClick: aY(a.onClick, () => {
            let a = f.current;
            if (!c && a) {
              let b = new CustomEvent(go, { bubbles: !0, cancelable: !0 });
              a.addEventListener(go, (a) => d?.(a), { once: !0 }),
                bd(a, b),
                b.defaultPrevented ? (j.current = !1) : g.onClose();
            }
          }),
          onPointerDown: (b) => {
            a.onPointerDown?.(b), (j.current = !0);
          },
          onPointerUp: aY(a.onPointerUp, (a) => {
            j.current || a.currentTarget?.click();
          }),
          onKeyDown: aY(a.onKeyDown, (a) => {
            let b = '' !== h.searchRef.current;
            c ||
              (b && ' ' === a.key) ||
              (fS.includes(a.key) && (a.currentTarget.click(), a.preventDefault()));
          }),
        });
      });
    gp.displayName = gn;
    var gq = aX.forwardRef((a, b) => {
        let { __scopeMenu: c, disabled: d = !1, textValue: e, ...f } = a,
          g = gf(gn, c),
          h = f2(c),
          i = aX.useRef(null),
          j = a_(b, i),
          [k, l] = aX.useState(!1),
          [m, n] = aX.useState('');
        return (
          aX.useEffect(() => {
            let a = i.current;
            a && n((a.textContent ?? '').trim());
          }, [f.children]),
          (0, a0.jsx)(fY.ItemSlot, {
            scope: c,
            disabled: d,
            textValue: e ?? m,
            children: (0, a0.jsx)(fN, {
              asChild: !0,
              ...h,
              focusable: !d,
              children: (0, a0.jsx)(bc.div, {
                role: 'menuitem',
                'data-highlighted': k ? '' : void 0,
                'aria-disabled': d || void 0,
                'data-disabled': d ? '' : void 0,
                ...f,
                ref: j,
                onPointerMove: aY(
                  a.onPointerMove,
                  gN((a) => {
                    d
                      ? g.onItemLeave(a)
                      : (g.onItemEnter(a),
                        a.defaultPrevented || a.currentTarget.focus({ preventScroll: !0 }));
                  })
                ),
                onPointerLeave: aY(
                  a.onPointerLeave,
                  gN((a) => g.onItemLeave(a))
                ),
                onFocus: aY(a.onFocus, () => l(!0)),
                onBlur: aY(a.onBlur, () => l(!1)),
              }),
            }),
          })
        );
      }),
      gr = aX.forwardRef((a, b) => {
        let { checked: c = !1, onCheckedChange: d, ...e } = a;
        return (0, a0.jsx)(gz, {
          scope: a.__scopeMenu,
          checked: c,
          children: (0, a0.jsx)(gp, {
            role: 'menuitemcheckbox',
            'aria-checked': gL(c) ? 'mixed' : c,
            ...e,
            ref: b,
            'data-state': gM(c),
            onSelect: aY(e.onSelect, () => d?.(!!gL(c) || !c), { checkForDefaultPrevented: !1 }),
          }),
        });
      });
    gr.displayName = 'MenuCheckboxItem';
    var gs = 'MenuRadioGroup',
      [gt, gu] = f_(gs, { value: void 0, onValueChange: () => {} }),
      gv = aX.forwardRef((a, b) => {
        let { value: c, onValueChange: d, ...e } = a,
          f = be(d);
        return (0, a0.jsx)(gt, {
          scope: a.__scopeMenu,
          value: c,
          onValueChange: f,
          children: (0, a0.jsx)(gl, { ...e, ref: b }),
        });
      });
    gv.displayName = gs;
    var gw = 'MenuRadioItem',
      gx = aX.forwardRef((a, b) => {
        let { value: c, ...d } = a,
          e = gu(gw, a.__scopeMenu),
          f = c === e.value;
        return (0, a0.jsx)(gz, {
          scope: a.__scopeMenu,
          checked: f,
          children: (0, a0.jsx)(gp, {
            role: 'menuitemradio',
            'aria-checked': f,
            ...d,
            ref: b,
            'data-state': gM(f),
            onSelect: aY(d.onSelect, () => e.onValueChange?.(c), { checkForDefaultPrevented: !1 }),
          }),
        });
      });
    gx.displayName = gw;
    var gy = 'MenuItemIndicator',
      [gz, gA] = f_(gy, { checked: !1 }),
      gB = aX.forwardRef((a, b) => {
        let { __scopeMenu: c, forceMount: d, ...e } = a,
          f = gA(gy, c);
        return (0, a0.jsx)(bu, {
          present: d || gL(f.checked) || !0 === f.checked,
          children: (0, a0.jsx)(bc.span, { ...e, ref: b, 'data-state': gM(f.checked) }),
        });
      });
    gB.displayName = gy;
    var gC = aX.forwardRef((a, b) => {
      let { __scopeMenu: c, ...d } = a;
      return (0, a0.jsx)(bc.div, {
        role: 'separator',
        'aria-orientation': 'horizontal',
        ...d,
        ref: b,
      });
    });
    gC.displayName = 'MenuSeparator';
    var gD = aX.forwardRef((a, b) => {
      let { __scopeMenu: c, ...d } = a,
        e = f1(c);
      return (0, a0.jsx)(fw, { ...e, ...d, ref: b });
    });
    gD.displayName = 'MenuArrow';
    var [gE, gF] = f_('MenuSub'),
      gG = 'MenuSubTrigger',
      gH = aX.forwardRef((a, b) => {
        let c = f4(gG, a.__scopeMenu),
          d = f6(gG, a.__scopeMenu),
          e = gF(gG, a.__scopeMenu),
          f = gf(gG, a.__scopeMenu),
          g = aX.useRef(null),
          { pointerGraceTimerRef: h, onPointerGraceIntentChange: i } = f,
          j = { __scopeMenu: a.__scopeMenu },
          k = aX.useCallback(() => {
            g.current && window.clearTimeout(g.current), (g.current = null);
          }, []);
        return (
          aX.useEffect(() => k, [k]),
          aX.useEffect(() => {
            let a = h.current;
            return () => {
              window.clearTimeout(a), i(null);
            };
          }, [h, i]),
          (0, a0.jsx)(f8, {
            asChild: !0,
            ...j,
            children: (0, a0.jsx)(gq, {
              id: e.triggerId,
              'aria-haspopup': 'menu',
              'aria-expanded': c.open,
              'aria-controls': e.contentId,
              'data-state': gK(c.open),
              ...a,
              ref: a$(b, e.onTriggerChange),
              onClick: (b) => {
                a.onClick?.(b),
                  a.disabled ||
                    b.defaultPrevented ||
                    (b.currentTarget.focus(), c.open || c.onOpenChange(!0));
              },
              onPointerMove: aY(
                a.onPointerMove,
                gN((b) => {
                  f.onItemEnter(b),
                    !b.defaultPrevented &&
                      (a.disabled ||
                        c.open ||
                        g.current ||
                        (f.onPointerGraceIntentChange(null),
                        (g.current = window.setTimeout(() => {
                          c.onOpenChange(!0), k();
                        }, 100))));
                })
              ),
              onPointerLeave: aY(
                a.onPointerLeave,
                gN((a) => {
                  k();
                  let b = c.content?.getBoundingClientRect();
                  if (b) {
                    let d = c.content?.dataset.side,
                      e = 'right' === d,
                      g = b[e ? 'left' : 'right'],
                      i = b[e ? 'right' : 'left'];
                    f.onPointerGraceIntentChange({
                      area: [
                        { x: a.clientX + (e ? -5 : 5), y: a.clientY },
                        { x: g, y: b.top },
                        { x: i, y: b.top },
                        { x: i, y: b.bottom },
                        { x: g, y: b.bottom },
                      ],
                      side: d,
                    }),
                      window.clearTimeout(h.current),
                      (h.current = window.setTimeout(
                        () => f.onPointerGraceIntentChange(null),
                        300
                      ));
                  } else {
                    if ((f.onTriggerLeave(a), a.defaultPrevented)) return;
                    f.onPointerGraceIntentChange(null);
                  }
                })
              ),
              onKeyDown: aY(a.onKeyDown, (b) => {
                let e = '' !== f.searchRef.current;
                a.disabled ||
                  (e && ' ' === b.key) ||
                  (fV[d.dir].includes(b.key) &&
                    (c.onOpenChange(!0), c.content?.focus(), b.preventDefault()));
              }),
            }),
          })
        );
      });
    gH.displayName = gG;
    var gI = 'MenuSubContent',
      gJ = aX.forwardRef((a, b) => {
        let c = gb(gd, a.__scopeMenu),
          { forceMount: d = c.forceMount, ...e } = a,
          f = f4(gd, a.__scopeMenu),
          g = f6(gd, a.__scopeMenu),
          h = gF(gI, a.__scopeMenu),
          i = aX.useRef(null),
          j = a_(b, i);
        return (0, a0.jsx)(fY.Provider, {
          scope: a.__scopeMenu,
          children: (0, a0.jsx)(bu, {
            present: d || f.open,
            children: (0, a0.jsx)(fY.Slot, {
              scope: a.__scopeMenu,
              children: (0, a0.jsx)(gk, {
                id: h.contentId,
                'aria-labelledby': h.triggerId,
                ...e,
                ref: j,
                align: 'start',
                side: 'rtl' === g.dir ? 'left' : 'right',
                disableOutsidePointerEvents: !1,
                disableOutsideScroll: !1,
                trapFocus: !1,
                onOpenAutoFocus: (a) => {
                  g.isUsingKeyboardRef.current && i.current?.focus(), a.preventDefault();
                },
                onCloseAutoFocus: (a) => a.preventDefault(),
                onFocusOutside: aY(a.onFocusOutside, (a) => {
                  a.target !== h.trigger && f.onOpenChange(!1);
                }),
                onEscapeKeyDown: aY(a.onEscapeKeyDown, (a) => {
                  g.onClose(), a.preventDefault();
                }),
                onKeyDown: aY(a.onKeyDown, (a) => {
                  let b = a.currentTarget.contains(a.target),
                    c = fW[g.dir].includes(a.key);
                  b && c && (f.onOpenChange(!1), h.trigger?.focus(), a.preventDefault());
                }),
              }),
            }),
          }),
        });
      });
    function gK(a) {
      return a ? 'open' : 'closed';
    }
    function gL(a) {
      return 'indeterminate' === a;
    }
    function gM(a) {
      return gL(a) ? 'indeterminate' : a ? 'checked' : 'unchecked';
    }
    function gN(a) {
      return (b) => ('mouse' === b.pointerType ? a(b) : void 0);
    }
    gJ.displayName = gI;
    var gO = 'DropdownMenu',
      [gP, gQ] = a2(gO, [f0]),
      gR = f0(),
      [gS, gT] = gP(gO),
      gU = (a) => {
        let {
            __scopeDropdownMenu: b,
            children: c,
            dir: d,
            open: e,
            defaultOpen: f,
            onOpenChange: g,
            modal: h = !0,
          } = a,
          i = gR(b),
          j = aX.useRef(null),
          [k, l] = a8({ prop: e, defaultProp: f ?? !1, onChange: g, caller: gO });
        return (0, a0.jsx)(gS, {
          scope: b,
          triggerId: a6(),
          triggerRef: j,
          contentId: a6(),
          open: k,
          onOpenChange: l,
          onOpenToggle: aX.useCallback(() => l((a) => !a), [l]),
          modal: h,
          children: (0, a0.jsx)(f7, {
            ...i,
            open: k,
            onOpenChange: l,
            dir: d,
            modal: h,
            children: c,
          }),
        });
      };
    gU.displayName = gO;
    var gV = 'DropdownMenuTrigger',
      gW = aX.forwardRef((a, b) => {
        let { __scopeDropdownMenu: c, disabled: d = !1, ...e } = a,
          f = gT(gV, c),
          g = gR(c);
        return (0, a0.jsx)(f8, {
          asChild: !0,
          ...g,
          children: (0, a0.jsx)(bc.button, {
            type: 'button',
            id: f.triggerId,
            'aria-haspopup': 'menu',
            'aria-expanded': f.open,
            'aria-controls': f.open ? f.contentId : void 0,
            'data-state': f.open ? 'open' : 'closed',
            'data-disabled': d ? '' : void 0,
            disabled: d,
            ...e,
            ref: a$(b, f.triggerRef),
            onPointerDown: aY(a.onPointerDown, (a) => {
              !d &&
                0 === a.button &&
                !1 === a.ctrlKey &&
                (f.onOpenToggle(), f.open || a.preventDefault());
            }),
            onKeyDown: aY(a.onKeyDown, (a) => {
              !d &&
                (['Enter', ' '].includes(a.key) && f.onOpenToggle(),
                'ArrowDown' === a.key && f.onOpenChange(!0),
                ['Enter', ' ', 'ArrowDown'].includes(a.key) && a.preventDefault());
            }),
          }),
        });
      });
    gW.displayName = gV;
    var gX = (a) => {
      let { __scopeDropdownMenu: b, ...c } = a,
        d = gR(b);
      return (0, a0.jsx)(gc, { ...d, ...c });
    };
    gX.displayName = 'DropdownMenuPortal';
    var gY = 'DropdownMenuContent',
      gZ = aX.forwardRef((a, b) => {
        let { __scopeDropdownMenu: c, ...d } = a,
          e = gT(gY, c),
          f = gR(c),
          g = aX.useRef(!1);
        return (0, a0.jsx)(gg, {
          id: e.contentId,
          'aria-labelledby': e.triggerId,
          ...f,
          ...d,
          ref: b,
          onCloseAutoFocus: aY(a.onCloseAutoFocus, (a) => {
            g.current || e.triggerRef.current?.focus(), (g.current = !1), a.preventDefault();
          }),
          onInteractOutside: aY(a.onInteractOutside, (a) => {
            let b = a.detail.originalEvent,
              c = 0 === b.button && !0 === b.ctrlKey,
              d = 2 === b.button || c;
            (!e.modal || d) && (g.current = !0);
          }),
          style: {
            ...a.style,
            '--radix-dropdown-menu-content-transform-origin':
              'var(--radix-popper-transform-origin)',
            '--radix-dropdown-menu-content-available-width': 'var(--radix-popper-available-width)',
            '--radix-dropdown-menu-content-available-height':
              'var(--radix-popper-available-height)',
            '--radix-dropdown-menu-trigger-width': 'var(--radix-popper-anchor-width)',
            '--radix-dropdown-menu-trigger-height': 'var(--radix-popper-anchor-height)',
          },
        });
      });
    (gZ.displayName = gY),
      (aX.forwardRef((a, b) => {
        let { __scopeDropdownMenu: c, ...d } = a,
          e = gR(c);
        return (0, a0.jsx)(gl, { ...e, ...d, ref: b });
      }).displayName = 'DropdownMenuGroup'),
      (aX.forwardRef((a, b) => {
        let { __scopeDropdownMenu: c, ...d } = a,
          e = gR(c);
        return (0, a0.jsx)(gm, { ...e, ...d, ref: b });
      }).displayName = 'DropdownMenuLabel');
    var g$ = aX.forwardRef((a, b) => {
      let { __scopeDropdownMenu: c, ...d } = a,
        e = gR(c);
      return (0, a0.jsx)(gp, { ...e, ...d, ref: b });
    });
    (g$.displayName = 'DropdownMenuItem'),
      (aX.forwardRef((a, b) => {
        let { __scopeDropdownMenu: c, ...d } = a,
          e = gR(c);
        return (0, a0.jsx)(gr, { ...e, ...d, ref: b });
      }).displayName = 'DropdownMenuCheckboxItem'),
      (aX.forwardRef((a, b) => {
        let { __scopeDropdownMenu: c, ...d } = a,
          e = gR(c);
        return (0, a0.jsx)(gv, { ...e, ...d, ref: b });
      }).displayName = 'DropdownMenuRadioGroup'),
      (aX.forwardRef((a, b) => {
        let { __scopeDropdownMenu: c, ...d } = a,
          e = gR(c);
        return (0, a0.jsx)(gx, { ...e, ...d, ref: b });
      }).displayName = 'DropdownMenuRadioItem'),
      (aX.forwardRef((a, b) => {
        let { __scopeDropdownMenu: c, ...d } = a,
          e = gR(c);
        return (0, a0.jsx)(gB, { ...e, ...d, ref: b });
      }).displayName = 'DropdownMenuItemIndicator');
    var g_ = aX.forwardRef((a, b) => {
      let { __scopeDropdownMenu: c, ...d } = a,
        e = gR(c);
      return (0, a0.jsx)(gC, { ...e, ...d, ref: b });
    });
    (g_.displayName = 'DropdownMenuSeparator'),
      (aX.forwardRef((a, b) => {
        let { __scopeDropdownMenu: c, ...d } = a,
          e = gR(c);
        return (0, a0.jsx)(gD, { ...e, ...d, ref: b });
      }).displayName = 'DropdownMenuArrow'),
      (aX.forwardRef((a, b) => {
        let { __scopeDropdownMenu: c, ...d } = a,
          e = gR(c);
        return (0, a0.jsx)(gH, { ...e, ...d, ref: b });
      }).displayName = 'DropdownMenuSubTrigger'),
      (aX.forwardRef((a, b) => {
        let { __scopeDropdownMenu: c, ...d } = a,
          e = gR(c);
        return (0, a0.jsx)(gJ, {
          ...e,
          ...d,
          ref: b,
          style: {
            ...a.style,
            '--radix-dropdown-menu-content-transform-origin':
              'var(--radix-popper-transform-origin)',
            '--radix-dropdown-menu-content-available-width': 'var(--radix-popper-available-width)',
            '--radix-dropdown-menu-content-available-height':
              'var(--radix-popper-available-height)',
            '--radix-dropdown-menu-trigger-width': 'var(--radix-popper-anchor-width)',
            '--radix-dropdown-menu-trigger-height': 'var(--radix-popper-anchor-height)',
          },
        });
      }).displayName = 'DropdownMenuSubContent');
    var g0 =
      (((M = g0 || {}).Mainnet = 'mainnet'),
      (M.Devnet = 'devnet'),
      (M.Testnet = 'testnet'),
      (M.Localnet = 'localnet'),
      (M.Custom = 'custom'),
      M);
    function g1(a) {
      return (
        (function () {
          let a;
          try {
            a = JSON.parse(
              '{\n    "mainnet": {\n        "id": "mainnet",\n        "name": "Mainnet",\n        "url": "https://api.mainnet.iota.cafe",\n        "graphql": "https://graphql.mainnet.iota.cafe",\n        "explorer": "https://explorer.rebased.iota.org",\n        "chain": "iota:mainnet"\n    },\n    "testnet": {\n        "id": "testnet",\n        "name": "Testnet",\n        "url": "https://api.testnet.iota.cafe",\n        "graphql": "https://graphql.testnet.iota.cafe",\n        "explorer": "https://explorer.rebased.iota.org",\n        "chain": "iota:testnet",\n        "faucet": "https://faucet.testnet.iota.cafe",\n        "kiosk": {\n            "royaltyRulePackageId": "0x975f749f57701209454e4b9b9e33825ccb6a9abf57de2ce86979e5fa86c343f2",\n            "kioskLockRulePackageId": "0x975f749f57701209454e4b9b9e33825ccb6a9abf57de2ce86979e5fa86c343f2",\n            "floorPriceRulePackageId": "0x975f749f57701209454e4b9b9e33825ccb6a9abf57de2ce86979e5fa86c343f2",\n            "personalKioskRulePackageId": "0x975f749f57701209454e4b9b9e33825ccb6a9abf57de2ce86979e5fa86c343f2"\n        }\n    },\n    "devnet": {\n        "id": "devnet",\n        "name": "Devnet",\n        "url": "https://api.devnet.iota.cafe",\n        "graphql": "https://graphql.devnet.iota.cafe",\n        "explorer": "https://explorer.rebased.iota.org",\n        "chain": "iota:devnet",\n        "faucet": "https://faucet.devnet.iota.cafe"\n    },\n    "localnet": {\n        "id": "localnet",\n        "name": "Localnet",\n        "url": "http://localhost:9000",\n        "graphql": "http://localhost:9125",\n        "explorer": "http://localhost:3000",\n        "chain": "iota:local",\n        "faucet": "http://localhost:9123"\n    }\n}'
            );
          } catch {
            throw Error('Failed to parse env var "IOTA_NETWORKS".');
          }
          return a;
        })()[a] ?? a
      );
    }
    var g2 = class extends dc {
      #s;
      #t;
      #u;
      #h;
      #k;
      #v;
      #w;
      constructor(a) {
        super(),
          (this.#w = !1),
          (this.#v = a.defaultOptions),
          this.setOptions(a.options),
          (this.observers = []),
          (this.#h = a.client),
          (this.#u = this.#h.getQueryCache()),
          (this.queryKey = a.queryKey),
          (this.queryHash = a.queryHash),
          (this.#s = g5(this.options)),
          (this.state = a.state ?? this.#s),
          this.scheduleGc();
      }
      get meta() {
        return this.options.meta;
      }
      get promise() {
        return this.#k?.promise;
      }
      setOptions(a) {
        if (
          ((this.options = { ...this.#v, ...a }),
          this.updateGcTime(this.options.gcTime),
          this.state && void 0 === this.state.data)
        ) {
          let a = g5(this.options);
          void 0 !== a.data && (this.setState(g4(a.data, a.dataUpdatedAt)), (this.#s = a));
        }
      }
      optionalRemove() {
        this.observers.length || 'idle' !== this.state.fetchStatus || this.#u.remove(this);
      }
      setData(a, b) {
        let c = c6(this.state.data, a, this.options);
        return (
          this.#l({ data: c, type: 'success', dataUpdatedAt: b?.updatedAt, manual: b?.manual }), c
        );
      }
      setState(a, b) {
        this.#l({ type: 'setState', state: a, setStateOptions: b });
      }
      cancel(a) {
        let b = this.#k?.promise;
        return this.#k?.cancel(a), b ? b.then(cQ).catch(cQ) : Promise.resolve();
      }
      destroy() {
        super.destroy(), this.cancel({ silent: !0 });
      }
      reset() {
        this.destroy(), this.setState(this.#s);
      }
      isActive() {
        return this.observers.some((a) => !1 !== cV(a.options.enabled, this));
      }
      isDisabled() {
        return this.getObserversCount() > 0
          ? !this.isActive()
          : this.options.queryFn === c9 ||
              this.state.dataUpdateCount + this.state.errorUpdateCount === 0;
      }
      isStatic() {
        return (
          this.getObserversCount() > 0 &&
          this.observers.some((a) => 'static' === cU(a.options.staleTime, this))
        );
      }
      isStale() {
        return this.getObserversCount() > 0
          ? this.observers.some((a) => a.getCurrentResult().isStale)
          : void 0 === this.state.data || this.state.isInvalidated;
      }
      isStaleByTime(a = 0) {
        return (
          void 0 === this.state.data ||
          ('static' !== a && (!!this.state.isInvalidated || !cT(this.state.dataUpdatedAt, a)))
        );
      }
      onFocus() {
        let a = this.observers.find((a) => a.shouldFetchOnWindowFocus());
        a?.refetch({ cancelRefetch: !1 }), this.#k?.continue();
      }
      onOnline() {
        let a = this.observers.find((a) => a.shouldFetchOnReconnect());
        a?.refetch({ cancelRefetch: !1 }), this.#k?.continue();
      }
      addObserver(a) {
        this.observers.includes(a) ||
          (this.observers.push(a),
          this.clearGcTimeout(),
          this.#u.notify({ type: 'observerAdded', query: this, observer: a }));
      }
      removeObserver(a) {
        this.observers.includes(a) &&
          ((this.observers = this.observers.filter((b) => b !== a)),
          this.observers.length ||
            (this.#k && (this.#w ? this.#k.cancel({ revert: !0 }) : this.#k.cancelRetry()),
            this.scheduleGc()),
          this.#u.notify({ type: 'observerRemoved', query: this, observer: a }));
      }
      getObserversCount() {
        return this.observers.length;
      }
      invalidate() {
        this.state.isInvalidated || this.#l({ type: 'invalidate' });
      }
      async fetch(a, b) {
        let c;
        if ('idle' !== this.state.fetchStatus && this.#k?.status() !== 'rejected') {
          if (void 0 !== this.state.data && b?.cancelRefetch) this.cancel({ silent: !0 });
          else if (this.#k) return this.#k.continueRetry(), this.#k.promise;
        }
        if ((a && this.setOptions(a), !this.options.queryFn)) {
          let a = this.observers.find((a) => a.options.queryFn);
          a && this.setOptions(a.options);
        }
        let d = new AbortController(),
          e = (a) => {
            Object.defineProperty(a, 'signal', {
              enumerable: !0,
              get: () => ((this.#w = !0), d.signal),
            });
          },
          f = () => {
            let a,
              c = da(this.options, b),
              d = (e((a = { client: this.#h, queryKey: this.queryKey, meta: this.meta })), a);
            return ((this.#w = !1), this.options.persister)
              ? this.options.persister(c, d, this)
              : c(d);
          },
          g =
            (e(
              (c = {
                fetchOptions: b,
                options: this.options,
                queryKey: this.queryKey,
                client: this.#h,
                state: this.state,
                fetchFn: f,
              })
            ),
            c);
        this.options.behavior?.onFetch(g, this),
          (this.#t = this.state),
          ('idle' === this.state.fetchStatus || this.state.fetchMeta !== g.fetchOptions?.meta) &&
            this.#l({ type: 'fetch', meta: g.fetchOptions?.meta }),
          (this.#k = dk({
            initialPromise: b?.initialPromise,
            fn: g.fetchFn,
            onCancel: (a) => {
              a instanceof dj && a.revert && this.setState({ ...this.#t, fetchStatus: 'idle' }),
                d.abort();
            },
            onFail: (a, b) => {
              this.#l({ type: 'failed', failureCount: a, error: b });
            },
            onPause: () => {
              this.#l({ type: 'pause' });
            },
            onContinue: () => {
              this.#l({ type: 'continue' });
            },
            retry: g.options.retry,
            retryDelay: g.options.retryDelay,
            networkMode: g.options.networkMode,
            canRun: () => !0,
          }));
        try {
          let a = await this.#k.start();
          if (void 0 === a) throw Error(`${this.queryHash} data is undefined`);
          return (
            this.setData(a),
            this.#u.config.onSuccess?.(a, this),
            this.#u.config.onSettled?.(a, this.state.error, this),
            a
          );
        } catch (a) {
          if (a instanceof dj) {
            if (a.silent) return this.#k.promise;
            else if (a.revert) {
              if (void 0 === this.state.data) throw a;
              return this.state.data;
            }
          }
          throw (
            (this.#l({ type: 'error', error: a }),
            this.#u.config.onError?.(a, this),
            this.#u.config.onSettled?.(this.state.data, a, this),
            a)
          );
        } finally {
          this.scheduleGc();
        }
      }
      #l(a) {
        let b = (b) => {
          switch (a.type) {
            case 'failed':
              return { ...b, fetchFailureCount: a.failureCount, fetchFailureReason: a.error };
            case 'pause':
              return { ...b, fetchStatus: 'paused' };
            case 'continue':
              return { ...b, fetchStatus: 'fetching' };
            case 'fetch':
              return { ...b, ...g3(b.data, this.options), fetchMeta: a.meta ?? null };
            case 'success':
              let c = {
                ...b,
                ...g4(a.data, a.dataUpdatedAt),
                dataUpdateCount: b.dataUpdateCount + 1,
                ...(!a.manual && {
                  fetchStatus: 'idle',
                  fetchFailureCount: 0,
                  fetchFailureReason: null,
                }),
              };
              return (this.#t = a.manual ? c : void 0), c;
            case 'error':
              let d = a.error;
              return {
                ...b,
                error: d,
                errorUpdateCount: b.errorUpdateCount + 1,
                errorUpdatedAt: Date.now(),
                fetchFailureCount: b.fetchFailureCount + 1,
                fetchFailureReason: d,
                fetchStatus: 'idle',
                status: 'error',
              };
            case 'invalidate':
              return { ...b, isInvalidated: !0 };
            case 'setState':
              return { ...b, ...a.state };
          }
        };
        (this.state = b(this.state)),
          cP.batch(() => {
            this.observers.forEach((a) => {
              a.onQueryUpdate();
            }),
              this.#u.notify({ query: this, type: 'updated', action: a });
          });
      }
    };
    function g3(a, b) {
      return {
        fetchFailureCount: 0,
        fetchFailureReason: null,
        fetchStatus: di(b.networkMode) ? 'fetching' : 'paused',
        ...(void 0 === a && { error: null, status: 'pending' }),
      };
    }
    function g4(a, b) {
      return {
        data: a,
        dataUpdatedAt: b ?? Date.now(),
        error: null,
        isInvalidated: !1,
        status: 'success',
      };
    }
    function g5(a) {
      let b = 'function' == typeof a.initialData ? a.initialData() : a.initialData,
        c = void 0 !== b,
        d = c
          ? 'function' == typeof a.initialDataUpdatedAt
            ? a.initialDataUpdatedAt()
            : a.initialDataUpdatedAt
          : 0;
      return {
        data: b,
        dataUpdateCount: 0,
        dataUpdatedAt: c ? d ?? Date.now() : 0,
        error: null,
        errorUpdateCount: 0,
        errorUpdatedAt: 0,
        fetchFailureCount: 0,
        fetchFailureReason: null,
        fetchMeta: null,
        isInvalidated: !1,
        status: c ? 'success' : 'pending',
        fetchStatus: 'idle',
      };
    }
    a.s(['Query', () => g2, 'fetchState', () => g3], 76644);
    var g6 = class extends dd {
      constructor(a, b) {
        super(),
          (this.options = b),
          (this.#h = a),
          (this.#x = null),
          (this.#y = dg()),
          this.bindMethods(),
          this.setOptions(b);
      }
      #h;
      #z = void 0;
      #A = void 0;
      #m = void 0;
      #B;
      #C;
      #y;
      #x;
      #D;
      #E;
      #F;
      #G;
      #H;
      #I;
      #J = new Set();
      bindMethods() {
        this.refetch = this.refetch.bind(this);
      }
      onSubscribe() {
        1 === this.listeners.size &&
          (this.#z.addObserver(this),
          g7(this.#z, this.options) ? this.#K() : this.updateResult(),
          this.#L());
      }
      onUnsubscribe() {
        this.hasListeners() || this.destroy();
      }
      shouldFetchOnReconnect() {
        return g8(this.#z, this.options, this.options.refetchOnReconnect);
      }
      shouldFetchOnWindowFocus() {
        return g8(this.#z, this.options, this.options.refetchOnWindowFocus);
      }
      destroy() {
        (this.listeners = new Set()), this.#M(), this.#N(), this.#z.removeObserver(this);
      }
      setOptions(a) {
        let b = this.options,
          c = this.#z;
        if (
          ((this.options = this.#h.defaultQueryOptions(a)),
          void 0 !== this.options.enabled &&
            'boolean' != typeof this.options.enabled &&
            'function' != typeof this.options.enabled &&
            'boolean' != typeof cV(this.options.enabled, this.#z))
        )
          throw Error('Expected enabled to be a boolean or a callback that returns a boolean');
        this.#O(),
          this.#z.setOptions(this.options),
          b._defaulted &&
            !c1(this.options, b) &&
            this.#h
              .getQueryCache()
              .notify({ type: 'observerOptionsUpdated', query: this.#z, observer: this });
        let d = this.hasListeners();
        d && g9(this.#z, c, this.options, b) && this.#K(),
          this.updateResult(),
          d &&
            (this.#z !== c ||
              cV(this.options.enabled, this.#z) !== cV(b.enabled, this.#z) ||
              cU(this.options.staleTime, this.#z) !== cU(b.staleTime, this.#z)) &&
            this.#P();
        let e = this.#Q();
        d &&
          (this.#z !== c ||
            cV(this.options.enabled, this.#z) !== cV(b.enabled, this.#z) ||
            e !== this.#I) &&
          this.#R(e);
      }
      getOptimisticResult(a) {
        var b, c;
        let d = this.#h.getQueryCache().build(this.#h, a),
          e = this.createResult(d, a);
        return (
          (b = this),
          (c = e),
          c1(b.getCurrentResult(), c) ||
            ((this.#m = e), (this.#C = this.options), (this.#B = this.#z.state)),
          e
        );
      }
      getCurrentResult() {
        return this.#m;
      }
      trackResult(a, b) {
        return new Proxy(a, {
          get: (a, c) => (
            this.trackProp(c),
            b?.(c),
            'promise' === c &&
              (this.trackProp('data'),
              this.options.experimental_prefetchInRender ||
                'pending' !== this.#y.status ||
                this.#y.reject(Error('experimental_prefetchInRender feature flag is not enabled'))),
            Reflect.get(a, c)
          ),
        });
      }
      trackProp(a) {
        this.#J.add(a);
      }
      getCurrentQuery() {
        return this.#z;
      }
      refetch({ ...a } = {}) {
        return this.fetch({ ...a });
      }
      fetchOptimistic(a) {
        let b = this.#h.defaultQueryOptions(a),
          c = this.#h.getQueryCache().build(this.#h, b);
        return c.fetch().then(() => this.createResult(c, b));
      }
      fetch(a) {
        return this.#K({ ...a, cancelRefetch: a.cancelRefetch ?? !0 }).then(
          () => (this.updateResult(), this.#m)
        );
      }
      #K(a) {
        this.#O();
        let b = this.#z.fetch(this.options, a);
        return a?.throwOnError || (b = b.catch(cQ)), b;
      }
      #P() {
        this.#M(), cU(this.options.staleTime, this.#z);
      }
      #Q() {
        return (
          ('function' == typeof this.options.refetchInterval
            ? this.options.refetchInterval(this.#z)
            : this.options.refetchInterval) ?? !1
        );
      }
      #R(a) {
        this.#N(), (this.#I = a);
      }
      #L() {
        this.#P(), this.#R(this.#Q());
      }
      #M() {
        this.#G && (cO.clearTimeout(this.#G), (this.#G = void 0));
      }
      #N() {
        this.#H && (cO.clearInterval(this.#H), (this.#H = void 0));
      }
      createResult(a, b) {
        let c,
          d = this.#z,
          e = this.options,
          f = this.#m,
          g = this.#B,
          h = this.#C,
          i = a !== d ? a.state : this.#A,
          { state: j } = a,
          k = { ...j },
          l = !1;
        if (b._optimisticResults) {
          let c = this.hasListeners(),
            f = !c && g7(a, b),
            g = c && g9(a, d, b, e);
          (f || g) && (k = { ...k, ...g3(j.data, a.options) }),
            'isRestoring' === b._optimisticResults && (k.fetchStatus = 'idle');
        }
        let { error: m, errorUpdatedAt: n, status: o } = k;
        c = k.data;
        let p = !1;
        if (void 0 !== b.placeholderData && void 0 === c && 'pending' === o) {
          let a;
          f?.isPlaceholderData && b.placeholderData === h?.placeholderData
            ? ((a = f.data), (p = !0))
            : (a =
                'function' == typeof b.placeholderData
                  ? b.placeholderData(this.#F?.state.data, this.#F)
                  : b.placeholderData),
            void 0 !== a && ((o = 'success'), (c = c6(f?.data, a, b)), (l = !0));
        }
        if (b.select && void 0 !== c && !p)
          if (f && c === g?.data && b.select === this.#D) c = this.#E;
          else
            try {
              (this.#D = b.select),
                (c = b.select(c)),
                (c = c6(f?.data, c, b)),
                (this.#E = c),
                (this.#x = null);
            } catch (a) {
              this.#x = a;
            }
        this.#x && ((m = this.#x), (c = this.#E), (n = Date.now()), (o = 'error'));
        let q = 'fetching' === k.fetchStatus,
          s = 'pending' === o,
          t = 'error' === o,
          u = s && q,
          v = void 0 !== c,
          w = {
            status: o,
            fetchStatus: k.fetchStatus,
            isPending: s,
            isSuccess: 'success' === o,
            isError: t,
            isInitialLoading: u,
            isLoading: u,
            data: c,
            dataUpdatedAt: k.dataUpdatedAt,
            error: m,
            errorUpdatedAt: n,
            failureCount: k.fetchFailureCount,
            failureReason: k.fetchFailureReason,
            errorUpdateCount: k.errorUpdateCount,
            isFetched: k.dataUpdateCount > 0 || k.errorUpdateCount > 0,
            isFetchedAfterMount:
              k.dataUpdateCount > i.dataUpdateCount || k.errorUpdateCount > i.errorUpdateCount,
            isFetching: q,
            isRefetching: q && !s,
            isLoadingError: t && !v,
            isPaused: 'paused' === k.fetchStatus,
            isPlaceholderData: l,
            isRefetchError: t && v,
            isStale: ha(a, b),
            refetch: this.refetch,
            promise: this.#y,
            isEnabled: !1 !== cV(b.enabled, a),
          };
        if (this.options.experimental_prefetchInRender) {
          let b = (a) => {
              'error' === w.status ? a.reject(w.error) : void 0 !== w.data && a.resolve(w.data);
            },
            c = () => {
              b((this.#y = w.promise = dg()));
            },
            e = this.#y;
          switch (e.status) {
            case 'pending':
              a.queryHash === d.queryHash && b(e);
              break;
            case 'fulfilled':
              ('error' === w.status || w.data !== e.value) && c();
              break;
            case 'rejected':
              ('error' !== w.status || w.error !== e.reason) && c();
          }
        }
        return w;
      }
      updateResult() {
        let a = this.#m,
          b = this.createResult(this.#z, this.options);
        if (
          ((this.#B = this.#z.state),
          (this.#C = this.options),
          void 0 !== this.#B.data && (this.#F = this.#z),
          c1(b, a))
        )
          return;
        this.#m = b;
        let c = () => {
          if (!a) return !0;
          let { notifyOnChangeProps: b } = this.options,
            c = 'function' == typeof b ? b() : b;
          if ('all' === c || (!c && !this.#J.size)) return !0;
          let d = new Set(c ?? this.#J);
          return (
            this.options.throwOnError && d.add('error'),
            Object.keys(this.#m).some((b) => this.#m[b] !== a[b] && d.has(b))
          );
        };
        this.#q({ listeners: c() });
      }
      #O() {
        let a = this.#h.getQueryCache().build(this.#h, this.options);
        if (a === this.#z) return;
        let b = this.#z;
        (this.#z = a),
          (this.#A = a.state),
          this.hasListeners() && (b?.removeObserver(this), a.addObserver(this));
      }
      onQueryUpdate() {
        this.updateResult(), this.hasListeners() && this.#L();
      }
      #q(a) {
        cP.batch(() => {
          a.listeners &&
            this.listeners.forEach((a) => {
              a(this.#m);
            }),
            this.#h.getQueryCache().notify({ query: this.#z, type: 'observerResultsUpdated' });
        });
      }
    };
    function g7(a, b) {
      return (
        (!1 !== cV(b.enabled, a) &&
          void 0 === a.state.data &&
          ('error' !== a.state.status || !1 !== b.retryOnMount)) ||
        (void 0 !== a.state.data && g8(a, b, b.refetchOnMount))
      );
    }
    function g8(a, b, c) {
      if (!1 !== cV(b.enabled, a) && 'static' !== cU(b.staleTime, a)) {
        let d = 'function' == typeof c ? c(a) : c;
        return 'always' === d || (!1 !== d && ha(a, b));
      }
      return !1;
    }
    function g9(a, b, c, d) {
      return (
        (a !== b || !1 === cV(d.enabled, a)) &&
        (!c.suspense || 'error' !== a.state.status) &&
        ha(a, c)
      );
    }
    function ha(a, b) {
      return !1 !== cV(b.enabled, a) && a.isStaleByTime(cU(b.staleTime, a));
    }
    var hb = aX.createContext(
        ((p = !1),
        {
          clearReset: () => {
            p = !1;
          },
          reset: () => {
            p = !0;
          },
          isReset: () => p,
        })
      ),
      hc = aX.createContext(!1);
    hc.Provider;
    function hd(a, b) {
      return (function (a, b, c) {
        let d = aX.useContext(hc),
          e = aX.useContext(hb),
          f = dq(c),
          g = f.defaultQueryOptions(a);
        if (
          (f.getDefaultOptions().queries?._experimental_beforeQuery?.(g),
          (g._optimisticResults = d ? 'isRestoring' : 'optimistic'),
          g.suspense)
        ) {
          let a = (a) => ('static' === a ? a : Math.max(a ?? 1e3, 1e3)),
            b = g.staleTime;
          (g.staleTime = 'function' == typeof b ? (...c) => a(b(...c)) : a(b)),
            'number' == typeof g.gcTime && (g.gcTime = Math.max(g.gcTime, 1e3));
        }
        (g.suspense || g.throwOnError || g.experimental_prefetchInRender) &&
          !e.isReset() &&
          (g.retryOnMount = !1),
          aX.useEffect(() => {
            e.clearReset();
          }, [e]),
          f.getQueryCache().get(g.queryHash);
        let [h] = aX.useState(() => new b(f, g)),
          i = h.getOptimisticResult(g),
          j = !d && !1 !== a.subscribed;
        if (
          (aX.useSyncExternalStore(
            aX.useCallback(
              (a) => {
                let b = j ? h.subscribe(cP.batchCalls(a)) : cQ;
                return h.updateResult(), b;
              },
              [h, j]
            ),
            () => h.getCurrentResult(),
            () => h.getCurrentResult()
          ),
          aX.useEffect(() => {
            h.setOptions(g);
          }, [g, h]),
          g?.suspense && i.isPending)
        ) {
          let a, b, c;
          throw (
            ((a = g),
            (b = h),
            (c = e),
            b.fetchOptimistic(a).catch(() => {
              c.clearReset();
            }))
          );
        }
        if (
          (({ result: a, errorResetBoundary: b, throwOnError: c, query: d, suspense: e }) =>
            a.isError &&
            !b.isReset() &&
            !a.isFetching &&
            d &&
            ((e && void 0 === a.data) || db(c, [a.error, d])))({
            result: i,
            errorResetBoundary: e,
            throwOnError: g.throwOnError,
            query: f.getQueryCache().get(g.queryHash),
            suspense: g.suspense,
          })
        )
          throw i.error;
        return (
          f.getDefaultOptions().queries?._experimental_afterQuery?.(g, i),
          g.experimental_prefetchInRender,
          g.notifyOnChangeProps ? i : h.trackResult(i)
        );
      })(a, g6, b);
    }
    let he = (a) => dS.encode(a),
      hf = (a) => dS.decode(a);
    function hg(a) {
      return Uint8Array.from(atob(a), (a) => a.charCodeAt(0));
    }
    function hh(a) {
      if (a.length < 8192) return btoa(String.fromCharCode(...a));
      let b = '';
      for (let c = 0; c < a.length; c += 8192) b += String.fromCharCode(...a.slice(c, c + 8192));
      return btoa(b);
    }
    function hi(a) {
      let b = a.startsWith('0x') ? a.slice(2) : a,
        c = b.length % 2 == 0 ? b : `0${b}}`,
        d = c.match(/.{2}/g)?.map((a) => parseInt(a, 16)) ?? [];
      return Uint8Array.from(d);
    }
    function hj(a) {
      return a.reduce((a, b) => a + b.toString(16).padStart(2, '0'), '');
    }
    function hk(a) {
      let b = [],
        c = 0;
      if (0 === a) return [0];
      for (; a > 0; ) (b[c] = 127 & a), (a >>= 7) && (b[c] |= 128), (c += 1);
      return b;
    }
    a.s(['fromB58', () => hf, 'fromBase58', () => hf, 'toBase58', () => he], 47934),
      a.s(
        ['fromB64', () => hg, 'fromBase64', () => hg, 'toB64', () => hh, 'toBase64', () => hh],
        17760
      );
    class hl {
      constructor(a) {
        (this.bytePosition = 0),
          (this.dataView = new DataView(a.buffer, a.byteOffset, a.byteLength));
      }
      shift(a) {
        return (this.bytePosition += a), this;
      }
      read8() {
        let a = this.dataView.getUint8(this.bytePosition);
        return this.shift(1), a;
      }
      read16() {
        let a = this.dataView.getUint16(this.bytePosition, !0);
        return this.shift(2), a;
      }
      read32() {
        let a = this.dataView.getUint32(this.bytePosition, !0);
        return this.shift(4), a;
      }
      read64() {
        let a = this.read32();
        return BigInt(
          '0x' + (this.read32().toString(16) + a.toString(16).padStart(8, '0'))
        ).toString(10);
      }
      read128() {
        let a = BigInt(this.read64());
        return BigInt(
          '0x' + (BigInt(this.read64()).toString(16) + a.toString(16).padStart(16, '0'))
        ).toString(10);
      }
      read256() {
        let a = BigInt(this.read128());
        return BigInt(
          '0x' + (BigInt(this.read128()).toString(16) + a.toString(16).padStart(32, '0'))
        ).toString(10);
      }
      readBytes(a) {
        let b = this.bytePosition + this.dataView.byteOffset,
          c = new Uint8Array(this.dataView.buffer, b, a);
        return this.shift(a), c;
      }
      readULEB() {
        let a = this.bytePosition + this.dataView.byteOffset,
          { value: b, length: c } = (function (a) {
            let b = 0,
              c = 0,
              d = 0;
            for (;;) {
              let e = a[d];
              if (((d += 1), (b |= (127 & e) << c), (128 & e) == 0)) break;
              c += 7;
            }
            return { value: b, length: d };
          })(new Uint8Array(this.dataView.buffer, a));
        return this.shift(c), b;
      }
      readVec(a) {
        let b = this.readULEB(),
          c = [];
        for (let d = 0; d < b; d++) c.push(a(this, d, b));
        return c;
      }
    }
    class hm {
      constructor({ initialSize: a = 1024, maxSize: b = 1 / 0, allocateSize: c = 1024 } = {}) {
        (this.bytePosition = 0),
          (this.size = a),
          (this.maxSize = b),
          (this.allocateSize = c),
          (this.dataView = new DataView(new ArrayBuffer(a)));
      }
      ensureSizeOrGrow(a) {
        let b = this.bytePosition + a;
        if (b > this.size) {
          let a = Math.min(this.maxSize, this.size + this.allocateSize);
          if (b > a)
            throw Error(
              `SizeLimitExceeded: Attempting to serialize to BCS, but buffer does not have enough size. Allocated size: ${this.size}, Max size: ${this.maxSize}, Required size: ${b}`
            );
          this.size = a;
          let c = new ArrayBuffer(this.size);
          new Uint8Array(c).set(new Uint8Array(this.dataView.buffer)),
            (this.dataView = new DataView(c));
        }
      }
      shift(a) {
        return (this.bytePosition += a), this;
      }
      write8(a) {
        return (
          this.ensureSizeOrGrow(1),
          this.dataView.setUint8(this.bytePosition, Number(a)),
          this.shift(1)
        );
      }
      write16(a) {
        return (
          this.ensureSizeOrGrow(2),
          this.dataView.setUint16(this.bytePosition, Number(a), !0),
          this.shift(2)
        );
      }
      write32(a) {
        return (
          this.ensureSizeOrGrow(4),
          this.dataView.setUint32(this.bytePosition, Number(a), !0),
          this.shift(4)
        );
      }
      write64(a) {
        return hn(BigInt(a), 8).forEach((a) => this.write8(a)), this;
      }
      write128(a) {
        return hn(BigInt(a), 16).forEach((a) => this.write8(a)), this;
      }
      write256(a) {
        return hn(BigInt(a), 32).forEach((a) => this.write8(a)), this;
      }
      writeULEB(a) {
        return hk(a).forEach((a) => this.write8(a)), this;
      }
      writeVec(a, b) {
        return (
          this.writeULEB(a.length), Array.from(a).forEach((c, d) => b(this, c, d, a.length)), this
        );
      }
      *[Symbol.iterator]() {
        for (let a = 0; a < this.bytePosition; a++) yield this.dataView.getUint8(a);
        return this.toBytes();
      }
      toBytes() {
        return new Uint8Array(this.dataView.buffer.slice(0, this.bytePosition));
      }
      toString(a) {
        var b = this.toBytes();
        switch (a) {
          case 'base58':
            return he(b);
          case 'base64':
            return hh(b);
          case 'hex':
            return hj(b);
          default:
            throw Error('Unsupported encoding, supported values are: base64, hex');
        }
      }
    }
    function hn(a, b) {
      let c = new Uint8Array(b),
        d = 0;
      for (; a > 0; ) (c[d] = Number(a % BigInt(256))), (a /= BigInt(256)), (d += 1);
      return c;
    }
    var ho = (a) => {
        throw TypeError(a);
      },
      hp = (a, b, c) => b.has(a) || ho('Cannot ' + c),
      hq = (a, b, c) => (hp(a, b, 'read from private field'), c ? c.call(a) : b.get(a)),
      hr = (a, b, c) =>
        b.has(a)
          ? ho('Cannot add the same private member more than once')
          : b instanceof WeakSet
          ? b.add(a)
          : b.set(a, c),
      hs = (a, b, c, d) => (hp(a, b, 'write to private field'), d ? d.call(a, c) : b.set(a, c), c);
    let ht = class a {
      constructor(a) {
        hr(this, $),
          hr(this, _),
          (this.name = a.name),
          (this.read = a.read),
          (this.serializedSize = a.serializedSize ?? (() => null)),
          hs(this, $, a.write),
          hs(
            this,
            _,
            a.serialize ??
              ((a, b) => {
                let c = new hm({ initialSize: this.serializedSize(a) ?? void 0, ...b });
                return hq(this, $).call(this, a, c), c.toBytes();
              })
          ),
          (this.validate = a.validate ?? (() => {}));
      }
      write(a, b) {
        this.validate(a), hq(this, $).call(this, a, b);
      }
      serialize(a, b) {
        return this.validate(a), new hw(this, hq(this, _).call(this, a, b));
      }
      parse(a) {
        let b = new hl(a);
        return this.read(b);
      }
      fromHex(a) {
        return this.parse(hi(a));
      }
      fromBase58(a) {
        return this.parse(hf(a));
      }
      fromBase64(a) {
        return this.parse(hg(a));
      }
      transform({ name: b, input: c, output: d, validate: e }) {
        return new a({
          name: b ?? this.name,
          read: (a) => (d ? d(this.read(a)) : this.read(a)),
          write: (a, b) => hq(this, $).call(this, c ? c(a) : a, b),
          serializedSize: (a) => this.serializedSize(c ? c(a) : a),
          serialize: (a, b) => hq(this, _).call(this, c ? c(a) : a, b),
          validate: (a) => {
            e?.(a), this.validate(c ? c(a) : a);
          },
        });
      }
    };
    ($ = new WeakMap()), (_ = new WeakMap());
    let hu = Symbol.for('@iota/serialized-bcs');
    function hv(a) {
      return !!a && 'object' == typeof a && !0 === a[hu];
    }
    class hw {
      constructor(a, b) {
        hr(this, aa), hr(this, ab), hs(this, aa, a), hs(this, ab, b);
      }
      get [hu]() {
        return !0;
      }
      toBytes() {
        return hq(this, ab);
      }
      toHex() {
        return hj(hq(this, ab));
      }
      toBase64() {
        return hh(hq(this, ab));
      }
      toBase58() {
        return he(hq(this, ab));
      }
      parse() {
        return hq(this, aa).parse(hq(this, ab));
      }
    }
    function hx({ size: a, ...b }) {
      return new ht({ ...b, serializedSize: () => a });
    }
    function hy({ readMethod: a, writeMethod: b, ...c }) {
      return hx({
        ...c,
        read: (b) => b[a](),
        write: (a, c) => c[b](a),
        validate: (a) => {
          if (a < 0 || a > c.maxValue)
            throw TypeError(
              `Invalid ${c.name} value: ${a}. Expected value in range 0-${c.maxValue}`
            );
          c.validate?.(a);
        },
      });
    }
    function hz({ readMethod: a, writeMethod: b, ...c }) {
      return hx({
        ...c,
        read: (b) => b[a](),
        write: (a, c) => c[b](BigInt(a)),
        validate: (a) => {
          let b = BigInt(a);
          if (b < 0 || b > c.maxValue)
            throw TypeError(
              `Invalid ${c.name} value: ${b}. Expected value in range 0-${c.maxValue}`
            );
          c.validate?.(b);
        },
      });
    }
    function hA({ serialize: a, ...b }) {
      let c = new ht({
        ...b,
        serialize: a,
        write: (a, b) => {
          for (let d of c.serialize(a).toBytes()) b.write8(d);
        },
      });
      return c;
    }
    function hB({ toBytes: a, fromBytes: b, ...c }) {
      return new ht({
        ...c,
        read: (a) => {
          let c = a.readULEB();
          return b(a.readBytes(c));
        },
        write: (b, c) => {
          let d = a(b);
          c.writeULEB(d.length);
          for (let a = 0; a < d.length; a++) c.write8(d[a]);
        },
        serialize: (b) => {
          let c = a(b),
            d = hk(c.length),
            e = new Uint8Array(d.length + c.length);
          return e.set(d, 0), e.set(c, d.length), e;
        },
        validate: (a) => {
          if ('string' != typeof a)
            throw TypeError(`Invalid ${c.name} value: ${a}. Expected string`);
          c.validate?.(a);
        },
      });
    }
    function hC(a) {
      let b = null;
      function c() {
        return b || (b = a()), b;
      }
      return new ht({
        name: 'lazy',
        read: (a) => c().read(a),
        serializedSize: (a) => c().serializedSize(a),
        write: (a, b) => c().write(a, b),
        serialize: (a, b) => c().serialize(a, b).toBytes(),
      });
    }
    (aa = new WeakMap()),
      (ab = new WeakMap()),
      a.s(
        [
          'BcsType',
          () => ht,
          'bigUIntBcsType',
          () => hz,
          'dynamicSizeBcsType',
          () => hA,
          'fixedSizeBcsType',
          () => hx,
          'isSerializedBcs',
          () => hv,
          'lazyBcsType',
          () => hC,
          'stringLikeBcsType',
          () => hB,
          'uIntBcsType',
          () => hy,
        ],
        63770
      );
    let hD = {
      u8: (a) =>
        hy({
          name: 'u8',
          readMethod: 'read8',
          writeMethod: 'write8',
          size: 1,
          maxValue: 255,
          ...a,
        }),
      u16: (a) =>
        hy({
          name: 'u16',
          readMethod: 'read16',
          writeMethod: 'write16',
          size: 2,
          maxValue: 65535,
          ...a,
        }),
      u32: (a) =>
        hy({
          name: 'u32',
          readMethod: 'read32',
          writeMethod: 'write32',
          size: 4,
          maxValue: 0x100000000 - 1,
          ...a,
        }),
      u64: (a) =>
        hz({
          name: 'u64',
          readMethod: 'read64',
          writeMethod: 'write64',
          size: 8,
          maxValue: 2n ** 64n - 1n,
          ...a,
        }),
      u128: (a) =>
        hz({
          name: 'u128',
          readMethod: 'read128',
          writeMethod: 'write128',
          size: 16,
          maxValue: 2n ** 128n - 1n,
          ...a,
        }),
      u256: (a) =>
        hz({
          name: 'u256',
          readMethod: 'read256',
          writeMethod: 'write256',
          size: 32,
          maxValue: 2n ** 256n - 1n,
          ...a,
        }),
      bool: (a) =>
        hx({
          name: 'bool',
          size: 1,
          read: (a) => 1 === a.read8(),
          write: (a, b) => b.write8(+!!a),
          ...a,
          validate: (b) => {
            if ((a?.validate?.(b), 'boolean' != typeof b))
              throw TypeError(`Expected boolean, found ${typeof b}`);
          },
        }),
      uleb128: (a) =>
        hA({
          name: 'uleb128',
          read: (a) => a.readULEB(),
          serialize: (a) => Uint8Array.from(hk(a)),
          ...a,
        }),
      bytes: (a, b) =>
        hx({
          name: `bytes[${a}]`,
          size: a,
          read: (b) => b.readBytes(a),
          write: (b, c) => {
            for (let d = 0; d < a; d++) c.write8(b[d] ?? 0);
          },
          ...b,
          validate: (c) => {
            if ((b?.validate?.(c), !c || 'object' != typeof c || !('length' in c)))
              throw TypeError(`Expected array, found ${typeof c}`);
            if (c.length !== a) throw TypeError(`Expected array of length ${a}, found ${c.length}`);
          },
        }),
      byteVector: (a) =>
        new ht({
          name: 'bytesVector',
          read: (a) => {
            let b = a.readULEB();
            return a.readBytes(b);
          },
          write: (a, b) => {
            let c = new Uint8Array(a);
            b.writeULEB(c.length);
            for (let a = 0; a < c.length; a++) b.write8(c[a] ?? 0);
          },
          ...a,
          serializedSize: (a) => {
            let b = 'length' in a ? a.length : null;
            return null == b ? null : hk(b).length + b;
          },
          validate: (b) => {
            if ((a?.validate?.(b), !b || 'object' != typeof b || !('length' in b)))
              throw TypeError(`Expected array, found ${typeof b}`);
          },
        }),
      string: (a) =>
        hB({
          name: 'string',
          toBytes: (a) => new TextEncoder().encode(a),
          fromBytes: (a) => new TextDecoder().decode(a),
          ...a,
        }),
      fixedArray: (a, b, c) =>
        new ht({
          name: `${b.name}[${a}]`,
          read: (c) => {
            let d = Array(a);
            for (let e = 0; e < a; e++) d[e] = b.read(c);
            return d;
          },
          write: (a, c) => {
            for (let d of a) b.write(d, c);
          },
          ...c,
          validate: (b) => {
            if ((c?.validate?.(b), !b || 'object' != typeof b || !('length' in b)))
              throw TypeError(`Expected array, found ${typeof b}`);
            if (b.length !== a) throw TypeError(`Expected array of length ${a}, found ${b.length}`);
          },
        }),
      option: (a) =>
        hD
          .enum(`Option<${a.name}>`, { None: null, Some: a })
          .transform({
            input: (a) => (null == a ? { None: !0 } : { Some: a }),
            output: (a) => ('Some' === a.$kind ? a.Some : null),
          }),
      vector: (a, b) =>
        new ht({
          name: `vector<${a.name}>`,
          read: (b) => {
            let c = b.readULEB(),
              d = Array(c);
            for (let e = 0; e < c; e++) d[e] = a.read(b);
            return d;
          },
          write: (b, c) => {
            for (let d of (c.writeULEB(b.length), b)) a.write(d, c);
          },
          ...b,
          validate: (a) => {
            if ((b?.validate?.(a), !a || 'object' != typeof a || !('length' in a)))
              throw TypeError(`Expected array, found ${typeof a}`);
          },
        }),
      tuple: (a, b) =>
        new ht({
          name: `(${a.map((a) => a.name).join(', ')})`,
          serializedSize: (b) => {
            let c = 0;
            for (let d = 0; d < a.length; d++) {
              let e = a[d].serializedSize(b[d]);
              if (null == e) return null;
              c += e;
            }
            return c;
          },
          read: (b) => {
            let c = [];
            for (let d of a) c.push(d.read(b));
            return c;
          },
          write: (b, c) => {
            for (let d = 0; d < a.length; d++) a[d].write(b[d], c);
          },
          ...b,
          validate: (c) => {
            if ((b?.validate?.(c), !Array.isArray(c)))
              throw TypeError(`Expected array, found ${typeof c}`);
            if (c.length !== a.length)
              throw TypeError(`Expected array of length ${a.length}, found ${c.length}`);
          },
        }),
      struct(a, b, c) {
        let d = Object.entries(b);
        return new ht({
          name: a,
          serializedSize: (a) => {
            let b = 0;
            for (let [c, e] of d) {
              let d = e.serializedSize(a[c]);
              if (null == d) return null;
              b += d;
            }
            return b;
          },
          read: (a) => {
            let b = {};
            for (let [c, e] of d) b[c] = e.read(a);
            return b;
          },
          write: (a, b) => {
            for (let [c, e] of d) e.write(a[c], b);
          },
          ...c,
          validate: (a) => {
            if ((c?.validate?.(a), 'object' != typeof a || null == a))
              throw TypeError(`Expected object, found ${typeof a}`);
          },
        });
      },
      enum(a, b, c) {
        let d = Object.entries(b);
        return new ht({
          name: a,
          read: (b) => {
            let c = b.readULEB(),
              e = d[c];
            if (!e) throw TypeError(`Unknown value ${c} for enum ${a}`);
            let [f, g] = e;
            return { [f]: g?.read(b) ?? !0, $kind: f };
          },
          write: (a, c) => {
            let [e, f] = Object.entries(a).filter(([a]) => Object.hasOwn(b, a))[0];
            for (let a = 0; a < d.length; a++) {
              let [b, g] = d[a];
              if (b === e) {
                c.writeULEB(a), g?.write(f, c);
                return;
              }
            }
          },
          ...c,
          validate: (d) => {
            if ((c?.validate?.(d), 'object' != typeof d || null == d))
              throw TypeError(`Expected object, found ${typeof d}`);
            let e = Object.keys(d).filter((a) => void 0 !== d[a] && Object.hasOwn(b, a));
            if (1 !== e.length)
              throw TypeError(`Expected object with one key, but found ${e.length} for type ${a}}`);
            let [f] = e;
            if (!Object.hasOwn(b, f)) throw TypeError(`Invalid enum variant ${f}`);
          },
        });
      },
      map: (a, b) =>
        hD.vector(hD.tuple([a, b])).transform({
          name: `Map<${a.name}, ${b.name}>`,
          input: (a) => [...a.entries()],
          output: (a) => {
            let b = new Map();
            for (let [c, d] of a) b.set(c, d);
            return b;
          },
        }),
      lazy: (a) => hC(a),
    };
    function hE(a) {
      var b, c;
      return (
        (b = a),
        /^(0x|0X)?[a-fA-F0-9]+$/.test(b) &&
          b.length % 2 == 0 &&
          32 == ((c = a), /^(0x|0X)/.test(c) ? (c.length - 2) / 2 : c.length / 2)
      );
    }
    function hF(a, b = !1, c = !1) {
      let d = a.toLowerCase().replace(/ /g, '');
      if (
        (!b && d.startsWith('0x') && (d = d.slice(2)),
        (d = `0x${d.padStart(64, '0')}`),
        !c || hE(d))
      )
        return d;
      throw Error(`Invalid IOTA address: ${a}`);
    }
    function hG(a, b = !1, c = !1) {
      return hF(a, b, c);
    }
    a.s(
      [
        'IOTA_ADDRESS_LENGTH',
        () => 32,
        'isValidIotaAddress',
        () => hE,
        'normalizeIotaAddress',
        () => hF,
        'normalizeIotaObjectId',
        () => hG,
      ],
      35110
    );
    let hH = /^vector<(.+)>$/,
      hI = /^([^:]+)::([^:]+)::([^<]+)(<(.+)>)?/;
    class hJ {
      static parseFromStr(a, b = !1) {
        if ('address' === a) return { address: null };
        if ('bool' === a) return { bool: null };
        if ('u8' === a) return { u8: null };
        if ('u16' === a) return { u16: null };
        if ('u32' === a) return { u32: null };
        else if ('u64' === a) return { u64: null };
        else if ('u128' === a) return { u128: null };
        else if ('u256' === a) return { u256: null };
        else if ('signer' === a) return { signer: null };
        let c = a.match(hH);
        if (c) return { vector: hJ.parseFromStr(c[1], b) };
        let d = a.match(hI);
        if (d)
          return {
            struct: {
              address: b ? hF(d[1]) : d[1],
              module: d[2],
              name: d[3],
              typeParams: void 0 === d[5] ? [] : hJ.parseStructTypeArgs(d[5], b),
            },
          };
        throw Error(`Encountered unexpected token when parsing type args for ${a}`);
      }
      static parseStructTypeArgs(a, b = !1) {
        return (function (a, b = ['<', '>']) {
          let [c, d] = b,
            e = [],
            f = '',
            g = 0;
          for (let b = 0; b < a.length; b++) {
            let h = a[b];
            if ((h === c && g++, h === d && g--, 0 === g && ',' === h)) {
              e.push(f.trim()), (f = '');
              continue;
            }
            f += h;
          }
          return e.push(f.trim()), e;
        })(a).map((a) => hJ.parseFromStr(a, b));
      }
      static tagToString(a) {
        if ('bool' in a) return 'bool';
        if ('u8' in a) return 'u8';
        if ('u16' in a) return 'u16';
        if ('u32' in a) return 'u32';
        if ('u64' in a) return 'u64';
        if ('u128' in a) return 'u128';
        if ('u256' in a) return 'u256';
        if ('address' in a) return 'address';
        if ('signer' in a) return 'signer';
        if ('vector' in a) return `vector<${hJ.tagToString(a.vector)}>`;
        if ('struct' in a) {
          let b = a.struct,
            c = b.typeParams.map(hJ.tagToString).join(', ');
          return `${b.address}::${b.module}::${b.name}${c ? `<${c}>` : ''}`;
        }
        throw Error('Invalid TypeTag');
      }
    }
    a.s(['TypeTagSerializer', () => hJ], 20914);
    let hK = hD.bytes(32).transform({
        validate: (a) => {
          let b = 'string' == typeof a ? a : hj(a);
          if (!b || !hE(hF(b))) throw Error(`Invalid IOTA address ${b}`);
        },
        input: (a) => ('string' == typeof a ? hi(hF(a)) : a),
        output: (a) => hF(hj(a)),
      }),
      hL = hD.vector(hD.u8()).transform({
        name: 'ObjectDigest',
        input: (a) => hf(a),
        output: (a) => he(new Uint8Array(a)),
        validate: (a) => {
          if (32 !== hf(a).length) throw Error('ObjectDigest must be 32 bytes');
        },
      }),
      hM = hD.struct('IotaObjectRef', { objectId: hK, version: hD.u64(), digest: hL }),
      hN = hD.struct('SharedObjectRef', {
        objectId: hK,
        initialSharedVersion: hD.u64(),
        mutable: hD.bool(),
      }),
      hO = hD.enum('ObjectArg', { ImmOrOwnedObject: hM, SharedObject: hN, Receiving: hM }),
      hP = hD.enum('Owner', {
        AddressOwner: hK,
        ObjectOwner: hK,
        Shared: hD.struct('Shared', { initialSharedVersion: hD.u64() }),
        Immutable: null,
      }),
      hQ = hD.enum('CallArg', {
        Pure: hD.struct('Pure', {
          bytes: hD
            .vector(hD.u8())
            .transform({
              input: (a) => ('string' == typeof a ? hg(a) : a),
              output: (a) => hh(new Uint8Array(a)),
            }),
        }),
        Object: hO,
      }),
      hR = hD.enum('TypeTag', {
        bool: null,
        u8: null,
        u64: null,
        u128: null,
        address: null,
        signer: null,
        vector: hD.lazy(() => hR),
        struct: hD.lazy(() => hZ),
        u16: null,
        u32: null,
        u256: null,
      }),
      hS = hR.transform({
        input: (a) => ('string' == typeof a ? hJ.parseFromStr(a, !0) : a),
        output: (a) => hJ.tagToString(a),
      }),
      hT = hD.enum('Argument', {
        GasCoin: null,
        Input: hD.u16(),
        Result: hD.u16(),
        NestedResult: hD.tuple([hD.u16(), hD.u16()]),
      }),
      hU = hD.struct('ProgrammableMoveCall', {
        package: hK,
        module: hD.string(),
        function: hD.string(),
        typeArguments: hD.vector(hS),
        arguments: hD.vector(hT),
      }),
      hV = hD.enum('Command', {
        MoveCall: hU,
        TransferObjects: hD.struct('TransferObjects', { objects: hD.vector(hT), address: hT }),
        SplitCoins: hD.struct('SplitCoins', { coin: hT, amounts: hD.vector(hT) }),
        MergeCoins: hD.struct('MergeCoins', { destination: hT, sources: hD.vector(hT) }),
        Publish: hD.struct('Publish', {
          modules: hD.vector(
            hD
              .vector(hD.u8())
              .transform({
                input: (a) => ('string' == typeof a ? hg(a) : a),
                output: (a) => hh(new Uint8Array(a)),
              })
          ),
          dependencies: hD.vector(hK),
        }),
        MakeMoveVec: hD.struct('MakeMoveVec', {
          type: hD
            .enum('Option', { None: null, Some: hS })
            .transform({
              input: (a) => (null === a ? { None: !0 } : { Some: a }),
              output: (a) => a.Some ?? null,
            }),
          elements: hD.vector(hT),
        }),
        Upgrade: hD.struct('Upgrade', {
          modules: hD.vector(
            hD
              .vector(hD.u8())
              .transform({
                input: (a) => ('string' == typeof a ? hg(a) : a),
                output: (a) => hh(new Uint8Array(a)),
              })
          ),
          dependencies: hD.vector(hK),
          package: hK,
          ticket: hT,
        }),
      }),
      hW = hD.struct('ProgrammableTransaction', { inputs: hD.vector(hQ), commands: hD.vector(hV) }),
      hX = hD.enum('TransactionKind', {
        ProgrammableTransaction: hW,
        ChangeEpoch: null,
        Genesis: null,
        ConsensusCommitPrologue: null,
      }),
      hY = hD.enum('TransactionExpiration', {
        None: null,
        Epoch: hD
          .u64({ name: 'unsafe_u64', ...void 0 })
          .transform({ input: (a) => a, output: (a) => Number(a) }),
      }),
      hZ = hD.struct('StructTag', {
        address: hK,
        module: hD.string(),
        name: hD.string(),
        typeParams: hD.vector(hR),
      }),
      h$ = hD.struct('GasData', {
        payment: hD.vector(hM),
        owner: hK,
        price: hD.u64(),
        budget: hD.u64(),
      }),
      h_ = hD.struct('TransactionDataV1', { kind: hX, sender: hK, gasData: h$, expiration: hY }),
      h0 = hD.enum('TransactionData', { V1: h_ }),
      h1 = hD.enum('IntentScope', {
        TransactionData: null,
        TransactionEffects: null,
        CheckpointSummary: null,
        PersonalMessage: null,
      }),
      h2 = hD.enum('IntentVersion', { V0: null }),
      h3 = hD.enum('AppId', { Iota: null }),
      h4 = hD.struct('Intent', { scope: h1, version: h2, appId: h3 });
    function h5(a) {
      return hD.struct(`IntentMessage<${a.name}>`, { intent: h4, value: a });
    }
    let h6 = hD.enum('CompressedSignature', {
        ED25519: hD.fixedArray(64, hD.u8()),
        Secp256k1: hD.fixedArray(64, hD.u8()),
        Secp256r1: hD.fixedArray(64, hD.u8()),
      }),
      h7 = hD.enum('PublicKey', {
        ED25519: hD.fixedArray(32, hD.u8()),
        Secp256k1: hD.fixedArray(33, hD.u8()),
        Secp256r1: hD.fixedArray(33, hD.u8()),
      }),
      h8 = hD.struct('MultiSigPkMap', { pubKey: h7, weight: hD.u8() }),
      h9 = hD.struct('MultiSigPublicKey', { pk_map: hD.vector(h8), threshold: hD.u16() }),
      ia = hD.struct('MultiSig', { sigs: hD.vector(h6), bitmap: hD.u16(), multisig_pk: h9 }),
      ib = hD
        .vector(hD.u8())
        .transform({
          input: (a) => ('string' == typeof a ? hg(a) : a),
          output: (a) => hh(new Uint8Array(a)),
        }),
      ic = hD.struct('SenderSignedTransaction', {
        intentMessage: h5(h0),
        txSignatures: hD.vector(ib),
      }),
      id = hD.vector(ic, { name: 'SenderSignedData' }),
      ie = hD.struct('PasskeyAuthenticator', {
        authenticatorData: hD.vector(hD.u8()),
        clientDataJson: hD.string(),
        userSignature: hD.vector(hD.u8()),
      }),
      ig = hD.enum('PackageUpgradeError', {
        UnableToFetchPackage: hD.struct('UnableToFetchPackage', { packageId: hK }),
        NotAPackage: hD.struct('NotAPackage', { objectId: hK }),
        IncompatibleUpgrade: null,
        DigestDoesNotMatch: hD.struct('DigestDoesNotMatch', { digest: hD.vector(hD.u8()) }),
        UnknownUpgradePolicy: hD.struct('UnknownUpgradePolicy', { policy: hD.u8() }),
        PackageIDDoesNotMatch: hD.struct('PackageIDDoesNotMatch', { packageId: hK, ticketId: hK }),
      }),
      ih = hD.struct('ModuleId', { address: hK, name: hD.string() }),
      ii = hD.struct('MoveLocation', {
        module: ih,
        function: hD.u16(),
        instruction: hD.u16(),
        functionName: hD.option(hD.string()),
      }),
      ij = hD.enum('CommandArgumentError', {
        TypeMismatch: null,
        InvalidBCSBytes: null,
        InvalidUsageOfPureArg: null,
        InvalidArgumentToPrivateEntryFunction: null,
        IndexOutOfBounds: hD.struct('IndexOutOfBounds', { idx: hD.u16() }),
        SecondaryIndexOutOfBounds: hD.struct('SecondaryIndexOutOfBounds', {
          resultIdx: hD.u16(),
          secondaryIdx: hD.u16(),
        }),
        InvalidResultArity: hD.struct('InvalidResultArity', { resultIdx: hD.u16() }),
        InvalidGasCoinUsage: null,
        InvalidValueUsage: null,
        InvalidObjectByValue: null,
        InvalidObjectByMutRef: null,
        SharedObjectOperationNotAllowed: null,
      }),
      ik = hD.enum('TypeArgumentError', { TypeNotFound: null, ConstraintNotSatisfied: null }),
      il = hD.enum('ExecutionFailureStatus', {
        InsufficientGas: null,
        InvalidGasObject: null,
        InvariantViolation: null,
        FeatureNotYetSupported: null,
        MoveObjectTooBig: hD.struct('MoveObjectTooBig', {
          objectSize: hD.u64(),
          maxObjectSize: hD.u64(),
        }),
        MovePackageTooBig: hD.struct('MovePackageTooBig', {
          objectSize: hD.u64(),
          maxObjectSize: hD.u64(),
        }),
        CircularObjectOwnership: hD.struct('CircularObjectOwnership', { object: hK }),
        InsufficientCoinBalance: null,
        CoinBalanceOverflow: null,
        PublishErrorNonZeroAddress: null,
        IotaMoveVerificationError: null,
        MovePrimitiveRuntimeError: hD.option(ii),
        MoveAbort: hD.tuple([ii, hD.u64()]),
        VMVerificationOrDeserializationError: null,
        VMInvariantViolation: null,
        FunctionNotFound: null,
        ArityMismatch: null,
        TypeArityMismatch: null,
        NonEntryFunctionInvoked: null,
        CommandArgumentError: hD.struct('CommandArgumentError', { argIdx: hD.u16(), kind: ij }),
        TypeArgumentError: hD.struct('TypeArgumentError', { argumentIdx: hD.u16(), kind: ik }),
        UnusedValueWithoutDrop: hD.struct('UnusedValueWithoutDrop', {
          resultIdx: hD.u16(),
          secondaryIdx: hD.u16(),
        }),
        InvalidPublicFunctionReturnType: hD.struct('InvalidPublicFunctionReturnType', {
          idx: hD.u16(),
        }),
        InvalidTransferObject: null,
        EffectsTooLarge: hD.struct('EffectsTooLarge', { currentSize: hD.u64(), maxSize: hD.u64() }),
        PublishUpgradeMissingDependency: null,
        PublishUpgradeDependencyDowngrade: null,
        PackageUpgradeError: hD.struct('PackageUpgradeError', { upgradeError: ig }),
        WrittenObjectsTooLarge: hD.struct('WrittenObjectsTooLarge', {
          currentSize: hD.u64(),
          maxSize: hD.u64(),
        }),
        CertificateDenied: null,
        IotaMoveVerificationTimedout: null,
        SharedObjectOperationNotAllowed: null,
        InputObjectDeleted: null,
        ExecutionCancelledDueToSharedObjectCongestion: hD.struct(
          'ExecutionCancelledDueToSharedObjectCongestion',
          { congestedObjects: hD.vector(hK) }
        ),
        AddressDeniedForCoin: hD.struct('AddressDeniedForCoin', {
          address: hK,
          coinType: hD.string(),
        }),
        CoinTypeGlobalPause: hD.struct('CoinTypeGlobalPause', { coinType: hD.string() }),
        ExecutionCancelledDueToRandomnessUnavailable: null,
      }),
      im = hD.enum('ExecutionStatus', {
        Success: null,
        Failed: hD.struct('ExecutionFailed', { error: il, command: hD.option(hD.u64()) }),
      }),
      io = hD.struct('GasCostSummary', {
        computationCost: hD.u64(),
        computationCostBurned: hD.u64(),
        storageCost: hD.u64(),
        storageRebate: hD.u64(),
        nonRefundableStorageFee: hD.u64(),
      }),
      ip = hD.tuple([hD.u64(), hL]),
      iq = hD.enum('ObjectIn', { NotExist: null, Exist: hD.tuple([ip, hP]) }),
      ir = hD.enum('ObjectOut', {
        NotExist: null,
        ObjectWrite: hD.tuple([hL, hP]),
        PackageWrite: ip,
      }),
      is = hD.enum('IDOperation', { None: null, Created: null, Deleted: null }),
      it = hD.struct('EffectsObjectChange', { inputState: iq, outputState: ir, idOperation: is }),
      iu = hD.enum('UnchangedSharedKind', {
        ReadOnlyRoot: ip,
        MutateDeleted: hD.u64(),
        ReadDeleted: hD.u64(),
        Cancelled: hD.u64(),
        PerEpochConfig: null,
      }),
      iv = hD.struct('TransactionEffectsV1', {
        status: im,
        executedEpoch: hD.u64(),
        gasUsed: io,
        transactionDigest: hL,
        gasObjectIndex: hD.option(hD.u32()),
        eventsDigest: hD.option(hL),
        dependencies: hD.vector(hL),
        lamportVersion: hD.u64(),
        changedObjects: hD.vector(hD.tuple([hK, it])),
        unchangedSharedObjects: hD.vector(hD.tuple([hK, iu])),
        auxDataDigest: hD.option(hL),
      }),
      iw = hD.enum('TransactionEffects', { V1: iv }),
      ix = {
        ...hD,
        U8: hD.u8(),
        U16: hD.u16(),
        U32: hD.u32(),
        U64: hD.u64(),
        U128: hD.u128(),
        U256: hD.u256(),
        ULEB128: hD.uleb128(),
        Bool: hD.bool(),
        String: hD.string(),
        Address: hK,
        AppId: h3,
        Argument: hT,
        CallArg: hQ,
        CompressedSignature: h6,
        GasData: h$,
        Intent: h4,
        IntentMessage: h5,
        IntentScope: h1,
        IntentVersion: h2,
        MultiSig: ia,
        MultiSigPkMap: h8,
        MultiSigPublicKey: h9,
        ObjectArg: hO,
        ObjectDigest: hL,
        Owner: hP,
        ProgrammableMoveCall: hU,
        ProgrammableTransaction: hW,
        PublicKey: h7,
        SenderSignedData: id,
        SenderSignedTransaction: ic,
        SharedObjectRef: hN,
        StructTag: hZ,
        IotaObjectRef: hM,
        Command: hV,
        TransactionData: h0,
        TransactionDataV1: h_,
        TransactionExpiration: hY,
        TransactionKind: hX,
        TypeTag: hS,
        TransactionEffects: iw,
        PasskeyAuthenticator: ie,
      };
    a.s(['bcs', () => ix], 13515);
    var iy = 'Document',
      iz = 'FragmentDefinition';
    class iA extends Error {
      constructor(a, b, c, d, e, f, g) {
        super(a),
          (this.name = 'GraphQLError'),
          (this.message = a),
          e && (this.path = e),
          b && (this.nodes = Array.isArray(b) ? b : [b]),
          c && (this.source = c),
          d && (this.positions = d),
          f && (this.originalError = f);
        var h = g;
        if (!h && f) {
          var i = f.extensions;
          i && 'object' == typeof i && (h = i);
        }
        this.extensions = h || {};
      }
      toJSON() {
        return { ...this, message: this.message };
      }
      toString() {
        return this.message;
      }
      get [Symbol.toStringTag]() {
        return 'GraphQLError';
      }
    }
    function iB(a) {
      return new iA(`Syntax Error: Unexpected token at ${ad} in ${a}`);
    }
    function iC(a) {
      if (((a.lastIndex = ad), a.test(ac))) return ac.slice(ad, (ad = a.lastIndex));
    }
    var iD = / +(?=[^\s])/y;
    function iE() {
      for (
        var a = 0 | ac.charCodeAt(ad++);
        9 === a || 10 === a || 13 === a || 32 === a || 35 === a || 44 === a || 65279 === a;
        a = 0 | ac.charCodeAt(ad++)
      )
        if (35 === a) for (; (a = 0 | ac.charCodeAt(ad++)) && 10 !== a && 13 !== a; );
      ad--;
    }
    function iF() {
      for (
        var a = ad, b = 0 | ac.charCodeAt(ad++);
        (b >= 48 && b <= 57) || (b >= 65 && b <= 90) || 95 === b || (b >= 97 && b <= 122);
        b = 0 | ac.charCodeAt(ad++)
      );
      if (a === ad - 1) throw iB('Name');
      var c = ac.slice(a, --ad);
      return iE(), c;
    }
    function iG() {
      return { kind: 'Name', value: iF() };
    }
    var iH = /(?:"""|(?:[\s\S]*?[^\\])""")/y,
      iI = /(?:(?:\.\d+)?[eE][+-]?\d+|\.\d+)/y;
    function iJ(a) {
      var b;
      switch (ac.charCodeAt(ad)) {
        case 91:
          ad++, iE();
          for (var c = []; 93 !== ac.charCodeAt(ad); ) c.push(iJ(a));
          return ad++, iE(), { kind: 'ListValue', values: c };
        case 123:
          ad++, iE();
          for (var d = []; 125 !== ac.charCodeAt(ad); ) {
            var e = iG();
            if (58 !== ac.charCodeAt(ad++)) throw iB('ObjectField');
            iE(), d.push({ kind: 'ObjectField', name: e, value: iJ(a) });
          }
          return ad++, iE(), { kind: 'ObjectValue', fields: d };
        case 36:
          if (a) throw iB('Variable');
          return ad++, { kind: 'Variable', name: iG() };
        case 34:
          if (34 === ac.charCodeAt(ad + 1) && 34 === ac.charCodeAt(ad + 2)) {
            if (((ad += 3), null == (b = iC(iH)))) throw iB('StringValue');
            return (
              iE(),
              {
                kind: 'StringValue',
                value: (function (a) {
                  for (
                    var b = a.split('\n'), c = '', d = 0, e = 0, f = b.length - 1, g = 0;
                    g < b.length;
                    g++
                  )
                    (iD.lastIndex = 0),
                      iD.test(b[g]) &&
                        (g && (!d || iD.lastIndex < d) && (d = iD.lastIndex),
                        (e = e || g),
                        (f = g));
                  for (var h = e; h <= f; h++)
                    h !== e && (c += '\n'), (c += b[h].slice(d).replace(/\\"""/g, '"""'));
                  return c;
                })(b.slice(0, -3)),
                block: !0,
              }
            );
          }
          var f,
            g = ad;
          ad++;
          var h = !1;
          for (
            f = 0 | ac.charCodeAt(ad++);
            (92 === f && (ad++, (h = !0))) || (10 !== f && 13 !== f && 34 !== f && f);
            f = 0 | ac.charCodeAt(ad++)
          );
          if (34 !== f) throw iB('StringValue');
          return (
            (b = ac.slice(g, ad)),
            iE(),
            { kind: 'StringValue', value: h ? JSON.parse(b) : b.slice(1, -1), block: !1 }
          );
        case 45:
        case 48:
        case 49:
        case 50:
        case 51:
        case 52:
        case 53:
        case 54:
        case 55:
        case 56:
        case 57:
          for (var i, j = ad++; (i = 0 | ac.charCodeAt(ad++)) >= 48 && i <= 57; );
          var k = ac.slice(j, --ad);
          if (46 !== (i = ac.charCodeAt(ad)) && 69 !== i && 101 !== i)
            return iE(), { kind: 'IntValue', value: k };
          if (null == (b = iC(iI))) throw iB('FloatValue');
          return iE(), { kind: 'FloatValue', value: k + b };
        case 110:
          if (
            117 === ac.charCodeAt(ad + 1) &&
            108 === ac.charCodeAt(ad + 2) &&
            108 === ac.charCodeAt(ad + 3)
          )
            return (ad += 4), iE(), { kind: 'NullValue' };
          break;
        case 116:
          if (
            114 === ac.charCodeAt(ad + 1) &&
            117 === ac.charCodeAt(ad + 2) &&
            101 === ac.charCodeAt(ad + 3)
          )
            return (ad += 4), iE(), { kind: 'BooleanValue', value: !0 };
          break;
        case 102:
          if (
            97 === ac.charCodeAt(ad + 1) &&
            108 === ac.charCodeAt(ad + 2) &&
            115 === ac.charCodeAt(ad + 3) &&
            101 === ac.charCodeAt(ad + 4)
          )
            return (ad += 5), iE(), { kind: 'BooleanValue', value: !1 };
      }
      return { kind: 'EnumValue', value: iF() };
    }
    function iK(a) {
      if (40 === ac.charCodeAt(ad)) {
        var b = [];
        ad++, iE();
        do {
          var c = iG();
          if (58 !== ac.charCodeAt(ad++)) throw iB('Argument');
          iE(), b.push({ kind: 'Argument', name: c, value: iJ(a) });
        } while (41 !== ac.charCodeAt(ad));
        return ad++, iE(), b;
      }
    }
    function iL(a) {
      if (64 === ac.charCodeAt(ad)) {
        var b = [];
        do ad++, b.push({ kind: 'Directive', name: iG(), arguments: iK(a) });
        while (64 === ac.charCodeAt(ad));
        return b;
      }
    }
    function iM() {
      if (123 !== ac.charCodeAt(ad++)) throw iB('SelectionSet');
      return iE(), iN();
    }
    function iN() {
      var a = [];
      do
        if (46 === ac.charCodeAt(ad)) {
          if (46 !== ac.charCodeAt(++ad) || 46 !== ac.charCodeAt(++ad)) throw iB('SelectionSet');
          switch ((ad++, iE(), ac.charCodeAt(ad))) {
            case 64:
              a.push({
                kind: 'InlineFragment',
                typeCondition: void 0,
                directives: iL(!1),
                selectionSet: iM(),
              });
              break;
            case 111:
              110 === ac.charCodeAt(ad + 1)
                ? ((ad += 2),
                  iE(),
                  a.push({
                    kind: 'InlineFragment',
                    typeCondition: { kind: 'NamedType', name: iG() },
                    directives: iL(!1),
                    selectionSet: iM(),
                  }))
                : a.push({ kind: 'FragmentSpread', name: iG(), directives: iL(!1) });
              break;
            case 123:
              ad++,
                iE(),
                a.push({
                  kind: 'InlineFragment',
                  typeCondition: void 0,
                  directives: void 0,
                  selectionSet: iN(),
                });
              break;
            default:
              a.push({ kind: 'FragmentSpread', name: iG(), directives: iL(!1) });
          }
        } else {
          var b = iG(),
            c = void 0;
          58 === ac.charCodeAt(ad) && (ad++, iE(), (c = b), (b = iG()));
          var d = iK(!1),
            e = iL(!1),
            f = void 0;
          123 === ac.charCodeAt(ad) && (ad++, iE(), (f = iN())),
            a.push({
              kind: 'Field',
              alias: c,
              name: b,
              arguments: d,
              directives: e,
              selectionSet: f,
            });
        }
      while (125 !== ac.charCodeAt(ad));
      return ad++, iE(), { kind: 'SelectionSet', selections: a };
    }
    function iO(a, b, c) {
      for (var d = '', e = 0; e < a.length; e++) e && (d += b), (d += c(a[e]));
      return d;
    }
    var iP = '\n',
      iQ = {
        OperationDefinition(a) {
          var b = '';
          a.description && (b += iQ.StringValue(a.description) + '\n'),
            (b += a.operation),
            a.name && (b += ' ' + a.name.value),
            a.variableDefinitions &&
              a.variableDefinitions.length &&
              (a.name || (b += ' '),
              (b += '(' + iO(a.variableDefinitions, ', ', iQ.VariableDefinition) + ')')),
            a.directives && a.directives.length && (b += ' ' + iO(a.directives, ' ', iQ.Directive));
          var c = iQ.SelectionSet(a.selectionSet);
          return 'query' !== b ? b + ' ' + c : c;
        },
        VariableDefinition(a) {
          var b = '';
          return (
            a.description && (b += iQ.StringValue(a.description) + ' '),
            (b += iQ.Variable(a.variable) + ': ' + iR(a.type)),
            a.defaultValue && (b += ' = ' + iR(a.defaultValue)),
            a.directives && a.directives.length && (b += ' ' + iO(a.directives, ' ', iQ.Directive)),
            b
          );
        },
        Field(a) {
          var b = a.alias ? a.alias.value + ': ' + a.name.value : a.name.value;
          if (a.arguments && a.arguments.length) {
            var c = iO(a.arguments, ', ', iQ.Argument);
            b.length + c.length + 2 > 80
              ? (b +=
                  '(' +
                  (iP += '  ') +
                  iO(a.arguments, iP, iQ.Argument) +
                  (iP = iP.slice(0, -2)) +
                  ')')
              : (b += '(' + c + ')');
          }
          return (
            a.directives && a.directives.length && (b += ' ' + iO(a.directives, ' ', iQ.Directive)),
            a.selectionSet &&
              a.selectionSet.selections.length &&
              (b += ' ' + iQ.SelectionSet(a.selectionSet)),
            b
          );
        },
        StringValue: (a) =>
          a.block
            ? ('"""\n' + a.value.replace(/"""/g, '\\"""') + '\n"""').replace(/\n/g, iP)
            : JSON.stringify(a.value),
        BooleanValue: (a) => '' + a.value,
        NullValue: (a) => 'null',
        IntValue: (a) => a.value,
        FloatValue: (a) => a.value,
        EnumValue: (a) => a.value,
        Name: (a) => a.value,
        Variable: (a) => '$' + a.name.value,
        ListValue: (a) => '[' + iO(a.values, ', ', iR) + ']',
        ObjectValue: (a) => '{' + iO(a.fields, ', ', iQ.ObjectField) + '}',
        ObjectField: (a) => a.name.value + ': ' + iR(a.value),
        Document: (a) =>
          a.definitions && a.definitions.length ? iO(a.definitions, '\n\n', iR) : '',
        SelectionSet: (a) =>
          '{' + (iP += '  ') + iO(a.selections, iP, iR) + (iP = iP.slice(0, -2)) + '}',
        Argument: (a) => a.name.value + ': ' + iR(a.value),
        FragmentSpread(a) {
          var b = '...' + a.name.value;
          return (
            a.directives && a.directives.length && (b += ' ' + iO(a.directives, ' ', iQ.Directive)),
            b
          );
        },
        InlineFragment(a) {
          var b = '...';
          return (
            a.typeCondition && (b += ' on ' + a.typeCondition.name.value),
            a.directives && a.directives.length && (b += ' ' + iO(a.directives, ' ', iQ.Directive)),
            b + ' ' + iQ.SelectionSet(a.selectionSet)
          );
        },
        FragmentDefinition(a) {
          var b = '';
          return (
            a.description && (b += iQ.StringValue(a.description) + '\n'),
            (b += 'fragment ' + a.name.value + ' on ' + a.typeCondition.name.value),
            a.directives && a.directives.length && (b += ' ' + iO(a.directives, ' ', iQ.Directive)),
            b + ' ' + iQ.SelectionSet(a.selectionSet)
          );
        },
        Directive(a) {
          var b = '@' + a.name.value;
          return (
            a.arguments &&
              a.arguments.length &&
              (b += '(' + iO(a.arguments, ', ', iQ.Argument) + ')'),
            b
          );
        },
        NamedType: (a) => a.name.value,
        ListType: (a) => '[' + iR(a.type) + ']',
        NonNullType: (a) => iR(a.type) + '!',
      },
      iR = (a) => iQ[a.kind](a),
      iS = 0,
      iT = new Set();
    function iU() {
      function a(a, b) {
        var c,
          d,
          e = ((ac = a.body ? a.body : a),
          (ad = 0),
          iE(),
          {
            kind: 'Document',
            definitions: (function () {
              var a = [];
              do {
                var b = void 0;
                if ((34 === ac.charCodeAt(ad) && (b = iJ(!0)), 123 === ac.charCodeAt(ad))) {
                  if (b) throw iB('Document');
                  ad++,
                    iE(),
                    a.push({
                      kind: 'OperationDefinition',
                      operation: 'query',
                      name: void 0,
                      variableDefinitions: void 0,
                      directives: void 0,
                      selectionSet: iN(),
                    });
                } else {
                  var c = iF();
                  switch (c) {
                    case 'fragment':
                      a.push(
                        (function (a) {
                          var b = iG();
                          if (111 !== ac.charCodeAt(ad++) || 110 !== ac.charCodeAt(ad++))
                            throw iB('FragmentDefinition');
                          iE();
                          var c = {
                            kind: 'FragmentDefinition',
                            name: b,
                            typeCondition: { kind: 'NamedType', name: iG() },
                            directives: iL(!1),
                            selectionSet: iM(),
                          };
                          return a && (c.description = a), c;
                        })(b)
                      );
                      break;
                    case 'query':
                    case 'mutation':
                    case 'subscription':
                      var d,
                        e = void 0;
                      40 !== (d = ac.charCodeAt(ad)) && 64 !== d && 123 !== d && (e = iG());
                      var f = {
                        kind: 'OperationDefinition',
                        operation: c,
                        name: e,
                        variableDefinitions: (function () {
                          if ((iE(), 40 === ac.charCodeAt(ad))) {
                            var a = [];
                            ad++, iE();
                            do {
                              var b = void 0;
                              if (
                                (34 === ac.charCodeAt(ad) && (b = iJ(!0)),
                                36 !== ac.charCodeAt(ad++))
                              )
                                throw iB('Variable');
                              var c = iG();
                              if (58 !== ac.charCodeAt(ad++)) throw iB('VariableDefinition');
                              iE();
                              var d = (function () {
                                  for (var a = 0; 91 === ac.charCodeAt(ad); ) a++, ad++, iE();
                                  var b = { kind: 'NamedType', name: iG() };
                                  do
                                    if (
                                      (33 === ac.charCodeAt(ad) &&
                                        (ad++, iE(), (b = { kind: 'NonNullType', type: b })),
                                      a)
                                    ) {
                                      if (93 !== ac.charCodeAt(ad++)) throw iB('NamedType');
                                      iE(), (b = { kind: 'ListType', type: b });
                                    }
                                  while (a--);
                                  return b;
                                })(),
                                e = void 0;
                              61 === ac.charCodeAt(ad) && (ad++, iE(), (e = iJ(!0))), iE();
                              var f = {
                                kind: 'VariableDefinition',
                                variable: { kind: 'Variable', name: c },
                                type: d,
                                defaultValue: e,
                                directives: iL(!0),
                              };
                              b && (f.description = b), a.push(f);
                            } while (41 !== ac.charCodeAt(ad));
                            return ad++, iE(), a;
                          }
                        })(),
                        directives: iL(!1),
                        selectionSet: iM(),
                      };
                      b && (f.description = b), a.push(f);
                      break;
                    default:
                      throw iB('Document');
                  }
                }
              } while (ad < ac.length);
              return a;
            })(),
            loc: {
              start: 0,
              end: ac.length,
              startToken: void 0,
              endToken: void 0,
              source: { body: ac, name: 'graphql.web', locationOffset: { line: 1, column: 1 } },
            },
          }).definitions,
          f = new Set();
        for (var g of b || [])
          for (var h of g.definitions) h.kind !== iz || f.has(h) || (e.push(h), f.add(h));
        return (
          (c = e[0].kind === iz) &&
            e[0].directives &&
            (e[0].directives = e[0].directives.filter((a) => '_unmask' !== a.name.value)),
          {
            kind: iy,
            definitions: e,
            get loc() {
              if (!d && c) {
                var i =
                  a +
                  (function (a) {
                    try {
                      iS++;
                      var b = '';
                      for (var c of a)
                        if (!iT.has(c)) {
                          iT.add(c);
                          var { loc: d } = c;
                          d && (b += d.source.body);
                        }
                      return b;
                    } finally {
                      0 == --iS && iT.clear();
                    }
                  })(b || []);
                return {
                  start: 0,
                  end: i.length,
                  source: { body: i, name: 'GraphQLTada', locationOffset: { line: 1, column: 1 } },
                };
              }
              return d;
            },
            set loc(r) {
              d = r;
            },
          }
        );
      }
      return (
        (a.scalar = function (a, b) {
          return b;
        }),
        (a.persisted = function (a, b) {
          return { kind: iy, definitions: b ? b.definitions : [], documentId: a };
        }),
        a
      );
    }
    iU();
    let iV = iU();
    var iW = a.i(66680);
    let iX =
      iW && 'object' == typeof iW && 'webcrypto' in iW
        ? iW.webcrypto
        : iW && 'object' == typeof iW && 'randomBytes' in iW
        ? iW
        : void 0;
    function iY(a) {
      return (
        a instanceof Uint8Array || (ArrayBuffer.isView(a) && 'Uint8Array' === a.constructor.name)
      );
    }
    function iZ(a) {
      if (!Number.isSafeInteger(a) || a < 0) throw Error('positive integer expected, got ' + a);
    }
    function i$(a, ...b) {
      if (!iY(a)) throw Error('Uint8Array expected');
      if (b.length > 0 && !b.includes(a.length))
        throw Error('Uint8Array expected of length ' + b + ', got length=' + a.length);
    }
    function i_(a) {
      if ('function' != typeof a || 'function' != typeof a.create)
        throw Error('Hash should be wrapped by utils.createHasher');
      iZ(a.outputLen), iZ(a.blockLen);
    }
    function i0(a, b = !0) {
      if (a.destroyed) throw Error('Hash instance has been destroyed');
      if (b && a.finished) throw Error('Hash#digest() has already been called');
    }
    function i1(a, b) {
      i$(a);
      let c = b.outputLen;
      if (a.length < c) throw Error('digestInto() expects output buffer of length at least ' + c);
    }
    function i2(a) {
      return new Uint32Array(a.buffer, a.byteOffset, Math.floor(a.byteLength / 4));
    }
    function i3(...a) {
      for (let b = 0; b < a.length; b++) a[b].fill(0);
    }
    function i4(a) {
      return new DataView(a.buffer, a.byteOffset, a.byteLength);
    }
    function i5(a, b) {
      return (a << (32 - b)) | (a >>> b);
    }
    let i6 = 68 === new Uint8Array(new Uint32Array([0x11223344]).buffer)[0];
    function i7(a) {
      return (
        ((a << 24) & 0xff000000) | ((a << 8) & 0xff0000) | ((a >>> 8) & 65280) | ((a >>> 24) & 255)
      );
    }
    let i8 = i6 ? (a) => a : (a) => i7(a),
      i9 = i6
        ? (a) => a
        : function (a) {
            for (let b = 0; b < a.length; b++) a[b] = i7(a[b]);
            return a;
          },
      ja =
        'function' == typeof Uint8Array.from([]).toHex && 'function' == typeof Uint8Array.fromHex,
      jb = Array.from({ length: 256 }, (a, b) => b.toString(16).padStart(2, '0'));
    function jc(a) {
      if ((i$(a), ja)) return a.toHex();
      let b = '';
      for (let c = 0; c < a.length; c++) b += jb[a[c]];
      return b;
    }
    function jd(a) {
      return a >= 48 && a <= 57
        ? a - 48
        : a >= 65 && a <= 70
        ? a - 55
        : a >= 97 && a <= 102
        ? a - 87
        : void 0;
    }
    function je(a) {
      if ('string' != typeof a) throw Error('hex string expected, got ' + typeof a);
      if (ja) return Uint8Array.fromHex(a);
      let b = a.length,
        c = b / 2;
      if (b % 2) throw Error('hex string expected, got unpadded hex of length ' + b);
      let d = new Uint8Array(c);
      for (let b = 0, e = 0; b < c; b++, e += 2) {
        let c = jd(a.charCodeAt(e)),
          f = jd(a.charCodeAt(e + 1));
        if (void 0 === c || void 0 === f)
          throw Error(
            'hex string expected, got non-hex character "' + (a[e] + a[e + 1]) + '" at index ' + e
          );
        d[b] = 16 * c + f;
      }
      return d;
    }
    function jf(a) {
      if ('string' != typeof a) throw Error('string expected');
      return new Uint8Array(new TextEncoder().encode(a));
    }
    function jg(a) {
      return 'string' == typeof a && (a = jf(a)), i$(a), a;
    }
    function jh(a) {
      return 'string' == typeof a && (a = jf(a)), i$(a), a;
    }
    function ji(...a) {
      let b = 0;
      for (let c = 0; c < a.length; c++) {
        let d = a[c];
        i$(d), (b += d.length);
      }
      let c = new Uint8Array(b);
      for (let b = 0, d = 0; b < a.length; b++) {
        let e = a[b];
        c.set(e, d), (d += e.length);
      }
      return c;
    }
    class jj {}
    function jk(a) {
      let b = (b) => a().update(jg(b)).digest(),
        c = a();
      return (b.outputLen = c.outputLen), (b.blockLen = c.blockLen), (b.create = () => a()), b;
    }
    function jl(a = 32) {
      if (iX && 'function' == typeof iX.getRandomValues)
        return iX.getRandomValues(new Uint8Array(a));
      if (iX && 'function' == typeof iX.randomBytes) return Uint8Array.from(iX.randomBytes(a));
      throw Error('crypto.getRandomValues must be defined');
    }
    let jm = Uint8Array.from([
      0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2,
      11, 7, 5, 3, 11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4, 7, 9, 3, 1, 13, 12, 11, 14,
      2, 6, 5, 10, 4, 0, 15, 8, 9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13, 2, 12, 6, 10,
      0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9, 12, 5, 1, 15, 14, 13, 4, 10, 0, 7, 6, 3, 9, 2, 8, 11,
      13, 11, 7, 14, 12, 1, 3, 9, 5, 0, 15, 4, 8, 6, 2, 10, 6, 15, 14, 9, 11, 3, 0, 8, 12, 2, 13, 7,
      1, 4, 10, 5, 10, 2, 8, 4, 7, 6, 1, 5, 15, 11, 9, 14, 3, 12, 13, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8,
      9, 10, 11, 12, 13, 14, 15, 14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3, 11, 8, 12, 0,
      5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4, 7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8,
      9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13, 2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5,
      15, 14, 1, 9,
    ]);
    class jn extends jj {
      constructor(a, b, c, d) {
        super(),
          (this.finished = !1),
          (this.length = 0),
          (this.pos = 0),
          (this.destroyed = !1),
          (this.blockLen = a),
          (this.outputLen = b),
          (this.padOffset = c),
          (this.isLE = d),
          (this.buffer = new Uint8Array(a)),
          (this.view = i4(this.buffer));
      }
      update(a) {
        i0(this), i$((a = jg(a)));
        let { view: b, buffer: c, blockLen: d } = this,
          e = a.length;
        for (let f = 0; f < e; ) {
          let g = Math.min(d - this.pos, e - f);
          if (g === d) {
            let b = i4(a);
            for (; d <= e - f; f += d) this.process(b, f);
            continue;
          }
          c.set(a.subarray(f, f + g), this.pos),
            (this.pos += g),
            (f += g),
            this.pos === d && (this.process(b, 0), (this.pos = 0));
        }
        return (this.length += a.length), this.roundClean(), this;
      }
      digestInto(a) {
        i0(this), i1(a, this), (this.finished = !0);
        let { buffer: b, view: c, blockLen: d, isLE: e } = this,
          { pos: f } = this;
        (b[f++] = 128),
          i3(this.buffer.subarray(f)),
          this.padOffset > d - f && (this.process(c, 0), (f = 0));
        for (let a = f; a < d; a++) b[a] = 0;
        !(function (a, b, c, d) {
          if ('function' == typeof a.setBigUint64) return a.setBigUint64(b, c, d);
          let e = BigInt(32),
            f = BigInt(0xffffffff),
            g = Number((c >> e) & f),
            h = Number(c & f),
            i = 4 * !!d,
            j = 4 * !d;
          a.setUint32(b + i, g, d), a.setUint32(b + j, h, d);
        })(c, d - 8, BigInt(8 * this.length), e),
          this.process(c, 0);
        let g = i4(a),
          h = this.outputLen;
        if (h % 4) throw Error('_sha2: outputLen should be aligned to 32bit');
        let i = h / 4,
          j = this.get();
        if (i > j.length) throw Error('_sha2: outputLen bigger than state');
        for (let a = 0; a < i; a++) g.setUint32(4 * a, j[a], e);
      }
      digest() {
        let { buffer: a, outputLen: b } = this;
        this.digestInto(a);
        let c = a.slice(0, b);
        return this.destroy(), c;
      }
      _cloneInto(a) {
        a || (a = new this.constructor()), a.set(...this.get());
        let { blockLen: b, buffer: c, length: d, finished: e, destroyed: f, pos: g } = this;
        return (
          (a.destroyed = f),
          (a.finished = e),
          (a.length = d),
          (a.pos = g),
          d % b && a.buffer.set(c),
          a
        );
      }
      clone() {
        return this._cloneInto();
      }
    }
    let jo = Uint32Array.from([
        0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab,
        0x5be0cd19,
      ]),
      jp = Uint32Array.from([
        0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939, 0xffc00b31, 0x68581511, 0x64f98fa7,
        0xbefa4fa4,
      ]),
      jq = Uint32Array.from([
        0xcbbb9d5d, 0xc1059ed8, 0x629a292a, 0x367cd507, 0x9159015a, 0x3070dd17, 0x152fecd8,
        0xf70e5939, 0x67332667, 0xffc00b31, 0x8eb44a87, 0x68581511, 0xdb0c2e0d, 0x64f98fa7,
        0x47b5481d, 0xbefa4fa4,
      ]),
      jr = Uint32Array.from([
        0x6a09e667, 0xf3bcc908, 0xbb67ae85, 0x84caa73b, 0x3c6ef372, 0xfe94f82b, 0xa54ff53a,
        0x5f1d36f1, 0x510e527f, 0xade682d1, 0x9b05688c, 0x2b3e6c1f, 0x1f83d9ab, 0xfb41bd6b,
        0x5be0cd19, 0x137e2179,
      ]),
      js = BigInt(0x100000000 - 1),
      jt = BigInt(32);
    function ju(a, b = !1) {
      return b
        ? { h: Number(a & js), l: Number((a >> jt) & js) }
        : { h: 0 | Number((a >> jt) & js), l: 0 | Number(a & js) };
    }
    let jv = (a, b, c) => a >>> c,
      jw = (a, b, c) => (a << (32 - c)) | (b >>> c),
      jx = (a, b, c) => (a >>> c) | (b << (32 - c)),
      jy = (a, b, c) => (a << (32 - c)) | (b >>> c),
      jz = (a, b, c) => (a << (64 - c)) | (b >>> (c - 32)),
      jA = (a, b, c) => (a >>> (c - 32)) | (b << (64 - c));
    function jB(a, b, c, d) {
      let e = (b >>> 0) + (d >>> 0);
      return { h: (a + c + ((e / 0x100000000) | 0)) | 0, l: 0 | e };
    }
    let jC = (a, b, c) => (a >>> 0) + (b >>> 0) + (c >>> 0),
      jD = (a, b, c, d) => (b + c + d + ((a / 0x100000000) | 0)) | 0,
      jE = (a, b, c, d) => (a >>> 0) + (b >>> 0) + (c >>> 0) + (d >>> 0),
      jF = (a, b, c, d, e) => (b + c + d + e + ((a / 0x100000000) | 0)) | 0,
      jG = (a, b, c, d, e) => (a >>> 0) + (b >>> 0) + (c >>> 0) + (d >>> 0) + (e >>> 0),
      jH = (a, b, c, d, e, f) => (b + c + d + e + f + ((a / 0x100000000) | 0)) | 0,
      jI = Uint32Array.from([
        0xf3bcc908, 0x6a09e667, 0x84caa73b, 0xbb67ae85, 0xfe94f82b, 0x3c6ef372, 0x5f1d36f1,
        0xa54ff53a, 0xade682d1, 0x510e527f, 0x2b3e6c1f, 0x9b05688c, 0xfb41bd6b, 0x1f83d9ab,
        0x137e2179, 0x5be0cd19,
      ]),
      jJ = new Uint32Array(32);
    function jK(a, b, c, d, e, f) {
      let g = e[f],
        h = e[f + 1],
        i = jJ[2 * a],
        j = jJ[2 * a + 1],
        k = jJ[2 * b],
        l = jJ[2 * b + 1],
        m = jJ[2 * c],
        n = jJ[2 * c + 1],
        o = jJ[2 * d],
        p = jJ[2 * d + 1],
        q = jC(i, k, g);
      (j = jD(q, j, l, h)),
        (i = 0 | q),
        ({ Dh: p, Dl: o } = { Dh: p ^ j, Dl: o ^ i }),
        ({ Dh: p, Dl: o } = { Dh: o, Dl: p }),
        ({ h: n, l: m } = jB(n, m, p, o)),
        ({ Bh: l, Bl: k } = { Bh: l ^ n, Bl: k ^ m }),
        ({ Bh: l, Bl: k } = { Bh: jx(l, k, 24), Bl: jy(l, k, 24) }),
        (jJ[2 * a] = i),
        (jJ[2 * a + 1] = j),
        (jJ[2 * b] = k),
        (jJ[2 * b + 1] = l),
        (jJ[2 * c] = m),
        (jJ[2 * c + 1] = n),
        (jJ[2 * d] = o),
        (jJ[2 * d + 1] = p);
    }
    function jL(a, b, c, d, e, f) {
      let g = e[f],
        h = e[f + 1],
        i = jJ[2 * a],
        j = jJ[2 * a + 1],
        k = jJ[2 * b],
        l = jJ[2 * b + 1],
        m = jJ[2 * c],
        n = jJ[2 * c + 1],
        o = jJ[2 * d],
        p = jJ[2 * d + 1],
        q = jC(i, k, g);
      (j = jD(q, j, l, h)),
        (i = 0 | q),
        ({ Dh: p, Dl: o } = { Dh: p ^ j, Dl: o ^ i }),
        ({ Dh: p, Dl: o } = { Dh: jx(p, o, 16), Dl: jy(p, o, 16) }),
        ({ h: n, l: m } = jB(n, m, p, o)),
        ({ Bh: l, Bl: k } = { Bh: l ^ n, Bl: k ^ m }),
        ({ Bh: l, Bl: k } = { Bh: jz(l, k, 63), Bl: jA(l, k, 63) }),
        (jJ[2 * a] = i),
        (jJ[2 * a + 1] = j),
        (jJ[2 * b] = k),
        (jJ[2 * b + 1] = l),
        (jJ[2 * c] = m),
        (jJ[2 * c + 1] = n),
        (jJ[2 * d] = o),
        (jJ[2 * d + 1] = p);
    }
    function jM(a, b = {}, c, d, e) {
      if ((iZ(c), a < 0 || a > c)) throw Error('outputLen bigger than keyLen');
      let { key: f, salt: g, personalization: h } = b;
      if (void 0 !== f && (f.length < 1 || f.length > c))
        throw Error('key length must be undefined or 1..' + c);
      if (void 0 !== g && g.length !== d) throw Error('salt must be undefined or ' + d);
      if (void 0 !== h && h.length !== e) throw Error('personalization must be undefined or ' + e);
    }
    class jN extends jj {
      constructor(a, b) {
        super(),
          (this.finished = !1),
          (this.destroyed = !1),
          (this.length = 0),
          (this.pos = 0),
          iZ(a),
          iZ(b),
          (this.blockLen = a),
          (this.outputLen = b),
          (this.buffer = new Uint8Array(a)),
          (this.buffer32 = i2(this.buffer));
      }
      update(a) {
        i0(this), i$((a = jg(a)));
        let { blockLen: b, buffer: c, buffer32: d } = this,
          e = a.length,
          f = a.byteOffset,
          g = a.buffer;
        for (let h = 0; h < e; ) {
          this.pos === b && (i9(d), this.compress(d, 0, !1), i9(d), (this.pos = 0));
          let i = Math.min(b - this.pos, e - h),
            j = f + h;
          if (i === b && !(j % 4) && h + i < e) {
            let a = new Uint32Array(g, j, Math.floor((e - h) / 4));
            i9(a);
            for (let c = 0; h + b < e; c += d.length, h += b)
              (this.length += b), this.compress(a, c, !1);
            i9(a);
            continue;
          }
          c.set(a.subarray(h, h + i), this.pos), (this.pos += i), (this.length += i), (h += i);
        }
        return this;
      }
      digestInto(a) {
        i0(this), i1(a, this);
        let { pos: b, buffer32: c } = this;
        (this.finished = !0), i3(this.buffer.subarray(b)), i9(c), this.compress(c, 0, !0), i9(c);
        let d = i2(a);
        this.get().forEach((a, b) => (d[b] = i8(a)));
      }
      digest() {
        let { buffer: a, outputLen: b } = this;
        this.digestInto(a);
        let c = a.slice(0, b);
        return this.destroy(), c;
      }
      _cloneInto(a) {
        let { buffer: b, length: c, finished: d, destroyed: e, outputLen: f, pos: g } = this;
        return (
          a || (a = new this.constructor({ dkLen: f })),
          a.set(...this.get()),
          a.buffer.set(b),
          (a.destroyed = e),
          (a.finished = d),
          (a.length = c),
          (a.pos = g),
          (a.outputLen = f),
          a
        );
      }
      clone() {
        return this._cloneInto();
      }
    }
    class jO extends jN {
      constructor(a = {}) {
        const b = void 0 === a.dkLen ? 64 : a.dkLen;
        super(128, b),
          (this.v0l = 0 | jI[0]),
          (this.v0h = 0 | jI[1]),
          (this.v1l = 0 | jI[2]),
          (this.v1h = 0 | jI[3]),
          (this.v2l = 0 | jI[4]),
          (this.v2h = 0 | jI[5]),
          (this.v3l = 0 | jI[6]),
          (this.v3h = 0 | jI[7]),
          (this.v4l = 0 | jI[8]),
          (this.v4h = 0 | jI[9]),
          (this.v5l = 0 | jI[10]),
          (this.v5h = 0 | jI[11]),
          (this.v6l = 0 | jI[12]),
          (this.v6h = 0 | jI[13]),
          (this.v7l = 0 | jI[14]),
          (this.v7h = 0 | jI[15]),
          jM(b, a, 64, 16, 16);
        let { key: c, personalization: d, salt: e } = a,
          f = 0;
        if (
          (void 0 !== c && (f = (c = jg(c)).length),
          (this.v0l ^= this.outputLen | (f << 8) | 0x1010000),
          void 0 !== e)
        ) {
          const a = i2((e = jg(e)));
          (this.v4l ^= i8(a[0])),
            (this.v4h ^= i8(a[1])),
            (this.v5l ^= i8(a[2])),
            (this.v5h ^= i8(a[3]));
        }
        if (void 0 !== d) {
          const a = i2((d = jg(d)));
          (this.v6l ^= i8(a[0])),
            (this.v6h ^= i8(a[1])),
            (this.v7l ^= i8(a[2])),
            (this.v7h ^= i8(a[3]));
        }
        if (void 0 !== c) {
          const a = new Uint8Array(this.blockLen);
          a.set(c), this.update(a);
        }
      }
      get() {
        let {
          v0l: a,
          v0h: b,
          v1l: c,
          v1h: d,
          v2l: e,
          v2h: f,
          v3l: g,
          v3h: h,
          v4l: i,
          v4h: j,
          v5l: k,
          v5h: l,
          v6l: m,
          v6h: n,
          v7l: o,
          v7h: p,
        } = this;
        return [a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p];
      }
      set(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p) {
        (this.v0l = 0 | a),
          (this.v0h = 0 | b),
          (this.v1l = 0 | c),
          (this.v1h = 0 | d),
          (this.v2l = 0 | e),
          (this.v2h = 0 | f),
          (this.v3l = 0 | g),
          (this.v3h = 0 | h),
          (this.v4l = 0 | i),
          (this.v4h = 0 | j),
          (this.v5l = 0 | k),
          (this.v5h = 0 | l),
          (this.v6l = 0 | m),
          (this.v6h = 0 | n),
          (this.v7l = 0 | o),
          (this.v7h = 0 | p);
      }
      compress(a, b, c) {
        this.get().forEach((a, b) => (jJ[b] = a)), jJ.set(jI, 16);
        let { h: d, l: e } = ju(BigInt(this.length));
        (jJ[24] = jI[8] ^ e), (jJ[25] = jI[9] ^ d), c && ((jJ[28] = ~jJ[28]), (jJ[29] = ~jJ[29]));
        let f = 0;
        for (let c = 0; c < 12; c++)
          jK(0, 4, 8, 12, a, b + 2 * jm[f++]),
            jL(0, 4, 8, 12, a, b + 2 * jm[f++]),
            jK(1, 5, 9, 13, a, b + 2 * jm[f++]),
            jL(1, 5, 9, 13, a, b + 2 * jm[f++]),
            jK(2, 6, 10, 14, a, b + 2 * jm[f++]),
            jL(2, 6, 10, 14, a, b + 2 * jm[f++]),
            jK(3, 7, 11, 15, a, b + 2 * jm[f++]),
            jL(3, 7, 11, 15, a, b + 2 * jm[f++]),
            jK(0, 5, 10, 15, a, b + 2 * jm[f++]),
            jL(0, 5, 10, 15, a, b + 2 * jm[f++]),
            jK(1, 6, 11, 12, a, b + 2 * jm[f++]),
            jL(1, 6, 11, 12, a, b + 2 * jm[f++]),
            jK(2, 7, 8, 13, a, b + 2 * jm[f++]),
            jL(2, 7, 8, 13, a, b + 2 * jm[f++]),
            jK(3, 4, 9, 14, a, b + 2 * jm[f++]),
            jL(3, 4, 9, 14, a, b + 2 * jm[f++]);
        (this.v0l ^= jJ[0] ^ jJ[16]),
          (this.v0h ^= jJ[1] ^ jJ[17]),
          (this.v1l ^= jJ[2] ^ jJ[18]),
          (this.v1h ^= jJ[3] ^ jJ[19]),
          (this.v2l ^= jJ[4] ^ jJ[20]),
          (this.v2h ^= jJ[5] ^ jJ[21]),
          (this.v3l ^= jJ[6] ^ jJ[22]),
          (this.v3h ^= jJ[7] ^ jJ[23]),
          (this.v4l ^= jJ[8] ^ jJ[24]),
          (this.v4h ^= jJ[9] ^ jJ[25]),
          (this.v5l ^= jJ[10] ^ jJ[26]),
          (this.v5h ^= jJ[11] ^ jJ[27]),
          (this.v6l ^= jJ[12] ^ jJ[28]),
          (this.v6h ^= jJ[13] ^ jJ[29]),
          (this.v7l ^= jJ[14] ^ jJ[30]),
          (this.v7h ^= jJ[15] ^ jJ[31]),
          i3(jJ);
      }
      destroy() {
        (this.destroyed = !0),
          i3(this.buffer32),
          this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
      }
    }
    let jP =
        ((N = (a) => new jO(a)),
        ((q = (a, b) => N(b).update(jg(a)).digest()).outputLen = (s = N({})).outputLen),
        (q.blockLen = s.blockLen),
        (q.create = (a) => N(a)),
        q),
      jQ = ix.struct('DummyFieldObj', { dummy_field: ix.bool() }),
      jR = ix.struct('Name', { labels: ix.vector(ix.string()) }),
      jS = ix.struct('Range', { from: ix.u8(), to: ix.u8() }),
      jT = ix.struct('CouponRules', {
        length: ix.option(jS),
        available_claims: ix.option(ix.u64()),
        user: ix.option(ix.Address),
        expiration: ix.option(ix.u64()),
        years: ix.option(jS),
        can_stack: ix.bool(),
      }),
      jU = ix.struct('CouponHouse', {
        coupons: ix.struct('Coupons', {
          coupons: ix.struct('Table', {
            id: ix.struct('UID', { id: ix.struct('ID', { bytes: ix.Address }) }),
            size: ix.u64(),
          }),
        }),
        version: ix.u8(),
        id: ix.struct('UID', { id: ix.struct('ID', { bytes: ix.Address }) }),
      }),
      jV = ix.struct('Coupon', { kind: ix.u8(), amount: ix.u64(), rules: jT });
    BigInt('18446744073709551615');
    let jW = {
        devnet: {
          adminAddress: '0x1ca3c38e888493f869ac35346a2041d6cf87b0b935ebba14b35a08811d8a76e4',
          adminCap: '0x5a45ba086c2a873b5d6d34e8503e8ca8850588bf7f301285e279c8dab94eeb73',
          auctionPackageId: '0x79c8714ea294a92da04875c77ccabf8d1a06107e80d41c23d6777d5b1e6724a5',
          auctionHouseObjectId:
            '0xc922c77a1d4f4e699aa912a7c24aee4668f8975d2a5f01ba780f656289bf2c2c',
          coins: {
            IOTA: {
              type: '0x0000000000000000000000000000000000000000000000000000000000000002::iota::IOTA',
              metadataId: '0xf7ceb0424ca93f77858c74aebda8bcd5ffe0f32b82ebcc38afb3ba643d03a5f8',
            },
          },
          iotaNamesObjectId: '0x07c59b37bd7d036bf78fa30561a2ab9f7a970837487656ec29466e817f879342',
          packageId: '0xb9d617f24c84826bf660a2f4031951678cc80c264aebc4413459fb2a95ada9ba',
          paymentsPackageId: '0x98b9b33b7c2347a8f4e8b8716fb4c7e6e1af846ec2ea063a47bba81ffe03b440',
          publisherId: '0xb9435d6c5f3a7bd85fa362b4b89262cf738d48774695e8e9955704ce0fd3526f',
          registryTableId: '0xe00b2f2400c33b4dbd3081c4dcf2e289d0544caba23a3d130b264bd756403c07',
          reverseRegistryTableId:
            '0x1c1da17843cc453ad4079b05ce55e103b7a8cdd4db6ab42dc367b47ed6d8994d',
          couponsPackageId: '0xf2d61106ef44216f03709276c4e79c78485080c6d8fbad8464b7a570b9f36470',
          subnamesPackageId: '0x1efbf928710d0d92635dacff4c502516169d37fa006cabd2f3cdd0123221e09e',
          tempSubnameProxyPackageId:
            '0x4a16b7b2a9c194989519c87ee3f1d1007ece8aecb62b9a50a4c10075db0591a3',
          upgradeCap: '0xd64205c4b10eff4b4adb00ab6f754cda8d8e7525985a31307f7e232481dfaf6e',
        },
        testnet: {
          adminAddress: '0x548474360f9769077ccf07ff6e65060eb448470eabc1ae42b9ed371ddbfc23d2',
          adminCap: '0x541b117cac18fb1c07a293db300acd12b05c01fa81232b37151b005ca7d4f755',
          auctionPackageId: '0x6f727ea576a00036657fff0ae3a6d7c8171b178bf35112d6b83b2a6272cc5f0d',
          auctionHouseObjectId:
            '0x2292ea885039babe8c320f19e0b7546ebdef2b2f6cf2be600bf994cdb51e0050',
          coins: {
            IOTA: {
              type: '0x0000000000000000000000000000000000000000000000000000000000000002::iota::IOTA',
              metadataId: '0x6dcda050874e2f160a008afc9e3ca6304a667cc85045e35f25b3c7967282b153',
            },
          },
          iotaNamesObjectId: '0x7cab491740d51e0d75b26bf9984e49ba2e32a2d0694cabcee605543ed13c7dec',
          packageId: '0x7fff6e95f385349bec98d17121ab2bfa3e134f2f0b1ccefc270313415f7835ea',
          paymentsPackageId: '0x6b1b01f4c72786a893191d5c6e73d3012f7529f86fdee3bc8c163323cee08441',
          publisherId: '0x42faed18f40323158fb9b0f38630800addc2e9eea696265756769fc1f0e08ceb',
          registryTableId: '0x2dfc6f6d46ba55217425643a59dc85fe4d8ed273a9f74077bd0ee280dbb4f590',
          reverseRegistryTableId:
            '0x3550bcacb793ef8b776264665e7c99fa3d897695ed664656aac693cf9cf9b76b',
          couponsPackageId: '0xa7e4e483d79c245470d5eb3c285a4503a78d90a69d36e35e0993012f5c6137ca',
          subnamesPackageId: '0xd06a5607cc762f2352eeeb8c86c7f962558a06c6023c1eec031a41651d898c87',
          tempSubnameProxyPackageId:
            '0x7f34c135e55e5b436b3feaad369eabfe5b6d14c0c57544fefb6921db047e8cbc',
          upgradeCap: '0x03ac547ee58c268a69b5663a1fdee0e8202206922968d2a387104730627d188e',
        },
      },
      jX = /(?!-)[a-z0-9-]{0,62}[a-z0-9]/,
      jY = RegExp(`(?:${jX.source}(?:\\.${jX.source})*)`),
      jZ = RegExp(`^(${jY.source})?@${jX.source}$`),
      j$ = RegExp(`^(?:${jX.source}\\.)+(iota)$`);
    function j_(a) {
      return !(a.length > 235) && (jZ.test(a) || j$.test(a));
    }
    function j0(
      a,
      b = 'at',
      { onlyFirstSubname: c, truncateLongParts: d, ellipsisForDeepSubnames: e = !0 === c } = {}
    ) {
      let f,
        g = a.toLowerCase();
      if (jZ.test(g)) {
        let [a, b] = g.split('@');
        f = [...(a ? a.split('.') : []), b];
      } else if (j$.test(g)) f = g.split('.').slice(0, -1);
      else throw Error(`Invalid IOTA name "${a}"`);
      let h =
          c && f.length >= 2
            ? [f[0], e && f.length > 2 ? ('dot' === b ? '.' : '..') : ''].filter(Boolean)
            : f.slice(0, -1),
        i = f[f.length - 1];
      return (d &&
        ((h = h.map((a) => (a.length > 11 ? `${a.slice(0, 6)}...${a.slice(-6)}` : a))),
        (i = i.length > 11 ? `${i.slice(0, 6)}...${i.slice(-6)}` : i)),
      'dot' === b)
        ? `${[...h, i].join('.')}.iota`
        : `${h.join('.')}@${i}`;
    }
    function j1(a, b) {
      return `${a}::iota_names::ConfigKey<${b}>`;
    }
    class j2 {
      constructor(a) {
        (this.graphQlClient = a.graphQlClient),
          'network' in a ? (this.config = jW[a.network]) : (this.config = a.packageInfo);
      }
      async getCoreConfig() {
        var a;
        if (!this.config.iotaNamesObjectId) throw Error('IotaNames object ID is not set');
        if (!this.config.packageId) throw Error('IotaNames package ID is not set');
        let b = hh(jQ.serialize({ dummy_field: !1 }).toBytes()),
          c = await this.graphQlClient.query({
            query: iV(`
                query getCoreConfig($parentId: IotaAddress!, $name: DynamicFieldName!) {
                    owner(address: $parentId) {
                        address
                        dynamicField(name: $name) {
                            value {
                                ... on MoveValue {
                                    json
                                }
                            }
                        }
                    }
                }
            `),
            variables: {
              parentId: this.config.iotaNamesObjectId,
              name: {
                type: j1(
                  this.config.packageId,
                  ((a = this.config.packageId), `${a}::core_config::CoreConfig`)
                ),
                bcs: b,
              },
            },
          }),
          d = c?.data?.owner?.dynamicField?.value?.json;
        if (!d) throw Error('Core config not found or is invalid');
        return d;
      }
      async getPriceList() {
        var a;
        if (!this.config.iotaNamesObjectId) throw Error('IotaNames object ID is not set');
        if (!this.config.packageId) throw Error('IotaNames package ID is not set');
        let b = hh(jQ.serialize({ dummy_field: !1 }).toBytes()),
          c = await this.graphQlClient.query({
            query: iV(`
                query getPriceList($parentId: IotaAddress!, $name: DynamicFieldName!) {
                    owner(address: $parentId) {
                        address
                        dynamicField(name: $name) {
                            value {
                                ... on MoveValue {
                                    json
                                }
                            }
                        }
                    }
                }
            `),
            variables: {
              parentId: this.config.iotaNamesObjectId,
              name: {
                type: j1(
                  this.config.packageId,
                  ((a = this.config.packageId), `${a}::pricing_config::PricingConfig`)
                ),
                bcs: b,
              },
            },
          }),
          d = c?.data?.owner?.dynamicField?.value?.json?.pricing,
          e = d?.contents;
        if (!e) throw Error('Price list not found or content is invalid');
        let f = new Map();
        for (let a of e) {
          let { pos0: b, pos1: c } = a.key,
            d = [Number(b), Number(c)],
            e = Number(a.value);
          f.set(d, e);
        }
        return f;
      }
      async getRenewalPriceList() {
        var a;
        if (!this.config.iotaNamesObjectId) throw Error('IotaNames object ID is not set');
        if (!this.config.packageId) throw Error('IotaNames package ID is not set');
        let b = hh(jQ.serialize({ dummy_field: !1 }).toBytes()),
          c = await this.graphQlClient.query({
            query: iV(`
                query getRenewalPriceList($parentId: IotaAddress!, $name: DynamicFieldName!) {
                    owner(address: $parentId) {
                        address
                        dynamicField(name: $name) {
                            value {
                                ... on MoveValue {
                                    json
                                }
                            }
                        }
                    }
                }
            `),
            variables: {
              parentId: this.config.iotaNamesObjectId,
              name: {
                type: j1(
                  this.config.packageId,
                  ((a = this.config.packageId), `${a}::pricing_config::RenewalConfig`)
                ),
                bcs: b,
              },
            },
          }),
          d = c?.data?.owner?.dynamicField?.value?.json?.config?.pricing,
          e = d?.contents;
        if (!e) throw Error('Price list not found or content is invalid');
        let f = new Map();
        for (let a of e) {
          let { pos0: b, pos1: c } = a.key,
            d = [Number(b), Number(c)],
            e = Number(a.value);
          f.set(d, e);
        }
        return f;
      }
      async getDefaultName(a) {
        let b = await this.graphQlClient.query({
          query: iV(`
                query resolveNameServiceName($address: IotaAddress!, $nameFormat: NameFormat) {
                    address(address: $address) {
                        iotaNamesDefaultName(format: $nameFormat)
                    }
                }
            `),
          variables: { address: a },
        });
        return b?.data?.address?.iotaNamesDefaultName ?? null;
      }
      async getNameRecord(a) {
        var b;
        if (!j_(a)) throw Error('Invalid IOTA name');
        if (!this.config.registryTableId) throw Error('IotaNames package ID is not set');
        let c = hh(jR.serialize({ labels: j0(a, 'dot').split('.').reverse() }).toBytes()),
          d = await this.graphQlClient.query({
            query: iV(`
                query getNameRecord($parentId: IotaAddress!, $name: DynamicFieldName!) {
                    owner(address: $parentId) {
                        address
                        dynamicField(name: $name) {
                            value {
                                ... on MoveValue {
                                    json
                                }
                            }
                        }
                    }
                }
            `),
            variables: {
              parentId: this.config.registryTableId,
              name: { type: ((b = this.config.packageId), `${b}::name::Name`), bcs: c },
            },
          }),
          e = d.data?.owner?.dynamicField?.value?.json;
        if (!e) return null;
        let f = e.data?.contents;
        if (e.error || !f) throw Error('Name record not found. This name is not registered.');
        let g = {};
        return (
          f &&
            f.forEach((a) => {
              a.key && (g[a.key] = a.value);
            }),
          {
            name: a,
            nftId: e?.nft_id,
            targetAddress: e?.target_address,
            expirationTimestampMs: Number(e?.expiration_timestamp_ms),
            data: g,
            avatar: g.avatar,
          }
        );
      }
      async getCouponHouse() {
        if (!this.config.iotaNamesObjectId) throw Error('IotaNames object ID is not set');
        if (!this.config.packageId) throw Error('IotaNames package ID is not set');
        if (!this.config.couponsPackageId) throw Error('Coupon package ID is not set');
        let a = this.config.iotaNamesObjectId,
          b = this.config.packageId,
          c = this.config.couponsPackageId,
          d = jQ.serialize({ dummy_field: !1 }).toBase64(),
          e = await this.graphQlClient.query({
            query: iV(`
                query getIotaNamesCouponHouseRegistryKey(
                    $parentId: IotaAddress!
                    $name: DynamicFieldName!
                ) {
                    owner(address: $parentId) {
                        dynamicField(name: $name) {
                            value {
                                ... on MoveValue {
                                    bcs
                                }
                            }
                        }
                    }
                }
            `),
            variables: {
              parentId: a,
              name: {
                type: `${b}::iota_names::RegistryKey<${c}::coupon_house::CouponHouse>`,
                bcs: d,
              },
            },
          }),
          f = e?.data?.owner?.dynamicField?.value?.bcs;
        if (!f) throw Error('Coupon house not found or is invalid');
        return jU.parse(hg(f));
      }
      async resolveCoupon(a) {
        let b = await this.getCouponHouse(),
          c = b?.coupons?.coupons?.id.id.bytes;
        if (!c) throw Error('Coupons table ID not found in the coupon house');
        let d = je(jc(jP(a, { dkLen: 32 }))),
          e = ix.vector(ix.u8()).serialize(d).toBase64(),
          f = await this.graphQlClient.query({
            query: iV(`
                query getCouponBcs($parentId: IotaAddress!, $name: DynamicFieldName!) {
                    owner(address: $parentId) {
                        dynamicField(name: $name) {
                            value {
                                ... on MoveValue {
                                    bcs
                                }
                            }
                        }
                    }
                }
            `),
            variables: { parentId: c, name: { type: 'vector<u8>', bcs: e } },
          }),
          g = f?.data?.owner?.dynamicField?.value?.bcs;
        return g ? { ...jV.parse(hg(g)), couponCode: a } : null;
      }
      async calculatePrice({ name: a, years: b, isRegistration: c = !0 }) {
        if (!j_(a)) throw Error('Invalid IOTA names');
        if (!(b > 0 && b < 6)) throw Error('Years must be between 1 and 5');
        if (j0(a, 'dot').split('.').length > 2)
          throw Error('Subnames do not have a registration fee');
        let d = j0(a, 'dot').split('.')[0].length,
          e = await this.getPriceList(),
          f = await this.getRenewalPriceList(),
          g = b,
          h = 0;
        if (c) {
          for (let [[a, b], c] of e.entries())
            if (d >= a && d <= b) {
              (h += c), (g -= 1);
              break;
            }
        }
        for (let [[a, b], c] of f.entries())
          if (d >= a && d <= b) {
            h += g * c;
            break;
          }
        return h;
      }
      async calculateDiscountedPrice({
        coupons: a,
        name: b,
        years: c,
        isRegistration: d = !0,
        address: e,
      }) {
        if (a.every((a) => 'string' == typeof a)) {
          let b = a.map(async (a) => {
            let b = await this.resolveCoupon(a);
            if (!b) throw Error(`Coupon not found: ${a}`);
            return b;
          });
          a = await Promise.all(b);
        }
        let f = j0(b, 'dot');
        !(function (a, b = 3, c = 64, d = !0) {
          if (!a) return;
          let e = a.toLowerCase().split('.');
          if (d || !(e.length > 2)) {
            for (let a of e.slice(0, -1))
              if (a.length < b || a.length > c) return `Name must be ${b}-${c} characters long`;
            j$.test(a);
          }
        })(f);
        let g = f.split('.')[0];
        var h = a,
          i = c,
          j = g.length,
          k = e;
        for (let a of h) {
          if (!a.rules.can_stack && h.length > 1)
            throw Error(
              `Coupon '${a.couponCode}' validation failed: Coupon cannot be used with other coupons.`
            );
          try {
            (function (a) {
              if (
                a?.available_claims !== null &&
                a?.available_claims !== void 0 &&
                0 >= parseInt(a?.available_claims)
              )
                throw Error('Number of claims cannot be zero.');
            })(a.rules),
              (function (a, b) {
                let { from: c, to: d } = a.years || {};
                if (c && d && (b < c || b > d))
                  throw Error('Coupon is not valid for the given number of years.');
              })(a.rules, i),
              0 === a.kind &&
                (function (a) {
                  if (0 >= parseInt(a) || parseInt(a) > 100)
                    throw Error('Invalid percentage amount for coupon.');
                })(a.amount),
              (function (a, b) {
                let { from: c, to: d } = a.length || {};
                if (c && d && (b < c || b > d))
                  throw Error('Coupon is not valid for the given name length.');
              })(a.rules, j),
              (function (a, b) {
                if (a.user && a.user !== b) throw Error('Coupon address does not match.');
              })(a.rules, k),
              (function (a, b = Date.now().toString()) {
                if (a.expiration && Number(b) > Number(a.expiration))
                  throw Error('Coupon has expired.');
              })(a.rules);
          } catch (b) {
            throw Error(`Coupon '${a.couponCode}' validation failed: ${b?.message}`);
          }
        }
        let l = await this.calculatePrice({ name: b, years: c, isRegistration: d });
        var m = a;
        if (!m || 0 === m.length) return l;
        let n = l;
        for (let a of m) {
          if (!a.rules.can_stack && m.length > 1) throw Error('Coupons provided cannot be stacked');
          n = (function (a, b) {
            if (!b) return a;
            let c = Number(b.amount);
            if (0 === b.kind) return a - (a * c) / 100;
            if (1 === b.kind) {
              let b = a - c;
              return b < 0 ? 0 : b;
            }
            throw Error(`Unknown coupon kind: ${b.kind}`);
          })(n, a);
        }
        return n;
      }
    }
    function j3(a) {
      let b = [],
        c = 0;
      if (0 === a) return [0];
      for (; a > 0; ) (b[c] = 127 & a), (a >>= 7) && (b[c] |= 128), (c += 1);
      return b;
    }
    class j4 {
      constructor(a) {
        (this.bytePosition = 0),
          (this.dataView = new DataView(a.buffer, a.byteOffset, a.byteLength));
      }
      shift(a) {
        return (this.bytePosition += a), this;
      }
      read8() {
        let a = this.dataView.getUint8(this.bytePosition);
        return this.shift(1), a;
      }
      read16() {
        let a = this.dataView.getUint16(this.bytePosition, !0);
        return this.shift(2), a;
      }
      read32() {
        let a = this.dataView.getUint32(this.bytePosition, !0);
        return this.shift(4), a;
      }
      read64() {
        let a = this.read32();
        return BigInt(
          '0x' + (this.read32().toString(16) + a.toString(16).padStart(8, '0'))
        ).toString(10);
      }
      read128() {
        let a = BigInt(this.read64());
        return BigInt(
          '0x' + (BigInt(this.read64()).toString(16) + a.toString(16).padStart(16, '0'))
        ).toString(10);
      }
      read256() {
        let a = BigInt(this.read128());
        return BigInt(
          '0x' + (BigInt(this.read128()).toString(16) + a.toString(16).padStart(32, '0'))
        ).toString(10);
      }
      readBytes(a) {
        let b = this.bytePosition + this.dataView.byteOffset,
          c = new Uint8Array(this.dataView.buffer, b, a);
        return this.shift(a), c;
      }
      readULEB() {
        let a = this.bytePosition + this.dataView.byteOffset,
          { value: b, length: c } = (function (a) {
            let b = 0,
              c = 0,
              d = 0;
            for (;;) {
              let e = a[d];
              if (((d += 1), (b |= (127 & e) << c), (128 & e) == 0)) break;
              c += 7;
            }
            return { value: b, length: d };
          })(new Uint8Array(this.dataView.buffer, a));
        return this.shift(c), b;
      }
      readVec(a) {
        let b = this.readULEB(),
          c = [];
        for (let d = 0; d < b; d++) c.push(a(this, d, b));
        return c;
      }
    }
    class j5 {
      constructor({ initialSize: a = 1024, maxSize: b = 1 / 0, allocateSize: c = 1024 } = {}) {
        (this.bytePosition = 0),
          (this.size = a),
          (this.maxSize = b),
          (this.allocateSize = c),
          (this.dataView = new DataView(new ArrayBuffer(a)));
      }
      ensureSizeOrGrow(a) {
        let b = this.bytePosition + a;
        if (b > this.size) {
          let a = Math.min(this.maxSize, this.size + this.allocateSize);
          if (b > a)
            throw Error(
              `SizeLimitExceeded: Attempting to serialize to BCS, but buffer does not have enough size. Allocated size: ${this.size}, Max size: ${this.maxSize}, Required size: ${b}`
            );
          this.size = a;
          let c = new ArrayBuffer(this.size);
          new Uint8Array(c).set(new Uint8Array(this.dataView.buffer)),
            (this.dataView = new DataView(c));
        }
      }
      shift(a) {
        return (this.bytePosition += a), this;
      }
      write8(a) {
        return (
          this.ensureSizeOrGrow(1),
          this.dataView.setUint8(this.bytePosition, Number(a)),
          this.shift(1)
        );
      }
      write16(a) {
        return (
          this.ensureSizeOrGrow(2),
          this.dataView.setUint16(this.bytePosition, Number(a), !0),
          this.shift(2)
        );
      }
      write32(a) {
        return (
          this.ensureSizeOrGrow(4),
          this.dataView.setUint32(this.bytePosition, Number(a), !0),
          this.shift(4)
        );
      }
      write64(a) {
        return j6(BigInt(a), 8).forEach((a) => this.write8(a)), this;
      }
      write128(a) {
        return j6(BigInt(a), 16).forEach((a) => this.write8(a)), this;
      }
      write256(a) {
        return j6(BigInt(a), 32).forEach((a) => this.write8(a)), this;
      }
      writeULEB(a) {
        return j3(a).forEach((a) => this.write8(a)), this;
      }
      writeVec(a, b) {
        return (
          this.writeULEB(a.length), Array.from(a).forEach((c, d) => b(this, c, d, a.length)), this
        );
      }
      *[Symbol.iterator]() {
        for (let a = 0; a < this.bytePosition; a++) yield this.dataView.getUint8(a);
        return this.toBytes();
      }
      toBytes() {
        return new Uint8Array(this.dataView.buffer.slice(0, this.bytePosition));
      }
      toString(a) {
        var b = this.toBytes();
        switch (a) {
          case 'base58':
            return dS.encode(b);
          case 'base64':
            return dU(b);
          case 'hex':
            return dW(b);
          default:
            throw Error('Unsupported encoding, supported values are: base64, hex');
        }
      }
    }
    function j6(a, b) {
      let c = new Uint8Array(b),
        d = 0;
      for (; a > 0; ) (c[d] = Number(a % BigInt(256))), (a /= BigInt(256)), (d += 1);
      return c;
    }
    var j7 = (a) => {
        throw TypeError(a);
      },
      j8 = (a, b, c) => b.has(a) || j7('Cannot ' + c),
      j9 = (a, b, c) => (j8(a, b, 'read from private field'), c ? c.call(a) : b.get(a)),
      ka = (a, b, c) =>
        b.has(a)
          ? j7('Cannot add the same private member more than once')
          : b instanceof WeakSet
          ? b.add(a)
          : b.set(a, c),
      kb = (a, b, c, d) => (j8(a, b, 'write to private field'), d ? d.call(a, c) : b.set(a, c), c);
    let kc = class a {
      constructor(a) {
        ka(this, ae),
          ka(this, af),
          (this.name = a.name),
          (this.read = a.read),
          (this.serializedSize = a.serializedSize ?? (() => null)),
          kb(this, ae, a.write),
          kb(
            this,
            af,
            a.serialize ??
              ((a, b) => {
                let c = new j5({ initialSize: this.serializedSize(a) ?? void 0, ...b });
                return j9(this, ae).call(this, a, c), c.toBytes();
              })
          ),
          (this.validate = a.validate ?? (() => {}));
      }
      write(a, b) {
        this.validate(a), j9(this, ae).call(this, a, b);
      }
      serialize(a, b) {
        return this.validate(a), new kf(this, j9(this, af).call(this, a, b));
      }
      parse(a) {
        let b = new j4(a);
        return this.read(b);
      }
      fromHex(a) {
        return this.parse(dV(a));
      }
      fromBase58(a) {
        let b;
        return this.parse(((b = a), dS.decode(b)));
      }
      fromBase64(a) {
        return this.parse(dT(a));
      }
      transform({ name: b, input: c, output: d, validate: e }) {
        return new a({
          name: b ?? this.name,
          read: (a) => (d ? d(this.read(a)) : this.read(a)),
          write: (a, b) => j9(this, ae).call(this, c ? c(a) : a, b),
          serializedSize: (a) => this.serializedSize(c ? c(a) : a),
          serialize: (a, b) => j9(this, af).call(this, c ? c(a) : a, b),
          validate: (a) => {
            e?.(a), this.validate(c ? c(a) : a);
          },
        });
      }
    };
    (ae = new WeakMap()), (af = new WeakMap());
    let kd = Symbol.for('@iota/serialized-bcs');
    function ke(a) {
      return !!a && 'object' == typeof a && !0 === a[kd];
    }
    class kf {
      constructor(a, b) {
        ka(this, ag), ka(this, ah), kb(this, ag, a), kb(this, ah, b);
      }
      get [kd]() {
        return !0;
      }
      toBytes() {
        return j9(this, ah);
      }
      toHex() {
        return dW(j9(this, ah));
      }
      toBase64() {
        return dU(j9(this, ah));
      }
      toBase58() {
        let a;
        return (a = j9(this, ah)), dS.encode(a);
      }
      parse() {
        return j9(this, ag).parse(j9(this, ah));
      }
    }
    function kg({ size: a, ...b }) {
      return new kc({ ...b, serializedSize: () => a });
    }
    function kh({ readMethod: a, writeMethod: b, ...c }) {
      return kg({
        ...c,
        read: (b) => b[a](),
        write: (a, c) => c[b](a),
        validate: (a) => {
          if (a < 0 || a > c.maxValue)
            throw TypeError(
              `Invalid ${c.name} value: ${a}. Expected value in range 0-${c.maxValue}`
            );
          c.validate?.(a);
        },
      });
    }
    function ki({ readMethod: a, writeMethod: b, ...c }) {
      return kg({
        ...c,
        read: (b) => b[a](),
        write: (a, c) => c[b](BigInt(a)),
        validate: (a) => {
          let b = BigInt(a);
          if (b < 0 || b > c.maxValue)
            throw TypeError(
              `Invalid ${c.name} value: ${b}. Expected value in range 0-${c.maxValue}`
            );
          c.validate?.(b);
        },
      });
    }
    function kj(a) {
      let b = typeof a;
      return 'string' === b
        ? `"${a}"`
        : 'number' === b || 'bigint' === b || 'boolean' === b
        ? `${a}`
        : 'object' === b || 'function' === b
        ? (a && Object.getPrototypeOf(a)?.constructor?.name) ?? 'null'
        : b;
    }
    function kk(a, b, c, d, e) {
      var f, g, h, i;
      let j = e && 'input' in e ? e.input : c.value,
        k = e?.expected ?? a.expects ?? null,
        l = e?.received ?? kj(j),
        m = {
          kind: a.kind,
          type: a.type,
          input: j,
          expected: k,
          received: l,
          message: `Invalid ${b}: ${k ? `Expected ${k} but r` : 'R'}eceived ${l}`,
          requirement: a.requirement,
          path: e?.path,
          issues: e?.issues,
          lang: d.lang,
          abortEarly: d.abortEarly,
          abortPipeEarly: d.abortPipeEarly,
        },
        n = 'schema' === a.kind,
        o =
          e?.message ??
          a.message ??
          ((f = a.reference), (g = m.lang), al?.get(f)?.get(g)) ??
          (n ? ((h = m.lang), ak?.get(h)) : null) ??
          d.message ??
          ((i = m.lang), aj?.get(i));
      o && (m.message = 'function' == typeof o ? o(m) : o),
        n && (c.typed = !1),
        c.issues ? c.issues.push(m) : (c.issues = [m]);
    }
    (ag = new WeakMap()), (ah = new WeakMap());
    var kl = class extends Error {
      issues;
      constructor(a) {
        super(a[0].message), (this.name = 'ValiError'), (this.issues = a);
      }
    };
    function km(a, b) {
      return {
        kind: 'validation',
        type: 'check',
        reference: km,
        async: !1,
        expects: null,
        requirement: a,
        message: b,
        _run(a, b) {
          return a.typed && !this.requirement(a.value) && kk(this, 'input', a, b), a;
        },
      };
    }
    function kn(a) {
      return {
        kind: 'validation',
        type: 'integer',
        reference: kn,
        async: !1,
        expects: null,
        requirement: Number.isInteger,
        message: a,
        _run(a, b) {
          return a.typed && !this.requirement(a.value) && kk(this, 'integer', a, b), a;
        },
      };
    }
    function ko(a) {
      return {
        kind: 'transformation',
        type: 'transform',
        reference: ko,
        async: !1,
        operation: a,
        _run(a) {
          return (a.value = this.operation(a.value)), a;
        },
      };
    }
    function kp(a, b, c) {
      return 'function' == typeof a.default ? a.default(b, c) : a.default;
    }
    function kq(a, b) {
      return !a._run({ typed: !1, value: b }, { abortEarly: !0 }).issues;
    }
    function kr(a, b) {
      return {
        kind: 'schema',
        type: 'array',
        reference: kr,
        expects: 'Array',
        async: !1,
        item: a,
        message: b,
        _run(a, b) {
          let c = a.value;
          if (Array.isArray(c)) {
            (a.typed = !0), (a.value = []);
            for (let d = 0; d < c.length; d++) {
              let e = c[d],
                f = this.item._run({ typed: !1, value: e }, b);
              if (f.issues) {
                let g = { type: 'array', origin: 'value', input: c, key: d, value: e };
                for (let b of f.issues)
                  b.path ? b.path.unshift(g) : (b.path = [g]), a.issues?.push(b);
                if ((a.issues || (a.issues = f.issues), b.abortEarly)) {
                  a.typed = !1;
                  break;
                }
              }
              f.typed || (a.typed = !1), a.value.push(f.value);
            }
          } else kk(this, 'type', a, b);
          return a;
        },
      };
    }
    function ks(a) {
      return {
        kind: 'schema',
        type: 'bigint',
        reference: ks,
        expects: 'bigint',
        async: !1,
        message: a,
        _run(a, b) {
          return 'bigint' == typeof a.value ? (a.typed = !0) : kk(this, 'type', a, b), a;
        },
      };
    }
    function kt(a) {
      return {
        kind: 'schema',
        type: 'boolean',
        reference: kt,
        expects: 'boolean',
        async: !1,
        message: a,
        _run(a, b) {
          return 'boolean' == typeof a.value ? (a.typed = !0) : kk(this, 'type', a, b), a;
        },
      };
    }
    function ku(a) {
      return {
        kind: 'schema',
        type: 'lazy',
        reference: ku,
        expects: 'unknown',
        async: !1,
        getter: a,
        _run(a, b) {
          return this.getter(a.value)._run(a, b);
        },
      };
    }
    function kv(a, b) {
      return {
        kind: 'schema',
        type: 'literal',
        reference: kv,
        expects: kj(a),
        async: !1,
        literal: a,
        message: b,
        _run(a, b) {
          return a.value === this.literal ? (a.typed = !0) : kk(this, 'type', a, b), a;
        },
      };
    }
    function kw(a, ...b) {
      let c = {
        kind: 'schema',
        type: 'nullable',
        reference: kw,
        expects: `${a.expects} | null`,
        async: !1,
        wrapped: a,
        _run(a, b) {
          return null === a.value &&
            ('default' in this && (a.value = kp(this, a, b)), null === a.value)
            ? ((a.typed = !0), a)
            : this.wrapped._run(a, b);
        },
      };
      return 0 in b && (c.default = b[0]), c;
    }
    function kx(a, ...b) {
      let c = {
        kind: 'schema',
        type: 'nullish',
        reference: kx,
        expects: `${a.expects} | null | undefined`,
        async: !1,
        wrapped: a,
        _run(a, b) {
          return (null === a.value || void 0 === a.value) &&
            ('default' in this && (a.value = kp(this, a, b)),
            null === a.value || void 0 === a.value)
            ? ((a.typed = !0), a)
            : this.wrapped._run(a, b);
        },
      };
      return 0 in b && (c.default = b[0]), c;
    }
    function ky(a) {
      return {
        kind: 'schema',
        type: 'number',
        reference: ky,
        expects: 'number',
        async: !1,
        message: a,
        _run(a, b) {
          return (
            'number' != typeof a.value || isNaN(a.value) ? kk(this, 'type', a, b) : (a.typed = !0),
            a
          );
        },
      };
    }
    function kz(a, b) {
      return {
        kind: 'schema',
        type: 'object',
        reference: kz,
        expects: 'Object',
        async: !1,
        entries: a,
        message: b,
        _run(a, b) {
          let c = a.value;
          if (c && 'object' == typeof c)
            for (let d in ((a.typed = !0), (a.value = {}), this.entries)) {
              let e = c[d],
                f = this.entries[d]._run({ typed: !1, value: e }, b);
              if (f.issues) {
                let g = { type: 'object', origin: 'value', input: c, key: d, value: e };
                for (let b of f.issues)
                  b.path ? b.path.unshift(g) : (b.path = [g]), a.issues?.push(b);
                if ((a.issues || (a.issues = f.issues), b.abortEarly)) {
                  a.typed = !1;
                  break;
                }
              }
              f.typed || (a.typed = !1), (void 0 !== f.value || d in c) && (a.value[d] = f.value);
            }
          else kk(this, 'type', a, b);
          return a;
        },
      };
    }
    function kA(a, ...b) {
      let c = {
        kind: 'schema',
        type: 'optional',
        reference: kA,
        expects: `${a.expects} | undefined`,
        async: !1,
        wrapped: a,
        _run(a, b) {
          return void 0 === a.value &&
            ('default' in this && (a.value = kp(this, a, b)), void 0 === a.value)
            ? ((a.typed = !0), a)
            : this.wrapped._run(a, b);
        },
      };
      return 0 in b && (c.default = b[0]), c;
    }
    function kB(a, b, c) {
      return {
        kind: 'schema',
        type: 'record',
        reference: kB,
        expects: 'Object',
        async: !1,
        key: a,
        value: b,
        message: c,
        _run(a, b) {
          let c = a.value;
          if (c && 'object' == typeof c) {
            for (let d in ((a.typed = !0), (a.value = {}), c))
              if (
                Object.hasOwn(c, d) &&
                '__proto__' !== d &&
                'prototype' !== d &&
                'constructor' !== d
              ) {
                let e = c[d],
                  f = this.key._run({ typed: !1, value: d }, b);
                if (f.issues) {
                  let g = { type: 'object', origin: 'key', input: c, key: d, value: e };
                  for (let b of f.issues) (b.path = [g]), a.issues?.push(b);
                  if ((a.issues || (a.issues = f.issues), b.abortEarly)) {
                    a.typed = !1;
                    break;
                  }
                }
                let g = this.value._run({ typed: !1, value: e }, b);
                if (g.issues) {
                  let f = { type: 'object', origin: 'value', input: c, key: d, value: e };
                  for (let b of g.issues)
                    b.path ? b.path.unshift(f) : (b.path = [f]), a.issues?.push(b);
                  if ((a.issues || (a.issues = g.issues), b.abortEarly)) {
                    a.typed = !1;
                    break;
                  }
                }
                (f.typed && g.typed) || (a.typed = !1), f.typed && (a.value[f.value] = g.value);
              }
          } else kk(this, 'type', a, b);
          return a;
        },
      };
    }
    function kC(a) {
      return {
        kind: 'schema',
        type: 'string',
        reference: kC,
        expects: 'string',
        async: !1,
        message: a,
        _run(a, b) {
          return 'string' == typeof a.value ? (a.typed = !0) : kk(this, 'type', a, b), a;
        },
      };
    }
    function kD(a, b) {
      return {
        kind: 'schema',
        type: 'tuple',
        reference: kD,
        expects: 'Array',
        async: !1,
        items: a,
        message: b,
        _run(a, b) {
          let c = a.value;
          if (Array.isArray(c)) {
            (a.typed = !0), (a.value = []);
            for (let d = 0; d < this.items.length; d++) {
              let e = c[d],
                f = this.items[d]._run({ typed: !1, value: e }, b);
              if (f.issues) {
                let g = { type: 'array', origin: 'value', input: c, key: d, value: e };
                for (let b of f.issues)
                  b.path ? b.path.unshift(g) : (b.path = [g]), a.issues?.push(b);
                if ((a.issues || (a.issues = f.issues), b.abortEarly)) {
                  a.typed = !1;
                  break;
                }
              }
              f.typed || (a.typed = !1), a.value.push(f.value);
            }
          } else kk(this, 'type', a, b);
          return a;
        },
      };
    }
    function kE(a) {
      let b;
      if (a) for (let c of a) b ? b.push(...c.issues) : (b = c.issues);
      return b;
    }
    function kF(a, b) {
      return {
        kind: 'schema',
        type: 'union',
        reference: kF,
        expects: [...new Set(a.map((a) => a.expects))].join(' | ') || 'never',
        async: !1,
        options: a,
        message: b,
        _run(a, b) {
          let c, d, e;
          for (let f of this.options) {
            let g = f._run({ typed: !1, value: a.value }, b);
            if (g.typed)
              if (g.issues) d ? d.push(g) : (d = [g]);
              else {
                c = g;
                break;
              }
            else e ? e.push(g) : (e = [g]);
          }
          if (c) return c;
          if (d) {
            if (1 === d.length) return d[0];
            kk(this, 'type', a, b, { issues: kE(d) }), (a.typed = !0);
          } else {
            if (e?.length === 1) return e[0];
            kk(this, 'type', a, b, { issues: kE(e) });
          }
          return a;
        },
      };
    }
    function kG() {
      return {
        kind: 'schema',
        type: 'unknown',
        reference: kG,
        expects: 'unknown',
        async: !1,
        _run: (a) => ((a.typed = !0), a),
      };
    }
    function kH(a, b, c) {
      let d = a._run(
        { typed: !1, value: b },
        {
          lang: c?.lang ?? ai?.lang,
          message: c?.message,
          abortEarly: c?.abortEarly ?? ai?.abortEarly,
          abortPipeEarly: c?.abortPipeEarly ?? ai?.abortPipeEarly,
        }
      );
      if (d.issues) throw new kl(d.issues);
      return d.value;
    }
    function kI(...a) {
      return {
        ...a[0],
        pipe: a,
        _run(b, c) {
          for (let d = 0; d < a.length; d++) {
            if (b.issues && ('schema' === a[d].kind || 'transformation' === a[d].kind)) {
              b.typed = !1;
              break;
            }
            (b.issues && (c.abortEarly || c.abortPipeEarly)) || (b = a[d]._run(b, c));
          }
          return b;
        },
      };
    }
    function kJ(a) {
      return kI(
        kF(Object.entries(a).map(([a, b]) => kz({ [a]: b }))),
        ko((a) => ({ ...a, $kind: Object.keys(a)[0] }))
      );
    }
    a.s(
      [
        'array',
        () => kr,
        'bigint',
        () => ks,
        'boolean',
        () => kt,
        'check',
        () => km,
        'integer',
        () => kn,
        'is',
        () => kq,
        'lazy',
        () => ku,
        'literal',
        () => kv,
        'nullable',
        () => kw,
        'nullish',
        () => kx,
        'number',
        () => ky,
        'object',
        () => kz,
        'optional',
        () => kA,
        'parse',
        () => kH,
        'pipe',
        () => kI,
        'record',
        () => kB,
        'string',
        () => kC,
        'transform',
        () => ko,
        'tuple',
        () => kD,
        'union',
        () => kF,
        'unknown',
        () => kG,
      ],
      79716
    );
    let kK = kI(
        kC(),
        ko((a) => dZ(a)),
        km(dY)
      ),
      kL = kC(),
      kM = kI(
        kF([kC(), kI(ky(), kn())]),
        km((a) => {
          try {
            return BigInt(a), BigInt(a) >= 0 && 0xffffffffffffffffn >= BigInt(a);
          } catch {
            return !1;
          }
        }, 'Invalid u64')
      ),
      kN = kz({ objectId: kK, version: kM, digest: kC() }),
      kO = kI(
        kF([
          kz({ GasCoin: kv(!0) }),
          kz({ Input: kI(ky(), kn()), type: kA(kv('pure')) }),
          kz({ Input: kI(ky(), kn()), type: kA(kv('object')) }),
          kz({ Result: kI(ky(), kn()) }),
          kz({ NestedResult: kD([kI(ky(), kn()), kI(ky(), kn())]) }),
        ]),
        ko((a) => ({ ...a, $kind: Object.keys(a)[0] }))
      ),
      kP = kz({ budget: kw(kM), price: kw(kM), owner: kw(kK), payment: kw(kr(kN)) });
    kz({ address: kC(), module: kC(), name: kC(), typeParams: kr(kC()) });
    let kQ = kF([
        kv('address'),
        kv('bool'),
        kv('u8'),
        kv('u16'),
        kv('u32'),
        kv('u64'),
        kv('u128'),
        kv('u256'),
        kz({ vector: ku(() => kQ) }),
        kz({
          datatype: kz({
            package: kC(),
            module: kC(),
            type: kC(),
            typeParameters: kr(ku(() => kQ)),
          }),
        }),
        kz({ typeParameter: kI(ky(), kn()) }),
      ]),
      kR = kz({ ref: kw(kF([kv('&'), kv('&mut')])), body: kQ }),
      kS = kz({
        package: kK,
        module: kC(),
        function: kC(),
        typeArguments: kr(kC()),
        arguments: kr(kO),
        _argumentTypes: kA(kw(kr(kR))),
      }),
      kT = kz({ name: kC(), inputs: kB(kC(), kF([kO, kr(kO)])), data: kB(kC(), kG()) }),
      kU = kJ({
        MoveCall: kS,
        TransferObjects: kz({ objects: kr(kO), address: kO }),
        SplitCoins: kz({ coin: kO, amounts: kr(kO) }),
        MergeCoins: kz({ destination: kO, sources: kr(kO) }),
        Publish: kz({ modules: kr(kL), dependencies: kr(kK) }),
        MakeMoveVec: kz({ type: kw(kC()), elements: kr(kO) }),
        Upgrade: kz({ modules: kr(kL), dependencies: kr(kK), package: kK, ticket: kO }),
        $Intent: kT,
      }),
      kV = kJ({
        ImmOrOwnedObject: kN,
        SharedObject: kz({ objectId: kK, initialSharedVersion: kM, mutable: kt() }),
        Receiving: kN,
      }),
      kW = kJ({
        Object: kV,
        Pure: kz({ bytes: kL }),
        UnresolvedPure: kz({ value: kG() }),
        UnresolvedObject: kz({
          objectId: kK,
          version: kA(kw(kM)),
          digest: kA(kw(kC())),
          initialSharedVersion: kA(kw(kM)),
        }),
      }),
      kX = kJ({ Object: kV, Pure: kz({ bytes: kL }) }),
      kY = kJ({ None: kv(!0), Epoch: kM }),
      kZ = kz({
        version: kv(2),
        sender: kx(kK),
        expiration: kx(kY),
        gasData: kP,
        inputs: kr(kW),
        commands: kr(kU),
      });
    var k$ =
      (((O = k$ || {})[(O.COMPATIBLE = 0)] = 'COMPATIBLE'),
      (O[(O.ADDITIVE = 128)] = 'ADDITIVE'),
      (O[(O.DEP_ONLY = 192)] = 'DEP_ONLY'),
      O);
    let k_ = {
        MoveCall(a) {
          let [b, c = '', d = ''] =
            'target' in a ? a.target.split('::') : [a.package, a.module, a.function];
          return {
            $kind: 'MoveCall',
            MoveCall: {
              package: b,
              module: c,
              function: d,
              typeArguments: a.typeArguments ?? [],
              arguments: a.arguments ?? [],
            },
          };
        },
        TransferObjects: (a, b) => ({
          $kind: 'TransferObjects',
          TransferObjects: { objects: a.map((a) => kH(kO, a)), address: kH(kO, b) },
        }),
        SplitCoins: (a, b) => ({
          $kind: 'SplitCoins',
          SplitCoins: { coin: kH(kO, a), amounts: b.map((a) => kH(kO, a)) },
        }),
        MergeCoins: (a, b) => ({
          $kind: 'MergeCoins',
          MergeCoins: { destination: kH(kO, a), sources: b.map((a) => kH(kO, a)) },
        }),
        Publish: ({ modules: a, dependencies: b }) => ({
          $kind: 'Publish',
          Publish: {
            modules: a.map((a) => ('string' == typeof a ? a : dU(new Uint8Array(a)))),
            dependencies: b.map((a) => d$(a)),
          },
        }),
        Upgrade: ({ modules: a, dependencies: b, package: c, ticket: d }) => ({
          $kind: 'Upgrade',
          Upgrade: {
            modules: a.map((a) => ('string' == typeof a ? a : dU(new Uint8Array(a)))),
            dependencies: b.map((a) => d$(a)),
            package: c,
            ticket: kH(kO, d),
          },
        }),
        MakeMoveVec: ({ type: a, elements: b }) => ({
          $kind: 'MakeMoveVec',
          MakeMoveVec: { type: a ?? null, elements: b.map((a) => kH(kO, a)) },
        }),
        Intent: ({ name: a, inputs: b = {}, data: c = {} }) => ({
          $kind: '$Intent',
          $Intent: {
            name: a,
            inputs: Object.fromEntries(
              Object.entries(b).map(([a, b]) => [
                a,
                Array.isArray(b) ? b.map((a) => kH(kO, a)) : kH(kO, b),
              ])
            ),
            data: c,
          },
        }),
      },
      k0 = /^vector<(.+)>$/,
      k1 = /^([^:]+)::([^:]+)::([^<]+)(<(.+)>)?/;
    class k2 {
      static parseFromStr(a, b = !1) {
        if ('address' === a) return { address: null };
        if ('bool' === a) return { bool: null };
        if ('u8' === a) return { u8: null };
        if ('u16' === a) return { u16: null };
        if ('u32' === a) return { u32: null };
        else if ('u64' === a) return { u64: null };
        else if ('u128' === a) return { u128: null };
        else if ('u256' === a) return { u256: null };
        else if ('signer' === a) return { signer: null };
        let c = a.match(k0);
        if (c) return { vector: k2.parseFromStr(c[1], b) };
        let d = a.match(k1);
        if (d)
          return {
            struct: {
              address: b ? dZ(d[1]) : d[1],
              module: d[2],
              name: d[3],
              typeParams: void 0 === d[5] ? [] : k2.parseStructTypeArgs(d[5], b),
            },
          };
        throw Error(`Encountered unexpected token when parsing type args for ${a}`);
      }
      static parseStructTypeArgs(a, b = !1) {
        return (function (a, b = ['<', '>']) {
          let [c, d] = b,
            e = [],
            f = '',
            g = 0;
          for (let b = 0; b < a.length; b++) {
            let h = a[b];
            if ((h === c && g++, h === d && g--, 0 === g && ',' === h)) {
              e.push(f.trim()), (f = '');
              continue;
            }
            f += h;
          }
          return e.push(f.trim()), e;
        })(a).map((a) => k2.parseFromStr(a, b));
      }
      static tagToString(a) {
        if ('bool' in a) return 'bool';
        if ('u8' in a) return 'u8';
        if ('u16' in a) return 'u16';
        if ('u32' in a) return 'u32';
        if ('u64' in a) return 'u64';
        if ('u128' in a) return 'u128';
        if ('u256' in a) return 'u256';
        if ('address' in a) return 'address';
        if ('signer' in a) return 'signer';
        if ('vector' in a) return `vector<${k2.tagToString(a.vector)}>`;
        if ('struct' in a) {
          let b = a.struct,
            c = b.typeParams.map(k2.tagToString).join(', ');
          return `${b.address}::${b.module}::${b.name}${c ? `<${c}>` : ''}`;
        }
        throw Error('Invalid TypeTag');
      }
    }
    let k3 = kz({ digest: kC(), objectId: kC(), version: kF([kI(ky(), kn()), kC(), ks()]) }),
      k4 = kJ({
        ImmOrOwned: k3,
        Shared: kz({ objectId: kK, initialSharedVersion: kM, mutable: kt() }),
        Receiving: k3,
      }),
      k5 = kJ({ Object: k4, Pure: kr(kI(ky(), kn())) }),
      k6 = kF([
        kz({ kind: kv('Input'), index: kI(ky(), kn()), value: kG(), type: kA(kv('object')) }),
        kz({ kind: kv('Input'), index: kI(ky(), kn()), value: kG(), type: kv('pure') }),
      ]),
      k7 = kF([kz({ Epoch: kI(ky(), kn()) }), kz({ None: kw(kv(!0)) })]),
      k8 = kI(
        kF([ky(), kC(), ks()]),
        km((a) => {
          if (!['string', 'number', 'bigint'].includes(typeof a)) return !1;
          try {
            return BigInt(a), !0;
          } catch {
            return !1;
          }
        })
      ),
      k9 = kF([
        kz({ bool: kw(kv(!0)) }),
        kz({ u8: kw(kv(!0)) }),
        kz({ u64: kw(kv(!0)) }),
        kz({ u128: kw(kv(!0)) }),
        kz({ address: kw(kv(!0)) }),
        kz({ signer: kw(kv(!0)) }),
        kz({ vector: ku(() => k9) }),
        kz({ struct: ku(() => la) }),
        kz({ u16: kw(kv(!0)) }),
        kz({ u32: kw(kv(!0)) }),
        kz({ u256: kw(kv(!0)) }),
      ]),
      la = kz({ address: kC(), module: kC(), name: kC(), typeParams: kr(k9) }),
      lb = kz({ budget: kA(k8), price: kA(k8), payment: kA(kr(k3)), owner: kA(kC()) }),
      lc = kF([
        k6,
        kz({ kind: kv('GasCoin') }),
        kz({ kind: kv('Result'), index: kI(ky(), kn()) }),
        kz({ kind: kv('NestedResult'), index: kI(ky(), kn()), resultIndex: kI(ky(), kn()) }),
      ]),
      ld = kz({
        kind: kv('MoveCall'),
        target: kI(
          kC(),
          km((a) => 3 === a.split('::').length)
        ),
        typeArguments: kr(kC()),
        arguments: kr(lc),
      }),
      le = kz({ kind: kv('TransferObjects'), objects: kr(lc), address: lc }),
      lf = kz({ kind: kv('SplitCoins'), coin: lc, amounts: kr(lc) }),
      lg = kz({ kind: kv('MergeCoins'), destination: lc, sources: kr(lc) }),
      lh = kz({
        kind: kv('MakeMoveVec'),
        type: kF([kz({ Some: k9 }), kz({ None: kw(kv(!0)) })]),
        objects: kr(lc),
      }),
      li = kF([
        ld,
        le,
        lf,
        lg,
        kz({ kind: kv('Publish'), modules: kr(kr(kI(ky(), kn()))), dependencies: kr(kC()) }),
        kz({
          kind: kv('Upgrade'),
          modules: kr(kr(kI(ky(), kn()))),
          dependencies: kr(kC()),
          packageId: kC(),
          ticket: lc,
        }),
        lh,
      ]);
    function lj(a) {
      let b = a.inputs.map((a, b) => {
        if (a.Object)
          return {
            kind: 'Input',
            index: b,
            value: {
              Object: a.Object.ImmOrOwnedObject
                ? { ImmOrOwned: a.Object.ImmOrOwnedObject }
                : a.Object.Receiving
                ? {
                    Receiving: {
                      digest: a.Object.Receiving.digest,
                      version: a.Object.Receiving.version,
                      objectId: a.Object.Receiving.objectId,
                    },
                  }
                : {
                    Shared: {
                      mutable: a.Object.SharedObject.mutable,
                      initialSharedVersion: a.Object.SharedObject.initialSharedVersion,
                      objectId: a.Object.SharedObject.objectId,
                    },
                  },
            },
            type: 'object',
          };
        if (a.Pure)
          return {
            kind: 'Input',
            index: b,
            value: { Pure: Array.from(dT(a.Pure.bytes)) },
            type: 'pure',
          };
        if (a.UnresolvedPure)
          return { kind: 'Input', type: 'pure', index: b, value: a.UnresolvedPure.value };
        if (a.UnresolvedObject)
          return { kind: 'Input', type: 'object', index: b, value: a.UnresolvedObject.objectId };
        throw Error('Invalid input');
      });
      return {
        version: 1,
        sender: a.sender ?? void 0,
        expiration:
          a.expiration?.$kind === 'Epoch'
            ? { Epoch: Number(a.expiration.Epoch) }
            : a.expiration
            ? { None: !0 }
            : null,
        gasConfig: {
          owner: a.gasData.owner ?? void 0,
          budget: a.gasData.budget ?? void 0,
          price: a.gasData.price ?? void 0,
          payment: a.gasData.payment ?? void 0,
        },
        inputs: b,
        transactions: a.commands.map((a) => {
          if (a.MakeMoveVec)
            return {
              kind: 'MakeMoveVec',
              type:
                null === a.MakeMoveVec.type
                  ? { None: !0 }
                  : { Some: k2.parseFromStr(a.MakeMoveVec.type) },
              objects: a.MakeMoveVec.elements.map((a) => lk(a, b)),
            };
          if (a.MergeCoins)
            return {
              kind: 'MergeCoins',
              destination: lk(a.MergeCoins.destination, b),
              sources: a.MergeCoins.sources.map((a) => lk(a, b)),
            };
          if (a.MoveCall)
            return {
              kind: 'MoveCall',
              target: `${a.MoveCall.package}::${a.MoveCall.module}::${a.MoveCall.function}`,
              typeArguments: a.MoveCall.typeArguments,
              arguments: a.MoveCall.arguments.map((a) => lk(a, b)),
            };
          if (a.Publish)
            return {
              kind: 'Publish',
              modules: a.Publish.modules.map((a) => Array.from(dT(a))),
              dependencies: a.Publish.dependencies,
            };
          if (a.SplitCoins)
            return {
              kind: 'SplitCoins',
              coin: lk(a.SplitCoins.coin, b),
              amounts: a.SplitCoins.amounts.map((a) => lk(a, b)),
            };
          if (a.TransferObjects)
            return {
              kind: 'TransferObjects',
              objects: a.TransferObjects.objects.map((a) => lk(a, b)),
              address: lk(a.TransferObjects.address, b),
            };
          if (a.Upgrade)
            return {
              kind: 'Upgrade',
              modules: a.Upgrade.modules.map((a) => Array.from(dT(a))),
              dependencies: a.Upgrade.dependencies,
              packageId: a.Upgrade.package,
              ticket: lk(a.Upgrade.ticket, b),
            };
          throw Error(`Unknown transaction ${Object.keys(a)}`);
        }),
      };
    }
    function lk(a, b) {
      if ('GasCoin' === a.$kind) return { kind: 'GasCoin' };
      if ('Result' === a.$kind) return { kind: 'Result', index: a.Result };
      if ('NestedResult' === a.$kind)
        return { kind: 'NestedResult', index: a.NestedResult[0], resultIndex: a.NestedResult[1] };
      if ('Input' === a.$kind) return b[a.Input];
      throw Error(`Invalid argument ${Object.keys(a)}`);
    }
    function ll(a) {
      switch (a.kind) {
        case 'GasCoin':
          return { GasCoin: !0 };
        case 'Result':
          return { Result: a.index };
        case 'NestedResult':
          return { NestedResult: [a.index, a.resultIndex] };
        case 'Input':
          return { Input: a.index };
      }
    }
    function lm(a) {
      return kF(Object.entries(a).map(([a, b]) => kz({ [a]: b })));
    }
    kz({
      version: kv(1),
      sender: kA(kC()),
      expiration: kx(k7),
      gasConfig: lb,
      inputs: kr(k6),
      transactions: kr(li),
    });
    let ln = lm({
        GasCoin: kv(!0),
        Input: kI(ky(), kn()),
        Result: kI(ky(), kn()),
        NestedResult: kD([kI(ky(), kn()), kI(ky(), kn())]),
      }),
      lo = kz({ budget: kw(kM), price: kw(kM), owner: kw(kK), payment: kw(kr(kN)) }),
      lp = kz({
        package: kK,
        module: kC(),
        function: kC(),
        typeArguments: kr(kC()),
        arguments: kr(ln),
      }),
      lq = kz({ name: kC(), inputs: kB(kC(), kF([ln, kr(ln)])), data: kB(kC(), kG()) }),
      lr = lm({
        MoveCall: lp,
        TransferObjects: kz({ objects: kr(ln), address: ln }),
        SplitCoins: kz({ coin: ln, amounts: kr(ln) }),
        MergeCoins: kz({ destination: ln, sources: kr(ln) }),
        Publish: kz({ modules: kr(kL), dependencies: kr(kK) }),
        MakeMoveVec: kz({ type: kw(kC()), elements: kr(ln) }),
        Upgrade: kz({ modules: kr(kL), dependencies: kr(kK), package: kK, ticket: ln }),
        $Intent: lq,
      }),
      ls = lm({
        ImmOrOwnedObject: kN,
        SharedObject: kz({ objectId: kK, initialSharedVersion: kM, mutable: kt() }),
        Receiving: kN,
      }),
      lt = lm({
        Object: ls,
        Pure: kz({ bytes: kL }),
        UnresolvedPure: kz({ value: kG() }),
        UnresolvedObject: kz({
          objectId: kK,
          version: kA(kw(kM)),
          digest: kA(kw(kC())),
          initialSharedVersion: kA(kw(kM)),
        }),
      }),
      lu = lm({ None: kv(!0), Epoch: kM }),
      lv = kz({
        version: kv(2),
        sender: kx(kK),
        expiration: kx(lu),
        gasData: lo,
        inputs: kr(lt),
        commands: kr(lr),
      }),
      lw = function (a) {
        return { $kind: 'Pure', Pure: { bytes: a instanceof Uint8Array ? dU(a) : a.toBase64() } };
      },
      lx = ({ objectId: a, digest: b, version: c }) => ({
        $kind: 'Object',
        Object: {
          $kind: 'ImmOrOwnedObject',
          ImmOrOwnedObject: { digest: b, version: c, objectId: dZ(a) },
        },
      }),
      ly = ({ objectId: a, mutable: b, initialSharedVersion: c }) => ({
        $kind: 'Object',
        Object: {
          $kind: 'SharedObject',
          SharedObject: { mutable: b, initialSharedVersion: c, objectId: dZ(a) },
        },
      }),
      lz = ({ objectId: a, digest: b, version: c }) => ({
        $kind: 'Object',
        Object: { $kind: 'Receiving', Receiving: { digest: b, version: c, objectId: dZ(a) } },
      }),
      lA = {
        u8: (a) =>
          kh({
            name: 'u8',
            readMethod: 'read8',
            writeMethod: 'write8',
            size: 1,
            maxValue: 255,
            ...a,
          }),
        u16: (a) =>
          kh({
            name: 'u16',
            readMethod: 'read16',
            writeMethod: 'write16',
            size: 2,
            maxValue: 65535,
            ...a,
          }),
        u32: (a) =>
          kh({
            name: 'u32',
            readMethod: 'read32',
            writeMethod: 'write32',
            size: 4,
            maxValue: 0x100000000 - 1,
            ...a,
          }),
        u64: (a) =>
          ki({
            name: 'u64',
            readMethod: 'read64',
            writeMethod: 'write64',
            size: 8,
            maxValue: 2n ** 64n - 1n,
            ...a,
          }),
        u128: (a) =>
          ki({
            name: 'u128',
            readMethod: 'read128',
            writeMethod: 'write128',
            size: 16,
            maxValue: 2n ** 128n - 1n,
            ...a,
          }),
        u256: (a) =>
          ki({
            name: 'u256',
            readMethod: 'read256',
            writeMethod: 'write256',
            size: 32,
            maxValue: 2n ** 256n - 1n,
            ...a,
          }),
        bool: (a) =>
          kg({
            name: 'bool',
            size: 1,
            read: (a) => 1 === a.read8(),
            write: (a, b) => b.write8(+!!a),
            ...a,
            validate: (b) => {
              if ((a?.validate?.(b), 'boolean' != typeof b))
                throw TypeError(`Expected boolean, found ${typeof b}`);
            },
          }),
        uleb128: (a) =>
          (function ({ serialize: a, ...b }) {
            let c = new kc({
              ...b,
              serialize: a,
              write: (a, b) => {
                for (let d of c.serialize(a).toBytes()) b.write8(d);
              },
            });
            return c;
          })({
            name: 'uleb128',
            read: (a) => a.readULEB(),
            serialize: (a) => Uint8Array.from(j3(a)),
            ...a,
          }),
        bytes: (a, b) =>
          kg({
            name: `bytes[${a}]`,
            size: a,
            read: (b) => b.readBytes(a),
            write: (b, c) => {
              for (let d = 0; d < a; d++) c.write8(b[d] ?? 0);
            },
            ...b,
            validate: (c) => {
              if ((b?.validate?.(c), !c || 'object' != typeof c || !('length' in c)))
                throw TypeError(`Expected array, found ${typeof c}`);
              if (c.length !== a)
                throw TypeError(`Expected array of length ${a}, found ${c.length}`);
            },
          }),
        byteVector: (a) =>
          new kc({
            name: 'bytesVector',
            read: (a) => {
              let b = a.readULEB();
              return a.readBytes(b);
            },
            write: (a, b) => {
              let c = new Uint8Array(a);
              b.writeULEB(c.length);
              for (let a = 0; a < c.length; a++) b.write8(c[a] ?? 0);
            },
            ...a,
            serializedSize: (a) => {
              let b = 'length' in a ? a.length : null;
              return null == b ? null : j3(b).length + b;
            },
            validate: (b) => {
              if ((a?.validate?.(b), !b || 'object' != typeof b || !('length' in b)))
                throw TypeError(`Expected array, found ${typeof b}`);
            },
          }),
        string: (a) =>
          (function ({ toBytes: a, fromBytes: b, ...c }) {
            return new kc({
              ...c,
              read: (a) => {
                let c = a.readULEB();
                return b(a.readBytes(c));
              },
              write: (b, c) => {
                let d = a(b);
                c.writeULEB(d.length);
                for (let a = 0; a < d.length; a++) c.write8(d[a]);
              },
              serialize: (b) => {
                let c = a(b),
                  d = j3(c.length),
                  e = new Uint8Array(d.length + c.length);
                return e.set(d, 0), e.set(c, d.length), e;
              },
              validate: (a) => {
                if ('string' != typeof a)
                  throw TypeError(`Invalid ${c.name} value: ${a}. Expected string`);
                c.validate?.(a);
              },
            });
          })({
            name: 'string',
            toBytes: (a) => new TextEncoder().encode(a),
            fromBytes: (a) => new TextDecoder().decode(a),
            ...a,
          }),
        fixedArray: (a, b, c) =>
          new kc({
            name: `${b.name}[${a}]`,
            read: (c) => {
              let d = Array(a);
              for (let e = 0; e < a; e++) d[e] = b.read(c);
              return d;
            },
            write: (a, c) => {
              for (let d of a) b.write(d, c);
            },
            ...c,
            validate: (b) => {
              if ((c?.validate?.(b), !b || 'object' != typeof b || !('length' in b)))
                throw TypeError(`Expected array, found ${typeof b}`);
              if (b.length !== a)
                throw TypeError(`Expected array of length ${a}, found ${b.length}`);
            },
          }),
        option: (a) =>
          lA
            .enum(`Option<${a.name}>`, { None: null, Some: a })
            .transform({
              input: (a) => (null == a ? { None: !0 } : { Some: a }),
              output: (a) => ('Some' === a.$kind ? a.Some : null),
            }),
        vector: (a, b) =>
          new kc({
            name: `vector<${a.name}>`,
            read: (b) => {
              let c = b.readULEB(),
                d = Array(c);
              for (let e = 0; e < c; e++) d[e] = a.read(b);
              return d;
            },
            write: (b, c) => {
              for (let d of (c.writeULEB(b.length), b)) a.write(d, c);
            },
            ...b,
            validate: (a) => {
              if ((b?.validate?.(a), !a || 'object' != typeof a || !('length' in a)))
                throw TypeError(`Expected array, found ${typeof a}`);
            },
          }),
        tuple: (a, b) =>
          new kc({
            name: `(${a.map((a) => a.name).join(', ')})`,
            serializedSize: (b) => {
              let c = 0;
              for (let d = 0; d < a.length; d++) {
                let e = a[d].serializedSize(b[d]);
                if (null == e) return null;
                c += e;
              }
              return c;
            },
            read: (b) => {
              let c = [];
              for (let d of a) c.push(d.read(b));
              return c;
            },
            write: (b, c) => {
              for (let d = 0; d < a.length; d++) a[d].write(b[d], c);
            },
            ...b,
            validate: (c) => {
              if ((b?.validate?.(c), !Array.isArray(c)))
                throw TypeError(`Expected array, found ${typeof c}`);
              if (c.length !== a.length)
                throw TypeError(`Expected array of length ${a.length}, found ${c.length}`);
            },
          }),
        struct(a, b, c) {
          let d = Object.entries(b);
          return new kc({
            name: a,
            serializedSize: (a) => {
              let b = 0;
              for (let [c, e] of d) {
                let d = e.serializedSize(a[c]);
                if (null == d) return null;
                b += d;
              }
              return b;
            },
            read: (a) => {
              let b = {};
              for (let [c, e] of d) b[c] = e.read(a);
              return b;
            },
            write: (a, b) => {
              for (let [c, e] of d) e.write(a[c], b);
            },
            ...c,
            validate: (a) => {
              if ((c?.validate?.(a), 'object' != typeof a || null == a))
                throw TypeError(`Expected object, found ${typeof a}`);
            },
          });
        },
        enum(a, b, c) {
          let d = Object.entries(b);
          return new kc({
            name: a,
            read: (b) => {
              let c = b.readULEB(),
                e = d[c];
              if (!e) throw TypeError(`Unknown value ${c} for enum ${a}`);
              let [f, g] = e;
              return { [f]: g?.read(b) ?? !0, $kind: f };
            },
            write: (a, c) => {
              let [e, f] = Object.entries(a).filter(([a]) => Object.hasOwn(b, a))[0];
              for (let a = 0; a < d.length; a++) {
                let [b, g] = d[a];
                if (b === e) {
                  c.writeULEB(a), g?.write(f, c);
                  return;
                }
              }
            },
            ...c,
            validate: (d) => {
              if ((c?.validate?.(d), 'object' != typeof d || null == d))
                throw TypeError(`Expected object, found ${typeof d}`);
              let e = Object.keys(d).filter((a) => void 0 !== d[a] && Object.hasOwn(b, a));
              if (1 !== e.length)
                throw TypeError(
                  `Expected object with one key, but found ${e.length} for type ${a}}`
                );
              let [f] = e;
              if (!Object.hasOwn(b, f)) throw TypeError(`Invalid enum variant ${f}`);
            },
          });
        },
        map: (a, b) =>
          lA.vector(lA.tuple([a, b])).transform({
            name: `Map<${a.name}, ${b.name}>`,
            input: (a) => [...a.entries()],
            output: (a) => {
              let b = new Map();
              for (let [c, d] of a) b.set(c, d);
              return b;
            },
          }),
        lazy: (a) =>
          (function (a) {
            let b = null;
            function c() {
              return b || (b = a()), b;
            }
            return new kc({
              name: 'lazy',
              read: (a) => c().read(a),
              serializedSize: (a) => c().serializedSize(a),
              write: (a, b) => c().write(a, b),
              serialize: (a, b) => c().serialize(a, b).toBytes(),
            });
          })(a),
      },
      lB = lA.bytes(32).transform({
        validate: (a) => {
          let b = 'string' == typeof a ? a : dW(a);
          if (!b || !dY(dZ(b))) throw Error(`Invalid IOTA address ${b}`);
        },
        input: (a) => ('string' == typeof a ? dV(dZ(a)) : a),
        output: (a) => dZ(dW(a)),
      }),
      lC = lA.vector(lA.u8()).transform({
        name: 'ObjectDigest',
        input: (a) => {
          let b;
          return (b = a), dS.decode(b);
        },
        output: (a) => {
          let b;
          return (b = new Uint8Array(a)), dS.encode(b);
        },
        validate: (a) => {
          let b;
          if (32 !== ((b = a), dS.decode(b)).length) throw Error('ObjectDigest must be 32 bytes');
        },
      }),
      lD = lA.struct('IotaObjectRef', { objectId: lB, version: lA.u64(), digest: lC }),
      lE = lA.struct('SharedObjectRef', {
        objectId: lB,
        initialSharedVersion: lA.u64(),
        mutable: lA.bool(),
      }),
      lF = lA.enum('ObjectArg', { ImmOrOwnedObject: lD, SharedObject: lE, Receiving: lD }),
      lG = lA.enum('Owner', {
        AddressOwner: lB,
        ObjectOwner: lB,
        Shared: lA.struct('Shared', { initialSharedVersion: lA.u64() }),
        Immutable: null,
      }),
      lH = lA.enum('CallArg', {
        Pure: lA.struct('Pure', {
          bytes: lA
            .vector(lA.u8())
            .transform({
              input: (a) => ('string' == typeof a ? dT(a) : a),
              output: (a) => dU(new Uint8Array(a)),
            }),
        }),
        Object: lF,
      }),
      lI = lA.enum('TypeTag', {
        bool: null,
        u8: null,
        u64: null,
        u128: null,
        address: null,
        signer: null,
        vector: lA.lazy(() => lI),
        struct: lA.lazy(() => lQ),
        u16: null,
        u32: null,
        u256: null,
      }),
      lJ = lI.transform({
        input: (a) => ('string' == typeof a ? k2.parseFromStr(a, !0) : a),
        output: (a) => k2.tagToString(a),
      }),
      lK = lA.enum('Argument', {
        GasCoin: null,
        Input: lA.u16(),
        Result: lA.u16(),
        NestedResult: lA.tuple([lA.u16(), lA.u16()]),
      }),
      lL = lA.struct('ProgrammableMoveCall', {
        package: lB,
        module: lA.string(),
        function: lA.string(),
        typeArguments: lA.vector(lJ),
        arguments: lA.vector(lK),
      }),
      lM = lA.enum('Command', {
        MoveCall: lL,
        TransferObjects: lA.struct('TransferObjects', { objects: lA.vector(lK), address: lK }),
        SplitCoins: lA.struct('SplitCoins', { coin: lK, amounts: lA.vector(lK) }),
        MergeCoins: lA.struct('MergeCoins', { destination: lK, sources: lA.vector(lK) }),
        Publish: lA.struct('Publish', {
          modules: lA.vector(
            lA
              .vector(lA.u8())
              .transform({
                input: (a) => ('string' == typeof a ? dT(a) : a),
                output: (a) => dU(new Uint8Array(a)),
              })
          ),
          dependencies: lA.vector(lB),
        }),
        MakeMoveVec: lA.struct('MakeMoveVec', {
          type: lA
            .enum('Option', { None: null, Some: lJ })
            .transform({
              input: (a) => (null === a ? { None: !0 } : { Some: a }),
              output: (a) => a.Some ?? null,
            }),
          elements: lA.vector(lK),
        }),
        Upgrade: lA.struct('Upgrade', {
          modules: lA.vector(
            lA
              .vector(lA.u8())
              .transform({
                input: (a) => ('string' == typeof a ? dT(a) : a),
                output: (a) => dU(new Uint8Array(a)),
              })
          ),
          dependencies: lA.vector(lB),
          package: lB,
          ticket: lK,
        }),
      }),
      lN = lA.struct('ProgrammableTransaction', { inputs: lA.vector(lH), commands: lA.vector(lM) }),
      lO = lA.enum('TransactionKind', {
        ProgrammableTransaction: lN,
        ChangeEpoch: null,
        Genesis: null,
        ConsensusCommitPrologue: null,
      }),
      lP = lA.enum('TransactionExpiration', {
        None: null,
        Epoch: lA
          .u64({ name: 'unsafe_u64', ...void 0 })
          .transform({ input: (a) => a, output: (a) => Number(a) }),
      }),
      lQ = lA.struct('StructTag', {
        address: lB,
        module: lA.string(),
        name: lA.string(),
        typeParams: lA.vector(lI),
      }),
      lR = lA.struct('GasData', {
        payment: lA.vector(lD),
        owner: lB,
        price: lA.u64(),
        budget: lA.u64(),
      }),
      lS = lA.struct('TransactionDataV1', { kind: lO, sender: lB, gasData: lR, expiration: lP }),
      lT = lA.enum('TransactionData', { V1: lS }),
      lU = lA.enum('IntentScope', {
        TransactionData: null,
        TransactionEffects: null,
        CheckpointSummary: null,
        PersonalMessage: null,
      }),
      lV = lA.enum('IntentVersion', { V0: null }),
      lW = lA.enum('AppId', { Iota: null }),
      lX = lA.struct('Intent', { scope: lU, version: lV, appId: lW });
    function lY(a) {
      return lA.struct(`IntentMessage<${a.name}>`, { intent: lX, value: a });
    }
    let lZ = lA.enum('CompressedSignature', {
        ED25519: lA.fixedArray(64, lA.u8()),
        Secp256k1: lA.fixedArray(64, lA.u8()),
        Secp256r1: lA.fixedArray(64, lA.u8()),
      }),
      l$ = lA.enum('PublicKey', {
        ED25519: lA.fixedArray(32, lA.u8()),
        Secp256k1: lA.fixedArray(33, lA.u8()),
        Secp256r1: lA.fixedArray(33, lA.u8()),
      }),
      l_ = lA.struct('MultiSigPkMap', { pubKey: l$, weight: lA.u8() }),
      l0 = lA.struct('MultiSigPublicKey', { pk_map: lA.vector(l_), threshold: lA.u16() }),
      l1 = lA.struct('MultiSig', { sigs: lA.vector(lZ), bitmap: lA.u16(), multisig_pk: l0 }),
      l2 = lA
        .vector(lA.u8())
        .transform({
          input: (a) => ('string' == typeof a ? dT(a) : a),
          output: (a) => dU(new Uint8Array(a)),
        }),
      l3 = lA.struct('SenderSignedTransaction', {
        intentMessage: lY(lT),
        txSignatures: lA.vector(l2),
      }),
      l4 = lA.vector(l3, { name: 'SenderSignedData' }),
      l5 = lA.struct('PasskeyAuthenticator', {
        authenticatorData: lA.vector(lA.u8()),
        clientDataJson: lA.string(),
        userSignature: lA.vector(lA.u8()),
      }),
      l6 = lA.enum('PackageUpgradeError', {
        UnableToFetchPackage: lA.struct('UnableToFetchPackage', { packageId: lB }),
        NotAPackage: lA.struct('NotAPackage', { objectId: lB }),
        IncompatibleUpgrade: null,
        DigestDoesNotMatch: lA.struct('DigestDoesNotMatch', { digest: lA.vector(lA.u8()) }),
        UnknownUpgradePolicy: lA.struct('UnknownUpgradePolicy', { policy: lA.u8() }),
        PackageIDDoesNotMatch: lA.struct('PackageIDDoesNotMatch', { packageId: lB, ticketId: lB }),
      }),
      l7 = lA.struct('ModuleId', { address: lB, name: lA.string() }),
      l8 = lA.struct('MoveLocation', {
        module: l7,
        function: lA.u16(),
        instruction: lA.u16(),
        functionName: lA.option(lA.string()),
      }),
      l9 = lA.enum('CommandArgumentError', {
        TypeMismatch: null,
        InvalidBCSBytes: null,
        InvalidUsageOfPureArg: null,
        InvalidArgumentToPrivateEntryFunction: null,
        IndexOutOfBounds: lA.struct('IndexOutOfBounds', { idx: lA.u16() }),
        SecondaryIndexOutOfBounds: lA.struct('SecondaryIndexOutOfBounds', {
          resultIdx: lA.u16(),
          secondaryIdx: lA.u16(),
        }),
        InvalidResultArity: lA.struct('InvalidResultArity', { resultIdx: lA.u16() }),
        InvalidGasCoinUsage: null,
        InvalidValueUsage: null,
        InvalidObjectByValue: null,
        InvalidObjectByMutRef: null,
        SharedObjectOperationNotAllowed: null,
      }),
      ma = lA.enum('TypeArgumentError', { TypeNotFound: null, ConstraintNotSatisfied: null }),
      mb = lA.enum('ExecutionFailureStatus', {
        InsufficientGas: null,
        InvalidGasObject: null,
        InvariantViolation: null,
        FeatureNotYetSupported: null,
        MoveObjectTooBig: lA.struct('MoveObjectTooBig', {
          objectSize: lA.u64(),
          maxObjectSize: lA.u64(),
        }),
        MovePackageTooBig: lA.struct('MovePackageTooBig', {
          objectSize: lA.u64(),
          maxObjectSize: lA.u64(),
        }),
        CircularObjectOwnership: lA.struct('CircularObjectOwnership', { object: lB }),
        InsufficientCoinBalance: null,
        CoinBalanceOverflow: null,
        PublishErrorNonZeroAddress: null,
        IotaMoveVerificationError: null,
        MovePrimitiveRuntimeError: lA.option(l8),
        MoveAbort: lA.tuple([l8, lA.u64()]),
        VMVerificationOrDeserializationError: null,
        VMInvariantViolation: null,
        FunctionNotFound: null,
        ArityMismatch: null,
        TypeArityMismatch: null,
        NonEntryFunctionInvoked: null,
        CommandArgumentError: lA.struct('CommandArgumentError', { argIdx: lA.u16(), kind: l9 }),
        TypeArgumentError: lA.struct('TypeArgumentError', { argumentIdx: lA.u16(), kind: ma }),
        UnusedValueWithoutDrop: lA.struct('UnusedValueWithoutDrop', {
          resultIdx: lA.u16(),
          secondaryIdx: lA.u16(),
        }),
        InvalidPublicFunctionReturnType: lA.struct('InvalidPublicFunctionReturnType', {
          idx: lA.u16(),
        }),
        InvalidTransferObject: null,
        EffectsTooLarge: lA.struct('EffectsTooLarge', { currentSize: lA.u64(), maxSize: lA.u64() }),
        PublishUpgradeMissingDependency: null,
        PublishUpgradeDependencyDowngrade: null,
        PackageUpgradeError: lA.struct('PackageUpgradeError', { upgradeError: l6 }),
        WrittenObjectsTooLarge: lA.struct('WrittenObjectsTooLarge', {
          currentSize: lA.u64(),
          maxSize: lA.u64(),
        }),
        CertificateDenied: null,
        IotaMoveVerificationTimedout: null,
        SharedObjectOperationNotAllowed: null,
        InputObjectDeleted: null,
        ExecutionCancelledDueToSharedObjectCongestion: lA.struct(
          'ExecutionCancelledDueToSharedObjectCongestion',
          { congestedObjects: lA.vector(lB) }
        ),
        AddressDeniedForCoin: lA.struct('AddressDeniedForCoin', {
          address: lB,
          coinType: lA.string(),
        }),
        CoinTypeGlobalPause: lA.struct('CoinTypeGlobalPause', { coinType: lA.string() }),
        ExecutionCancelledDueToRandomnessUnavailable: null,
      }),
      mc = lA.enum('ExecutionStatus', {
        Success: null,
        Failed: lA.struct('ExecutionFailed', { error: mb, command: lA.option(lA.u64()) }),
      }),
      md = lA.struct('GasCostSummary', {
        computationCost: lA.u64(),
        computationCostBurned: lA.u64(),
        storageCost: lA.u64(),
        storageRebate: lA.u64(),
        nonRefundableStorageFee: lA.u64(),
      }),
      me = lA.tuple([lA.u64(), lC]),
      mf = lA.enum('ObjectIn', { NotExist: null, Exist: lA.tuple([me, lG]) }),
      mg = lA.enum('ObjectOut', {
        NotExist: null,
        ObjectWrite: lA.tuple([lC, lG]),
        PackageWrite: me,
      }),
      mh = lA.enum('IDOperation', { None: null, Created: null, Deleted: null }),
      mi = lA.struct('EffectsObjectChange', { inputState: mf, outputState: mg, idOperation: mh }),
      mj = lA.enum('UnchangedSharedKind', {
        ReadOnlyRoot: me,
        MutateDeleted: lA.u64(),
        ReadDeleted: lA.u64(),
        Cancelled: lA.u64(),
        PerEpochConfig: null,
      }),
      mk = lA.struct('TransactionEffectsV1', {
        status: mc,
        executedEpoch: lA.u64(),
        gasUsed: md,
        transactionDigest: lC,
        gasObjectIndex: lA.option(lA.u32()),
        eventsDigest: lA.option(lC),
        dependencies: lA.vector(lC),
        lamportVersion: lA.u64(),
        changedObjects: lA.vector(lA.tuple([lB, mi])),
        unchangedSharedObjects: lA.vector(lA.tuple([lB, mj])),
        auxDataDigest: lA.option(lC),
      }),
      ml = lA.enum('TransactionEffects', { V1: mk }),
      mm = {
        ...lA,
        U8: lA.u8(),
        U16: lA.u16(),
        U32: lA.u32(),
        U64: lA.u64(),
        U128: lA.u128(),
        U256: lA.u256(),
        ULEB128: lA.uleb128(),
        Bool: lA.bool(),
        String: lA.string(),
        Address: lB,
        AppId: lW,
        Argument: lK,
        CallArg: lH,
        CompressedSignature: lZ,
        GasData: lR,
        Intent: lX,
        IntentMessage: lY,
        IntentScope: lU,
        IntentVersion: lV,
        MultiSig: l1,
        MultiSigPkMap: l_,
        MultiSigPublicKey: l0,
        ObjectArg: lF,
        ObjectDigest: lC,
        Owner: lG,
        ProgrammableMoveCall: lL,
        ProgrammableTransaction: lN,
        PublicKey: l$,
        SenderSignedData: l4,
        SenderSignedTransaction: l3,
        SharedObjectRef: lE,
        StructTag: lQ,
        IotaObjectRef: lD,
        Command: lM,
        TransactionData: lT,
        TransactionDataV1: lS,
        TransactionExpiration: lP,
        TransactionKind: lO,
        TypeTag: lJ,
        TransactionEffects: ml,
        PasskeyAuthenticator: l5,
      };
    BigInt(1e9), d$('0x6');
    function mn(a) {
      if ('string' == typeof a)
        switch (a) {
          case 'Address':
            return 'address';
          case 'Bool':
            return 'bool';
          case 'U8':
            return 'u8';
          case 'U16':
            return 'u16';
          case 'U32':
            return 'u32';
          case 'U64':
            return 'u64';
          case 'U128':
            return 'u128';
          case 'U256':
            return 'u256';
          default:
            throw Error(`Unexpected type ${a}`);
        }
      if ('Vector' in a) return { vector: mn(a.Vector) };
      if ('Struct' in a)
        return {
          datatype: {
            package: a.Struct.address,
            module: a.Struct.module,
            type: a.Struct.name,
            typeParameters: a.Struct.typeArguments.map(mn),
          },
        };
      if ('TypeParameter' in a) return { typeParameter: a.TypeParameter };
      throw Error(`Unexpected type ${JSON.stringify(a)}`);
    }
    async function mo(a, b, c) {
      return (
        await mt(a, b),
        await ms(a, b),
        b.onlyTransactionKind || (await mp(a, b), await mq(a, b), await mr(a, b)),
        await void a.inputs.forEach((a, b) => {
          if ('Object' !== a.$kind && 'Pure' !== a.$kind)
            throw Error(
              `Input at index ${b} has not been resolved.  Expected a Pure or Object input, but found ${JSON.stringify(
                a
              )}`
            );
        }),
        await c()
      );
    }
    async function mp(a, b) {
      a.gasConfig.price || (a.gasConfig.price = String(await mv(b).getReferenceGasPrice()));
    }
    async function mq(a, b) {
      if (a.gasConfig.budget) return;
      let c = await mv(b).dryRunTransactionBlock({
        transactionBlock: a.build({
          overrides: { gasData: { budget: String(5e10), payment: [] } },
        }),
      });
      if ('success' !== c.effects.status.status)
        throw Error(
          `Dry run failed, could not automatically determine a budget: ${c.effects.status.error}`,
          { cause: c }
        );
      let d = 1000n * BigInt(a.gasConfig.price || 1n),
        e = BigInt(c.effects.gasUsed.computationCost) + d,
        f = e + BigInt(c.effects.gasUsed.storageCost) - BigInt(c.effects.gasUsed.storageRebate);
      a.gasConfig.budget = String(f > e ? f : e);
    }
    async function mr(a, b) {
      if (!a.gasConfig.payment) {
        let c = (
          await mv(b).getCoins({
            owner: a.gasConfig.owner || a.sender,
            coinType: '0x2::iota::IOTA',
          })
        ).data
          .filter(
            (b) =>
              !a.inputs.find(
                (a) =>
                  !!a.Object?.ImmOrOwnedObject &&
                  b.coinObjectId === a.Object.ImmOrOwnedObject.objectId
              )
          )
          .map((a) => ({ objectId: a.coinObjectId, digest: a.digest, version: a.version }));
        if (!c.length) throw Error('No valid gas coins found for the transaction.');
        a.gasConfig.payment = c.map((a) => kH(kN, a));
      }
    }
    async function ms(a, b) {
      var c;
      let d = [
          ...new Set(
            a.inputs
              .filter(
                (a) =>
                  a.UnresolvedObject &&
                  !(a.UnresolvedObject.version || a.UnresolvedObject?.initialSharedVersion)
              )
              .map((a) => d$(a.UnresolvedObject.objectId))
          ),
        ],
        e = d.length
          ? Array.from({ length: Math.ceil((c = d).length / 50) }, (a, b) =>
              c.slice(50 * b, 50 * b + 50)
            )
          : [],
        f = new Map(),
        g = new Map();
      if (
        (await Promise.all(
          e.map(async (a) => {
            for (let c of await mv(b).multiGetObjects({ ids: a, options: { showOwner: !0 } })) {
              let a = c.data?.objectId;
              if (a) {
                if (c.error || !c.data) return void g.set(a, c.error);
                let b = c.data.owner,
                  d =
                    b && 'object' == typeof b && 'Shared' in b
                      ? b.Shared.initial_shared_version
                      : null;
                f.set(a, {
                  objectId: a,
                  digest: c.data.digest,
                  version: c.data.version,
                  initialSharedVersion: d,
                });
              }
            }
          })
        ),
        g.size > 0)
      )
        throw Error(`The following input objects are invalid: ${Array.from(g).join(', ')}`);
      for (let [b, c] of a.inputs.entries()) {
        let d;
        if (!c.UnresolvedObject) continue;
        let e = dZ(c.UnresolvedObject.objectId),
          g = f.get(e);
        c.UnresolvedObject.initialSharedVersion ?? g?.initialSharedVersion
          ? (d = ly({
              objectId: e,
              initialSharedVersion:
                c.UnresolvedObject.initialSharedVersion || g?.initialSharedVersion,
              mutable: (function (a, b) {
                let c = !1;
                return (
                  a.getInputUses(b, (a, b) => {
                    if (b.MoveCall && b.MoveCall._argumentTypes) {
                      let d = b.MoveCall.arguments.indexOf(a);
                      c = '&' !== b.MoveCall._argumentTypes[d].ref || c;
                    }
                    ('MakeMoveVec' === b.$kind ||
                      'MergeCoins' === b.$kind ||
                      'SplitCoins' === b.$kind) &&
                      (c = !0);
                  }),
                  c
                );
              })(a, b),
            }))
          : (function (a, b) {
              let c = !1;
              return (
                a.getInputUses(b, (a, b) => {
                  if (b.MoveCall && b.MoveCall._argumentTypes) {
                    var d;
                    let e = b.MoveCall.arguments.indexOf(a);
                    c =
                      ('object' == typeof (d = b.MoveCall._argumentTypes[e]).body &&
                        'datatype' in d.body &&
                        '0x2' === d.body.datatype.package &&
                        'transfer' === d.body.datatype.module &&
                        'Receiving' === d.body.datatype.type) ||
                      c;
                  }
                }),
                c
              );
            })(a, b) &&
            (d = lz({
              objectId: e,
              digest: c.UnresolvedObject.digest ?? g?.digest,
              version: c.UnresolvedObject.version ?? g?.version,
            })),
          (a.inputs[a.inputs.indexOf(c)] =
            d ??
            lx({
              objectId: e,
              digest: c.UnresolvedObject.digest ?? g?.digest,
              version: c.UnresolvedObject.version ?? g?.version,
            }));
      }
    }
    async function mt(a, b) {
      let { inputs: c, commands: d } = a,
        e = [],
        f = new Set();
      d.forEach((b) => {
        if (b.MoveCall) {
          if (b.MoveCall._argumentTypes) return;
          if (
            b.MoveCall.arguments
              .map((b) => ('Input' === b.$kind ? a.inputs[b.Input] : null))
              .some((a) => a?.UnresolvedPure || a?.UnresolvedObject)
          ) {
            let a = `${b.MoveCall.package}::${b.MoveCall.module}::${b.MoveCall.function}`;
            f.add(a), e.push(b.MoveCall);
          }
        }
        switch (b.$kind) {
          case 'SplitCoins':
            b.SplitCoins.amounts.forEach((b) => {
              mu(b, mm.U64, a);
            });
            break;
          case 'TransferObjects':
            mu(b.TransferObjects.address, mm.Address, a);
        }
      });
      let g = new Map();
      if (f.size > 0) {
        let a = mv(b);
        await Promise.all(
          [...f].map(async (b) => {
            let [c, d, e] = b.split('::'),
              f = await a.getNormalizedMoveFunction({ package: c, module: d, function: e });
            g.set(
              b,
              f.parameters.map((a) =>
                'object' == typeof a && 'Reference' in a
                  ? { ref: '&', body: mn(a.Reference) }
                  : 'object' == typeof a && 'MutableReference' in a
                  ? { ref: '&mut', body: mn(a.MutableReference) }
                  : { ref: null, body: mn(a) }
              )
            );
          })
        );
      }
      e.length &&
        (await Promise.all(
          e.map(async (a) => {
            var b;
            let c,
              d = g.get(`${a.package}::${a.module}::${a.function}`);
            d &&
              (a._argumentTypes =
                d.length > 0 &&
                (c =
                  'object' == typeof (b = d.at(-1)).body && 'datatype' in b.body
                    ? b.body.datatype
                    : null) &&
                dZ(c.package) === dZ('0x2') &&
                'tx_context' === c.module &&
                'TxContext' === c.type
                  ? d.slice(0, d.length - 1)
                  : d);
          })
        )),
        d.forEach((a) => {
          if (!a.MoveCall) return;
          let b = a.MoveCall,
            d = `${b.package}::${b.module}::${b.function}`,
            e = b._argumentTypes;
          if (e) {
            if (e.length !== a.MoveCall.arguments.length)
              throw Error(`Incorrect number of arguments for ${d}`);
            e.forEach((a, d) => {
              let e = b.arguments[d];
              if ('Input' !== e.$kind) return;
              let f = c[e.Input];
              if (!f.UnresolvedPure && !f.UnresolvedObject) return;
              let g = f.UnresolvedPure?.value ?? f.UnresolvedObject?.objectId,
                h = c.indexOf(f),
                i = (function a(b) {
                  if ('string' == typeof b)
                    switch (b) {
                      case 'address':
                        return mm.Address;
                      case 'bool':
                        return mm.Bool;
                      case 'u8':
                        return mm.U8;
                      case 'u16':
                        return mm.U16;
                      case 'u32':
                        return mm.U32;
                      case 'u64':
                        return mm.U64;
                      case 'u128':
                        return mm.U128;
                      case 'u256':
                        return mm.U256;
                      default:
                        throw Error(`Unknown type signature ${b}`);
                    }
                  if ('vector' in b) {
                    if ('u8' === b.vector)
                      return mm
                        .vector(mm.U8)
                        .transform({
                          input: (a) => ('string' == typeof a ? new TextEncoder().encode(a) : a),
                          output: (a) => a,
                        });
                    let c = a(b.vector);
                    return c ? mm.vector(c) : null;
                  }
                  if ('datatype' in b) {
                    let c = dZ(b.datatype.package);
                    if (c === dZ('0x1')) {
                      if (
                        ('ascii' === b.datatype.module && 'String' === b.datatype.type) ||
                        ('string' === b.datatype.module && 'String' === b.datatype.type)
                      )
                        return mm.String;
                      if ('option' === b.datatype.module && 'Option' === b.datatype.type) {
                        let c = a(b.datatype.typeParameters[0]);
                        return c ? mm.vector(c) : null;
                      }
                    }
                    if (
                      c === dZ('0x2') &&
                      'object' === b.datatype.module &&
                      'ID' === b.datatype.type
                    )
                      return mm.Address;
                  }
                  return null;
                })(a.body);
              if (i) {
                (e.type = 'pure'), (c[h] = lw(i.serialize(g)));
                return;
              }
              if ('string' != typeof g)
                throw Error(
                  `Expect the argument to be an object id string, got ${JSON.stringify(g, null, 2)}`
                );
              e.type = 'object';
              let j = f.UnresolvedPure
                ? { $kind: 'UnresolvedObject', UnresolvedObject: { objectId: g } }
                : f;
              c[h] = j;
            });
          }
        });
    }
    function mu(a, b, c) {
      if ('Input' !== a.$kind) return;
      let d = c.inputs[a.Input];
      'UnresolvedPure' === d.$kind && (c.inputs[a.Input] = lw(b.serialize(d.UnresolvedPure.value)));
    }
    function mv(a) {
      if (!a.client)
        throw Error(
          'No iota client passed to Transaction#build, but transaction data was not sufficient to build offline.'
        );
      return a.client;
    }
    function mw(a) {
      switch (a) {
        case 'u8':
          return mm.u8();
        case 'u16':
          return mm.u16();
        case 'u32':
          return mm.u32();
        case 'u64':
          return mm.u64();
        case 'u128':
          return mm.u128();
        case 'u256':
          return mm.u256();
        case 'bool':
          return mm.bool();
        case 'string':
          return mm.string();
        case 'id':
        case 'address':
          return mm.Address;
      }
      let b = a.match(/^(vector|option)<(.+)>$/);
      if (b) {
        let [a, c] = b.slice(1);
        return 'vector' === a ? mm.vector(mw(c)) : mm.option(mw(c));
      }
      throw Error(`Invalid Pure type name: ${a}`);
    }
    function mx(a) {
      return dZ(a).replace('0x', '');
    }
    d$('0x5'), a.s(['blake2b', 0, jP], 41377);
    class my {
      constructor(a) {
        (this.version = 2),
          (this.sender = a?.sender ?? null),
          (this.expiration = a?.expiration ?? null),
          (this.inputs = a?.inputs ?? []),
          (this.commands = a?.commands ?? []),
          (this.gasData = a?.gasData ?? { budget: null, price: null, owner: null, payment: null });
      }
      static fromKindBytes(a) {
        let b = mm.TransactionKind.parse(a).ProgrammableTransaction;
        if (!b) throw Error('Unable to deserialize from bytes.');
        return my.restore({
          version: 2,
          sender: null,
          expiration: null,
          gasData: { budget: null, owner: null, payment: null, price: null },
          inputs: b.inputs,
          commands: b.commands,
        });
      }
      static fromBytes(a) {
        let b = mm.TransactionData.parse(a),
          c = b?.V1,
          d = c.kind.ProgrammableTransaction;
        if (!c || !d) throw Error('Unable to deserialize from bytes.');
        return my.restore({
          version: 2,
          sender: c.sender,
          expiration: c.expiration,
          gasData: c.gasData,
          inputs: d.inputs,
          commands: d.commands,
        });
      }
      static restore(a) {
        return 2 === a.version
          ? new my(kH(kZ, a))
          : new my(
              kH(
                kZ,
                kH(kZ, {
                  version: 2,
                  sender: a.sender ?? null,
                  expiration: a.expiration
                    ? 'Epoch' in a.expiration
                      ? { Epoch: a.expiration.Epoch }
                      : { None: !0 }
                    : null,
                  gasData: {
                    owner: a.gasConfig.owner ?? null,
                    budget: a.gasConfig.budget?.toString() ?? null,
                    price: a.gasConfig.price?.toString() ?? null,
                    payment:
                      a.gasConfig.payment?.map((a) => ({
                        digest: a.digest,
                        objectId: a.objectId,
                        version: a.version.toString(),
                      })) ?? null,
                  },
                  inputs: a.inputs.map((a) => {
                    if ('Input' === a.kind) {
                      if (kq(k5, a.value)) {
                        let b = kH(k5, a.value);
                        if (b.Object) {
                          if (b.Object.ImmOrOwned)
                            return {
                              Object: {
                                ImmOrOwnedObject: {
                                  objectId: b.Object.ImmOrOwned.objectId,
                                  version: String(b.Object.ImmOrOwned.version),
                                  digest: b.Object.ImmOrOwned.digest,
                                },
                              },
                            };
                          if (b.Object.Shared)
                            return {
                              Object: {
                                SharedObject: {
                                  mutable: b.Object.Shared.mutable ?? null,
                                  initialSharedVersion: b.Object.Shared.initialSharedVersion,
                                  objectId: b.Object.Shared.objectId,
                                },
                              },
                            };
                          if (b.Object.Receiving)
                            return {
                              Object: {
                                Receiving: {
                                  digest: b.Object.Receiving.digest,
                                  version: String(b.Object.Receiving.version),
                                  objectId: b.Object.Receiving.objectId,
                                },
                              },
                            };
                          throw Error('Invalid object input');
                        }
                        return { Pure: { bytes: dU(new Uint8Array(b.Pure)) } };
                      }
                      return 'object' === a.type
                        ? { UnresolvedObject: { objectId: a.value } }
                        : { UnresolvedPure: { value: a.value } };
                    }
                    throw Error('Invalid input');
                  }),
                  commands: a.transactions.map((a) => {
                    switch (a.kind) {
                      case 'MakeMoveVec':
                        return {
                          MakeMoveVec: {
                            type: 'Some' in a.type ? k2.tagToString(a.type.Some) : null,
                            elements: a.objects.map((a) => ll(a)),
                          },
                        };
                      case 'MergeCoins':
                        return {
                          MergeCoins: {
                            destination: ll(a.destination),
                            sources: a.sources.map((a) => ll(a)),
                          },
                        };
                      case 'MoveCall': {
                        let [b, c, d] = a.target.split('::');
                        return {
                          MoveCall: {
                            package: b,
                            module: c,
                            function: d,
                            typeArguments: a.typeArguments,
                            arguments: a.arguments.map((a) => ll(a)),
                          },
                        };
                      }
                      case 'Publish':
                        return {
                          Publish: {
                            modules: a.modules.map((a) => dU(Uint8Array.from(a))),
                            dependencies: a.dependencies,
                          },
                        };
                      case 'SplitCoins':
                        return {
                          SplitCoins: { coin: ll(a.coin), amounts: a.amounts.map((a) => ll(a)) },
                        };
                      case 'TransferObjects':
                        return {
                          TransferObjects: {
                            objects: a.objects.map((a) => ll(a)),
                            address: ll(a.address),
                          },
                        };
                      case 'Upgrade':
                        return {
                          Upgrade: {
                            modules: a.modules.map((a) => dU(Uint8Array.from(a))),
                            dependencies: a.dependencies,
                            package: a.packageId,
                            ticket: ll(a.ticket),
                          },
                        };
                    }
                    throw Error(`Unknown transaction ${Object.keys(a)}`);
                  }),
                })
              )
            );
      }
      static getDigestFromBytes(a) {
        let b, c, d;
        return (
          (c = new Uint8Array(
            (b = Array.from('TransactionData::').map((a) => a.charCodeAt(0))).length + a.length
          )).set(b),
          c.set(a, b.length),
          (d = jP(c, { dkLen: 32 })),
          dS.encode(d)
        );
      }
      get gasConfig() {
        return this.gasData;
      }
      set gasConfig(a) {
        this.gasData = a;
      }
      build({ maxSizeBytes: a = 1 / 0, overrides: b, onlyTransactionKind: c } = {}) {
        let d = this.inputs,
          e = this.commands;
        if (c)
          return mm.TransactionKind.serialize(
            { ProgrammableTransaction: { inputs: d, commands: e } },
            { maxSize: a }
          ).toBytes();
        let f = b?.expiration ?? this.expiration,
          g = b?.sender ?? this.sender,
          h = { ...this.gasData, ...b?.gasConfig, ...b?.gasData };
        if (!g) throw Error('Missing transaction sender');
        if (!h.budget) throw Error('Missing gas budget');
        if (!h.payment) throw Error('Missing gas payment');
        if (!h.price) throw Error('Missing gas price');
        let i = {
          sender: mx(g),
          expiration: f || { None: !0 },
          gasData: {
            payment: h.payment,
            owner: mx(this.gasData.owner ?? g),
            price: BigInt(h.price),
            budget: BigInt(h.budget),
          },
          kind: { ProgrammableTransaction: { inputs: d, commands: e } },
        };
        return mm.TransactionData.serialize({ V1: i }, { maxSize: a }).toBytes();
      }
      addInput(a, b) {
        let c = this.inputs.length;
        return this.inputs.push(b), { Input: c, type: a, $kind: 'Input' };
      }
      getInputUses(a, b) {
        this.mapArguments((c, d) => ('Input' === c.$kind && c.Input === a && b(c, d), c));
      }
      mapArguments(a) {
        for (let b of this.commands)
          switch (b.$kind) {
            case 'MoveCall':
              b.MoveCall.arguments = b.MoveCall.arguments.map((c) => a(c, b));
              break;
            case 'TransferObjects':
              (b.TransferObjects.objects = b.TransferObjects.objects.map((c) => a(c, b))),
                (b.TransferObjects.address = a(b.TransferObjects.address, b));
              break;
            case 'SplitCoins':
              (b.SplitCoins.coin = a(b.SplitCoins.coin, b)),
                (b.SplitCoins.amounts = b.SplitCoins.amounts.map((c) => a(c, b)));
              break;
            case 'MergeCoins':
              (b.MergeCoins.destination = a(b.MergeCoins.destination, b)),
                (b.MergeCoins.sources = b.MergeCoins.sources.map((c) => a(c, b)));
              break;
            case 'MakeMoveVec':
              b.MakeMoveVec.elements = b.MakeMoveVec.elements.map((c) => a(c, b));
              break;
            case 'Upgrade':
              b.Upgrade.ticket = a(b.Upgrade.ticket, b);
              break;
            case '$Intent':
              let c = b.$Intent.inputs;
              for (let [d, e] of ((b.$Intent.inputs = {}), Object.entries(c)))
                b.$Intent.inputs[d] = Array.isArray(e) ? e.map((c) => a(c, b)) : a(e, b);
              break;
            case 'Publish':
              break;
            default:
              throw Error(`Unexpected transaction kind: ${b.$kind}`);
          }
      }
      replaceCommand(a, b) {
        if (!Array.isArray(b)) {
          this.commands[a] = b;
          return;
        }
        let c = b.length - 1;
        this.commands.splice(a, 1, ...b),
          0 !== c &&
            this.mapArguments((b) => {
              switch (b.$kind) {
                case 'Result':
                  b.Result > a && (b.Result += c);
                  break;
                case 'NestedResult':
                  b.NestedResult[0] > a && (b.NestedResult[0] += c);
              }
              return b;
            });
      }
      getDigest() {
        let a = this.build({ onlyTransactionKind: !1 });
        return my.getDigestFromBytes(a);
      }
      snapshot() {
        return kH(kZ, this);
      }
    }
    function mz(a) {
      return 'string' == typeof a
        ? dZ(a)
        : a.Object
        ? a.Object.ImmOrOwnedObject
          ? dZ(a.Object.ImmOrOwnedObject.objectId)
          : a.Object.Receiving
          ? dZ(a.Object.Receiving.objectId)
          : dZ(a.Object.SharedObject.objectId)
        : a.UnresolvedObject
        ? dZ(a.UnresolvedObject.objectId)
        : void 0;
    }
    var mA = (a) => {
        throw TypeError(a);
      },
      mB = (a, b, c) => b.has(a) || mA('Cannot ' + c),
      mC = (a, b, c) => (mB(a, b, 'read from private field'), c ? c.call(a) : b.get(a)),
      mD = (a, b, c) =>
        b.has(a)
          ? mA('Cannot add the same private member more than once')
          : b instanceof WeakSet
          ? b.add(a)
          : b.set(a, c),
      mE = (a, b, c, d) => (mB(a, b, 'write to private field'), d ? d.call(a, c) : b.set(a, c), c),
      mF = (a, b, c) => (mB(a, b, 'access private method'), c);
    let mG = Symbol.for('@iota/transaction');
    function mH(a) {
      return !!a && 'object' == typeof a && !0 === a[mG];
    }
    let mI = { buildPlugins: new Map(), serializationPlugins: new Map() },
      mJ = Symbol.for('@iota/transaction/registry');
    function mK() {
      try {
        let a = globalThis;
        return a[mJ] || (a[mJ] = mI), a[mJ];
      } catch (a) {
        return mI;
      }
    }
    let mL = class a {
      constructor() {
        mD(this, aq),
          mD(this, am),
          mD(this, an),
          mD(this, ao, new Map()),
          mD(this, ap),
          (this.object = (function (a) {
            function b(b) {
              return a(b);
            }
            return (
              (b.system = () => a('0x5')),
              (b.clock = () => a('0x6')),
              (b.random = () => a('0x8')),
              (b.denyList = () => a('0x403')),
              (b.option =
                ({ type: a, value: b }) =>
                (c) =>
                  c.moveCall({
                    typeArguments: [a],
                    target: `0x1::option::${null === b ? 'none' : 'some'}`,
                    arguments: null === b ? [] : [c.object(b)],
                  })),
              b
            );
          })((a) => {
            if ('function' == typeof a) return this.object(a(this));
            if ('object' == typeof a && kq(kO, a)) return a;
            let b = mz(a),
              c = mC(this, ap).inputs.find((a) => b === mz(a));
            return (
              c?.Object?.SharedObject &&
                'object' == typeof a &&
                a.Object?.SharedObject &&
                (c.Object.SharedObject.mutable =
                  c.Object.SharedObject.mutable || a.Object.SharedObject.mutable),
              c
                ? { $kind: 'Input', Input: mC(this, ap).inputs.indexOf(c), type: 'object' }
                : mC(this, ap).addInput(
                    'object',
                    'string' == typeof a
                      ? { $kind: 'UnresolvedObject', UnresolvedObject: { objectId: dZ(a) } }
                      : a
                  )
            );
          }));
        const a = mK();
        mE(this, ap, new my()),
          mE(this, an, [...a.buildPlugins.values()]),
          mE(this, am, [...a.serializationPlugins.values()]);
      }
      static fromKind(b) {
        let c = new a();
        return mE(c, ap, my.fromKindBytes('string' == typeof b ? dT(b) : b)), c;
      }
      static from(b) {
        let c = new a();
        return (
          mH(b)
            ? mE(c, ap, new my(b.getData()))
            : 'string' == typeof b && b.startsWith('{')
            ? mE(c, ap, my.restore(JSON.parse(b)))
            : mE(c, ap, my.fromBytes('string' == typeof b ? dT(b) : b)),
          c
        );
      }
      static registerGlobalSerializationPlugin(a, b) {
        mK().serializationPlugins.set(a, b ?? a);
      }
      static unregisterGlobalSerializationPlugin(a) {
        mK().serializationPlugins.delete(a);
      }
      static registerGlobalBuildPlugin(a, b) {
        mK().buildPlugins.set(a, b ?? a);
      }
      static unregisterGlobalBuildPlugin(a) {
        mK().buildPlugins.delete(a);
      }
      addSerializationPlugin(a) {
        mC(this, am).push(a);
      }
      addBuildPlugin(a) {
        mC(this, an).push(a);
      }
      addIntentResolver(a, b) {
        if (mC(this, ao).has(a) && mC(this, ao).get(a) !== b)
          throw Error(`Intent resolver for ${a} already exists`);
        mC(this, ao).set(a, b);
      }
      setSender(a) {
        mC(this, ap).sender = a;
      }
      setSenderIfNotSet(a) {
        mC(this, ap).sender || (mC(this, ap).sender = a);
      }
      setExpiration(a) {
        mC(this, ap).expiration = a ? kH(kY, a) : null;
      }
      setGasPrice(a) {
        mC(this, ap).gasConfig.price = String(a);
      }
      setGasBudget(a) {
        mC(this, ap).gasConfig.budget = String(a);
      }
      setGasBudgetIfNotSet(a) {
        null == mC(this, ap).gasData.budget && (mC(this, ap).gasConfig.budget = String(a));
      }
      setGasOwner(a) {
        mC(this, ap).gasConfig.owner = a;
      }
      setGasPayment(a) {
        mC(this, ap).gasConfig.payment = a.map((a) => kH(kN, a));
      }
      get blockData() {
        return lj(mC(this, ap).snapshot());
      }
      getData() {
        return mC(this, ap).snapshot();
      }
      get [mG]() {
        return !0;
      }
      get pure() {
        return (
          Object.defineProperty(this, 'pure', {
            enumerable: !1,
            value: (function (a) {
              function b(b, c) {
                if ('string' == typeof b) return a(mw(b).serialize(c));
                if (b instanceof Uint8Array || ke(b)) return a(b);
                throw Error(
                  'tx.pure must be called either a bcs type name, or a serialized bcs value'
                );
              }
              return (
                (b.u8 = (b) => a(mm.U8.serialize(b))),
                (b.u16 = (b) => a(mm.U16.serialize(b))),
                (b.u32 = (b) => a(mm.U32.serialize(b))),
                (b.u64 = (b) => a(mm.U64.serialize(b))),
                (b.u128 = (b) => a(mm.U128.serialize(b))),
                (b.u256 = (b) => a(mm.U256.serialize(b))),
                (b.bool = (b) => a(mm.Bool.serialize(b))),
                (b.string = (b) => a(mm.String.serialize(b))),
                (b.address = (b) => a(mm.Address.serialize(b))),
                (b.id = b.address),
                (b.vector = (b, c) => a(mm.vector(mw(b)).serialize(c))),
                (b.option = (b, c) => a(mm.option(mw(b)).serialize(c))),
                b
              );
            })((a) =>
              ke(a)
                ? mC(this, ap).addInput('pure', { $kind: 'Pure', Pure: { bytes: a.toBase64() } })
                : mC(this, ap).addInput(
                    'pure',
                    kq(kX, a)
                      ? kH(kX, a)
                      : a instanceof Uint8Array
                      ? lw(a)
                      : { $kind: 'UnresolvedPure', UnresolvedPure: { value: a } }
                  )
            ),
          }),
          this.pure
        );
      }
      get gas() {
        return { $kind: 'GasCoin', GasCoin: !0 };
      }
      objectRef(...a) {
        return this.object(lx(...a));
      }
      receivingRef(...a) {
        return this.object(lz(...a));
      }
      sharedObjectRef(...a) {
        return this.object(ly(...a));
      }
      add(a) {
        var b;
        let c, d;
        return 'function' == typeof a
          ? a(this)
          : ((b = mC(this, ap).commands.push(a) - 1),
            (c = []),
            (d = (a) => c[a] ?? (c[a] = { $kind: 'NestedResult', NestedResult: [b, a] })),
            new Proxy(
              { $kind: 'Result', Result: b },
              {
                set() {
                  throw Error(
                    'The transaction result is a proxy, and does not support setting properties directly'
                  );
                },
                get(a, b) {
                  if (b in a) return Reflect.get(a, b);
                  if (b === Symbol.iterator)
                    return function* () {
                      let a = 0;
                      for (;;) yield d(a), a++;
                    };
                  if ('symbol' == typeof b) return;
                  let c = parseInt(b, 10);
                  if (!Number.isNaN(c) && !(c < 0)) return d(c);
                },
              }
            ));
      }
      splitCoins(a, b) {
        return this.add(
          k_.SplitCoins(
            'string' == typeof a ? this.object(a) : mF(this, aq, as).call(this, a),
            b.map((a) =>
              'number' == typeof a || 'bigint' == typeof a || 'string' == typeof a
                ? this.pure.u64(a)
                : mF(this, aq, ar).call(this, a)
            )
          )
        );
      }
      mergeCoins(a, b) {
        return this.add(
          k_.MergeCoins(
            this.object(a),
            b.map((a) => this.object(a))
          )
        );
      }
      publish({ modules: a, dependencies: b }) {
        return this.add(k_.Publish({ modules: a, dependencies: b }));
      }
      upgrade({ modules: a, dependencies: b, package: c, ticket: d }) {
        return this.add(
          k_.Upgrade({ modules: a, dependencies: b, package: c, ticket: this.object(d) })
        );
      }
      moveCall({ arguments: a, ...b }) {
        return this.add(
          k_.MoveCall({ ...b, arguments: a?.map((a) => mF(this, aq, ar).call(this, a)) })
        );
      }
      transferObjects(a, b) {
        return this.add(
          k_.TransferObjects(
            a.map((a) => this.object(a)),
            'string' == typeof b ? this.pure.address(b) : mF(this, aq, ar).call(this, b)
          )
        );
      }
      makeMoveVec({ type: a, elements: b }) {
        return this.add(k_.MakeMoveVec({ type: a, elements: b.map((a) => this.object(a)) }));
      }
      serialize() {
        return JSON.stringify(lj(mC(this, ap).snapshot()));
      }
      async toJSON(a = {}) {
        return (
          await this.prepareForSerialization(a),
          JSON.stringify(
            kH(lv, mC(this, ap).snapshot()),
            (a, b) => ('bigint' == typeof b ? b.toString() : b),
            2
          )
        );
      }
      async sign(a) {
        let { signer: b, ...c } = a,
          d = await this.build(c);
        return b.signTransaction(d);
      }
      async build(a = {}) {
        return (
          await this.prepareForSerialization(a),
          await mF(this, aq, at).call(this, a),
          mC(this, ap).build({
            maxSizeBytes: a.maxSizeBytes,
            onlyTransactionKind: a.onlyTransactionKind,
          })
        );
      }
      async getDigest(a = {}) {
        return await mF(this, aq, at).call(this, a), mC(this, ap).getDigest();
      }
      async prepareForSerialization(a) {
        let b = new Set();
        for (let a of mC(this, ap).commands) a.$Intent && b.add(a.$Intent.name);
        let c = [...mC(this, am)];
        for (let d of b)
          if (!a.supportedIntents?.includes(d)) {
            if (!mC(this, ao).has(d)) throw Error(`Missing intent resolver for ${d}`);
            c.push(mC(this, ao).get(d));
          }
        await mF(this, aq, au).call(this, c, a);
      }
    };
    (am = new WeakMap()),
      (an = new WeakMap()),
      (ao = new WeakMap()),
      (ap = new WeakMap()),
      (aq = new WeakSet()),
      (ar = function (a) {
        return ke(a) ? this.pure(a) : mF(this, aq, as).call(this, a);
      }),
      (as = function (a) {
        return 'function' == typeof a ? kH(kO, a(this)) : kH(kO, a);
      }),
      (at = async function (a) {
        if (!a.onlyTransactionKind && !mC(this, ap).sender)
          throw Error('Missing transaction sender');
        await mF(this, aq, au).call(this, [...mC(this, an), mo], a);
      }),
      (au = async function (a, b) {
        let c = (d) => {
          if (d >= a.length) return () => {};
          let e = a[d];
          return async () => {
            let a = c(d + 1),
              f = !1,
              g = !1;
            if (
              (await e(mC(this, ap), b, async () => {
                if (f) throw Error(`next() was call multiple times in TransactionPlugin ${d}`);
                (f = !0), await a(), (g = !0);
              }),
              !f)
            )
              throw Error(`next() was not called in TransactionPlugin ${d}`);
            if (!g) throw Error(`next() was not awaited in TransactionPlugin ${d}`);
          };
        };
        await c(0)();
      });
    let mM = {
      '-32700': 'ParseError',
      '-32701': 'OversizedRequest',
      '-32702': 'OversizedResponse',
      '-32600': 'InvalidRequest',
      '-32601': 'MethodNotFound',
      '-32602': 'InvalidParams',
      '-32603': 'InternalError',
      '-32604': 'ServerBusy',
      '-32000': 'CallExecutionFailed',
      '-32001': 'UnknownError',
      '-32003': 'SubscriptionClosed',
      '-32004': 'SubscriptionClosedWithError',
      '-32005': 'BatchesNotSupported',
      '-32006': 'TooManySubscriptions',
      '-32050': 'TransientError',
      '-32002': 'TransactionExecutionClientError',
    };
    class mN extends Error {}
    class mO extends mN {
      constructor(a, b) {
        super(a), (this.code = b), (this.type = mM[b] ?? 'ServerError');
      }
    }
    class mP extends mN {
      constructor(a, b, c) {
        super(a), (this.status = b), (this.statusText = c);
      }
    }
    var mQ = (a) => {
        throw TypeError(a);
      },
      mR = (a, b, c) => b.has(a) || mQ('Cannot ' + c),
      mS = (a, b, c) => (mR(a, b, 'read from private field'), c ? c.call(a) : b.get(a)),
      mT = (a, b, c) =>
        b.has(a)
          ? mQ('Cannot add the same private member more than once')
          : b instanceof WeakSet
          ? b.add(a)
          : b.set(a, c),
      mU = (a, b, c, d) => (mR(a, b, 'write to private field'), d ? d.call(a, c) : b.set(a, c), c),
      mV = (a, b, c) => (mR(a, b, 'access private method'), c);
    let mW = {
      WebSocketConstructor: 'undefined' != typeof WebSocket ? WebSocket : void 0,
      callTimeout: 3e4,
      reconnectTimeout: 3e3,
      maxReconnects: 5,
    };
    class mX {
      constructor(a, b = {}) {
        if (
          (mT(this, aB),
          mT(this, av, 0),
          mT(this, aw, 0),
          mT(this, ax, null),
          mT(this, ay, null),
          mT(this, az, new Set()),
          mT(this, aA, new Map()),
          (this.endpoint = a),
          (this.options = { ...mW, ...b }),
          !this.options.WebSocketConstructor)
        )
          throw Error('Missing WebSocket constructor');
        this.endpoint.startsWith('http') &&
          (this.endpoint = (function (a) {
            let b = new URL(a);
            return (b.protocol = b.protocol.replace('http', 'ws')), b.toString();
          })(this.endpoint));
      }
      async makeRequest(a, b) {
        let c = await mV(this, aB, aC).call(this);
        return new Promise((d, e) => {
          mU(this, av, mS(this, av) + 1),
            mS(this, aA).set(mS(this, av), {
              resolve: d,
              reject: e,
              timeout: setTimeout(() => {
                mS(this, aA).delete(mS(this, av)), e(Error(`Request timeout: ${a}`));
              }, this.options.callTimeout),
            }),
            c.send(JSON.stringify({ jsonrpc: '2.0', id: mS(this, av), method: a, params: b }));
        }).then(({ error: a, result: b }) => {
          if (a) throw new mO(a.message, a.code);
          return b;
        });
      }
      async subscribe(a) {
        let b = new mY(a);
        return mS(this, az).add(b), await b.subscribe(this), () => b.unsubscribe(this);
      }
    }
    (av = new WeakMap()),
      (aw = new WeakMap()),
      (ax = new WeakMap()),
      (ay = new WeakMap()),
      (az = new WeakMap()),
      (aA = new WeakMap()),
      (aB = new WeakSet()),
      (aC = function () {
        return (
          mS(this, ay) ||
            mU(
              this,
              ay,
              new Promise((a) => {
                mS(this, ax)?.close(),
                  mU(this, ax, new this.options.WebSocketConstructor(this.endpoint)),
                  mS(this, ax).addEventListener('open', () => {
                    mU(this, aw, 0), a(mS(this, ax));
                  }),
                  mS(this, ax).addEventListener('close', () => {
                    let a, b, c, d;
                    ((a = this),
                    (b = aw),
                    {
                      set _(value) {
                        mU(a, b, value, c);
                      },
                      get _() {
                        return mS(a, b, d);
                      },
                    })._++,
                      mS(this, aw) <= this.options.maxReconnects &&
                        setTimeout(() => {
                          mV(this, aB, aD).call(this);
                        }, this.options.reconnectTimeout);
                  }),
                  mS(this, ax).addEventListener('message', ({ data: a }) => {
                    let b;
                    try {
                      b = JSON.parse(a);
                    } catch (b) {
                      console.error(Error(`Failed to parse RPC message: ${a}`, { cause: b }));
                      return;
                    }
                    if ('id' in b && null != b.id && mS(this, aA).has(b.id)) {
                      let { resolve: a, timeout: c } = mS(this, aA).get(b.id);
                      clearTimeout(c), a(b);
                    } else if ('params' in b) {
                      let { params: a } = b;
                      mS(this, az).forEach((b) => {
                        b.subscriptionId === a.subscription &&
                          a.subscription === b.subscriptionId &&
                          b.onMessage(a.result);
                      });
                    }
                  });
              })
            ),
          mS(this, ay)
        );
      }),
      (aD = async function () {
        return (
          mS(this, ax)?.close(),
          mU(this, ay, null),
          Promise.allSettled([...mS(this, az)].map((a) => a.subscribe(this)))
        );
      });
    class mY {
      constructor(a) {
        (this.subscriptionId = null), (this.subscribed = !1), (this.input = a);
      }
      onMessage(a) {
        this.subscribed && this.input.onMessage(a);
      }
      async unsubscribe(a) {
        let { subscriptionId: b } = this;
        return (
          (this.subscribed = !1),
          null != b && ((this.subscriptionId = null), a.makeRequest(this.input.unsubscribe, [b]))
        );
      }
      async subscribe(a) {
        (this.subscriptionId = null), (this.subscribed = !0);
        let b = await a.makeRequest(this.input.method, this.input.params);
        this.subscribed && (this.subscriptionId = b);
      }
    }
    var mZ = (a) => {
        throw TypeError(a);
      },
      m$ = (a, b, c) => b.has(a) || mZ('Cannot ' + c),
      m_ = (a, b, c) => (m$(a, b, 'read from private field'), c ? c.call(a) : b.get(a)),
      m0 = (a, b, c) =>
        b.has(a)
          ? mZ('Cannot add the same private member more than once')
          : b instanceof WeakSet
          ? b.add(a)
          : b.set(a, c),
      m1 = (a, b, c, d) => (m$(a, b, 'write to private field'), d ? d.call(a, c) : b.set(a, c), c);
    class m2 {
      constructor(a) {
        m0(this, aH), m0(this, aE, 0), m0(this, aF), m0(this, aG), m1(this, aF, a);
      }
      fetch(a, b) {
        let c = m_(this, aF).fetch ?? fetch;
        if (!c)
          throw Error(
            'The current environment does not support fetch, you can provide a fetch implementation in the options for IotaHTTPTransport.'
          );
        return c(a, b);
      }
      async request(a) {
        m1(this, aE, m_(this, aE) + 1);
        let b = await this.fetch(m_(this, aF).rpc?.url ?? m_(this, aF).url, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Client-Sdk-Type': 'typescript',
            'Client-Sdk-Version': '1.7.0',
            'Client-Target-Api-Version': '1.12.0-alpha',
            ...m_(this, aF).rpc?.headers,
          },
          body: JSON.stringify({
            jsonrpc: '2.0',
            id: m_(this, aE),
            method: a.method,
            params: a.params,
          }),
        });
        if (!b.ok) throw new mP(`Unexpected status code: ${b.status}`, b.status, b.statusText);
        let c = await b.json();
        if ('error' in c && null != c.error) throw new mO(c.error.message, c.error.code);
        return c.result;
      }
      async subscribe(a) {
        let b,
          c,
          d = await ((b = aH), (c = aI), m$(this, b, 'access private method'), c)
            .call(this)
            .subscribe(a);
        return async () => !!(await d());
      }
    }
    (aE = new WeakMap()),
      (aF = new WeakMap()),
      (aG = new WeakMap()),
      (aH = new WeakSet()),
      (aI = function () {
        if (!m_(this, aG)) {
          let a = m_(this, aF).WebSocketConstructor ?? WebSocket;
          if (!a)
            throw Error(
              'The current environment does not support WebSocket, you can provide a WebSocketConstructor in the options for IotaHTTPTransport.'
            );
          m1(
            this,
            aG,
            new mX(m_(this, aF).websocket?.url ?? m_(this, aF).url, {
              WebSocketConstructor: a,
              ...m_(this, aF).websocket,
            })
          );
        }
        return m_(this, aG);
      });
    let m3 = Symbol.for('@iota/IotaClient');
    class m4 {
      get [m3]() {
        return !0;
      }
      constructor(a) {
        this.transport = a.transport ?? new m2({ url: a.url });
      }
      async getRpcApiVersion() {
        return (await this.transport.request({ method: 'rpc.discover', params: [] })).info.version;
      }
      async getCoins(a) {
        if (!a.owner || !dY(dZ(a.owner))) throw Error('Invalid IOTA address');
        return await this.transport.request({
          method: 'iotax_getCoins',
          params: [a.owner, a.coinType, a.cursor, a.limit],
        });
      }
      async getAllCoins(a) {
        if (!a.owner || !dY(dZ(a.owner))) throw Error('Invalid IOTA address');
        return await this.transport.request({
          method: 'iotax_getAllCoins',
          params: [a.owner, a.cursor, a.limit],
        });
      }
      async getBalance(a) {
        if (!a.owner || !dY(dZ(a.owner))) throw Error('Invalid IOTA address');
        return await this.transport.request({
          method: 'iotax_getBalance',
          params: [a.owner, a.coinType],
        });
      }
      async getAllBalances(a) {
        if (!a.owner || !dY(dZ(a.owner))) throw Error('Invalid IOTA address');
        return await this.transport.request({ method: 'iotax_getAllBalances', params: [a.owner] });
      }
      async getCoinMetadata(a) {
        return await this.transport.request({
          method: 'iotax_getCoinMetadata',
          params: [a.coinType],
        });
      }
      async getTotalSupply(a) {
        return await this.transport.request({
          method: 'iotax_getTotalSupply',
          params: [a.coinType],
        });
      }
      async getCirculatingSupply() {
        return await this.transport.request({ method: 'iotax_getCirculatingSupply', params: [] });
      }
      async call(a, b) {
        return await this.transport.request({ method: a, params: b });
      }
      async getMoveFunctionArgTypes(a) {
        return await this.transport.request({
          method: 'iota_getMoveFunctionArgTypes',
          params: [a.package, a.module, a.function],
        });
      }
      async getNormalizedMoveModulesByPackage(a) {
        return await this.transport.request({
          method: 'iota_getNormalizedMoveModulesByPackage',
          params: [a.package],
        });
      }
      async getNormalizedMoveModule(a) {
        return await this.transport.request({
          method: 'iota_getNormalizedMoveModule',
          params: [a.package, a.module],
        });
      }
      async getNormalizedMoveFunction(a) {
        return await this.transport.request({
          method: 'iota_getNormalizedMoveFunction',
          params: [a.package, a.module, a.function],
        });
      }
      async getNormalizedMoveStruct(a) {
        return await this.transport.request({
          method: 'iota_getNormalizedMoveStruct',
          params: [a.package, a.module, a.struct],
        });
      }
      async getOwnedObjects(a) {
        if (!a.owner || !dY(dZ(a.owner))) throw Error('Invalid IOTA address');
        return await this.transport.request({
          method: 'iotax_getOwnedObjects',
          params: [a.owner, { filter: a.filter, options: a.options }, a.cursor, a.limit],
        });
      }
      async getObject(a) {
        if (!a.id || !dY(d$(a.id))) throw Error('Invalid IOTA Object id');
        return await this.transport.request({
          method: 'iota_getObject',
          params: [a.id, a.options],
        });
      }
      async tryGetPastObject(a) {
        return await this.transport.request({
          method: 'iota_tryGetPastObject',
          params: [a.id, a.version, a.options],
        });
      }
      async multiGetObjects(a) {
        if (
          (a.ids.forEach((a) => {
            if (!a || !dY(d$(a))) throw Error(`Invalid IOTA Object id ${a}`);
          }),
          a.ids.length !== new Set(a.ids).size)
        )
          throw Error(`Duplicate object ids in batch call ${a.ids}`);
        return await this.transport.request({
          method: 'iota_multiGetObjects',
          params: [a.ids, a.options],
        });
      }
      async queryTransactionBlocks(a) {
        return await this.transport.request({
          method: 'iotax_queryTransactionBlocks',
          params: [
            { filter: a.filter, options: a.options },
            a.cursor,
            a.limit,
            'descending' === (a.order || 'descending'),
          ],
        });
      }
      async getTransactionBlock(a) {
        if (!dX(a.digest)) throw Error('Invalid Transaction digest');
        return await this.transport.request({
          method: 'iota_getTransactionBlock',
          params: [a.digest, a.options],
        });
      }
      async multiGetTransactionBlocks(a) {
        if (
          (a.digests.forEach((a) => {
            if (!dX(a)) throw Error(`Invalid Transaction digest ${a}`);
          }),
          a.digests.length !== new Set(a.digests).size)
        )
          throw Error(`Duplicate digests in batch call ${a.digests}`);
        return await this.transport.request({
          method: 'iota_multiGetTransactionBlocks',
          params: [a.digests, a.options],
        });
      }
      async executeTransactionBlock({ transactionBlock: a, signature: b, options: c }) {
        return await this.transport.request({
          method: 'iota_executeTransactionBlock',
          params: ['string' == typeof a ? a : dU(a), Array.isArray(b) ? b : [b], c],
        });
      }
      async signAndExecuteTransaction({ transaction: a, signer: b, ...c }) {
        let d;
        a instanceof Uint8Array
          ? (d = a)
          : (a.setSenderIfNotSet(b.toIotaAddress()), (d = await a.build({ client: this })));
        let { signature: e, bytes: f } = await b.signTransaction(d);
        return this.executeTransactionBlock({ transactionBlock: f, signature: e, ...c });
      }
      async getTotalTransactionBlocks() {
        return BigInt(
          await this.transport.request({ method: 'iota_getTotalTransactionBlocks', params: [] })
        );
      }
      async getReferenceGasPrice() {
        return BigInt(
          await this.transport.request({ method: 'iotax_getReferenceGasPrice', params: [] })
        );
      }
      async getStakes(a) {
        if (!a.owner || !dY(dZ(a.owner))) throw Error('Invalid IOTA address');
        return await this.transport.request({ method: 'iotax_getStakes', params: [a.owner] });
      }
      async getTimelockedStakes(a) {
        if (!a.owner || !dY(dZ(a.owner))) throw Error('Invalid IOTA address');
        return await this.transport.request({
          method: 'iotax_getTimelockedStakes',
          params: [a.owner],
        });
      }
      async getStakesByIds(a) {
        return (
          a.stakedIotaIds.forEach((a) => {
            if (!a || !dY(d$(a))) throw Error(`Invalid IOTA Stake id ${a}`);
          }),
          await this.transport.request({
            method: 'iotax_getStakesByIds',
            params: [a.stakedIotaIds],
          })
        );
      }
      async getTimelockedStakesByIds(a) {
        return (
          a.timelockedStakedIotaIds.forEach((a) => {
            if (!a || !dY(d$(a))) throw Error(`Invalid IOTA Timelocked Stake id ${a}`);
          }),
          await this.transport.request({
            method: 'iotax_getTimelockedStakesByIds',
            params: [a.timelockedStakedIotaIds],
          })
        );
      }
      async getLatestIotaSystemStateV1() {
        return await this.transport.request({
          method: 'iotax_getLatestIotaSystemState',
          params: [],
        });
      }
      async getLatestIotaSystemStateV2() {
        return await this.transport.request({
          method: 'iotax_getLatestIotaSystemStateV2',
          params: [],
        });
      }
      async getLatestIotaSystemState() {
        let a =
          Number((await this.getProtocolConfig()).maxSupportedProtocolVersion) >= 5
            ? await this.getLatestIotaSystemStateV2()
            : { V1: await this.getLatestIotaSystemStateV1() };
        return 'V2' in a
          ? {
              ...a.V2,
              committeeMembers: a.V2.committeeMembers.map((b) => a.V2.activeValidators[Number(b)]),
            }
          : {
              ...a.V1,
              committeeMembers: a.V1.activeValidators,
              safeModeComputationCharges: a.V1.safeModeComputationRewards,
              safeModeComputationChargesBurned: a.V1.safeModeComputationRewards,
            };
      }
      async queryEvents(a) {
        return await this.transport.request({
          method: 'iotax_queryEvents',
          params: [a.query, a.cursor, a.limit, 'descending' === (a.order || 'descending')],
        });
      }
      async subscribeEvent(a) {
        return this.transport.subscribe({
          method: 'iotax_subscribeEvent',
          unsubscribe: 'iotax_unsubscribeEvent',
          params: [a.filter],
          onMessage: a.onMessage,
        });
      }
      async subscribeTransaction(a) {
        return this.transport.subscribe({
          method: 'iotax_subscribeTransaction',
          unsubscribe: 'iotax_unsubscribeTransaction',
          params: [a.filter],
          onMessage: a.onMessage,
        });
      }
      async devInspectTransactionBlock(a) {
        let b;
        if (mH(a.transactionBlock))
          a.transactionBlock.setSenderIfNotSet(a.sender),
            (b = dU(await a.transactionBlock.build({ client: this, onlyTransactionKind: !0 })));
        else if ('string' == typeof a.transactionBlock) b = a.transactionBlock;
        else if (a.transactionBlock instanceof Uint8Array) b = dU(a.transactionBlock);
        else throw Error('Unknown transaction block format.');
        return await this.transport.request({
          method: 'iota_devInspectTransactionBlock',
          params: [a.sender, b, a.gasPrice?.toString(), a.epoch],
        });
      }
      async dryRunTransactionBlock(a) {
        return await this.transport.request({
          method: 'iota_dryRunTransactionBlock',
          params: [
            'string' == typeof a.transactionBlock ? a.transactionBlock : dU(a.transactionBlock),
          ],
        });
      }
      async getDynamicFields(a) {
        if (!a.parentId || !dY(d$(a.parentId))) throw Error('Invalid IOTA Object id');
        return await this.transport.request({
          method: 'iotax_getDynamicFields',
          params: [a.parentId, a.cursor, a.limit],
        });
      }
      async getDynamicFieldObject(a) {
        return await this.transport.request({
          method: 'iotax_getDynamicFieldObjectV2',
          params: [a.parentObjectId, a.name, a.options],
        });
      }
      async getDynamicFieldObjectV1(a) {
        return await this.transport.request({
          method: 'iotax_getDynamicFieldObject',
          params: [a.parentId, a.name],
        });
      }
      async getDynamicFieldObjectV2(a) {
        return await this.transport.request({
          method: 'iotax_getDynamicFieldObjectV2',
          params: [a.parentObjectId, a.name, a.options],
        });
      }
      async getLatestCheckpointSequenceNumber() {
        return String(
          await this.transport.request({
            method: 'iota_getLatestCheckpointSequenceNumber',
            params: [],
          })
        );
      }
      async getCheckpoint(a) {
        return await this.transport.request({ method: 'iota_getCheckpoint', params: [a.id] });
      }
      async getCheckpoints(a) {
        return await this.transport.request({
          method: 'iota_getCheckpoints',
          params: [a.cursor, a?.limit, a.descendingOrder],
        });
      }
      async getCommitteeInfo(a) {
        return await this.transport.request({
          method: 'iotax_getCommitteeInfo',
          params: [a?.epoch],
        });
      }
      async getNetworkMetrics() {
        return await this.transport.request({ method: 'iotax_getNetworkMetrics', params: [] });
      }
      async getAddressMetrics() {
        return await this.transport.request({
          method: 'iotax_getLatestAddressMetrics',
          params: [],
        });
      }
      async getEpochMetrics(a) {
        return await this.transport.request({
          method: 'iotax_getEpochMetrics',
          params: [a?.cursor, a?.limit, a?.descendingOrder],
        });
      }
      async getAllEpochAddressMetrics(a) {
        return await this.transport.request({
          method: 'iotax_getAllEpochAddressMetrics',
          params: [a?.descendingOrder],
        });
      }
      async getCheckpointAddressMetrics(a) {
        return await this.transport.request({
          method: 'iotax_getCheckpointAddressMetrics',
          params: [a?.checkpoint],
        });
      }
      async getEpochs(a) {
        return await this.transport.request({
          method: 'iotax_getEpochs',
          params: [a?.cursor, a?.limit, a?.descendingOrder],
        });
      }
      async getMoveCallMetrics() {
        return await this.transport.request({ method: 'iotax_getMoveCallMetrics', params: [] });
      }
      async getCurrentEpoch() {
        return await this.transport.request({ method: 'iotax_getCurrentEpoch', params: [] });
      }
      async getTotalTransactions() {
        return String(
          await this.transport.request({ method: 'iotax_getTotalTransactions', params: [] })
        );
      }
      async getValidatorsApy() {
        return await this.transport.request({ method: 'iotax_getValidatorsApy', params: [] });
      }
      async getChainIdentifier() {
        return await this.transport.request({ method: 'iota_getChainIdentifier', params: [] });
      }
      async getProtocolConfig(a) {
        return await this.transport.request({
          method: 'iota_getProtocolConfig',
          params: [a?.version],
        });
      }
      async getParticipationMetrics() {
        return await this.transport.request({
          method: 'iotax_getParticipationMetrics',
          params: [],
        });
      }
      async waitForTransaction({
        signal: a,
        timeout: b = 6e4,
        pollInterval: c = 2e3,
        waitMode: d,
        ...e
      }) {
        let f = AbortSignal.timeout(b),
          g = new Promise((a, b) => {
            f.addEventListener('abort', () => b(f.reason));
          });
        for (g.catch(() => {}); !f.aborted; ) {
          a?.throwIfAborted();
          let b = async () => {
            await Promise.race([new Promise((a) => setTimeout(a, c)), g]);
          };
          try {
            if ('indexed-on-node' === d) {
              if (await this.isTransactionIndexedOnNode({ digest: e.digest }))
                return await this.getTransactionBlock(e);
            } else {
              if ('checkpoint' !== d) return await this.getTransactionBlock(e);
              let a = await this.getTransactionBlock(e);
              if (a.checkpoint) return a;
            }
            await b();
          } catch (a) {
            await b();
          }
        }
        throw (f.throwIfAborted(), Error('Unexpected error while waiting for transaction block.'));
      }
      async iotaNamesLookup(a) {
        return await this.transport.request({ method: 'iotax_iotaNamesLookup', params: [a.name] });
      }
      async iotaNamesReverseLookup(a) {
        return await this.transport.request({
          method: 'iotax_iotaNamesReverseLookup',
          params: [a.address],
        });
      }
      async iotaNamesFindAllRegistrationNFTs(a) {
        return await this.transport.request({
          method: 'iotax_iotaNamesFindAllRegistrationNFTs',
          params: [a.address, a.cursor, a.limit, a.options],
        });
      }
      async isTransactionIndexedOnNode(a) {
        return await this.transport.request({
          method: 'iota_isTransactionIndexedOnNode',
          params: [a.digest],
        });
      }
      async view(a) {
        return await this.transport.request({
          method: 'iota_view',
          params: [a.functionName, a.typeArgs, a.callArgs],
        });
      }
    }
    function m5(a) {
      return 9 === a || 32 === a;
    }
    let m6 = /[\x00-\x1f\x22\x5c\x7f-\x9f]/g;
    function m7(a) {
      return m8[a.charCodeAt(0)];
    }
    let m8 = [
        '\\u0000',
        '\\u0001',
        '\\u0002',
        '\\u0003',
        '\\u0004',
        '\\u0005',
        '\\u0006',
        '\\u0007',
        '\\b',
        '\\t',
        '\\n',
        '\\u000B',
        '\\f',
        '\\r',
        '\\u000E',
        '\\u000F',
        '\\u0010',
        '\\u0011',
        '\\u0012',
        '\\u0013',
        '\\u0014',
        '\\u0015',
        '\\u0016',
        '\\u0017',
        '\\u0018',
        '\\u0019',
        '\\u001A',
        '\\u001B',
        '\\u001C',
        '\\u001D',
        '\\u001E',
        '\\u001F',
        '',
        '',
        '\\"',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '\\\\',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '\\u007F',
        '\\u0080',
        '\\u0081',
        '\\u0082',
        '\\u0083',
        '\\u0084',
        '\\u0085',
        '\\u0086',
        '\\u0087',
        '\\u0088',
        '\\u0089',
        '\\u008A',
        '\\u008B',
        '\\u008C',
        '\\u008D',
        '\\u008E',
        '\\u008F',
        '\\u0090',
        '\\u0091',
        '\\u0092',
        '\\u0093',
        '\\u0094',
        '\\u0095',
        '\\u0096',
        '\\u0097',
        '\\u0098',
        '\\u0099',
        '\\u009A',
        '\\u009B',
        '\\u009C',
        '\\u009D',
        '\\u009E',
        '\\u009F',
      ],
      m9 = {
        Name: [],
        Document: ['definitions'],
        OperationDefinition: [
          'description',
          'name',
          'variableDefinitions',
          'directives',
          'selectionSet',
        ],
        VariableDefinition: ['description', 'variable', 'type', 'defaultValue', 'directives'],
        Variable: ['name'],
        SelectionSet: ['selections'],
        Field: ['alias', 'name', 'arguments', 'directives', 'selectionSet'],
        Argument: ['name', 'value'],
        FragmentSpread: ['name', 'directives'],
        InlineFragment: ['typeCondition', 'directives', 'selectionSet'],
        FragmentDefinition: [
          'description',
          'name',
          'variableDefinitions',
          'typeCondition',
          'directives',
          'selectionSet',
        ],
        IntValue: [],
        FloatValue: [],
        StringValue: [],
        BooleanValue: [],
        NullValue: [],
        EnumValue: [],
        ListValue: ['values'],
        ObjectValue: ['fields'],
        ObjectField: ['name', 'value'],
        Directive: ['name', 'arguments'],
        NamedType: ['name'],
        ListType: ['type'],
        NonNullType: ['type'],
        SchemaDefinition: ['description', 'directives', 'operationTypes'],
        OperationTypeDefinition: ['type'],
        ScalarTypeDefinition: ['description', 'name', 'directives'],
        ObjectTypeDefinition: ['description', 'name', 'interfaces', 'directives', 'fields'],
        FieldDefinition: ['description', 'name', 'arguments', 'type', 'directives'],
        InputValueDefinition: ['description', 'name', 'type', 'defaultValue', 'directives'],
        InterfaceTypeDefinition: ['description', 'name', 'interfaces', 'directives', 'fields'],
        UnionTypeDefinition: ['description', 'name', 'directives', 'types'],
        EnumTypeDefinition: ['description', 'name', 'directives', 'values'],
        EnumValueDefinition: ['description', 'name', 'directives'],
        InputObjectTypeDefinition: ['description', 'name', 'directives', 'fields'],
        DirectiveDefinition: ['description', 'name', 'arguments', 'locations'],
        SchemaExtension: ['directives', 'operationTypes'],
        ScalarTypeExtension: ['name', 'directives'],
        ObjectTypeExtension: ['name', 'interfaces', 'directives', 'fields'],
        InterfaceTypeExtension: ['name', 'interfaces', 'directives', 'fields'],
        UnionTypeExtension: ['name', 'directives', 'types'],
        EnumTypeExtension: ['name', 'directives', 'values'],
        InputObjectTypeExtension: ['name', 'directives', 'fields'],
        TypeCoordinate: ['name'],
        MemberCoordinate: ['name', 'memberName'],
        ArgumentCoordinate: ['name', 'fieldName', 'argumentName'],
        DirectiveCoordinate: ['name'],
        DirectiveArgumentCoordinate: ['name', 'argumentName'],
      },
      na = new Set(Object.keys(m9));
    function nb(a) {
      let b = null == a ? void 0 : a.kind;
      return 'string' == typeof b && na.has(b);
    }
    ((P = aJ || (aJ = {})).QUERY = 'query'),
      (P.MUTATION = 'mutation'),
      (P.SUBSCRIPTION = 'subscription'),
      ((Q = aK || (aK = {})).NAME = 'Name'),
      (Q.DOCUMENT = 'Document'),
      (Q.OPERATION_DEFINITION = 'OperationDefinition'),
      (Q.VARIABLE_DEFINITION = 'VariableDefinition'),
      (Q.SELECTION_SET = 'SelectionSet'),
      (Q.FIELD = 'Field'),
      (Q.ARGUMENT = 'Argument'),
      (Q.FRAGMENT_SPREAD = 'FragmentSpread'),
      (Q.INLINE_FRAGMENT = 'InlineFragment'),
      (Q.FRAGMENT_DEFINITION = 'FragmentDefinition'),
      (Q.VARIABLE = 'Variable'),
      (Q.INT = 'IntValue'),
      (Q.FLOAT = 'FloatValue'),
      (Q.STRING = 'StringValue'),
      (Q.BOOLEAN = 'BooleanValue'),
      (Q.NULL = 'NullValue'),
      (Q.ENUM = 'EnumValue'),
      (Q.LIST = 'ListValue'),
      (Q.OBJECT = 'ObjectValue'),
      (Q.OBJECT_FIELD = 'ObjectField'),
      (Q.DIRECTIVE = 'Directive'),
      (Q.NAMED_TYPE = 'NamedType'),
      (Q.LIST_TYPE = 'ListType'),
      (Q.NON_NULL_TYPE = 'NonNullType'),
      (Q.SCHEMA_DEFINITION = 'SchemaDefinition'),
      (Q.OPERATION_TYPE_DEFINITION = 'OperationTypeDefinition'),
      (Q.SCALAR_TYPE_DEFINITION = 'ScalarTypeDefinition'),
      (Q.OBJECT_TYPE_DEFINITION = 'ObjectTypeDefinition'),
      (Q.FIELD_DEFINITION = 'FieldDefinition'),
      (Q.INPUT_VALUE_DEFINITION = 'InputValueDefinition'),
      (Q.INTERFACE_TYPE_DEFINITION = 'InterfaceTypeDefinition'),
      (Q.UNION_TYPE_DEFINITION = 'UnionTypeDefinition'),
      (Q.ENUM_TYPE_DEFINITION = 'EnumTypeDefinition'),
      (Q.ENUM_VALUE_DEFINITION = 'EnumValueDefinition'),
      (Q.INPUT_OBJECT_TYPE_DEFINITION = 'InputObjectTypeDefinition'),
      (Q.DIRECTIVE_DEFINITION = 'DirectiveDefinition'),
      (Q.SCHEMA_EXTENSION = 'SchemaExtension'),
      (Q.SCALAR_TYPE_EXTENSION = 'ScalarTypeExtension'),
      (Q.OBJECT_TYPE_EXTENSION = 'ObjectTypeExtension'),
      (Q.INTERFACE_TYPE_EXTENSION = 'InterfaceTypeExtension'),
      (Q.UNION_TYPE_EXTENSION = 'UnionTypeExtension'),
      (Q.ENUM_TYPE_EXTENSION = 'EnumTypeExtension'),
      (Q.INPUT_OBJECT_TYPE_EXTENSION = 'InputObjectTypeExtension'),
      (Q.TYPE_COORDINATE = 'TypeCoordinate'),
      (Q.MEMBER_COORDINATE = 'MemberCoordinate'),
      (Q.ARGUMENT_COORDINATE = 'ArgumentCoordinate'),
      (Q.DIRECTIVE_COORDINATE = 'DirectiveCoordinate'),
      (Q.DIRECTIVE_ARGUMENT_COORDINATE = 'DirectiveArgumentCoordinate');
    let nc = Object.freeze({}),
      nd = {
        Name: { leave: (a) => a.value },
        Variable: { leave: (a) => '$' + a.name },
        Document: { leave: (a) => ne(a.definitions, '\n\n') },
        OperationDefinition: {
          leave(a) {
            let b = ni(a.variableDefinitions)
                ? ng('(\n', ne(a.variableDefinitions, '\n'), '\n)')
                : ng('(', ne(a.variableDefinitions, ', '), ')'),
              c =
                ng('', a.description, '\n') +
                ne([a.operation, ne([a.name, b]), ne(a.directives, ' ')], ' ');
            return ('query' === c ? '' : c + ' ') + a.selectionSet;
          },
        },
        VariableDefinition: {
          leave: ({ variable: a, type: b, defaultValue: c, directives: d, description: e }) =>
            ng('', e, '\n') + a + ': ' + b + ng(' = ', c) + ng(' ', ne(d, ' ')),
        },
        SelectionSet: { leave: ({ selections: a }) => nf(a) },
        Field: {
          leave({ alias: a, name: b, arguments: c, directives: d, selectionSet: e }) {
            let f = ng('', a, ': ') + b,
              g = f + ng('(', ne(c, ', '), ')');
            return (
              g.length > 80 && (g = f + ng('(\n', nh(ne(c, '\n')), '\n)')),
              ne([g, ne(d, ' '), e], ' ')
            );
          },
        },
        Argument: { leave: ({ name: a, value: b }) => a + ': ' + b },
        FragmentSpread: { leave: ({ name: a, directives: b }) => '...' + a + ng(' ', ne(b, ' ')) },
        InlineFragment: {
          leave: ({ typeCondition: a, directives: b, selectionSet: c }) =>
            ne(['...', ng('on ', a), ne(b, ' '), c], ' '),
        },
        FragmentDefinition: {
          leave: ({
            name: a,
            typeCondition: b,
            variableDefinitions: c,
            directives: d,
            selectionSet: e,
            description: f,
          }) =>
            ng('', f, '\n') +
            `fragment ${a}${ng('(', ne(c, ', '), ')')} ` +
            `on ${b} ${ng('', ne(d, ' '), ' ')}` +
            e,
        },
        IntValue: { leave: ({ value: a }) => a },
        FloatValue: { leave: ({ value: a }) => a },
        StringValue: {
          leave: ({ value: a, block: b }) => {
            let c, d, e, f, g, h, i, j, k, l, m;
            return b
              ? ((e = 1 === (d = (c = a.replace(/"""/g, '\\"""')).split(/\r\n|[\n\r]/g)).length),
                (f =
                  d.length > 1 && d.slice(1).every((a) => 0 === a.length || m5(a.charCodeAt(0)))),
                (g = c.endsWith('\\"""')),
                (h = a.endsWith('"') && !g),
                (i = a.endsWith('\\')),
                (j = h || i),
                (k = !e || a.length > 70 || j || f || g),
                (l = ''),
                (m = e && m5(a.charCodeAt(0))),
                ((k && !m) || f) && (l += '\n'),
                (l += c),
                (k || j) && (l += '\n'),
                '"""' + l + '"""')
              : `"${a.replace(m6, m7)}"`;
          },
        },
        BooleanValue: { leave: ({ value: a }) => (a ? 'true' : 'false') },
        NullValue: { leave: () => 'null' },
        EnumValue: { leave: ({ value: a }) => a },
        ListValue: { leave: ({ values: a }) => '[' + ne(a, ', ') + ']' },
        ObjectValue: { leave: ({ fields: a }) => '{' + ne(a, ', ') + '}' },
        ObjectField: { leave: ({ name: a, value: b }) => a + ': ' + b },
        Directive: { leave: ({ name: a, arguments: b }) => '@' + a + ng('(', ne(b, ', '), ')') },
        NamedType: { leave: ({ name: a }) => a },
        ListType: { leave: ({ type: a }) => '[' + a + ']' },
        NonNullType: { leave: ({ type: a }) => a + '!' },
        SchemaDefinition: {
          leave: ({ description: a, directives: b, operationTypes: c }) =>
            ng('', a, '\n') + ne(['schema', ne(b, ' '), nf(c)], ' '),
        },
        OperationTypeDefinition: { leave: ({ operation: a, type: b }) => a + ': ' + b },
        ScalarTypeDefinition: {
          leave: ({ description: a, name: b, directives: c }) =>
            ng('', a, '\n') + ne(['scalar', b, ne(c, ' ')], ' '),
        },
        ObjectTypeDefinition: {
          leave: ({ description: a, name: b, interfaces: c, directives: d, fields: e }) =>
            ng('', a, '\n') +
            ne(['type', b, ng('implements ', ne(c, ' & ')), ne(d, ' '), nf(e)], ' '),
        },
        FieldDefinition: {
          leave: ({ description: a, name: b, arguments: c, type: d, directives: e }) =>
            ng('', a, '\n') +
            b +
            (ni(c) ? ng('(\n', nh(ne(c, '\n')), '\n)') : ng('(', ne(c, ', '), ')')) +
            ': ' +
            d +
            ng(' ', ne(e, ' ')),
        },
        InputValueDefinition: {
          leave: ({ description: a, name: b, type: c, defaultValue: d, directives: e }) =>
            ng('', a, '\n') + ne([b + ': ' + c, ng('= ', d), ne(e, ' ')], ' '),
        },
        InterfaceTypeDefinition: {
          leave: ({ description: a, name: b, interfaces: c, directives: d, fields: e }) =>
            ng('', a, '\n') +
            ne(['interface', b, ng('implements ', ne(c, ' & ')), ne(d, ' '), nf(e)], ' '),
        },
        UnionTypeDefinition: {
          leave: ({ description: a, name: b, directives: c, types: d }) =>
            ng('', a, '\n') + ne(['union', b, ne(c, ' '), ng('= ', ne(d, ' | '))], ' '),
        },
        EnumTypeDefinition: {
          leave: ({ description: a, name: b, directives: c, values: d }) =>
            ng('', a, '\n') + ne(['enum', b, ne(c, ' '), nf(d)], ' '),
        },
        EnumValueDefinition: {
          leave: ({ description: a, name: b, directives: c }) =>
            ng('', a, '\n') + ne([b, ne(c, ' ')], ' '),
        },
        InputObjectTypeDefinition: {
          leave: ({ description: a, name: b, directives: c, fields: d }) =>
            ng('', a, '\n') + ne(['input', b, ne(c, ' '), nf(d)], ' '),
        },
        DirectiveDefinition: {
          leave: ({ description: a, name: b, arguments: c, repeatable: d, locations: e }) =>
            ng('', a, '\n') +
            'directive @' +
            b +
            (ni(c) ? ng('(\n', nh(ne(c, '\n')), '\n)') : ng('(', ne(c, ', '), ')')) +
            (d ? ' repeatable' : '') +
            ' on ' +
            ne(e, ' | '),
        },
        SchemaExtension: {
          leave: ({ directives: a, operationTypes: b }) =>
            ne(['extend schema', ne(a, ' '), nf(b)], ' '),
        },
        ScalarTypeExtension: {
          leave: ({ name: a, directives: b }) => ne(['extend scalar', a, ne(b, ' ')], ' '),
        },
        ObjectTypeExtension: {
          leave: ({ name: a, interfaces: b, directives: c, fields: d }) =>
            ne(['extend type', a, ng('implements ', ne(b, ' & ')), ne(c, ' '), nf(d)], ' '),
        },
        InterfaceTypeExtension: {
          leave: ({ name: a, interfaces: b, directives: c, fields: d }) =>
            ne(['extend interface', a, ng('implements ', ne(b, ' & ')), ne(c, ' '), nf(d)], ' '),
        },
        UnionTypeExtension: {
          leave: ({ name: a, directives: b, types: c }) =>
            ne(['extend union', a, ne(b, ' '), ng('= ', ne(c, ' | '))], ' '),
        },
        EnumTypeExtension: {
          leave: ({ name: a, directives: b, values: c }) =>
            ne(['extend enum', a, ne(b, ' '), nf(c)], ' '),
        },
        InputObjectTypeExtension: {
          leave: ({ name: a, directives: b, fields: c }) =>
            ne(['extend input', a, ne(b, ' '), nf(c)], ' '),
        },
        TypeCoordinate: { leave: ({ name: a }) => a },
        MemberCoordinate: { leave: ({ name: a, memberName: b }) => ne([a, ng('.', b)]) },
        ArgumentCoordinate: {
          leave: ({ name: a, fieldName: b, argumentName: c }) =>
            ne([a, ng('.', b), ng('(', c, ':)')]),
        },
        DirectiveCoordinate: { leave: ({ name: a }) => ne(['@', a]) },
        DirectiveArgumentCoordinate: {
          leave: ({ name: a, argumentName: b }) => ne(['@', a, ng('(', b, ':)')]),
        },
      };
    function ne(a, b = '') {
      var c;
      return null != (c = null == a ? void 0 : a.filter((a) => a).join(b)) ? c : '';
    }
    function nf(a) {
      return ng('{\n', nh(ne(a, '\n')), '\n}');
    }
    function ng(a, b, c = '') {
      return null != b && '' !== b ? a + b + c : '';
    }
    function nh(a) {
      return ng('  ', a.replace(/\n/g, '\n  '));
    }
    function ni(a) {
      var b;
      return null != (b = null == a ? void 0 : a.some((a) => a.includes('\n'))) && b;
    }
    var nj = (a) => {
        throw TypeError(a);
      },
      nk = (a, b, c) => b.has(a) || nj('Cannot ' + c),
      nl = (a, b, c) => (nk(a, b, 'read from private field'), c ? c.call(a) : b.get(a)),
      nm = (a, b, c) =>
        b.has(a)
          ? nj('Cannot add the same private member more than once')
          : b instanceof WeakSet
          ? b.add(a)
          : b.set(a, c),
      nn = (a, b, c, d) => (nk(a, b, 'write to private field'), d ? d.call(a, c) : b.set(a, c), c);
    class no extends Error {}
    class np {
      constructor({ url: a, fetch: b = fetch, headers: c = {}, queries: d = {} }) {
        nm(this, aL),
          nm(this, aM),
          nm(this, aN),
          nm(this, aO),
          nn(this, aL, a),
          nn(this, aM, d),
          nn(this, aN, c),
          nn(this, aO, (...a) => b(...a));
      }
      async query(a) {
        let b = await nl(this, aO).call(this, nl(this, aL), {
          method: 'POST',
          headers: { 'Content-Type': 'application/json', ...nl(this, aN) },
          body: JSON.stringify({
            query:
              'string' == typeof a.query
                ? String(a.query)
                : (function (a, b, c = m9) {
                    let d,
                      e,
                      f,
                      g = new Map();
                    for (let a of Object.values(aK))
                      g.set(
                        a,
                        (function (a, b) {
                          let c = a[b];
                          return 'object' == typeof c
                            ? c
                            : 'function' == typeof c
                            ? { enter: c, leave: void 0 }
                            : { enter: a.enter, leave: a.leave };
                        })(b, a)
                      );
                    let h = Array.isArray(a),
                      i = [a],
                      j = -1,
                      k = [],
                      l = a,
                      m = [],
                      n = [];
                    do {
                      var o, p, q;
                      let a,
                        s = ++j === i.length,
                        t = s && 0 !== k.length;
                      if (s) {
                        if (
                          ((e = 0 === n.length ? void 0 : m[m.length - 1]),
                          (l = f),
                          (f = n.pop()),
                          t)
                        )
                          if (h) {
                            l = l.slice();
                            let a = 0;
                            for (let [b, c] of k) {
                              let d = b - a;
                              null === c ? (l.splice(d, 1), a++) : (l[d] = c);
                            }
                          } else for (let [a, b] of ((l = { ...l }), k)) l[a] = b;
                        (j = d.index), (i = d.keys), (k = d.edits), (h = d.inArray), (d = d.prev);
                      } else if (f) {
                        if (null == (l = f[(e = h ? j : i[j])])) continue;
                        m.push(e);
                      }
                      if (!Array.isArray(l)) {
                        nb(l) ||
                          (function (a, b) {
                            if (!a) throw Error(b);
                          })(
                            !1,
                            `Invalid AST Node: ${(function a(b, c) {
                              switch (typeof b) {
                                case 'string':
                                  return JSON.stringify(b);
                                case 'function':
                                  return b.name ? `[function ${b.name}]` : '[function]';
                                case 'object':
                                  return (function (b, c) {
                                    let d;
                                    if (null === b) return 'null';
                                    if (c.includes(b)) return '[Circular]';
                                    let e = [...c, b];
                                    if ('function' == typeof b.toJSON) {
                                      let c = b.toJSON();
                                      if (c !== b) return 'string' == typeof c ? c : a(c, e);
                                    } else if (Array.isArray(b)) {
                                      var f,
                                        g,
                                        h = b,
                                        i = e;
                                      if (0 === h.length) return '[]';
                                      if (i.length > 2) return '[Array]';
                                      let c = Math.min(10, h.length),
                                        d = h.length - c,
                                        j = [];
                                      for (let b = 0; b < c; ++b) j.push(a(h[b], i));
                                      return (
                                        1 === d
                                          ? j.push('... 1 more item')
                                          : d > 1 && j.push(`... ${d} more items`),
                                        '[' + j.join(', ') + ']'
                                      );
                                    }
                                    return (
                                      (f = b),
                                      (g = e),
                                      0 === (d = Object.entries(f)).length
                                        ? '{}'
                                        : g.length > 2
                                        ? '[' +
                                          (function (a) {
                                            let b = Object.prototype.toString
                                              .call(a)
                                              .replace(/^\[object /, '')
                                              .replace(/]$/, '');
                                            if (
                                              'Object' === b &&
                                              'function' == typeof a.constructor
                                            ) {
                                              let b = a.constructor.name;
                                              if ('string' == typeof b && '' !== b) return b;
                                            }
                                            return b;
                                          })(f) +
                                          ']'
                                        : '{ ' +
                                          d.map(([b, c]) => b + ': ' + a(c, g)).join(', ') +
                                          ' }'
                                    );
                                  })(b, c);
                                default:
                                  return String(b);
                              }
                            })(l, [])}.`
                          );
                        let c = s
                          ? null == (o = g.get(l.kind))
                            ? void 0
                            : o.leave
                          : null == (p = g.get(l.kind))
                          ? void 0
                          : p.enter;
                        if ((a = null == c ? void 0 : c.call(b, l, e, f, m, n)) === nc) break;
                        if (!1 === a) {
                          if (!s) {
                            m.pop();
                            continue;
                          }
                        } else if (void 0 !== a && (k.push([e, a]), !s))
                          if (nb(a)) l = a;
                          else {
                            m.pop();
                            continue;
                          }
                      }
                      void 0 === a && t && k.push([e, l]),
                        s
                          ? m.pop()
                          : ((d = { inArray: h, index: j, keys: i, edits: k, prev: d }),
                            (i = (h = Array.isArray(l)) ? l : null != (q = c[l.kind]) ? q : []),
                            (j = -1),
                            (k = []),
                            f && n.push(f),
                            (f = l));
                    } while (void 0 !== d);
                    return 0 !== k.length ? k[k.length - 1][1] : a;
                  })(a.query, nd),
            variables: a.variables,
            extensions: a.extensions,
            operationName: a.operationName,
          }),
        });
        if (!b.ok) throw new no(`GraphQL request failed: ${b.statusText} (${b.status})`);
        return await b.json();
      }
      async execute(a, b) {
        return this.query({ ...b, query: nl(this, aM)[a] });
      }
    }
    (aL = new WeakMap()), (aM = new WeakMap()), (aN = new WeakMap()), (aO = new WeakMap());
    var nq = a.i(21756),
      nr = a.i(45158);
    function ns(a, b) {
      return mm
        .IntentMessage(mm.fixedArray(b.length, mm.u8()))
        .serialize({
          intent: { scope: { [a]: !0 }, version: { V0: !0 }, appId: { Iota: !0 } },
          value: b,
        })
        .toBytes();
    }
    let nt = { ED25519: 0, Secp256k1: 1, Secp256r1: 2, MultiSig: 3, Passkey: 6 },
      nu = { ED25519: 32, Secp256k1: 33, Secp256r1: 33 },
      nv = { 0: 'ED25519', 1: 'Secp256k1', 2: 'Secp256r1', 3: 'MultiSig', 6: 'Passkey' },
      nw = Uint32Array.from([
        0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4,
        0xab1c5ed5, 0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe,
        0x9bdc06a7, 0xc19bf174, 0xe49b69c1, 0xefbe4786, 0xfc19dc6, 0x240ca1cc, 0x2de92c6f,
        0x4a7484aa, 0x5cb0a9dc, 0x76f988da, 0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,
        0xc6e00bf3, 0xd5a79147, 0x6ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc,
        0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85, 0xa2bfe8a1, 0xa81a664b,
        0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070, 0x19a4c116,
        0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7,
        0xc67178f2,
      ]),
      nx = new Uint32Array(64);
    class ny extends jn {
      constructor(a = 32) {
        super(64, a, 8, !1),
          (this.A = 0 | jo[0]),
          (this.B = 0 | jo[1]),
          (this.C = 0 | jo[2]),
          (this.D = 0 | jo[3]),
          (this.E = 0 | jo[4]),
          (this.F = 0 | jo[5]),
          (this.G = 0 | jo[6]),
          (this.H = 0 | jo[7]);
      }
      get() {
        let { A: a, B: b, C: c, D: d, E: e, F: f, G: g, H: h } = this;
        return [a, b, c, d, e, f, g, h];
      }
      set(a, b, c, d, e, f, g, h) {
        (this.A = 0 | a),
          (this.B = 0 | b),
          (this.C = 0 | c),
          (this.D = 0 | d),
          (this.E = 0 | e),
          (this.F = 0 | f),
          (this.G = 0 | g),
          (this.H = 0 | h);
      }
      process(a, b) {
        for (let c = 0; c < 16; c++, b += 4) nx[c] = a.getUint32(b, !1);
        for (let a = 16; a < 64; a++) {
          let b = nx[a - 15],
            c = nx[a - 2],
            d = i5(b, 7) ^ i5(b, 18) ^ (b >>> 3),
            e = i5(c, 17) ^ i5(c, 19) ^ (c >>> 10);
          nx[a] = (e + nx[a - 7] + d + nx[a - 16]) | 0;
        }
        let { A: c, B: d, C: e, D: f, E: g, F: h, G: i, H: j } = this;
        for (let a = 0; a < 64; a++) {
          var k, l, m, n;
          let b =
              (j +
                (i5(g, 6) ^ i5(g, 11) ^ i5(g, 25)) +
                (((k = g) & h) ^ (~k & i)) +
                nw[a] +
                nx[a]) |
              0,
            o =
              ((i5(c, 2) ^ i5(c, 13) ^ i5(c, 22)) +
                (((l = c) & (m = d)) ^ (l & (n = e)) ^ (m & n))) |
              0;
          (j = i),
            (i = h),
            (h = g),
            (g = (f + b) | 0),
            (f = e),
            (e = d),
            (d = c),
            (c = (b + o) | 0);
        }
        (c = (c + this.A) | 0),
          (d = (d + this.B) | 0),
          (e = (e + this.C) | 0),
          (f = (f + this.D) | 0),
          (g = (g + this.E) | 0),
          (h = (h + this.F) | 0),
          (i = (i + this.G) | 0),
          (j = (j + this.H) | 0),
          this.set(c, d, e, f, g, h, i, j);
      }
      roundClean() {
        i3(nx);
      }
      destroy() {
        this.set(0, 0, 0, 0, 0, 0, 0, 0), i3(this.buffer);
      }
    }
    let nz = (function (a, b = !1) {
        let c = a.length,
          d = new Uint32Array(c),
          e = new Uint32Array(c);
        for (let f = 0; f < c; f++) {
          let { h: c, l: g } = ju(a[f], b);
          [d[f], e[f]] = [c, g];
        }
        return [d, e];
      })(
        [
          '0x428a2f98d728ae22',
          '0x7137449123ef65cd',
          '0xb5c0fbcfec4d3b2f',
          '0xe9b5dba58189dbbc',
          '0x3956c25bf348b538',
          '0x59f111f1b605d019',
          '0x923f82a4af194f9b',
          '0xab1c5ed5da6d8118',
          '0xd807aa98a3030242',
          '0x12835b0145706fbe',
          '0x243185be4ee4b28c',
          '0x550c7dc3d5ffb4e2',
          '0x72be5d74f27b896f',
          '0x80deb1fe3b1696b1',
          '0x9bdc06a725c71235',
          '0xc19bf174cf692694',
          '0xe49b69c19ef14ad2',
          '0xefbe4786384f25e3',
          '0x0fc19dc68b8cd5b5',
          '0x240ca1cc77ac9c65',
          '0x2de92c6f592b0275',
          '0x4a7484aa6ea6e483',
          '0x5cb0a9dcbd41fbd4',
          '0x76f988da831153b5',
          '0x983e5152ee66dfab',
          '0xa831c66d2db43210',
          '0xb00327c898fb213f',
          '0xbf597fc7beef0ee4',
          '0xc6e00bf33da88fc2',
          '0xd5a79147930aa725',
          '0x06ca6351e003826f',
          '0x142929670a0e6e70',
          '0x27b70a8546d22ffc',
          '0x2e1b21385c26c926',
          '0x4d2c6dfc5ac42aed',
          '0x53380d139d95b3df',
          '0x650a73548baf63de',
          '0x766a0abb3c77b2a8',
          '0x81c2c92e47edaee6',
          '0x92722c851482353b',
          '0xa2bfe8a14cf10364',
          '0xa81a664bbc423001',
          '0xc24b8b70d0f89791',
          '0xc76c51a30654be30',
          '0xd192e819d6ef5218',
          '0xd69906245565a910',
          '0xf40e35855771202a',
          '0x106aa07032bbd1b8',
          '0x19a4c116b8d2d0c8',
          '0x1e376c085141ab53',
          '0x2748774cdf8eeb99',
          '0x34b0bcb5e19b48a8',
          '0x391c0cb3c5c95a63',
          '0x4ed8aa4ae3418acb',
          '0x5b9cca4f7763e373',
          '0x682e6ff3d6b2b8a3',
          '0x748f82ee5defb2fc',
          '0x78a5636f43172f60',
          '0x84c87814a1f0ab72',
          '0x8cc702081a6439ec',
          '0x90befffa23631e28',
          '0xa4506cebde82bde9',
          '0xbef9a3f7b2c67915',
          '0xc67178f2e372532b',
          '0xca273eceea26619c',
          '0xd186b8c721c0c207',
          '0xeada7dd6cde0eb1e',
          '0xf57d4f7fee6ed178',
          '0x06f067aa72176fba',
          '0x0a637dc5a2c898a6',
          '0x113f9804bef90dae',
          '0x1b710b35131c471b',
          '0x28db77f523047d84',
          '0x32caab7b40c72493',
          '0x3c9ebe0a15c9bebc',
          '0x431d67c49c100d4c',
          '0x4cc5d4becb3e42b6',
          '0x597f299cfc657e2a',
          '0x5fcb6fab3ad6faec',
          '0x6c44198c4a475817',
        ].map((a) => BigInt(a))
      ),
      nA = nz[0],
      nB = nz[1],
      nC = new Uint32Array(80),
      nD = new Uint32Array(80);
    class nE extends jn {
      constructor(a = 64) {
        super(128, a, 16, !1),
          (this.Ah = 0 | jr[0]),
          (this.Al = 0 | jr[1]),
          (this.Bh = 0 | jr[2]),
          (this.Bl = 0 | jr[3]),
          (this.Ch = 0 | jr[4]),
          (this.Cl = 0 | jr[5]),
          (this.Dh = 0 | jr[6]),
          (this.Dl = 0 | jr[7]),
          (this.Eh = 0 | jr[8]),
          (this.El = 0 | jr[9]),
          (this.Fh = 0 | jr[10]),
          (this.Fl = 0 | jr[11]),
          (this.Gh = 0 | jr[12]),
          (this.Gl = 0 | jr[13]),
          (this.Hh = 0 | jr[14]),
          (this.Hl = 0 | jr[15]);
      }
      get() {
        let {
          Ah: a,
          Al: b,
          Bh: c,
          Bl: d,
          Ch: e,
          Cl: f,
          Dh: g,
          Dl: h,
          Eh: i,
          El: j,
          Fh: k,
          Fl: l,
          Gh: m,
          Gl: n,
          Hh: o,
          Hl: p,
        } = this;
        return [a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p];
      }
      set(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p) {
        (this.Ah = 0 | a),
          (this.Al = 0 | b),
          (this.Bh = 0 | c),
          (this.Bl = 0 | d),
          (this.Ch = 0 | e),
          (this.Cl = 0 | f),
          (this.Dh = 0 | g),
          (this.Dl = 0 | h),
          (this.Eh = 0 | i),
          (this.El = 0 | j),
          (this.Fh = 0 | k),
          (this.Fl = 0 | l),
          (this.Gh = 0 | m),
          (this.Gl = 0 | n),
          (this.Hh = 0 | o),
          (this.Hl = 0 | p);
      }
      process(a, b) {
        for (let c = 0; c < 16; c++, b += 4)
          (nC[c] = a.getUint32(b)), (nD[c] = a.getUint32((b += 4)));
        for (let a = 16; a < 80; a++) {
          let b = 0 | nC[a - 15],
            c = 0 | nD[a - 15],
            d = jx(b, c, 1) ^ jx(b, c, 8) ^ jv(b, c, 7),
            e = jy(b, c, 1) ^ jy(b, c, 8) ^ jw(b, c, 7),
            f = 0 | nC[a - 2],
            g = 0 | nD[a - 2],
            h = jx(f, g, 19) ^ jz(f, g, 61) ^ jv(f, g, 6),
            i = jE(e, jy(f, g, 19) ^ jA(f, g, 61) ^ jw(f, g, 6), nD[a - 7], nD[a - 16]),
            j = jF(i, d, h, nC[a - 7], nC[a - 16]);
          (nC[a] = 0 | j), (nD[a] = 0 | i);
        }
        let {
          Ah: c,
          Al: d,
          Bh: e,
          Bl: f,
          Ch: g,
          Cl: h,
          Dh: i,
          Dl: j,
          Eh: k,
          El: l,
          Fh: m,
          Fl: n,
          Gh: o,
          Gl: p,
          Hh: q,
          Hl: s,
        } = this;
        for (let a = 0; a < 80; a++) {
          let b = jx(k, l, 14) ^ jx(k, l, 18) ^ jz(k, l, 41),
            t = jy(k, l, 14) ^ jy(k, l, 18) ^ jA(k, l, 41),
            u = (k & m) ^ (~k & o),
            v = jG(s, t, (l & n) ^ (~l & p), nB[a], nD[a]),
            w = jH(v, q, b, u, nA[a], nC[a]),
            x = 0 | v,
            y = jx(c, d, 28) ^ jz(c, d, 34) ^ jz(c, d, 39),
            z = jy(c, d, 28) ^ jA(c, d, 34) ^ jA(c, d, 39),
            A = (c & e) ^ (c & g) ^ (e & g),
            B = (d & f) ^ (d & h) ^ (f & h);
          (q = 0 | o),
            (s = 0 | p),
            (o = 0 | m),
            (p = 0 | n),
            (m = 0 | k),
            (n = 0 | l),
            ({ h: k, l: l } = jB(0 | i, 0 | j, 0 | w, 0 | x)),
            (i = 0 | g),
            (j = 0 | h),
            (g = 0 | e),
            (h = 0 | f),
            (e = 0 | c),
            (f = 0 | d);
          let C = jC(x, z, B);
          (c = jD(C, w, y, A)), (d = 0 | C);
        }
        ({ h: c, l: d } = jB(0 | this.Ah, 0 | this.Al, 0 | c, 0 | d)),
          ({ h: e, l: f } = jB(0 | this.Bh, 0 | this.Bl, 0 | e, 0 | f)),
          ({ h: g, l: h } = jB(0 | this.Ch, 0 | this.Cl, 0 | g, 0 | h)),
          ({ h: i, l: j } = jB(0 | this.Dh, 0 | this.Dl, 0 | i, 0 | j)),
          ({ h: k, l: l } = jB(0 | this.Eh, 0 | this.El, 0 | k, 0 | l)),
          ({ h: m, l: n } = jB(0 | this.Fh, 0 | this.Fl, 0 | m, 0 | n)),
          ({ h: o, l: p } = jB(0 | this.Gh, 0 | this.Gl, 0 | o, 0 | p)),
          ({ h: q, l: s } = jB(0 | this.Hh, 0 | this.Hl, 0 | q, 0 | s)),
          this.set(c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, s);
      }
      roundClean() {
        i3(nC, nD);
      }
      destroy() {
        i3(this.buffer), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
      }
    }
    class nF extends nE {
      constructor() {
        super(48),
          (this.Ah = 0 | jq[0]),
          (this.Al = 0 | jq[1]),
          (this.Bh = 0 | jq[2]),
          (this.Bl = 0 | jq[3]),
          (this.Ch = 0 | jq[4]),
          (this.Cl = 0 | jq[5]),
          (this.Dh = 0 | jq[6]),
          (this.Dl = 0 | jq[7]),
          (this.Eh = 0 | jq[8]),
          (this.El = 0 | jq[9]),
          (this.Fh = 0 | jq[10]),
          (this.Fl = 0 | jq[11]),
          (this.Gh = 0 | jq[12]),
          (this.Gl = 0 | jq[13]),
          (this.Hh = 0 | jq[14]),
          (this.Hl = 0 | jq[15]);
      }
    }
    let nG = jk(() => new ny()),
      nH = jk(() => new nE()),
      nI = jk(() => new nF());
    class nJ extends jj {
      constructor(a, b) {
        super(), (this.finished = !1), (this.destroyed = !1), i_(a);
        const c = jg(b);
        if (((this.iHash = a.create()), 'function' != typeof this.iHash.update))
          throw Error('Expected instance of class which extends utils.Hash');
        (this.blockLen = this.iHash.blockLen), (this.outputLen = this.iHash.outputLen);
        const d = this.blockLen,
          e = new Uint8Array(d);
        e.set(c.length > d ? a.create().update(c).digest() : c);
        for (let a = 0; a < e.length; a++) e[a] ^= 54;
        this.iHash.update(e), (this.oHash = a.create());
        for (let a = 0; a < e.length; a++) e[a] ^= 106;
        this.oHash.update(e), i3(e);
      }
      update(a) {
        return i0(this), this.iHash.update(a), this;
      }
      digestInto(a) {
        i0(this),
          i$(a, this.outputLen),
          (this.finished = !0),
          this.iHash.digestInto(a),
          this.oHash.update(a),
          this.oHash.digestInto(a),
          this.destroy();
      }
      digest() {
        let a = new Uint8Array(this.oHash.outputLen);
        return this.digestInto(a), a;
      }
      _cloneInto(a) {
        a || (a = Object.create(Object.getPrototypeOf(this), {}));
        let { oHash: b, iHash: c, finished: d, destroyed: e, blockLen: f, outputLen: g } = this;
        return (
          (a.finished = d),
          (a.destroyed = e),
          (a.blockLen = f),
          (a.outputLen = g),
          (a.oHash = b._cloneInto(a.oHash)),
          (a.iHash = c._cloneInto(a.iHash)),
          a
        );
      }
      clone() {
        return this._cloneInto();
      }
      destroy() {
        (this.destroyed = !0), this.oHash.destroy(), this.iHash.destroy();
      }
    }
    let nK = (a, b, c) => new nJ(a, b).update(c).digest();
    nK.create = (a, b) => new nJ(a, b);
    let nL = BigInt(0),
      nM = BigInt(1);
    function nN(a, b = '') {
      if ('boolean' != typeof a)
        throw Error((b && `"${b}"`) + 'expected boolean, got type=' + typeof a);
      return a;
    }
    function nO(a, b, c = '') {
      let d = iY(a),
        e = a?.length,
        f = void 0 !== b;
      if (!d || (f && e !== b))
        throw Error(
          (c && `"${c}" `) +
            'expected Uint8Array' +
            (f ? ` of length ${b}` : '') +
            ', got ' +
            (d ? `length=${e}` : `type=${typeof a}`)
        );
      return a;
    }
    function nP(a) {
      let b = a.toString(16);
      return 1 & b.length ? '0' + b : b;
    }
    function nQ(a) {
      if ('string' != typeof a) throw Error('hex string expected, got ' + typeof a);
      return '' === a ? nL : BigInt('0x' + a);
    }
    function nR(a) {
      return nQ(jc(a));
    }
    function nS(a) {
      return i$(a), nQ(jc(Uint8Array.from(a).reverse()));
    }
    function nT(a, b) {
      return je(a.toString(16).padStart(2 * b, '0'));
    }
    function nU(a, b) {
      return nT(a, b).reverse();
    }
    function nV(a, b, c) {
      let d;
      if ('string' == typeof b)
        try {
          d = je(b);
        } catch (b) {
          throw Error(a + ' must be hex string or Uint8Array, cause: ' + b);
        }
      else if (iY(b)) d = Uint8Array.from(b);
      else throw Error(a + ' must be hex string or Uint8Array');
      let e = d.length;
      if ('number' == typeof c && e !== c)
        throw Error(a + ' of length ' + c + ' expected, got ' + e);
      return d;
    }
    let nW = (a) => 'bigint' == typeof a && nL <= a;
    function nX(a) {
      let b;
      for (b = 0; a > nL; a >>= nM, b += 1);
      return b;
    }
    let nY = (a) => (nM << BigInt(a)) - nM;
    function nZ(a, b, c = {}) {
      if (!a || 'object' != typeof a) throw Error('expected valid options object');
      function d(b, c, d) {
        let e = a[b];
        if (d && void 0 === e) return;
        let f = typeof e;
        if (f !== c || null === e) throw Error(`param "${b}" is invalid: expected ${c}, got ${f}`);
      }
      Object.entries(b).forEach(([a, b]) => d(a, b, !1)),
        Object.entries(c).forEach(([a, b]) => d(a, b, !0));
    }
    function n$(a) {
      let b = new WeakMap();
      return (c, ...d) => {
        let e = b.get(c);
        if (void 0 !== e) return e;
        let f = a(c, ...d);
        return b.set(c, f), f;
      };
    }
    let n_ = BigInt(0),
      n0 = BigInt(1),
      n1 = BigInt(2),
      n2 = BigInt(3),
      n3 = BigInt(4),
      n4 = BigInt(5),
      n5 = BigInt(7),
      n6 = BigInt(8),
      n7 = BigInt(9),
      n8 = BigInt(16);
    function n9(a, b) {
      let c = a % b;
      return c >= n_ ? c : b + c;
    }
    function oa(a, b) {
      if (a === n_) throw Error('invert: expected non-zero number');
      if (b <= n_) throw Error('invert: expected positive modulus, got ' + b);
      let c = n9(a, b),
        d = b,
        e = n_,
        f = n0,
        g = n0,
        h = n_;
      for (; c !== n_; ) {
        let a = d / c,
          b = d % c,
          i = e - g * a,
          j = f - h * a;
        (d = c), (c = b), (e = g), (f = h), (g = i), (h = j);
      }
      if (d !== n0) throw Error('invert: does not exist');
      return n9(e, b);
    }
    function ob(a, b, c) {
      if (!a.eql(a.sqr(b), c)) throw Error('Cannot find square root');
    }
    function oc(a, b) {
      let c = (a.ORDER + n0) / n3,
        d = a.pow(b, c);
      return ob(a, d, b), d;
    }
    function od(a, b) {
      let c = (a.ORDER - n4) / n6,
        d = a.mul(b, n1),
        e = a.pow(d, c),
        f = a.mul(b, e),
        g = a.mul(a.mul(f, n1), e),
        h = a.mul(f, a.sub(g, a.ONE));
      return ob(a, h, b), h;
    }
    function oe(a) {
      if (a < n2) throw Error('sqrt is not defined for small field');
      let b = a - n0,
        c = 0;
      for (; b % n1 === n_; ) (b /= n1), c++;
      let d = n1,
        e = ok(a);
      for (; 1 === oi(e, d); )
        if (d++ > 1e3) throw Error('Cannot find square root: probably non-prime P');
      if (1 === c) return oc;
      let f = e.pow(d, b),
        g = (b + n0) / n1;
      return function (a, d) {
        if (a.is0(d)) return d;
        if (1 !== oi(a, d)) throw Error('Cannot find square root');
        let e = c,
          h = a.mul(a.ONE, f),
          i = a.pow(d, b),
          j = a.pow(d, g);
        for (; !a.eql(i, a.ONE); ) {
          if (a.is0(i)) return a.ZERO;
          let b = 1,
            c = a.sqr(i);
          for (; !a.eql(c, a.ONE); )
            if ((b++, (c = a.sqr(c)), b === e)) throw Error('Cannot find square root');
          let d = n0 << BigInt(e - b - 1),
            f = a.pow(h, d);
          (e = b), (h = a.sqr(f)), (i = a.mul(i, h)), (j = a.mul(j, f));
        }
        return j;
      };
    }
    let of = [
      'create',
      'isValid',
      'is0',
      'neg',
      'inv',
      'sqrt',
      'sqr',
      'eql',
      'add',
      'sub',
      'mul',
      'pow',
      'div',
      'addN',
      'subN',
      'mulN',
      'sqrN',
    ];
    function og(a) {
      return (
        nZ(
          a,
          of.reduce((a, b) => ((a[b] = 'function'), a), {
            ORDER: 'bigint',
            MASK: 'bigint',
            BYTES: 'number',
            BITS: 'number',
          })
        ),
        a
      );
    }
    function oh(a, b, c = !1) {
      let d = Array(b.length).fill(c ? a.ZERO : void 0),
        e = b.reduce((b, c, e) => (a.is0(c) ? b : ((d[e] = b), a.mul(b, c))), a.ONE),
        f = a.inv(e);
      return (
        b.reduceRight((b, c, e) => (a.is0(c) ? b : ((d[e] = a.mul(b, d[e])), a.mul(b, c))), f), d
      );
    }
    function oi(a, b) {
      let c = (a.ORDER - n0) / n1,
        d = a.pow(b, c),
        e = a.eql(d, a.ONE),
        f = a.eql(d, a.ZERO),
        g = a.eql(d, a.neg(a.ONE));
      if (!e && !f && !g) throw Error('invalid Legendre symbol result');
      return e ? 1 : f ? 0 : -1;
    }
    function oj(a, b) {
      void 0 !== b && iZ(b);
      let c = void 0 !== b ? b : a.toString(2).length,
        d = Math.ceil(c / 8);
      return { nBitLength: c, nByteLength: d };
    }
    function ok(a, b, c = !1, d = {}) {
      let e, f, g, h;
      if (a <= n_) throw Error('invalid field: expected ORDER > 0, got ' + a);
      let i = !1;
      if ('object' == typeof b && null != b) {
        if (d.sqrt || c) throw Error('cannot specify opts in two arguments');
        b.BITS && (f = b.BITS),
          b.sqrt && (g = b.sqrt),
          'boolean' == typeof b.isLE && (c = b.isLE),
          'boolean' == typeof b.modFromBytes && (i = b.modFromBytes),
          (h = b.allowedLengths);
      } else 'number' == typeof b && (f = b), d.sqrt && (g = d.sqrt);
      let { nBitLength: j, nByteLength: k } = oj(a, f);
      if (k > 2048) throw Error('invalid field: expected ORDER of <= 2048 bytes');
      let l = Object.freeze({
        ORDER: a,
        isLE: c,
        BITS: j,
        BYTES: k,
        MASK: nY(j),
        ZERO: n_,
        ONE: n0,
        allowedLengths: h,
        create: (b) => n9(b, a),
        isValid: (b) => {
          if ('bigint' != typeof b)
            throw Error('invalid field element: expected bigint, got ' + typeof b);
          return n_ <= b && b < a;
        },
        is0: (a) => a === n_,
        isValidNot0: (a) => !l.is0(a) && l.isValid(a),
        isOdd: (a) => (a & n0) === n0,
        neg: (b) => n9(-b, a),
        eql: (a, b) => a === b,
        sqr: (b) => n9(b * b, a),
        add: (b, c) => n9(b + c, a),
        sub: (b, c) => n9(b - c, a),
        mul: (b, c) => n9(b * c, a),
        pow: (a, b) =>
          (function (a, b, c) {
            if (c < n_) throw Error('invalid exponent, negatives unsupported');
            if (c === n_) return a.ONE;
            if (c === n0) return b;
            let d = a.ONE,
              e = b;
            for (; c > n_; ) c & n0 && (d = a.mul(d, e)), (e = a.sqr(e)), (c >>= n0);
            return d;
          })(l, a, b),
        div: (b, c) => n9(b * oa(c, a), a),
        sqrN: (a) => a * a,
        addN: (a, b) => a + b,
        subN: (a, b) => a - b,
        mulN: (a, b) => a * b,
        inv: (b) => oa(b, a),
        sqrt:
          g ||
          ((b) => (
            e ||
              (e = (function (a) {
                if (a % n3 === n2) return oc;
                if (a % n6 === n4) return od;
                if (a % n8 === n7) {
                  let b, c, d, e, f, g;
                  return (
                    (b = ok(a)),
                    (d = (c = oe(a))(b, b.neg(b.ONE))),
                    (e = c(b, d)),
                    (f = c(b, b.neg(d))),
                    (g = (a + n5) / n8),
                    (a, b) => {
                      let c = a.pow(b, g),
                        h = a.mul(c, d),
                        i = a.mul(c, e),
                        j = a.mul(c, f),
                        k = a.eql(a.sqr(h), b),
                        l = a.eql(a.sqr(i), b);
                      (c = a.cmov(c, h, k)), (h = a.cmov(j, i, l));
                      let m = a.eql(a.sqr(h), b),
                        n = a.cmov(c, h, m);
                      return ob(a, n, b), n;
                    }
                  );
                }
                return oe(a);
              })(a)),
            e(l, b)
          )),
        toBytes: (a) => (c ? nU(a, k) : nT(a, k)),
        fromBytes: (b, d = !0) => {
          if (h) {
            if (!h.includes(b.length) || b.length > k)
              throw Error('Field.fromBytes: expected ' + h + ' bytes, got ' + b.length);
            let a = new Uint8Array(k);
            a.set(b, c ? 0 : a.length - b.length), (b = a);
          }
          if (b.length !== k)
            throw Error('Field.fromBytes: expected ' + k + ' bytes, got ' + b.length);
          let e = c ? nS(b) : nR(b);
          if ((i && (e = n9(e, a)), !d && !l.isValid(e)))
            throw Error('invalid field element: outside of range 0..ORDER');
          return e;
        },
        invertBatch: (a) => oh(l, a),
        cmov: (a, b, c) => (c ? b : a),
      });
      return Object.freeze(l);
    }
    function ol(a) {
      if ('bigint' != typeof a) throw Error('field order must be bigint');
      return Math.ceil(a.toString(2).length / 8);
    }
    function om(a) {
      let b = ol(a);
      return b + Math.ceil(b / 2);
    }
    let on = BigInt(0),
      oo = BigInt(1);
    function op(a, b) {
      let c = b.negate();
      return a ? c : b;
    }
    function oq(a, b) {
      let c = oh(
        a.Fp,
        b.map((a) => a.Z)
      );
      return b.map((b, d) => a.fromAffine(b.toAffine(c[d])));
    }
    function or(a, b) {
      if (!Number.isSafeInteger(a) || a <= 0 || a > b)
        throw Error('invalid window size, expected [1..' + b + '], got W=' + a);
    }
    function os(a, b) {
      or(a, b);
      let c = Math.ceil(b / a) + 1,
        d = 2 ** (a - 1),
        e = 2 ** a;
      return { windows: c, windowSize: d, mask: nY(a), maxNumber: e, shiftBy: BigInt(a) };
    }
    function ot(a, b, c) {
      let { windowSize: d, mask: e, maxNumber: f, shiftBy: g } = c,
        h = Number(a & e),
        i = a >> g;
      h > d && ((h -= f), (i += oo));
      let j = b * d,
        k = j + Math.abs(h) - 1,
        l = 0 === h;
      return { nextN: i, offset: k, isZero: l, isNeg: h < 0, isNegF: b % 2 != 0, offsetF: j };
    }
    let ou = new WeakMap(),
      ov = new WeakMap();
    function ow(a) {
      return ov.get(a) || 1;
    }
    function ox(a) {
      if (a !== on) throw Error('invalid wNAF');
    }
    class oy {
      constructor(a, b) {
        (this.BASE = a.BASE), (this.ZERO = a.ZERO), (this.Fn = a.Fn), (this.bits = b);
      }
      _unsafeLadder(a, b, c = this.ZERO) {
        let d = a;
        for (; b > on; ) b & oo && (c = c.add(d)), (d = d.double()), (b >>= oo);
        return c;
      }
      precomputeWindow(a, b) {
        let { windows: c, windowSize: d } = os(b, this.bits),
          e = [],
          f = a,
          g = f;
        for (let a = 0; a < c; a++) {
          (g = f), e.push(g);
          for (let a = 1; a < d; a++) (g = g.add(f)), e.push(g);
          f = g.double();
        }
        return e;
      }
      wNAF(a, b, c) {
        if (!this.Fn.isValid(c)) throw Error('invalid scalar');
        let d = this.ZERO,
          e = this.BASE,
          f = os(a, this.bits);
        for (let a = 0; a < f.windows; a++) {
          let { nextN: g, offset: h, isZero: i, isNeg: j, isNegF: k, offsetF: l } = ot(c, a, f);
          (c = g), i ? (e = e.add(op(k, b[l]))) : (d = d.add(op(j, b[h])));
        }
        return ox(c), { p: d, f: e };
      }
      wNAFUnsafe(a, b, c, d = this.ZERO) {
        let e = os(a, this.bits);
        for (let a = 0; a < e.windows && c !== on; a++) {
          let { nextN: f, offset: g, isZero: h, isNeg: i } = ot(c, a, e);
          if (((c = f), !h)) {
            let a = b[g];
            d = d.add(i ? a.negate() : a);
          }
        }
        return ox(c), d;
      }
      getPrecomputes(a, b, c) {
        let d = ou.get(b);
        return (
          d ||
            ((d = this.precomputeWindow(b, a)),
            1 !== a && ('function' == typeof c && (d = c(d)), ou.set(b, d))),
          d
        );
      }
      cached(a, b, c) {
        let d = ow(a);
        return this.wNAF(d, this.getPrecomputes(d, a, c), b);
      }
      unsafe(a, b, c, d) {
        let e = ow(a);
        return 1 === e
          ? this._unsafeLadder(a, b, d)
          : this.wNAFUnsafe(e, this.getPrecomputes(e, a, c), b, d);
      }
      createCache(a, b) {
        or(b, this.bits), ov.set(a, b), ou.delete(a);
      }
      hasCache(a) {
        return 1 !== ow(a);
      }
    }
    function oz(a, b, c) {
      if (!b) return ok(a, { isLE: c });
      if (b.ORDER !== a) throw Error('Field.ORDER must match order: Fp == p, Fn == n');
      return og(b), b;
    }
    let oA = (a, b) => (a + (a >= 0 ? b : -b) / oG) / b;
    function oB(a) {
      if (!['compact', 'recovered', 'der'].includes(a))
        throw Error('Signature format must be "compact", "recovered", or "der"');
      return a;
    }
    function oC(a, b) {
      let c = {};
      for (let d of Object.keys(b)) c[d] = void 0 === a[d] ? b[d] : a[d];
      return nN(c.lowS, 'lowS'), nN(c.prehash, 'prehash'), void 0 !== c.format && oB(c.format), c;
    }
    let oD = {
        Err: class extends Error {
          constructor(a = '') {
            super(a);
          }
        },
        _tlv: {
          encode: (a, b) => {
            let { Err: c } = oD;
            if (a < 0 || a > 256) throw new c('tlv.encode: wrong tag');
            if (1 & b.length) throw new c('tlv.encode: unpadded data');
            let d = b.length / 2,
              e = nP(d);
            if ((e.length / 2) & 128) throw new c('tlv.encode: long form length too big');
            let f = d > 127 ? nP((e.length / 2) | 128) : '';
            return nP(a) + f + e + b;
          },
          decode(a, b) {
            let { Err: c } = oD,
              d = 0;
            if (a < 0 || a > 256) throw new c('tlv.encode: wrong tag');
            if (b.length < 2 || b[d++] !== a) throw new c('tlv.decode: wrong tlv');
            let e = b[d++],
              f = 0;
            if (128 & e) {
              let a = 127 & e;
              if (!a) throw new c('tlv.decode(long): indefinite length not supported');
              if (a > 4) throw new c('tlv.decode(long): byte length is too big');
              let g = b.subarray(d, d + a);
              if (g.length !== a) throw new c('tlv.decode: length bytes not complete');
              if (0 === g[0]) throw new c('tlv.decode(long): zero leftmost byte');
              for (let a of g) f = (f << 8) | a;
              if (((d += a), f < 128)) throw new c('tlv.decode(long): not minimal encoding');
            } else f = e;
            let g = b.subarray(d, d + f);
            if (g.length !== f) throw new c('tlv.decode: wrong value length');
            return { v: g, l: b.subarray(d + f) };
          },
        },
        _int: {
          encode(a) {
            let { Err: b } = oD;
            if (a < oE) throw new b('integer: negative integers are not allowed');
            let c = nP(a);
            if ((8 & Number.parseInt(c[0], 16) && (c = '00' + c), 1 & c.length))
              throw new b('unexpected DER parsing assertion: unpadded hex');
            return c;
          },
          decode(a) {
            let { Err: b } = oD;
            if (128 & a[0]) throw new b('invalid signature integer: negative');
            if (0 === a[0] && !(128 & a[1]))
              throw new b('invalid signature integer: unnecessary leading zero');
            return nR(a);
          },
        },
        toSig(a) {
          let { Err: b, _int: c, _tlv: d } = oD,
            e = nV('signature', a),
            { v: f, l: g } = d.decode(48, e);
          if (g.length) throw new b('invalid signature: left bytes after parsing');
          let { v: h, l: i } = d.decode(2, f),
            { v: j, l: k } = d.decode(2, i);
          if (k.length) throw new b('invalid signature: left bytes after parsing');
          return { r: c.decode(h), s: c.decode(j) };
        },
        hexFromSig(a) {
          let { _tlv: b, _int: c } = oD,
            d = b.encode(2, c.encode(a.r)),
            e = b.encode(2, c.encode(a.s));
          return b.encode(48, d + e);
        },
      },
      oE = BigInt(0),
      oF = BigInt(1),
      oG = BigInt(2),
      oH = BigInt(3),
      oI = BigInt(4);
    function oJ(a, b) {
      let c,
        { BYTES: d } = a;
      if ('bigint' == typeof b) c = b;
      else {
        let e = nV('private key', b);
        try {
          c = a.fromBytes(e);
        } catch (a) {
          throw Error(`invalid private key: expected ui8a of size ${d}, got ${typeof b}`);
        }
      }
      if (!a.isValidNot0(c)) throw Error('invalid private key: out of range [1..N-1]');
      return c;
    }
    function oK(a) {
      return Uint8Array.of(a ? 2 : 3);
    }
    function oL(a, b) {
      return {
        secretKey: b.BYTES,
        publicKey: 1 + a.BYTES,
        publicKeyUncompressed: 1 + 2 * a.BYTES,
        publicKeyHasPrefix: !0,
        signature: 2 * b.BYTES,
      };
    }
    function oM(a, b) {
      let c = (b) =>
        (function (a) {
          let b,
            {
              CURVE: c,
              curveOpts: d,
              hash: e,
              ecdsaOpts: f,
            } = (function (a) {
              let b,
                c,
                d,
                e,
                { CURVE: f, curveOpts: g } =
                  ((b = { a: a.a, b: a.b, p: a.Fp.ORDER, n: a.n, h: a.h, Gx: a.Gx, Gy: a.Gy }),
                  (c = a.Fp),
                  (d = a.allowedPrivateKeyLengths
                    ? Array.from(new Set(a.allowedPrivateKeyLengths.map((a) => Math.ceil(a / 2))))
                    : void 0),
                  (e = {
                    Fp: c,
                    Fn: ok(b.n, {
                      BITS: a.nBitLength,
                      allowedLengths: d,
                      modFromBytes: a.wrapPrivateKey,
                    }),
                    allowInfinityPoint: a.allowInfinityPoint,
                    endo: a.endo,
                    isTorsionFree: a.isTorsionFree,
                    clearCofactor: a.clearCofactor,
                    fromBytes: a.fromBytes,
                    toBytes: a.toBytes,
                  }),
                  { CURVE: b, curveOpts: e }),
                h = {
                  hmac: a.hmac,
                  randomBytes: a.randomBytes,
                  lowS: a.lowS,
                  bits2int: a.bits2int,
                  bits2int_modN: a.bits2int_modN,
                };
              return { CURVE: f, curveOpts: g, hash: a.hash, ecdsaOpts: h };
            })(a),
            g = (function (a, b, c = {}) {
              i_(b),
                nZ(
                  c,
                  {},
                  {
                    hmac: 'function',
                    lowS: 'boolean',
                    randomBytes: 'function',
                    bits2int: 'function',
                    bits2int_modN: 'function',
                  }
                );
              let d = c.randomBytes || jl,
                e = c.hmac || ((a, ...c) => nK(b, a, ji(...c))),
                { Fp: f, Fn: g } = a,
                { ORDER: h, BITS: i } = g,
                {
                  keygen: j,
                  getPublicKey: k,
                  getSharedSecret: l,
                  utils: m,
                  lengths: n,
                } = (function (a, b = {}) {
                  let { Fn: c } = a,
                    d = b.randomBytes || jl,
                    e = Object.assign(oL(a.Fp, c), { seed: om(c.ORDER) });
                  function f(a) {
                    try {
                      return !!oJ(c, a);
                    } catch (a) {
                      return !1;
                    }
                  }
                  function g(a = d(e.seed)) {
                    return (function (a, b, c = !1) {
                      let d = a.length,
                        e = ol(b),
                        f = om(b);
                      if (d < 16 || d < f || d > 1024)
                        throw Error('expected ' + f + '-1024 bytes of input, got ' + d);
                      let g = n9(c ? nS(a) : nR(a), b - n0) + n0;
                      return c ? nU(g, e) : nT(g, e);
                    })(nO(a, e.seed, 'seed'), c.ORDER);
                  }
                  function h(b, d = !0) {
                    return a.BASE.multiply(oJ(c, b)).toBytes(d);
                  }
                  function i(b) {
                    if ('bigint' == typeof b) return !1;
                    if (b instanceof a) return !0;
                    let { secretKey: d, publicKey: f, publicKeyUncompressed: g } = e;
                    if (c.allowedLengths || d === f) return;
                    let h = nV('key', b).length;
                    return h === f || h === g;
                  }
                  return Object.freeze({
                    getPublicKey: h,
                    getSharedSecret: function (b, d, e = !0) {
                      if (!0 === i(b)) throw Error('first arg must be private key');
                      if (!1 === i(d)) throw Error('second arg must be public key');
                      let f = oJ(c, b);
                      return a.fromHex(d).multiply(f).toBytes(e);
                    },
                    keygen: function (a) {
                      let b = g(a);
                      return { secretKey: b, publicKey: h(b) };
                    },
                    Point: a,
                    utils: {
                      isValidSecretKey: f,
                      isValidPublicKey: function (b, c) {
                        let { publicKey: d, publicKeyUncompressed: f } = e;
                        try {
                          let e = b.length;
                          if ((!0 === c && e !== d) || (!1 === c && e !== f)) return !1;
                          return !!a.fromBytes(b);
                        } catch (a) {
                          return !1;
                        }
                      },
                      randomSecretKey: g,
                      isValidPrivateKey: f,
                      randomPrivateKey: g,
                      normPrivateKeyToScalar: (a) => oJ(c, a),
                      precompute: (b = 8, c = a.BASE) => c.precompute(b, !1),
                    },
                    lengths: e,
                  });
                })(a, c),
                o = {
                  prehash: !1,
                  lowS: 'boolean' == typeof c.lowS && c.lowS,
                  format: void 0,
                  extraEntropy: !1,
                },
                p = 'compact';
              function q(a, b) {
                if (!g.isValidNot0(b))
                  throw Error(`invalid signature ${a}: out of range 1..Point.Fn.ORDER`);
                return b;
              }
              class s {
                constructor(a, b, c) {
                  (this.r = q('r', a)),
                    (this.s = q('s', b)),
                    null != c && (this.recovery = c),
                    Object.freeze(this);
                }
                static fromBytes(a, b = p) {
                  var c, d;
                  let e, f;
                  if (
                    ((c = a),
                    oB((d = b)),
                    (f = n.signature),
                    nO(
                      c,
                      'compact' === d ? f : 'recovered' === d ? f + 1 : void 0,
                      `${d} signature`
                    ),
                    'der' === b)
                  ) {
                    let { r: b, s: c } = oD.toSig(nO(a));
                    return new s(b, c);
                  }
                  'recovered' === b && ((e = a[0]), (b = 'compact'), (a = a.subarray(1)));
                  let h = g.BYTES,
                    i = a.subarray(0, h),
                    j = a.subarray(h, 2 * h);
                  return new s(g.fromBytes(i), g.fromBytes(j), e);
                }
                static fromHex(a, b) {
                  return this.fromBytes(je(a), b);
                }
                addRecoveryBit(a) {
                  return new s(this.r, this.s, a);
                }
                recoverPublicKey(b) {
                  let c = f.ORDER,
                    { r: d, s: e, recovery: i } = this;
                  if (null == i || ![0, 1, 2, 3].includes(i)) throw Error('recovery id invalid');
                  if (h * oG < c && i > 1) throw Error('recovery id is ambiguous for h>1 curve');
                  let j = 2 === i || 3 === i ? d + h : d;
                  if (!f.isValid(j)) throw Error('recovery id 2 or 3 invalid');
                  let k = f.toBytes(j),
                    l = a.fromBytes(ji(oK((1 & i) == 0), k)),
                    m = g.inv(j),
                    n = u(nV('msgHash', b)),
                    o = g.create(-n * m),
                    p = g.create(e * m),
                    q = a.BASE.multiplyUnsafe(o).add(l.multiplyUnsafe(p));
                  if (q.is0()) throw Error('point at infinify');
                  return q.assertValidity(), q;
                }
                hasHighS() {
                  return this.s > h >> oF;
                }
                toBytes(a = p) {
                  if ((oB(a), 'der' === a)) return je(oD.hexFromSig(this));
                  let b = g.toBytes(this.r),
                    c = g.toBytes(this.s);
                  if ('recovered' === a) {
                    if (null == this.recovery) throw Error('recovery bit must be present');
                    return ji(Uint8Array.of(this.recovery), b, c);
                  }
                  return ji(b, c);
                }
                toHex(a) {
                  return jc(this.toBytes(a));
                }
                assertValidity() {}
                static fromCompact(a) {
                  return s.fromBytes(nV('sig', a), 'compact');
                }
                static fromDER(a) {
                  return s.fromBytes(nV('sig', a), 'der');
                }
                normalizeS() {
                  return this.hasHighS() ? new s(this.r, g.neg(this.s), this.recovery) : this;
                }
                toDERRawBytes() {
                  return this.toBytes('der');
                }
                toDERHex() {
                  return jc(this.toBytes('der'));
                }
                toCompactRawBytes() {
                  return this.toBytes('compact');
                }
                toCompactHex() {
                  return jc(this.toBytes('compact'));
                }
              }
              let t =
                  c.bits2int ||
                  function (a) {
                    if (a.length > 8192) throw Error('input is too large');
                    let b = nR(a),
                      c = 8 * a.length - i;
                    return c > 0 ? b >> BigInt(c) : b;
                  },
                u =
                  c.bits2int_modN ||
                  function (a) {
                    return g.create(t(a));
                  },
                v = nY(i);
              function w(a) {
                return (
                  !(function (a, b, c, d) {
                    if (!(nW(b) && nW(c) && nW(d)) || !(c <= b) || !(b < d))
                      throw Error('expected valid ' + a + ': ' + c + ' <= n < ' + d + ', got ' + b);
                  })('num < 2^' + i, a, oE, v),
                  g.toBytes(a)
                );
              }
              function x(a, c) {
                return nO(a, void 0, 'message'), c ? nO(b(a), void 0, 'prehashed message') : a;
              }
              return Object.freeze({
                keygen: j,
                getPublicKey: k,
                getSharedSecret: l,
                utils: m,
                lengths: n,
                Point: a,
                sign: function (c, f, i = {}) {
                  let { seed: j, k2sig: k } = (function (b, c, e) {
                    if (['recovered', 'canonical'].some((a) => a in e))
                      throw Error('sign() legacy options not supported');
                    let { lowS: f, prehash: i, extraEntropy: j } = oC(e, o),
                      k = u((b = x(b, i))),
                      l = oJ(g, c),
                      m = [w(l), w(k)];
                    if (null != j && !1 !== j) {
                      let a = !0 === j ? d(n.secretKey) : j;
                      m.push(nV('extraEntropy', a));
                    }
                    return {
                      seed: ji(...m),
                      k2sig: function (b) {
                        let c = t(b);
                        if (!g.isValidNot0(c)) return;
                        let d = g.inv(c),
                          e = a.BASE.multiply(c).toAffine(),
                          i = g.create(e.x);
                        if (i === oE) return;
                        let j = g.create(d * g.create(k + i * l));
                        if (j === oE) return;
                        let m = (2 * (e.x !== i)) | Number(e.y & oF),
                          n = j;
                        return f && j > h >> oF && ((n = g.neg(j)), (m ^= 1)), new s(i, n, m);
                      },
                    };
                  })((c = nV('message', c)), f, i);
                  return (function (a, b, c) {
                    if ('number' != typeof a || a < 2) throw Error('hashLen must be a number');
                    if ('number' != typeof b || b < 2) throw Error('qByteLen must be a number');
                    if ('function' != typeof c) throw Error('hmacFn must be a function');
                    let d = (a) => new Uint8Array(a),
                      e = d(a),
                      f = d(a),
                      g = 0,
                      h = () => {
                        e.fill(1), f.fill(0), (g = 0);
                      },
                      i = (...a) => c(f, e, ...a),
                      j = (a = d(0)) => {
                        ((f = i(Uint8Array.of(0), a)), (e = i()), 0 !== a.length) &&
                          ((f = i(Uint8Array.of(1), a)), (e = i()));
                      },
                      k = () => {
                        if (g++ >= 1e3) throw Error('drbg: tried 1000 values');
                        let a = 0,
                          c = [];
                        for (; a < b; ) {
                          let b = (e = i()).slice();
                          c.push(b), (a += e.length);
                        }
                        return ji(...c);
                      };
                    return (a, b) => {
                      let c;
                      for (h(), j(a); !(c = b(k())); ) j();
                      return h(), c;
                    };
                  })(
                    b.outputLen,
                    g.BYTES,
                    e
                  )(j, k);
                },
                verify: function (b, c, d, e = {}) {
                  let { lowS: f, prehash: h, format: i } = oC(e, o);
                  if (((d = nV('publicKey', d)), (c = x(nV('message', c), h)), 'strict' in e))
                    throw Error('options.strict was renamed to lowS');
                  let j =
                    void 0 === i
                      ? (function (a) {
                          let b,
                            c = 'string' == typeof a || iY(a),
                            d =
                              !c &&
                              null !== a &&
                              'object' == typeof a &&
                              'bigint' == typeof a.r &&
                              'bigint' == typeof a.s;
                          if (!c && !d)
                            throw Error(
                              'invalid signature, expected Uint8Array, hex string or Signature instance'
                            );
                          if (d) b = new s(a.r, a.s);
                          else if (c) {
                            try {
                              b = s.fromBytes(nV('sig', a), 'der');
                            } catch (a) {
                              if (!(a instanceof oD.Err)) throw a;
                            }
                            if (!b)
                              try {
                                b = s.fromBytes(nV('sig', a), 'compact');
                              } catch (a) {
                                return !1;
                              }
                          }
                          return !!b && b;
                        })(b)
                      : s.fromBytes(nV('sig', b), i);
                  if (!1 === j) return !1;
                  try {
                    let b = a.fromBytes(d);
                    if (f && j.hasHighS()) return !1;
                    let { r: e, s: h } = j,
                      i = u(c),
                      k = g.inv(h),
                      l = g.create(i * k),
                      m = g.create(e * k),
                      n = a.BASE.multiplyUnsafe(l).add(b.multiplyUnsafe(m));
                    if (n.is0()) return !1;
                    return g.create(n.x) === e;
                  } catch (a) {
                    return !1;
                  }
                },
                recoverPublicKey: function (a, b, c = {}) {
                  let { prehash: d } = oC(c, o);
                  return (b = x(b, d)), s.fromBytes(a, 'recovered').recoverPublicKey(b).toBytes();
                },
                Signature: s,
                hash: b,
              });
            })(
              (function (a, b = {}) {
                let c = (function (a, b, c = {}, d) {
                    if ((void 0 === d && (d = 'edwards' === a), !b || 'object' != typeof b))
                      throw Error(`expected valid ${a} CURVE object`);
                    for (let a of ['p', 'n', 'h']) {
                      let c = b[a];
                      if (!('bigint' == typeof c && c > on))
                        throw Error(`CURVE.${a} must be positive bigint`);
                    }
                    let e = oz(b.p, c.Fp, d),
                      f = oz(b.n, c.Fn, d);
                    for (let c of ['Gx', 'Gy', 'a', 'weierstrass' === a ? 'b' : 'd'])
                      if (!e.isValid(b[c]))
                        throw Error(`CURVE.${c} must be valid field element of CURVE.Fp`);
                    return { CURVE: (b = Object.freeze(Object.assign({}, b))), Fp: e, Fn: f };
                  })('weierstrass', a, b),
                  { Fp: d, Fn: e } = c,
                  f = c.CURVE,
                  { h: g, n: h } = f;
                nZ(
                  b,
                  {},
                  {
                    allowInfinityPoint: 'boolean',
                    clearCofactor: 'function',
                    isTorsionFree: 'function',
                    fromBytes: 'function',
                    toBytes: 'function',
                    endo: 'object',
                    wrapPrivateKey: 'boolean',
                  }
                );
                let { endo: i } = b;
                if (i && (!d.is0(f.a) || 'bigint' != typeof i.beta || !Array.isArray(i.basises)))
                  throw Error('invalid endo: expected "beta": bigint and "basises": array');
                let j = oL(d, e);
                function k() {
                  if (!d.isOdd)
                    throw Error('compression is not supported: Field does not have .isOdd()');
                }
                let l =
                    b.toBytes ||
                    function (a, b, c) {
                      let { x: e, y: f } = b.toAffine(),
                        g = d.toBytes(e);
                      return (nN(c, 'isCompressed'), c)
                        ? (k(), ji(oK(!d.isOdd(f)), g))
                        : ji(Uint8Array.of(4), g, d.toBytes(f));
                    },
                  m =
                    b.fromBytes ||
                    function (a) {
                      nO(a, void 0, 'Point');
                      let { publicKey: b, publicKeyUncompressed: c } = j,
                        e = a.length,
                        f = a[0],
                        g = a.subarray(1);
                      if (e === b && (2 === f || 3 === f)) {
                        let a,
                          b = d.fromBytes(g);
                        if (!d.isValid(b)) throw Error('bad point: is not on curve, wrong x');
                        let c = n(b);
                        try {
                          a = d.sqrt(c);
                        } catch (a) {
                          throw Error(
                            'bad point: is not on curve, sqrt error' +
                              (a instanceof Error ? ': ' + a.message : '')
                          );
                        }
                        return k(), ((1 & f) == 1) !== d.isOdd(a) && (a = d.neg(a)), { x: b, y: a };
                      }
                      if (e === c && 4 === f) {
                        let a = d.BYTES,
                          b = d.fromBytes(g.subarray(0, a)),
                          c = d.fromBytes(g.subarray(a, 2 * a));
                        if (!o(b, c)) throw Error('bad point: is not on curve');
                        return { x: b, y: c };
                      }
                      throw Error(
                        `bad point: got length ${e}, expected compressed=${b} or uncompressed=${c}`
                      );
                    };
                function n(a) {
                  let b = d.sqr(a),
                    c = d.mul(b, a);
                  return d.add(d.add(c, d.mul(a, f.a)), f.b);
                }
                function o(a, b) {
                  let c = d.sqr(b),
                    e = n(a);
                  return d.eql(c, e);
                }
                if (!o(f.Gx, f.Gy)) throw Error('bad curve params: generator point');
                let p = d.mul(d.pow(f.a, oH), oI),
                  q = d.mul(d.sqr(f.b), BigInt(27));
                if (d.is0(d.add(p, q))) throw Error('bad curve params: a or b');
                function s(a, b, c = !1) {
                  if (!d.isValid(b) || (c && d.is0(b))) throw Error(`bad point coordinate ${a}`);
                  return b;
                }
                function t(a) {
                  if (!(a instanceof y)) throw Error('ProjectivePoint expected');
                }
                function u(a) {
                  if (!i || !i.basises) throw Error('no endo');
                  return (function (a, b, c) {
                    let [[d, e], [f, g]] = b,
                      h = oA(g * a, c),
                      i = oA(-e * a, c),
                      j = a - h * d - i * f,
                      k = -h * e - i * g,
                      l = j < oE,
                      m = k < oE;
                    l && (j = -j), m && (k = -k);
                    let n = nY(Math.ceil(nX(c) / 2)) + oF;
                    if (j < oE || j >= n || k < oE || k >= n)
                      throw Error('splitScalar (endomorphism): failed, k=' + a);
                    return { k1neg: l, k1: j, k2neg: m, k2: k };
                  })(a, i.basises, e.ORDER);
                }
                let v = n$((a, b) => {
                    let { X: c, Y: e, Z: f } = a;
                    if (d.eql(f, d.ONE)) return { x: c, y: e };
                    let g = a.is0();
                    null == b && (b = g ? d.ONE : d.inv(f));
                    let h = d.mul(c, b),
                      i = d.mul(e, b),
                      j = d.mul(f, b);
                    if (g) return { x: d.ZERO, y: d.ZERO };
                    if (!d.eql(j, d.ONE)) throw Error('invZ was invalid');
                    return { x: h, y: i };
                  }),
                  w = n$((a) => {
                    if (a.is0()) {
                      if (b.allowInfinityPoint && !d.is0(a.Y)) return;
                      throw Error('bad point: ZERO');
                    }
                    let { x: c, y: e } = a.toAffine();
                    if (!d.isValid(c) || !d.isValid(e))
                      throw Error('bad point: x or y not field elements');
                    if (!o(c, e)) throw Error('bad point: equation left != right');
                    if (!a.isTorsionFree()) throw Error('bad point: not in prime-order subgroup');
                    return !0;
                  });
                function x(a, b, c, e, f) {
                  return (
                    (c = new y(d.mul(c.X, a), c.Y, c.Z)), (b = op(e, b)), (c = op(f, c)), b.add(c)
                  );
                }
                class y {
                  constructor(a, b, c) {
                    (this.X = s('x', a)),
                      (this.Y = s('y', b, !0)),
                      (this.Z = s('z', c)),
                      Object.freeze(this);
                  }
                  static CURVE() {
                    return f;
                  }
                  static fromAffine(a) {
                    let { x: b, y: c } = a || {};
                    if (!a || !d.isValid(b) || !d.isValid(c)) throw Error('invalid affine point');
                    if (a instanceof y) throw Error('projective point not allowed');
                    return d.is0(b) && d.is0(c) ? y.ZERO : new y(b, c, d.ONE);
                  }
                  static fromBytes(a) {
                    let b = y.fromAffine(m(nO(a, void 0, 'point')));
                    return b.assertValidity(), b;
                  }
                  static fromHex(a) {
                    return y.fromBytes(nV('pointHex', a));
                  }
                  get x() {
                    return this.toAffine().x;
                  }
                  get y() {
                    return this.toAffine().y;
                  }
                  precompute(a = 8, b = !0) {
                    return A.createCache(this, a), b || this.multiply(oH), this;
                  }
                  assertValidity() {
                    w(this);
                  }
                  hasEvenY() {
                    let { y: a } = this.toAffine();
                    if (!d.isOdd) throw Error("Field doesn't support isOdd");
                    return !d.isOdd(a);
                  }
                  equals(a) {
                    t(a);
                    let { X: b, Y: c, Z: e } = this,
                      { X: f, Y: g, Z: h } = a,
                      i = d.eql(d.mul(b, h), d.mul(f, e)),
                      j = d.eql(d.mul(c, h), d.mul(g, e));
                    return i && j;
                  }
                  negate() {
                    return new y(this.X, d.neg(this.Y), this.Z);
                  }
                  double() {
                    let { a, b } = f,
                      c = d.mul(b, oH),
                      { X: e, Y: g, Z: h } = this,
                      i = d.ZERO,
                      j = d.ZERO,
                      k = d.ZERO,
                      l = d.mul(e, e),
                      m = d.mul(g, g),
                      n = d.mul(h, h),
                      o = d.mul(e, g);
                    return (
                      (o = d.add(o, o)),
                      (k = d.mul(e, h)),
                      (k = d.add(k, k)),
                      (i = d.mul(a, k)),
                      (j = d.mul(c, n)),
                      (j = d.add(i, j)),
                      (i = d.sub(m, j)),
                      (j = d.add(m, j)),
                      (j = d.mul(i, j)),
                      (i = d.mul(o, i)),
                      (k = d.mul(c, k)),
                      (n = d.mul(a, n)),
                      (o = d.sub(l, n)),
                      (o = d.mul(a, o)),
                      (o = d.add(o, k)),
                      (k = d.add(l, l)),
                      (l = d.add(k, l)),
                      (l = d.add(l, n)),
                      (l = d.mul(l, o)),
                      (j = d.add(j, l)),
                      (n = d.mul(g, h)),
                      (n = d.add(n, n)),
                      (l = d.mul(n, o)),
                      (i = d.sub(i, l)),
                      (k = d.mul(n, m)),
                      (k = d.add(k, k)),
                      new y(i, j, (k = d.add(k, k)))
                    );
                  }
                  add(a) {
                    t(a);
                    let { X: b, Y: c, Z: e } = this,
                      { X: g, Y: h, Z: i } = a,
                      j = d.ZERO,
                      k = d.ZERO,
                      l = d.ZERO,
                      m = f.a,
                      n = d.mul(f.b, oH),
                      o = d.mul(b, g),
                      p = d.mul(c, h),
                      q = d.mul(e, i),
                      s = d.add(b, c),
                      u = d.add(g, h);
                    (s = d.mul(s, u)), (u = d.add(o, p)), (s = d.sub(s, u)), (u = d.add(b, e));
                    let v = d.add(g, i);
                    return (
                      (u = d.mul(u, v)),
                      (v = d.add(o, q)),
                      (u = d.sub(u, v)),
                      (v = d.add(c, e)),
                      (j = d.add(h, i)),
                      (v = d.mul(v, j)),
                      (j = d.add(p, q)),
                      (v = d.sub(v, j)),
                      (l = d.mul(m, u)),
                      (j = d.mul(n, q)),
                      (l = d.add(j, l)),
                      (j = d.sub(p, l)),
                      (l = d.add(p, l)),
                      (k = d.mul(j, l)),
                      (p = d.add(o, o)),
                      (p = d.add(p, o)),
                      (q = d.mul(m, q)),
                      (u = d.mul(n, u)),
                      (p = d.add(p, q)),
                      (q = d.sub(o, q)),
                      (q = d.mul(m, q)),
                      (u = d.add(u, q)),
                      (o = d.mul(p, u)),
                      (k = d.add(k, o)),
                      (o = d.mul(v, u)),
                      (j = d.mul(s, j)),
                      (j = d.sub(j, o)),
                      (o = d.mul(s, p)),
                      (l = d.mul(v, l)),
                      new y(j, k, (l = d.add(l, o)))
                    );
                  }
                  subtract(a) {
                    return this.add(a.negate());
                  }
                  is0() {
                    return this.equals(y.ZERO);
                  }
                  multiply(a) {
                    let c,
                      d,
                      { endo: f } = b;
                    if (!e.isValidNot0(a)) throw Error('invalid scalar: out of range');
                    let g = (a) => A.cached(this, a, (a) => oq(y, a));
                    if (f) {
                      let { k1neg: b, k1: e, k2neg: h, k2: i } = u(a),
                        { p: j, f: k } = g(e),
                        { p: l, f: m } = g(i);
                      (d = k.add(m)), (c = x(f.beta, j, l, b, h));
                    } else {
                      let { p: b, f: e } = g(a);
                      (c = b), (d = e);
                    }
                    return oq(y, [c, d])[0];
                  }
                  multiplyUnsafe(a) {
                    let { endo: c } = b;
                    if (!e.isValid(a)) throw Error('invalid scalar: out of range');
                    if (a === oE || this.is0()) return y.ZERO;
                    if (a === oF) return this;
                    if (A.hasCache(this)) return this.multiply(a);
                    if (!c) return A.unsafe(this, a);
                    {
                      let { k1neg: b, k1: d, k2neg: e, k2: f } = u(a),
                        { p1: g, p2: h } = (function (a, b, c, d) {
                          let e = b,
                            f = a.ZERO,
                            g = a.ZERO;
                          for (; c > on || d > on; )
                            c & oo && (f = f.add(e)),
                              d & oo && (g = g.add(e)),
                              (e = e.double()),
                              (c >>= oo),
                              (d >>= oo);
                          return { p1: f, p2: g };
                        })(y, this, d, f);
                      return x(c.beta, g, h, b, e);
                    }
                  }
                  multiplyAndAddUnsafe(a, b, c) {
                    let d = this.multiplyUnsafe(b).add(a.multiplyUnsafe(c));
                    return d.is0() ? void 0 : d;
                  }
                  toAffine(a) {
                    return v(this, a);
                  }
                  isTorsionFree() {
                    let { isTorsionFree: a } = b;
                    return g === oF || (a ? a(y, this) : A.unsafe(this, h).is0());
                  }
                  clearCofactor() {
                    let { clearCofactor: a } = b;
                    return g === oF ? this : a ? a(y, this) : this.multiplyUnsafe(g);
                  }
                  isSmallOrder() {
                    return this.multiplyUnsafe(g).is0();
                  }
                  toBytes(a = !0) {
                    return nN(a, 'isCompressed'), this.assertValidity(), l(y, this, a);
                  }
                  toHex(a = !0) {
                    return jc(this.toBytes(a));
                  }
                  toString() {
                    return `<Point ${this.is0() ? 'ZERO' : this.toHex()}>`;
                  }
                  get px() {
                    return this.X;
                  }
                  get py() {
                    return this.X;
                  }
                  get pz() {
                    return this.Z;
                  }
                  toRawBytes(a = !0) {
                    return this.toBytes(a);
                  }
                  _setWindowSize(a) {
                    this.precompute(a);
                  }
                  static normalizeZ(a) {
                    return oq(y, a);
                  }
                  static msm(a, b) {
                    return (function (a, b, c, d) {
                      if (!Array.isArray(c)) throw Error('array expected');
                      c.forEach((b, c) => {
                        if (!(b instanceof a)) throw Error('invalid point at index ' + c);
                      });
                      if (!Array.isArray(d)) throw Error('array of scalars expected');
                      d.forEach((a, c) => {
                        if (!b.isValid(a)) throw Error('invalid scalar at index ' + c);
                      });
                      let e = c.length,
                        f = d.length;
                      if (e !== f)
                        throw Error('arrays of points and scalars must have equal length');
                      let g = a.ZERO,
                        h = nX(BigInt(e)),
                        i = 1;
                      h > 12 ? (i = h - 3) : h > 4 ? (i = h - 2) : h > 0 && (i = 2);
                      let j = nY(i),
                        k = Array(Number(j) + 1).fill(g),
                        l = Math.floor((b.BITS - 1) / i) * i,
                        m = g;
                      for (let a = l; a >= 0; a -= i) {
                        k.fill(g);
                        for (let b = 0; b < f; b++) {
                          let e = Number((d[b] >> BigInt(a)) & j);
                          k[e] = k[e].add(c[b]);
                        }
                        let b = g;
                        for (let a = k.length - 1, c = g; a > 0; a--)
                          (c = c.add(k[a])), (b = b.add(c));
                        if (((m = m.add(b)), 0 !== a)) for (let a = 0; a < i; a++) m = m.double();
                      }
                      return m;
                    })(y, e, a, b);
                  }
                  static fromPrivateKey(a) {
                    return y.BASE.multiply(oJ(e, a));
                  }
                }
                (y.BASE = new y(f.Gx, f.Gy, d.ONE)),
                  (y.ZERO = new y(d.ZERO, d.ONE, d.ZERO)),
                  (y.Fp = d),
                  (y.Fn = e);
                let z = e.BITS,
                  A = new oy(y, b.endo ? Math.ceil(z / 2) : z);
                return y.BASE.precompute(8), y;
              })(c, d),
              e,
              f
            );
          return (
            (b = g.Point),
            Object.assign({}, g, {
              ProjectivePoint: b,
              CURVE: Object.assign({}, a, oj(b.Fn.ORDER, b.Fn.BITS)),
            })
          );
        })({ ...a, hash: b });
      return { ...c(b), create: c };
    }
    jf('HashToScalar-');
    let oN = {
        p: BigInt('0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff'),
        n: BigInt('0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551'),
        h: BigInt(1),
        a: BigInt('0xffffffff00000001000000000000000000000000fffffffffffffffffffffffc'),
        b: BigInt('0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b'),
        Gx: BigInt('0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296'),
        Gy: BigInt('0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5'),
      },
      oO = {
        p: BigInt(
          '0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffeffffffff0000000000000000ffffffff'
        ),
        n: BigInt(
          '0xffffffffffffffffffffffffffffffffffffffffffffffffc7634d81f4372ddf581a0db248b0a77aecec196accc52973'
        ),
        h: BigInt(1),
        a: BigInt(
          '0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffeffffffff0000000000000000fffffffc'
        ),
        b: BigInt(
          '0xb3312fa7e23ee7e4988e056be3f82d19181d9c6efe8141120314088f5013875ac656398d8a2ed19d2a85c8edd3ec2aef'
        ),
        Gx: BigInt(
          '0xaa87ca22be8b05378eb1c71ef320ad746e1d3b628ba79b9859f741e082542a385502f25dbf55296c3a545e3872760ab7'
        ),
        Gy: BigInt(
          '0x3617de4a96262c6f5d9e98bf9292dc29f8f41dbd289a147ce9da3113b5f0b8c00a60b1ce1d7e819d7a431d7c90ea0e5f'
        ),
      },
      oP = {
        p: BigInt(
          '0x1ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff'
        ),
        n: BigInt(
          '0x01fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa51868783bf2f966b7fcc0148f709a5d03bb5c9b8899c47aebb6fb71e91386409'
        ),
        h: BigInt(1),
        a: BigInt(
          '0x1fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc'
        ),
        b: BigInt(
          '0x0051953eb9618e1c9a1f929a21a0b68540eea2da725b99b315f3b8b489918ef109e156193951ec7e937b1652c0bd3bb1bf073573df883d2c34f1ef451fd46b503f00'
        ),
        Gx: BigInt(
          '0x00c6858e06b70404e9cd9e3ecb662395b4429c648139053fb521f828af606b4d3dbaa14b5e77efe75928fe1dc127a2ffa8de3348b3c1856a429bf97e7e31c2e5bd66'
        ),
        Gy: BigInt(
          '0x011839296a789a3bc0045c8a5fb42c7d1bd998f54449579b446817afbd17273e662c97ee72995ef42640c550b9013fad0761353c7086a272c24088be94769fd16650'
        ),
      },
      oQ = ok(oN.p),
      oR = ok(oO.p),
      oS = ok(oP.p),
      oT = oM({ ...oN, Fp: oQ, lowS: !1 }, nG);
    function oU(a, b) {
      if (a === b) return !0;
      if (a.length !== b.length) return !1;
      for (let c = 0; c < a.length; c++) if (a[c] !== b[c]) return !1;
      return !0;
    }
    (function (a, b, c) {
      if ('function' != typeof b) throw Error('mapToCurve() must be defined');
    })(
      oT.Point,
      ((R = oT.Point),
      (S = { A: oN.a, B: oN.b, Z: oT.Point.Fp.create(BigInt('-10')) }),
      (t = (function (a, b) {
        og(a);
        let { A: c, B: d, Z: e } = b;
        if (!a.isValid(c) || !a.isValid(d) || !a.isValid(e))
          throw Error('mapToCurveSimpleSWU: invalid opts');
        let f = (function (a, b) {
          let c = a.ORDER,
            d = oE;
          for (let a = c - oF; a % oG === oE; a /= oG) d += oF;
          let e = d,
            f = oG << (e - oF - oF),
            g = f * oG,
            h = (c - oF) / g,
            i = (h - oF) / oG,
            j = g - oF,
            k = a.pow(b, h),
            l = a.pow(b, (h + oF) / oG),
            m = (b, c) => {
              let d = k,
                g = a.pow(c, j),
                h = a.sqr(g);
              h = a.mul(h, c);
              let m = a.mul(b, h);
              (m = a.pow(m, i)), (m = a.mul(m, g)), (g = a.mul(m, c)), (h = a.mul(m, b));
              let n = a.mul(h, g);
              m = a.pow(n, f);
              let o = a.eql(m, a.ONE);
              (g = a.mul(h, l)), (m = a.mul(n, d)), (h = a.cmov(g, h, o)), (n = a.cmov(m, n, o));
              for (let b = e; b > oF; b--) {
                let c = b - oG;
                c = oG << (c - oF);
                let e = a.pow(n, c),
                  f = a.eql(e, a.ONE);
                (g = a.mul(h, d)),
                  (d = a.mul(d, d)),
                  (e = a.mul(n, d)),
                  (h = a.cmov(g, h, f)),
                  (n = a.cmov(e, n, f));
              }
              return { isValid: o, value: h };
            };
          if (a.ORDER % oI === oH) {
            let c = (a.ORDER - oH) / oI,
              d = a.sqrt(a.neg(b));
            m = (b, e) => {
              let f = a.sqr(e),
                g = a.mul(b, e);
              f = a.mul(f, g);
              let h = a.pow(f, c);
              h = a.mul(h, g);
              let i = a.mul(h, d),
                j = a.mul(a.sqr(h), e),
                k = a.eql(j, b),
                l = a.cmov(i, h, k);
              return { isValid: k, value: l };
            };
          }
          return m;
        })(a, e);
        if (!a.isOdd) throw Error('Field does not have .isOdd()');
        return (b) => {
          let g, h, i, j, k, l, m, n;
          (g = a.sqr(b)),
            (g = a.mul(g, e)),
            (h = a.sqr(g)),
            (h = a.add(h, g)),
            (i = a.add(h, a.ONE)),
            (i = a.mul(i, d)),
            (j = a.cmov(e, a.neg(h), !a.eql(h, a.ZERO))),
            (j = a.mul(j, c)),
            (h = a.sqr(i)),
            (l = a.sqr(j)),
            (k = a.mul(l, c)),
            (h = a.add(h, k)),
            (h = a.mul(h, i)),
            (l = a.mul(l, j)),
            (k = a.mul(l, d)),
            (h = a.add(h, k)),
            (m = a.mul(g, i));
          let { isValid: o, value: p } = f(h, l);
          (n = a.mul(g, b)), (n = a.mul(n, p)), (m = a.cmov(m, i, o)), (n = a.cmov(n, p, o));
          let q = a.isOdd(b) === a.isOdd(n);
          n = a.cmov(a.neg(n), n, q);
          let s = oh(a, [j], !0)[0];
          return { x: (m = a.mul(m, s)), y: n };
        };
      })(R.Fp, S)),
      (a) => t(a[0])),
      oN.p
    ),
      oM({ ...oO, Fp: oR, lowS: !1 }, nI),
      oM({ ...oP, Fp: oS, lowS: !1, allowedPrivateKeyLengths: [130, 131, 132] }, nH);
    class oV {
      equals(a) {
        return oU(this.toRawBytes(), a.toRawBytes());
      }
      toBase64() {
        return dU(this.toRawBytes());
      }
      toString() {
        throw Error(
          '`toString` is not implemented on public keys. Use `toBase64()` or `toRawBytes()` instead.'
        );
      }
      toIotaPublicKey() {
        return dU(this.toIotaBytes());
      }
      verifyWithIntent(a, b, c) {
        let d = jP(ns(c, a), { dkLen: 32 });
        return this.verify(d, b);
      }
      verifyPersonalMessage(a, b) {
        return this.verifyWithIntent(
          mm.vector(mm.u8()).serialize(a).toBytes(),
          b,
          'PersonalMessage'
        );
      }
      verifyTransaction(a, b) {
        return this.verifyWithIntent(a, b, 'TransactionData');
      }
      toIotaBytes() {
        let a = this.toRawBytes(),
          b = new Uint8Array(a.length + 1);
        return b.set([this.flag()]), b.set(a, 1), b;
      }
      toIotaBytesForAddress() {
        let a = this.toRawBytes();
        if (this.flag() === nt.ED25519) return a;
        {
          let b = new Uint8Array(a.length + 1);
          return b.set([this.flag()]), b.set(a, 1), b;
        }
      }
      toIotaAddress() {
        return dZ(jc(jP(this.toIotaBytesForAddress(), { dkLen: 32 })).slice(0, 64));
      }
    }
    new Uint8Array([
      48, 89, 48, 19, 6, 7, 42, 134, 72, 206, 61, 2, 1, 6, 8, 42, 134, 72, 206, 61, 3, 1, 7, 3, 66,
      0,
    ]);
    let oW = 'iotaprivkey';
    class oX {
      async signWithIntent(a, b) {
        let c = jP(ns(b, a), { dkLen: 32 });
        return {
          signature: (function ({ signature: a, signatureScheme: b, publicKey: c }) {
            if (!c) throw Error('`publicKey` is required');
            let d = c.toRawBytes(),
              e = new Uint8Array(1 + a.length + d.length);
            return e.set([nt[b]]), e.set(a, 1), e.set(d, 1 + a.length), dU(e);
          })({
            signature: await this.sign(c),
            signatureScheme: this.getKeyScheme(),
            publicKey: this.getPublicKey(),
          }),
          bytes: dU(a),
        };
      }
      async signTransaction(a) {
        return this.signWithIntent(a, 'TransactionData');
      }
      async signPersonalMessage(a) {
        let { signature: b } = await this.signWithIntent(
          lA.vector(lA.u8()).serialize(a).toBytes(),
          'PersonalMessage'
        );
        return { bytes: dU(a), signature: b };
      }
      toIotaAddress() {
        return this.getPublicKey().toIotaAddress();
      }
    }
    class oY extends oX {}
    function oZ(a) {
      return (
        a instanceof Uint8Array || (ArrayBuffer.isView(a) && 'Uint8Array' === a.constructor.name)
      );
    }
    function o$(a, b) {
      return (
        !!Array.isArray(b) &&
        (0 === b.length ||
          (a ? b.every((a) => 'string' == typeof a) : b.every((a) => Number.isSafeInteger(a))))
      );
    }
    function o_(a) {
      if ('function' != typeof a) throw Error('function expected');
      return !0;
    }
    function o0(a, b) {
      if ('string' != typeof b) throw Error(`${a}: string expected`);
      return !0;
    }
    function o1(a) {
      if (!Number.isSafeInteger(a)) throw Error(`invalid integer: ${a}`);
    }
    function o2(a) {
      if (!Array.isArray(a)) throw Error('array expected');
    }
    function o3(a, b) {
      if (!o$(!0, b)) throw Error(`${a}: array of strings expected`);
    }
    function o4(a, b) {
      if (!o$(!1, b)) throw Error(`${a}: array of numbers expected`);
    }
    function o5(...a) {
      let b = (a) => a,
        c = (a, b) => (c) => a(b(c));
      return {
        encode: a.map((a) => a.encode).reduceRight(c, b),
        decode: a.map((a) => a.decode).reduce(c, b),
      };
    }
    function o6(a) {
      let b = 'string' == typeof a ? a.split('') : a,
        c = b.length;
      o3('alphabet', b);
      let d = new Map(b.map((a, b) => [a, b]));
      return {
        encode: (d) => (
          o2(d),
          d.map((d) => {
            if (!Number.isSafeInteger(d) || d < 0 || d >= c)
              throw Error(`alphabet.encode: digit index outside alphabet "${d}". Allowed: ${a}`);
            return b[d];
          })
        ),
        decode: (b) => (
          o2(b),
          b.map((b) => {
            o0('alphabet.decode', b);
            let c = d.get(b);
            if (void 0 === c) throw Error(`Unknown letter: "${b}". Allowed: ${a}`);
            return c;
          })
        ),
      };
    }
    function o7(a = '') {
      return (
        o0('join', a),
        {
          encode: (b) => (o3('join.decode', b), b.join(a)),
          decode: (b) => (o0('join.decode', b), b.split(a)),
        }
      );
    }
    function o8(a, b, c) {
      if (b < 2) throw Error(`convertRadix: invalid from=${b}, base cannot be less than 2`);
      if (c < 2) throw Error(`convertRadix: invalid to=${c}, base cannot be less than 2`);
      if ((o2(a), !a.length)) return [];
      let d = 0,
        e = [],
        f = Array.from(a, (a) => {
          if ((o1(a), a < 0 || a >= b)) throw Error(`invalid integer: ${a}`);
          return a;
        }),
        g = f.length;
      for (;;) {
        let a = 0,
          h = !0;
        for (let e = d; e < g; e++) {
          let g = f[e],
            i = b * a,
            j = i + g;
          if (!Number.isSafeInteger(j) || i / b !== a || j - g !== i)
            throw Error('convertRadix: carry overflow');
          let k = j / c;
          a = j % c;
          let l = Math.floor(k);
          if (((f[e] = l), !Number.isSafeInteger(l) || l * c + a !== j))
            throw Error('convertRadix: carry overflow');
          h && (l ? (h = !1) : (d = e));
        }
        if ((e.push(a), h)) break;
      }
      for (let b = 0; b < a.length - 1 && 0 === a[b]; b++) e.push(0);
      return e.reverse();
    }
    let o9 = (a, b) => (0 === b ? a : o9(b, a % b)),
      pa = (() => {
        let a = [];
        for (let b = 0; b < 40; b++) a.push(2 ** b);
        return a;
      })();
    'function' == typeof Uint8Array.from([]).toBase64 && Uint8Array.fromBase64;
    o1(58);
    function pb(a) {
      if ('string' != typeof a) throw TypeError('invalid mnemonic type: ' + typeof a);
      return a.normalize('NFKD');
    }
    function pc(a) {
      return !!RegExp("^m\\/44'\\/4218'\\/[0-9]+'\\/[0-9]+'\\/[0-9]+'+$").test(a);
    }
    ('function' == typeof Uint8Array.from([]).toHex && 'function' == typeof Uint8Array.fromHex) ||
      o_((a) => {
        if ('string' != typeof a || a.length % 2 != 0)
          throw TypeError(`hex.decode: expected string, got ${typeof a} with length ${a.length}`);
        return a.toLowerCase();
      });
    let pd = 0x80000000,
      pe = RegExp("^m(\\/[0-9]+')+$"),
      pf = (a) => a.replace("'", ''),
      pg = (a, b, c = pd) => {
        let d;
        if (!pe.test(a) || a.split('/').slice(1).map(pf).some(isNaN))
          throw Error('Invalid derivation path');
        let { key: e, chainCode: f } = {
          key: (d = nK.create(nH, 'ed25519 seed').update(dV(b)).digest()).slice(0, 32),
          chainCode: d.slice(32),
        };
        return a
          .split('/')
          .slice(1)
          .map(pf)
          .map((a) => parseInt(a, 10))
          .reduce(
            (a, b) =>
              (({ key: a, chainCode: b }, c) => {
                let d = new ArrayBuffer(4);
                new DataView(d).setUint32(0, c);
                let e = new Uint8Array(1 + a.length + d.byteLength);
                e.set(new Uint8Array(1).fill(0)),
                  e.set(a, 1),
                  e.set(new Uint8Array(d, 0, d.byteLength), a.length + 1);
                let f = nK.create(nH, b).update(e).digest();
                return { key: f.slice(0, 32), chainCode: f.slice(32) };
              })(a, b + c),
            { key: e, chainCode: f }
          );
      };
    class ph extends oV {
      constructor(a) {
        if (
          (super(),
          'string' == typeof a
            ? (this.data = dT(a))
            : a instanceof Uint8Array
            ? (this.data = a)
            : (this.data = Uint8Array.from(a)),
          32 !== this.data.length)
        )
          throw Error(`Invalid public key input. Expected 32 bytes, got ${this.data.length}`);
      }
      equals(a) {
        return super.equals(a);
      }
      toRawBytes() {
        return this.data;
      }
      flag() {
        return nt.ED25519;
      }
      async verify(a, b) {
        let c;
        if ('string' == typeof b) {
          let a = (function (a) {
            let b = dT(a),
              c = nv[b[0]];
            switch (c) {
              case 'Passkey':
                var d = a;
                let e = 'string' == typeof d ? dT(d) : d;
                if (e[0] !== nt.Passkey) throw Error('Invalid signature scheme');
                let f = l5.parse(e.slice(1));
                return {
                  signatureScheme: 'Passkey',
                  serializedSignature: dU(e),
                  signature: e,
                  authenticatorData: f.authenticatorData,
                  clientDataJson: f.clientDataJson,
                  userSignature: new Uint8Array(f.userSignature),
                  publicKey: new Uint8Array(f.userSignature.slice(65)),
                };
              case 'MultiSig':
                return {
                  serializedSignature: a,
                  signatureScheme: c,
                  multisig: mm.MultiSig.parse(b.slice(1)),
                  bytes: b,
                };
              case 'ED25519':
              case 'Secp256k1':
              case 'Secp256r1':
                let g = nu[c],
                  h = b.slice(1, b.length - g),
                  i = b.slice(1 + h.length);
                return {
                  serializedSignature: a,
                  signatureScheme: c,
                  signature: h,
                  publicKey: i,
                  bytes: b,
                };
              default:
                throw Error('Unsupported signature scheme');
            }
          })(b);
          if ('ED25519' !== a.signatureScheme) throw Error('Invalid signature scheme');
          if (!oU(this.toRawBytes(), a.publicKey))
            throw Error('Signature does not match public key');
          c = a.signature;
        } else c = b;
        return nq.default.sign.detached.verify(a, c, this.toRawBytes());
      }
    }
    ph.SIZE = 32;
    let pi = "m/44'/4218'/0'/0'/0'";
    class pj extends oY {
      constructor(a) {
        super(), a ? (this.keypair = a) : (this.keypair = nq.default.sign.keyPair());
      }
      getKeyScheme() {
        return 'ED25519';
      }
      static generate() {
        return new pj(nq.default.sign.keyPair());
      }
      static fromSecretKey(a, b) {
        if ('string' == typeof a) {
          let c = (function (a) {
            let { prefix: b, words: c } = nr.bech32.decode(a);
            if (b !== oW) throw Error('invalid private key prefix');
            let d = new Uint8Array(nr.bech32.fromWords(c)),
              e = d.slice(1);
            return { schema: nv[d[0]], secretKey: e };
          })(a);
          if ('ED25519' !== c.schema) throw Error(`Expected a ED25519 keypair, got ${c.schema}`);
          return this.fromSecretKey(c.secretKey, b);
        }
        let c = a.length;
        if (32 !== c) throw Error(`Wrong secretKey size. Expected 32 bytes, got ${c}.`);
        let d = nq.default.sign.keyPair.fromSeed(a);
        if (!b || !b.skipValidation) {
          let a = new TextEncoder().encode('iota validation'),
            b = nq.default.sign.detached(a, d.secretKey);
          if (!nq.default.sign.detached.verify(a, b, d.publicKey))
            throw Error('provided secretKey is invalid');
        }
        return new pj(d);
      }
      getPublicKey() {
        return new ph(this.keypair.publicKey);
      }
      getSecretKey() {
        return (function (a, b) {
          if (32 !== a.length) throw Error('Invalid bytes length');
          let c = nt[b],
            d = new Uint8Array(a.length + 1);
          return d.set([c]), d.set(a, 1), nr.bech32.encode(oW, nr.bech32.toWords(d));
        })(this.keypair.secretKey.slice(0, 32), this.getKeyScheme());
      }
      async sign(a) {
        return nq.default.sign.detached(a, this.keypair.secretKey);
      }
      static deriveKeypair(a, b) {
        if ((null == b && (b = pi), !pc(b))) throw Error('Invalid derivation path');
        let { key: c } = pg(
          b,
          dW(
            (function (a, b = '') {
              return (function (a, b, c, d) {
                var e;
                let f,
                  {
                    c: g,
                    dkLen: h,
                    DK: i,
                    PRF: j,
                    PRFSalt: k,
                  } = (function (a, b, c, d) {
                    i_(a);
                    let {
                      c: e,
                      dkLen: f,
                      asyncTick: g,
                    } = (function (a, b) {
                      if (void 0 !== b && '[object Object]' !== {}.toString.call(b))
                        throw Error('options should be object or undefined');
                      return Object.assign(a, b);
                    })({ dkLen: 32, asyncTick: 10 }, d);
                    if ((iZ(e), iZ(f), iZ(g), e < 1)) throw Error('iterations (c) should be >= 1');
                    let h = jh(b),
                      i = jh(c),
                      j = new Uint8Array(f),
                      k = nK.create(a, h),
                      l = k._cloneInto().update(i);
                    return { c: e, dkLen: f, asyncTick: g, DK: j, PRF: k, PRFSalt: l };
                  })(a, b, c, d),
                  l = new Uint8Array(4),
                  m = i4(l),
                  n = new Uint8Array(j.outputLen);
                for (let a = 1, b = 0; b < h; a++, b += j.outputLen) {
                  let c = i.subarray(b, b + j.outputLen);
                  m.setInt32(0, a, !1),
                    (f = k._cloneInto(f)).update(l).digestInto(n),
                    c.set(n.subarray(0, c.length));
                  for (let a = 1; a < g; a++) {
                    j._cloneInto(f).update(n).digestInto(n);
                    for (let a = 0; a < c.length; a++) c[a] ^= n[a];
                  }
                }
                return (e = f), j.destroy(), k.destroy(), e && e.destroy(), i3(n), i;
              })(
                nH,
                (function (a) {
                  let b = pb(a),
                    c = b.split(' ');
                  if (![12, 15, 18, 21, 24].includes(c.length)) throw Error('Invalid mnemonic');
                  return { nfkd: b, words: c };
                })(a).nfkd,
                pb('mnemonic' + b),
                { c: 2048, dkLen: 64 }
              );
            })(a, '')
          )
        );
        return pj.fromSecretKey(c);
      }
      static deriveKeypairFromSeed(a, b) {
        if ((null == b && (b = pi), !pc(b))) throw Error('Invalid derivation path');
        let { key: c } = pg(b, a);
        return pj.fromSecretKey(c);
      }
    }
    var pk = function (a, b, c, d) {
        if ('a' === c && !d) throw TypeError('Private accessor was defined without a getter');
        if ('function' == typeof b ? a !== b || !d : !b.has(a))
          throw TypeError(
            'Cannot read private member from an object whose class did not declare it'
          );
        return 'm' === c ? d : 'a' === c ? d.call(a) : d ? d.value : b.get(a);
      },
      pl = function (a, b, c, d, e) {
        if ('m' === d) throw TypeError('Private method is not writable');
        if ('a' === d && !e) throw TypeError('Private accessor was defined without a setter');
        if ('function' == typeof b ? a !== b || !e : !b.has(a))
          throw TypeError(
            'Cannot write private member to an object whose class did not declare it'
          );
        return 'a' === d ? e.call(a, c) : e ? (e.value = c) : b.set(a, c), c;
      };
    class pm {
      get address() {
        return pk(this, aP, 'f');
      }
      get publicKey() {
        return pk(this, aQ, 'f').slice();
      }
      get chains() {
        return pk(this, aR, 'f').slice();
      }
      get features() {
        return pk(this, aS, 'f').slice();
      }
      get label() {
        return pk(this, aT, 'f');
      }
      get icon() {
        return pk(this, aU, 'f');
      }
      constructor(a) {
        aP.set(this, void 0),
          aQ.set(this, void 0),
          aR.set(this, void 0),
          aS.set(this, void 0),
          aT.set(this, void 0),
          aU.set(this, void 0),
          new.target === pm && Object.freeze(this),
          pl(this, aP, a.address, 'f'),
          pl(this, aQ, a.publicKey.slice(), 'f'),
          pl(this, aR, a.chains.slice(), 'f'),
          pl(this, aS, a.features.slice(), 'f'),
          pl(this, aT, a.label, 'f'),
          pl(this, aU, a.icon, 'f');
      }
    }
    (aP = new WeakMap()),
      (aQ = new WeakMap()),
      (aR = new WeakMap()),
      (aS = new WeakMap()),
      (aT = new WeakMap()),
      (aU = new WeakMap());
    let pn = {
      get url() {
        return `file://${a.P('node_modules/zustand/esm/middleware.mjs')}`;
      },
    };
    function po(a, b) {
      let c;
      try {
        c = a();
      } catch (a) {
        return;
      }
      return {
        getItem: (a) => {
          var d;
          let e = (a) => (null === a ? null : JSON.parse(a, null == b ? void 0 : b.reviver)),
            f = null != (d = c.getItem(a)) ? d : null;
          return f instanceof Promise ? f.then(e) : e(f);
        },
        setItem: (a, d) => c.setItem(a, JSON.stringify(d, null == b ? void 0 : b.replacer)),
        removeItem: (a) => c.removeItem(a),
      };
    }
    let pp = (a) => (b) => {
      try {
        let c = a(b);
        if (c instanceof Promise) return c;
        return {
          then: (a) => pp(a)(c),
          catch(a) {
            return this;
          },
        };
      } catch (a) {
        return {
          then(a) {
            return this;
          },
          catch: (b) => pp(b)(a),
        };
      }
    };
    function pq(a) {
      var b = a.match(/^var\((.*)\)$/);
      return b ? b[1] : a;
    }
    function pr(a, b) {
      var c = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : [],
        d = {};
      for (var e in a) {
        var f = a[e],
          g = [...c, e];
        'string' == typeof f || 'number' == typeof f || null == f
          ? (d[e] = b(f, g))
          : 'object' != typeof f || Array.isArray(f)
          ? console.warn(
              'Skipping invalid key "'
                .concat(g.join('.'), '". Should be a string, number, null or object. Received: "')
                .concat(Array.isArray(f) ? 'Array' : typeof f, '"')
            )
          : (d[e] = pr(f, b, g));
      }
      return d;
    }
    var ps = a.i(73456);
    function pt(a, b) {
      var c = Object.keys(a);
      if (Object.getOwnPropertySymbols) {
        var d = Object.getOwnPropertySymbols(a);
        b &&
          (d = d.filter(function (b) {
            return Object.getOwnPropertyDescriptor(a, b).enumerable;
          })),
          c.push.apply(c, d);
      }
      return c;
    }
    function pu(a) {
      for (var b = 1; b < arguments.length; b++) {
        var c = null != arguments[b] ? arguments[b] : {};
        b % 2
          ? pt(Object(c), !0).forEach(function (b) {
              var d, e, f;
              (d = a),
                (e = b),
                (f = c[b]),
                (e = (function (a) {
                  var b = (function (a, b) {
                    if ('object' != typeof a || null === a) return a;
                    var c = a[Symbol.toPrimitive];
                    if (void 0 !== c) {
                      var d = c.call(a, b || 'default');
                      if ('object' != typeof d) return d;
                      throw TypeError('@@toPrimitive must return a primitive value.');
                    }
                    return ('string' === b ? String : Number)(a);
                  })(a, 'string');
                  return 'symbol' == typeof b ? b : String(b);
                })(e)) in d
                  ? Object.defineProperty(d, e, {
                      value: f,
                      enumerable: !0,
                      configurable: !0,
                      writable: !0,
                    })
                  : (d[e] = f);
            })
          : Object.getOwnPropertyDescriptors
          ? Object.defineProperties(a, Object.getOwnPropertyDescriptors(c))
          : pt(Object(c)).forEach(function (b) {
              Object.defineProperty(a, b, Object.getOwnPropertyDescriptor(c, b));
            });
      }
      return a;
    }
    ((T = aV || (aV = {})).Attribute = 'attribute'),
      (T.Pseudo = 'pseudo'),
      (T.PseudoElement = 'pseudo-element'),
      (T.Tag = 'tag'),
      (T.Universal = 'universal'),
      (T.Adjacent = 'adjacent'),
      (T.Child = 'child'),
      (T.Descendant = 'descendant'),
      (T.Parent = 'parent'),
      (T.Sibling = 'sibling'),
      (T.ColumnCombinator = 'column-combinator'),
      ((U = aW || (aW = {})).Any = 'any'),
      (U.Element = 'element'),
      (U.End = 'end'),
      (U.Equals = 'equals'),
      (U.Exists = 'exists'),
      (U.Hyphen = 'hyphen'),
      (U.Not = 'not'),
      (U.Start = 'start'),
      aW.Element,
      aW.Start,
      aW.End,
      aW.Any,
      aW.Not,
      aW.Hyphen,
      !(function a(b) {
        return (c.withOptions = (c) => a(pu(pu({}, b), c))), c;
        function c(a, ...d) {
          let e = 'string' == typeof a ? [a] : a.raw,
            {
              alignValues: f = !1,
              escapeSpecialCharacters: g = Array.isArray(a),
              trimWhitespace: h = !0,
            } = b,
            i = '';
          for (let a = 0; a < e.length; a++) {
            let b = e[a];
            if (
              (g &&
                (b = b
                  .replace(/\\\n[ \t]*/g, '')
                  .replace(/\\`/g, '`')
                  .replace(/\\\$/g, '$')
                  .replace(/\\\{/g, '{')),
              (i += b),
              a < d.length)
            ) {
              let b = f
                ? (function (a, b) {
                    if ('string' != typeof a || !a.includes('\n')) return a;
                    let c = b.slice(b.lastIndexOf('\n') + 1).match(/^(\s+)/);
                    if (c) {
                      let b = c[1];
                      return a.replace(
                        /\n/g,
                        `
${b}`
                      );
                    }
                    return a;
                  })(d[a], i)
                : d[a];
              i += b;
            }
          }
          let j = i.split('\n'),
            k = null;
          for (let a of j) {
            let b = a.match(/^(\s+)\S+/);
            if (b) {
              let a = b[1].length;
              k = k ? Math.min(k, a) : a;
            }
          }
          if (null !== k) {
            let a = k;
            i = j.map((b) => (' ' === b[0] || '	' === b[0] ? b.slice(a) : b)).join('\n');
          }
          return h && (i = i.trim()), g && (i = i.replace(/\\n/g, '\n')), i;
        }
      })({});
    let pv =
        'object' == typeof performance && performance && 'function' == typeof performance.now
          ? performance
          : Date,
      pw = new Set(),
      px = 'object' == typeof process && process ? process : {},
      py = (a, b, c, d) => {
        'function' == typeof px.emitWarning
          ? px.emitWarning(a, b, c, d)
          : console.error(`[${c}] ${b}: ${a}`);
      },
      pz = globalThis.AbortController,
      pA = globalThis.AbortSignal;
    if (void 0 === pz) {
      (pA = class {
        onabort;
        _onabort = [];
        reason;
        aborted = !1;
        addEventListener(a, b) {
          this._onabort.push(b);
        }
      }),
        (pz = class {
          constructor() {
            b();
          }
          signal = new pA();
          abort(a) {
            if (!this.signal.aborted) {
              for (let b of ((this.signal.reason = a),
              (this.signal.aborted = !0),
              this.signal._onabort))
                b(a);
              this.signal.onabort?.(a);
            }
          }
        });
      let a = px.env?.LRU_CACHE_IGNORE_AC_WARNING !== '1',
        b = () => {
          a &&
            ((a = !1),
            py(
              'AbortController is not defined. If using lru-cache in node 14, load an AbortController polyfill from the `node-abort-controller` package. A minimal polyfill is provided for use by LRUCache.fetch(), but it should not be relied upon in other contexts (eg, passing it to other APIs that use AbortController/AbortSignal might have undesirable effects). You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.',
              'NO_ABORT_CONTROLLER',
              'ENOTSUP',
              b
            ));
        };
    }
    Symbol('type');
    let pB = (a) => a && a === Math.floor(a) && a > 0 && isFinite(a),
      pC = (a) =>
        pB(a)
          ? a <= 256
            ? Uint8Array
            : a <= 65536
            ? Uint16Array
            : a <= 0x100000000
            ? Uint32Array
            : a <= Number.MAX_SAFE_INTEGER
            ? pD
            : null
          : null;
    class pD extends Array {
      constructor(a) {
        super(a), this.fill(0);
      }
    }
    class pE {
      heap;
      length;
      static #S = !1;
      static create(a) {
        let b = pC(a);
        if (!b) return [];
        pE.#S = !0;
        let c = new pE(a, b);
        return (pE.#S = !1), c;
      }
      constructor(a, b) {
        if (!pE.#S) throw TypeError('instantiate Stack using Stack.create(n)');
        (this.heap = new b(a)), (this.length = 0);
      }
      push(a) {
        this.heap[this.length++] = a;
      }
      pop() {
        return this.heap[--this.length];
      }
    }
    class pF {
      #T;
      #U;
      #V;
      #W;
      #X;
      #Y;
      ttl;
      ttlResolution;
      ttlAutopurge;
      updateAgeOnGet;
      updateAgeOnHas;
      allowStale;
      noDisposeOnSet;
      noUpdateTTL;
      maxEntrySize;
      sizeCalculation;
      noDeleteOnFetchRejection;
      noDeleteOnStaleGet;
      allowStaleOnFetchAbort;
      allowStaleOnFetchRejection;
      ignoreFetchAbort;
      #Z;
      #$;
      #_;
      #aa;
      #ab;
      #ac;
      #ad;
      #ae;
      #af;
      #ag;
      #ah;
      #ai;
      #aj;
      #ak;
      #al;
      #am;
      #an;
      static unsafeExposeInternals(a) {
        return {
          starts: a.#aj,
          ttls: a.#ak,
          sizes: a.#ai,
          keyMap: a.#_,
          keyList: a.#aa,
          valList: a.#ab,
          next: a.#ac,
          prev: a.#ad,
          get head() {
            return a.#ae;
          },
          get tail() {
            return a.#af;
          },
          free: a.#ag,
          isBackgroundFetch: (b) => a.#ao(b),
          backgroundFetch: (b, c, d, e) => a.#ap(b, c, d, e),
          moveToTail: (b) => a.#aq(b),
          indexes: (b) => a.#ar(b),
          rindexes: (b) => a.#as(b),
          isStale: (b) => a.#at(b),
        };
      }
      get max() {
        return this.#T;
      }
      get maxSize() {
        return this.#U;
      }
      get calculatedSize() {
        return this.#$;
      }
      get size() {
        return this.#Z;
      }
      get fetchMethod() {
        return this.#X;
      }
      get memoMethod() {
        return this.#Y;
      }
      get dispose() {
        return this.#V;
      }
      get disposeAfter() {
        return this.#W;
      }
      constructor(a) {
        const {
          max: b = 0,
          ttl: c,
          ttlResolution: d = 1,
          ttlAutopurge: e,
          updateAgeOnGet: f,
          updateAgeOnHas: g,
          allowStale: h,
          dispose: i,
          disposeAfter: j,
          noDisposeOnSet: k,
          noUpdateTTL: l,
          maxSize: m = 0,
          maxEntrySize: n = 0,
          sizeCalculation: o,
          fetchMethod: p,
          memoMethod: q,
          noDeleteOnFetchRejection: s,
          noDeleteOnStaleGet: t,
          allowStaleOnFetchRejection: u,
          allowStaleOnFetchAbort: v,
          ignoreFetchAbort: w,
        } = a;
        if (0 !== b && !pB(b)) throw TypeError('max option must be a nonnegative integer');
        const x = b ? pC(b) : Array;
        if (!x) throw Error('invalid max value: ' + b);
        if (
          ((this.#T = b),
          (this.#U = m),
          (this.maxEntrySize = n || this.#U),
          (this.sizeCalculation = o),
          this.sizeCalculation)
        ) {
          if (!this.#U && !this.maxEntrySize)
            throw TypeError('cannot set sizeCalculation without setting maxSize or maxEntrySize');
          if ('function' != typeof this.sizeCalculation)
            throw TypeError('sizeCalculation set to non-function');
        }
        if (void 0 !== q && 'function' != typeof q)
          throw TypeError('memoMethod must be a function if defined');
        if (((this.#Y = q), void 0 !== p && 'function' != typeof p))
          throw TypeError('fetchMethod must be a function if specified');
        if (
          ((this.#X = p),
          (this.#am = !!p),
          (this.#_ = new Map()),
          (this.#aa = Array(b).fill(void 0)),
          (this.#ab = Array(b).fill(void 0)),
          (this.#ac = new x(b)),
          (this.#ad = new x(b)),
          (this.#ae = 0),
          (this.#af = 0),
          (this.#ag = pE.create(b)),
          (this.#Z = 0),
          (this.#$ = 0),
          'function' == typeof i && (this.#V = i),
          'function' == typeof j
            ? ((this.#W = j), (this.#ah = []))
            : ((this.#W = void 0), (this.#ah = void 0)),
          (this.#al = !!this.#V),
          (this.#an = !!this.#W),
          (this.noDisposeOnSet = !!k),
          (this.noUpdateTTL = !!l),
          (this.noDeleteOnFetchRejection = !!s),
          (this.allowStaleOnFetchRejection = !!u),
          (this.allowStaleOnFetchAbort = !!v),
          (this.ignoreFetchAbort = !!w),
          0 !== this.maxEntrySize)
        ) {
          if (0 !== this.#U && !pB(this.#U))
            throw TypeError('maxSize must be a positive integer if specified');
          if (!pB(this.maxEntrySize))
            throw TypeError('maxEntrySize must be a positive integer if specified');
          this.#au();
        }
        if (
          ((this.allowStale = !!h),
          (this.noDeleteOnStaleGet = !!t),
          (this.updateAgeOnGet = !!f),
          (this.updateAgeOnHas = !!g),
          (this.ttlResolution = pB(d) || 0 === d ? d : 1),
          (this.ttlAutopurge = !!e),
          (this.ttl = c || 0),
          this.ttl)
        ) {
          if (!pB(this.ttl)) throw TypeError('ttl must be a positive integer if specified');
          this.#av();
        }
        if (0 === this.#T && 0 === this.ttl && 0 === this.#U)
          throw TypeError('At least one of max, maxSize, or ttl is required');
        if (!this.ttlAutopurge && !this.#T && !this.#U) {
          const a = 'LRU_CACHE_UNBOUNDED';
          pw.has(a) ||
            (pw.add(a),
            py(
              'TTL caching without ttlAutopurge, max, or maxSize can result in unbounded memory consumption.',
              'UnboundedCacheWarning',
              a,
              pF
            ));
        }
      }
      getRemainingTTL(a) {
        return this.#_.has(a) ? 1 / 0 : 0;
      }
      #av() {
        let a = new pD(this.#T),
          b = new pD(this.#T);
        (this.#ak = a),
          (this.#aj = b),
          (this.#aw = (c, d, e = pv.now()) => {
            if (((b[c] = 0 !== d ? e : 0), (a[c] = d), 0 !== d && this.ttlAutopurge)) {
              let a = setTimeout(() => {
                this.#at(c) && this.#ax(this.#aa[c], 'expire');
              }, d + 1);
              a.unref && a.unref();
            }
          }),
          (this.#ay = (c) => {
            b[c] = 0 !== a[c] ? pv.now() : 0;
          }),
          (this.#az = (e, f) => {
            if (a[f]) {
              let g = a[f],
                h = b[f];
              if (!g || !h) return;
              (e.ttl = g), (e.start = h), (e.now = c || d());
              let i = e.now - h;
              e.remainingTTL = g - i;
            }
          });
        let c = 0,
          d = () => {
            let a = pv.now();
            if (this.ttlResolution > 0) {
              c = a;
              let b = setTimeout(() => (c = 0), this.ttlResolution);
              b.unref && b.unref();
            }
            return a;
          };
        (this.getRemainingTTL = (e) => {
          let f = this.#_.get(e);
          if (void 0 === f) return 0;
          let g = a[f],
            h = b[f];
          return g && h ? g - ((c || d()) - h) : 1 / 0;
        }),
          (this.#at = (e) => {
            let f = b[e],
              g = a[e];
            return !!g && !!f && (c || d()) - f > g;
          });
      }
      #ay = () => {};
      #az = () => {};
      #aw = () => {};
      #at = () => !1;
      #au() {
        let a = new pD(this.#T);
        (this.#$ = 0),
          (this.#ai = a),
          (this.#aA = (b) => {
            (this.#$ -= a[b]), (a[b] = 0);
          }),
          (this.#aB = (a, b, c, d) => {
            if (this.#ao(b)) return 0;
            if (!pB(c))
              if (d) {
                if ('function' != typeof d) throw TypeError('sizeCalculation must be a function');
                if (!pB((c = d(b, a))))
                  throw TypeError('sizeCalculation return invalid (expect positive integer)');
              } else
                throw TypeError(
                  'invalid size value (must be positive integer). When maxSize or maxEntrySize is used, sizeCalculation or size must be set.'
                );
            return c;
          }),
          (this.#aC = (b, c, d) => {
            if (((a[b] = c), this.#U)) {
              let c = this.#U - a[b];
              for (; this.#$ > c; ) this.#aD(!0);
            }
            (this.#$ += a[b]), d && ((d.entrySize = c), (d.totalCalculatedSize = this.#$));
          });
      }
      #aA = (a) => {};
      #aC = (a, b, c) => {};
      #aB = (a, b, c, d) => {
        if (c || d)
          throw TypeError('cannot set size without setting maxSize or maxEntrySize on cache');
        return 0;
      };
      *#ar({ allowStale: a = this.allowStale } = {}) {
        if (this.#Z)
          for (
            let b = this.#af;
            this.#aE(b) && ((a || !this.#at(b)) && (yield b), b !== this.#ae);

          )
            b = this.#ad[b];
      }
      *#as({ allowStale: a = this.allowStale } = {}) {
        if (this.#Z)
          for (
            let b = this.#ae;
            this.#aE(b) && ((a || !this.#at(b)) && (yield b), b !== this.#af);

          )
            b = this.#ac[b];
      }
      #aE(a) {
        return void 0 !== a && this.#_.get(this.#aa[a]) === a;
      }
      *entries() {
        for (let a of this.#ar())
          void 0 === this.#ab[a] ||
            void 0 === this.#aa[a] ||
            this.#ao(this.#ab[a]) ||
            (yield [this.#aa[a], this.#ab[a]]);
      }
      *rentries() {
        for (let a of this.#as())
          void 0 === this.#ab[a] ||
            void 0 === this.#aa[a] ||
            this.#ao(this.#ab[a]) ||
            (yield [this.#aa[a], this.#ab[a]]);
      }
      *keys() {
        for (let a of this.#ar()) {
          let b = this.#aa[a];
          void 0 === b || this.#ao(this.#ab[a]) || (yield b);
        }
      }
      *rkeys() {
        for (let a of this.#as()) {
          let b = this.#aa[a];
          void 0 === b || this.#ao(this.#ab[a]) || (yield b);
        }
      }
      *values() {
        for (let a of this.#ar())
          void 0 === this.#ab[a] || this.#ao(this.#ab[a]) || (yield this.#ab[a]);
      }
      *rvalues() {
        for (let a of this.#as())
          void 0 === this.#ab[a] || this.#ao(this.#ab[a]) || (yield this.#ab[a]);
      }
      [Symbol.iterator]() {
        return this.entries();
      }
      [Symbol.toStringTag] = 'LRUCache';
      find(a, b = {}) {
        for (let c of this.#ar()) {
          let d = this.#ab[c],
            e = this.#ao(d) ? d.__staleWhileFetching : d;
          if (void 0 !== e && a(e, this.#aa[c], this)) return this.get(this.#aa[c], b);
        }
      }
      forEach(a, b = this) {
        for (let c of this.#ar()) {
          let d = this.#ab[c],
            e = this.#ao(d) ? d.__staleWhileFetching : d;
          void 0 !== e && a.call(b, e, this.#aa[c], this);
        }
      }
      rforEach(a, b = this) {
        for (let c of this.#as()) {
          let d = this.#ab[c],
            e = this.#ao(d) ? d.__staleWhileFetching : d;
          void 0 !== e && a.call(b, e, this.#aa[c], this);
        }
      }
      purgeStale() {
        let a = !1;
        for (let b of this.#as({ allowStale: !0 }))
          this.#at(b) && (this.#ax(this.#aa[b], 'expire'), (a = !0));
        return a;
      }
      info(a) {
        let b = this.#_.get(a);
        if (void 0 === b) return;
        let c = this.#ab[b],
          d = this.#ao(c) ? c.__staleWhileFetching : c;
        if (void 0 === d) return;
        let e = { value: d };
        if (this.#ak && this.#aj) {
          let a = this.#ak[b],
            c = this.#aj[b];
          a && c && ((e.ttl = a - (pv.now() - c)), (e.start = Date.now()));
        }
        return this.#ai && (e.size = this.#ai[b]), e;
      }
      dump() {
        let a = [];
        for (let b of this.#ar({ allowStale: !0 })) {
          let c = this.#aa[b],
            d = this.#ab[b],
            e = this.#ao(d) ? d.__staleWhileFetching : d;
          if (void 0 === e || void 0 === c) continue;
          let f = { value: e };
          if (this.#ak && this.#aj) {
            f.ttl = this.#ak[b];
            let a = pv.now() - this.#aj[b];
            f.start = Math.floor(Date.now() - a);
          }
          this.#ai && (f.size = this.#ai[b]), a.unshift([c, f]);
        }
        return a;
      }
      load(a) {
        for (let [b, c] of (this.clear(), a)) {
          if (c.start) {
            let a = Date.now() - c.start;
            c.start = pv.now() - a;
          }
          this.set(b, c.value, c);
        }
      }
      set(a, b, c = {}) {
        if (void 0 === b) return this.delete(a), this;
        let {
            ttl: d = this.ttl,
            start: e,
            noDisposeOnSet: f = this.noDisposeOnSet,
            sizeCalculation: g = this.sizeCalculation,
            status: h,
          } = c,
          { noUpdateTTL: i = this.noUpdateTTL } = c,
          j = this.#aB(a, b, c.size || 0, g);
        if (this.maxEntrySize && j > this.maxEntrySize)
          return h && ((h.set = 'miss'), (h.maxEntrySizeExceeded = !0)), this.#ax(a, 'set'), this;
        let k = 0 === this.#Z ? void 0 : this.#_.get(a);
        if (void 0 === k)
          (k =
            0 === this.#Z
              ? this.#af
              : 0 !== this.#ag.length
              ? this.#ag.pop()
              : this.#Z === this.#T
              ? this.#aD(!1)
              : this.#Z),
            (this.#aa[k] = a),
            (this.#ab[k] = b),
            this.#_.set(a, k),
            (this.#ac[this.#af] = k),
            (this.#ad[k] = this.#af),
            (this.#af = k),
            this.#Z++,
            this.#aC(k, j, h),
            h && (h.set = 'add'),
            (i = !1);
        else {
          this.#aq(k);
          let c = this.#ab[k];
          if (b !== c) {
            if (this.#am && this.#ao(c)) {
              c.__abortController.abort(Error('replaced'));
              let { __staleWhileFetching: b } = c;
              void 0 !== b &&
                !f &&
                (this.#al && this.#V?.(b, a, 'set'), this.#an && this.#ah?.push([b, a, 'set']));
            } else
              !f && (this.#al && this.#V?.(c, a, 'set'), this.#an && this.#ah?.push([c, a, 'set']));
            if ((this.#aA(k), this.#aC(k, j, h), (this.#ab[k] = b), h)) {
              h.set = 'replace';
              let a = c && this.#ao(c) ? c.__staleWhileFetching : c;
              void 0 !== a && (h.oldValue = a);
            }
          } else h && (h.set = 'update');
        }
        if (
          (0 === d || this.#ak || this.#av(),
          this.#ak && (i || this.#aw(k, d, e), h && this.#az(h, k)),
          !f && this.#an && this.#ah)
        ) {
          let a,
            b = this.#ah;
          for (; (a = b?.shift()); ) this.#W?.(...a);
        }
        return this;
      }
      pop() {
        try {
          for (; this.#Z; ) {
            let a = this.#ab[this.#ae];
            if ((this.#aD(!0), this.#ao(a))) {
              if (a.__staleWhileFetching) return a.__staleWhileFetching;
            } else if (void 0 !== a) return a;
          }
        } finally {
          if (this.#an && this.#ah) {
            let a,
              b = this.#ah;
            for (; (a = b?.shift()); ) this.#W?.(...a);
          }
        }
      }
      #aD(a) {
        let b = this.#ae,
          c = this.#aa[b],
          d = this.#ab[b];
        return (
          this.#am && this.#ao(d)
            ? d.__abortController.abort(Error('evicted'))
            : (this.#al || this.#an) &&
              (this.#al && this.#V?.(d, c, 'evict'), this.#an && this.#ah?.push([d, c, 'evict'])),
          this.#aA(b),
          a && ((this.#aa[b] = void 0), (this.#ab[b] = void 0), this.#ag.push(b)),
          1 === this.#Z
            ? ((this.#ae = this.#af = 0), (this.#ag.length = 0))
            : (this.#ae = this.#ac[b]),
          this.#_.delete(c),
          this.#Z--,
          b
        );
      }
      has(a, b = {}) {
        let { updateAgeOnHas: c = this.updateAgeOnHas, status: d } = b,
          e = this.#_.get(a);
        if (void 0 !== e) {
          let a = this.#ab[e];
          if (this.#ao(a) && void 0 === a.__staleWhileFetching) return !1;
          if (!this.#at(e)) return c && this.#ay(e), d && ((d.has = 'hit'), this.#az(d, e)), !0;
          d && ((d.has = 'stale'), this.#az(d, e));
        } else d && (d.has = 'miss');
        return !1;
      }
      peek(a, b = {}) {
        let { allowStale: c = this.allowStale } = b,
          d = this.#_.get(a);
        if (void 0 === d || (!c && this.#at(d))) return;
        let e = this.#ab[d];
        return this.#ao(e) ? e.__staleWhileFetching : e;
      }
      #ap(a, b, c, d) {
        let e = void 0 === b ? void 0 : this.#ab[b];
        if (this.#ao(e)) return e;
        let f = new pz(),
          { signal: g } = c;
        g?.addEventListener('abort', () => f.abort(g.reason), { signal: f.signal });
        let h = { signal: f.signal, options: c, context: d },
          i = (d, e = !1) => {
            let { aborted: g } = f.signal,
              i = c.ignoreFetchAbort && void 0 !== d;
            return (c.status &&
              (g && !e
                ? ((c.status.fetchAborted = !0),
                  (c.status.fetchError = f.signal.reason),
                  i && (c.status.fetchAbortIgnored = !0))
                : (c.status.fetchResolved = !0)),
            !g || i || e)
              ? (this.#ab[b] === l &&
                  (void 0 === d
                    ? l.__staleWhileFetching
                      ? (this.#ab[b] = l.__staleWhileFetching)
                      : this.#ax(a, 'fetch')
                    : (c.status && (c.status.fetchUpdated = !0), this.set(a, d, h.options))),
                d)
              : j(f.signal.reason);
          },
          j = (d) => {
            let { aborted: e } = f.signal,
              g = e && c.allowStaleOnFetchAbort,
              h = g || c.allowStaleOnFetchRejection,
              i = h || c.noDeleteOnFetchRejection;
            if (
              (this.#ab[b] === l &&
                (i && void 0 !== l.__staleWhileFetching
                  ? g || (this.#ab[b] = l.__staleWhileFetching)
                  : this.#ax(a, 'fetch')),
              h)
            )
              return (
                c.status && void 0 !== l.__staleWhileFetching && (c.status.returnedStale = !0),
                l.__staleWhileFetching
              );
            if (l.__returned === l) throw d;
          },
          k = (b, d) => {
            let g = this.#X?.(a, e, h);
            g && g instanceof Promise && g.then((a) => b(void 0 === a ? void 0 : a), d),
              f.signal.addEventListener('abort', () => {
                (!c.ignoreFetchAbort || c.allowStaleOnFetchAbort) &&
                  (b(void 0), c.allowStaleOnFetchAbort && (b = (a) => i(a, !0)));
              });
          };
        c.status && (c.status.fetchDispatched = !0);
        let l = new Promise(k).then(
            i,
            (a) => (c.status && ((c.status.fetchRejected = !0), (c.status.fetchError = a)), j(a))
          ),
          m = Object.assign(l, {
            __abortController: f,
            __staleWhileFetching: e,
            __returned: void 0,
          });
        return (
          void 0 === b
            ? (this.set(a, m, { ...h.options, status: void 0 }), (b = this.#_.get(a)))
            : (this.#ab[b] = m),
          m
        );
      }
      #ao(a) {
        return (
          !!this.#am &&
          !!a &&
          a instanceof Promise &&
          a.hasOwnProperty('__staleWhileFetching') &&
          a.__abortController instanceof pz
        );
      }
      async fetch(a, b = {}) {
        let {
          allowStale: c = this.allowStale,
          updateAgeOnGet: d = this.updateAgeOnGet,
          noDeleteOnStaleGet: e = this.noDeleteOnStaleGet,
          ttl: f = this.ttl,
          noDisposeOnSet: g = this.noDisposeOnSet,
          size: h = 0,
          sizeCalculation: i = this.sizeCalculation,
          noUpdateTTL: j = this.noUpdateTTL,
          noDeleteOnFetchRejection: k = this.noDeleteOnFetchRejection,
          allowStaleOnFetchRejection: l = this.allowStaleOnFetchRejection,
          ignoreFetchAbort: m = this.ignoreFetchAbort,
          allowStaleOnFetchAbort: n = this.allowStaleOnFetchAbort,
          context: o,
          forceRefresh: p = !1,
          status: q,
          signal: s,
        } = b;
        if (!this.#am)
          return (
            q && (q.fetch = 'get'),
            this.get(a, { allowStale: c, updateAgeOnGet: d, noDeleteOnStaleGet: e, status: q })
          );
        let t = {
            allowStale: c,
            updateAgeOnGet: d,
            noDeleteOnStaleGet: e,
            ttl: f,
            noDisposeOnSet: g,
            size: h,
            sizeCalculation: i,
            noUpdateTTL: j,
            noDeleteOnFetchRejection: k,
            allowStaleOnFetchRejection: l,
            allowStaleOnFetchAbort: n,
            ignoreFetchAbort: m,
            status: q,
            signal: s,
          },
          u = this.#_.get(a);
        if (void 0 === u) {
          q && (q.fetch = 'miss');
          let b = this.#ap(a, u, t, o);
          return (b.__returned = b);
        }
        {
          let b = this.#ab[u];
          if (this.#ao(b)) {
            let a = c && void 0 !== b.__staleWhileFetching;
            return (
              q && ((q.fetch = 'inflight'), a && (q.returnedStale = !0)),
              a ? b.__staleWhileFetching : (b.__returned = b)
            );
          }
          let e = this.#at(u);
          if (!p && !e)
            return q && (q.fetch = 'hit'), this.#aq(u), d && this.#ay(u), q && this.#az(q, u), b;
          let f = this.#ap(a, u, t, o),
            g = void 0 !== f.__staleWhileFetching && c;
          return (
            q && ((q.fetch = e ? 'stale' : 'refresh'), g && e && (q.returnedStale = !0)),
            g ? f.__staleWhileFetching : (f.__returned = f)
          );
        }
      }
      async forceFetch(a, b = {}) {
        let c = await this.fetch(a, b);
        if (void 0 === c) throw Error('fetch() returned undefined');
        return c;
      }
      memo(a, b = {}) {
        let c = this.#Y;
        if (!c) throw Error('no memoMethod provided to constructor');
        let { context: d, forceRefresh: e, ...f } = b,
          g = this.get(a, f);
        if (!e && void 0 !== g) return g;
        let h = c(a, g, { options: f, context: d });
        return this.set(a, h, f), h;
      }
      get(a, b = {}) {
        let {
            allowStale: c = this.allowStale,
            updateAgeOnGet: d = this.updateAgeOnGet,
            noDeleteOnStaleGet: e = this.noDeleteOnStaleGet,
            status: f,
          } = b,
          g = this.#_.get(a);
        if (void 0 !== g) {
          let b = this.#ab[g],
            h = this.#ao(b);
          return (f && this.#az(f, g), this.#at(g))
            ? (f && (f.get = 'stale'), h)
              ? (f && c && void 0 !== b.__staleWhileFetching && (f.returnedStale = !0),
                c ? b.__staleWhileFetching : void 0)
              : (e || this.#ax(a, 'expire'), f && c && (f.returnedStale = !0), c ? b : void 0)
            : (f && (f.get = 'hit'), h)
            ? b.__staleWhileFetching
            : (this.#aq(g), d && this.#ay(g), b);
        }
        f && (f.get = 'miss');
      }
      #aF(a, b) {
        (this.#ad[b] = a), (this.#ac[a] = b);
      }
      #aq(a) {
        a !== this.#af &&
          (a === this.#ae ? (this.#ae = this.#ac[a]) : this.#aF(this.#ad[a], this.#ac[a]),
          this.#aF(this.#af, a),
          (this.#af = a));
      }
      delete(a) {
        return this.#ax(a, 'delete');
      }
      #ax(a, b) {
        let c = !1;
        if (0 !== this.#Z) {
          let d = this.#_.get(a);
          if (void 0 !== d)
            if (((c = !0), 1 === this.#Z)) this.#aG(b);
            else {
              this.#aA(d);
              let c = this.#ab[d];
              if (
                (this.#ao(c)
                  ? c.__abortController.abort(Error('deleted'))
                  : (this.#al || this.#an) &&
                    (this.#al && this.#V?.(c, a, b), this.#an && this.#ah?.push([c, a, b])),
                this.#_.delete(a),
                (this.#aa[d] = void 0),
                (this.#ab[d] = void 0),
                d === this.#af)
              )
                this.#af = this.#ad[d];
              else if (d === this.#ae) this.#ae = this.#ac[d];
              else {
                let a = this.#ad[d];
                this.#ac[a] = this.#ac[d];
                let b = this.#ac[d];
                this.#ad[b] = this.#ad[d];
              }
              this.#Z--, this.#ag.push(d);
            }
        }
        if (this.#an && this.#ah?.length) {
          let a,
            b = this.#ah;
          for (; (a = b?.shift()); ) this.#W?.(...a);
        }
        return c;
      }
      clear() {
        return this.#aG('delete');
      }
      #aG(a) {
        for (let b of this.#as({ allowStale: !0 })) {
          let c = this.#ab[b];
          if (this.#ao(c)) c.__abortController.abort(Error('deleted'));
          else {
            let d = this.#aa[b];
            this.#al && this.#V?.(c, d, a), this.#an && this.#ah?.push([c, d, a]);
          }
        }
        if (
          (this.#_.clear(),
          this.#ab.fill(void 0),
          this.#aa.fill(void 0),
          this.#ak && this.#aj && (this.#ak.fill(0), this.#aj.fill(0)),
          this.#ai && this.#ai.fill(0),
          (this.#ae = 0),
          (this.#af = 0),
          (this.#ag.length = 0),
          (this.#$ = 0),
          (this.#Z = 0),
          this.#an && this.#ah)
        ) {
          let a,
            b = this.#ah;
          for (; (a = b?.shift()); ) this.#W?.(...a);
        }
      }
    }
    a.i(40226), a.i(7054);
    var pG = (a, b) => {
      for (var c = b - 1; c >= 0; ) {
        if ('/' === a[c]) return c;
        c--;
      }
      return -1;
    };
    function pH(a) {
      return {
        onFetch: (b, c) => {
          let d = b.options,
            e = b.fetchOptions?.meta?.fetchMore?.direction,
            f = b.state.data?.pages || [],
            g = b.state.data?.pageParams || [],
            h = { pages: [], pageParams: [] },
            i = 0,
            j = async () => {
              let c = !1,
                j = da(b.options, b.fetchOptions),
                k = async (a, d, e) => {
                  let f;
                  if (c) return Promise.reject();
                  if (null == d && a.pages.length) return Promise.resolve(a);
                  let g =
                      (Object.defineProperty(
                        (f = {
                          client: b.client,
                          queryKey: b.queryKey,
                          pageParam: d,
                          direction: e ? 'backward' : 'forward',
                          meta: b.options.meta,
                        }),
                        'signal',
                        {
                          enumerable: !0,
                          get: () => (
                            b.signal.aborted
                              ? (c = !0)
                              : b.signal.addEventListener('abort', () => {
                                  c = !0;
                                }),
                            b.signal
                          ),
                        }
                      ),
                      f),
                    h = await j(g),
                    { maxPages: i } = b.options,
                    k = e ? c8 : c7;
                  return { pages: k(a.pages, h, i), pageParams: k(a.pageParams, d, i) };
                };
              if (e && f.length) {
                let a = 'backward' === e,
                  b = { pages: f, pageParams: g },
                  c = (a ? pJ : pI)(d, b);
                h = await k(b, c, a);
              } else {
                let b = a ?? f.length;
                do {
                  let a = 0 === i ? g[0] ?? d.initialPageParam : pI(d, h);
                  if (i > 0 && null == a) break;
                  (h = await k(h, a)), i++;
                } while (i < b);
              }
              return h;
            };
          b.options.persister
            ? (b.fetchFn = () =>
                b.options.persister?.(
                  j,
                  {
                    client: b.client,
                    queryKey: b.queryKey,
                    meta: b.options.meta,
                    signal: b.signal,
                  },
                  c
                ))
            : (b.fetchFn = j);
        },
      };
    }
    function pI(a, { pages: b, pageParams: c }) {
      let d = b.length - 1;
      return b.length > 0 ? a.getNextPageParam(b[d], b, c[d], c) : void 0;
    }
    function pJ(a, { pages: b, pageParams: c }) {
      return b.length > 0 ? a.getPreviousPageParam?.(b[0], b, c[0], c) : void 0;
    }
    function pK(a, b) {
      return !!b && null != pI(a, b);
    }
    function pL(a, b) {
      return !!b && !!a.getPreviousPageParam && null != pJ(a, b);
    }
    async function pM(a, b) {
      if (!a.features['iota:signTransaction'])
        throw Error(`Provided wallet (${a.name}) does not support the signTransaction feature.`);
      return a.features['iota:signTransaction'].signTransaction(b);
    }
    (V = new pF({ max: 500 })),
      a.s(
        ['hasNextPage', () => pK, 'hasPreviousPage', () => pL, 'infiniteQueryBehavior', () => pH],
        74684
      );
    var pN = Object.create,
      pO = Object.defineProperty,
      pP = Object.getOwnPropertyDescriptor,
      pQ = Object.getOwnPropertyNames,
      pR = Object.getPrototypeOf,
      pS = Object.prototype.hasOwnProperty,
      pT = (a) => {
        throw TypeError(a);
      },
      pU = (a, b, c) => (
        b.has(a) || pT('Cannot read from private field'), c ? c.call(a) : b.get(a)
      ),
      pV = (a, b, c) =>
        b.has(a)
          ? pT('Cannot add the same private member more than once')
          : b instanceof WeakSet
          ? b.add(a)
          : b.set(a, c),
      pW =
        ((u = {
          'vanilla-extract-css-ns:src/components/styling/StyleMarker.css.ts.vanilla.css?source=OndoZXJlKCopIHsKICBib3gtc2l6aW5nOiBib3JkZXItYm94OwogIGNvbG9yOiB2YXIoLS1kYXBwLWtpdC1jb2xvcnMtYm9keSk7CiAgZm9udC1mYW1pbHk6IHZhcigtLWRhcHAta2l0LXR5cG9ncmFwaHktZm9udEZhbWlseSk7CiAgZm9udC1zaXplOiB2YXIoLS1kYXBwLWtpdC1mb250V2VpZ2h0cy1ub3JtYWwpOwogIGZvbnQtc3R5bGU6IHZhcigtLWRhcHAta2l0LXR5cG9ncmFwaHktZm9udFN0eWxlKTsKICBmb250LXdlaWdodDogdmFyKC0tZGFwcC1raXQtZm9udFdlaWdodHMtbm9ybWFsKTsKICBsaW5lLWhlaWdodDogdmFyKC0tZGFwcC1raXQtdHlwb2dyYXBoeS1saW5lSGVpZ2h0KTsKICBsZXR0ZXItc3BhY2luZzogdmFyKC0tZGFwcC1raXQtdHlwb2dyYXBoeS1sZXR0ZXJTcGFjaW5nKTsKfQo6d2hlcmUoYnV0dG9uKSB7CiAgYXBwZWFyYW5jZTogbm9uZTsKICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDsKICBmb250LXNpemU6IGluaGVyaXQ7CiAgZm9udC1mYW1pbHk6IGluaGVyaXQ7CiAgbGluZS1oZWlnaHQ6IGluaGVyaXQ7CiAgbGV0dGVyLXNwYWNpbmc6IGluaGVyaXQ7CiAgY29sb3I6IGluaGVyaXQ7CiAgYm9yZGVyOiAwOwogIHBhZGRpbmc6IDA7CiAgbWFyZ2luOiAwOwp9Cjp3aGVyZShhKSB7CiAgdGV4dC1kZWNvcmF0aW9uOiBub25lOwogIGNvbG9yOiBpbmhlcml0OwogIG91dGxpbmU6IG5vbmU7Cn0KOndoZXJlKG9sLCB1bCkgewogIGxpc3Qtc3R5bGU6IG5vbmU7CiAgbWFyZ2luOiAwOwogIHBhZGRpbmc6IDA7Cn0KOndoZXJlKGgxLCBoMiwgaDMsIGg0LCBoNSwgaDYpIHsKICBmb250LXNpemU6IGluaGVyaXQ7CiAgZm9udC13ZWlnaHQ6IGluaGVyaXQ7CiAgbWFyZ2luOiAwOwp9'() {},
        }),
        function () {
          return u && (v = (0, u[pQ(u)[0]])((u = 0))), v;
        }),
      pX =
        ((w = {
          'src/components/styling/StyleMarker.css.ts'() {
            pW();
          },
        }),
        function () {
          return x || (0, w[pQ(w)[0]])((x = { exports: {} }).exports, x), x.exports;
        }),
      pY = {
        all: { baseScope: 'wallet' },
        connectWallet: pZ('connect-wallet'),
        autoconnectWallet: pZ('autoconnect-wallet'),
        disconnectWallet: pZ('disconnect-wallet'),
        signPersonalMessage: pZ('sign-personal-message'),
        signTransaction: pZ('sign-transaction'),
        signAndExecuteTransaction: pZ('sign-and-execute-transaction'),
        switchAccount: pZ('switch-account'),
        reportTransactionEffects: pZ('report-transaction-effects'),
      };
    function pZ(a) {
      return function (b = []) {
        return [{ ...pY.all, baseEntity: a }, ...b];
      };
    }
    var p$ = (0, aX.createContext)(null);
    function p_(a) {
      let b = (0, aX.useContext)(p$);
      if (!b)
        throw Error(
          'Could not find WalletContext. Ensure that you have set up the WalletProvider.'
        );
      return (function (a, b = (a) => a, c) {
        dw.env && dw.env.MODE;
        let d = dy(a.subscribe, a.getState, a.getServerState || a.getInitialState, b, void 0);
        return dx(d), d;
      })(b, a);
    }
    function p0({ mutationKey: a, ...b } = {}) {
      let c = p_((a) => a.setWalletConnected),
        d = p_((a) => a.setConnectionStatus);
      return ds({
        mutationKey: pY.connectWallet(a),
        mutationFn: async ({ wallet: a, accountAddress: b, ...e }) => {
          try {
            var f, g;
            d('connecting');
            let h = await a.features['standard:connect'].connect(e),
              i = h.accounts.filter((a) => a.chains.some(cM)),
              j =
                ((f = i),
                (g = b),
                0 === f.length ? null : g ? f.find((a) => a.address === g) ?? f[0] : f[0]);
            return c(a, i, j, h.supportedIntents), { accounts: i };
          } catch (a) {
            throw (d('disconnected'), a);
          }
        },
        ...b,
      });
    }
    function p1(a, b) {
      let c = dB()
        .get()
        .filter(
          (a) =>
            (function (a, b = []) {
              return [...dG, ...b].every((b) => b in a.features);
            })(a) &&
            (!b || b(a))
        );
      return [
        ...a.map((a) => c.find((b) => b.name === a)).filter(Boolean),
        ...c.filter((b) => !a.includes(b.name)),
      ];
    }
    function p2(a) {
      return a?.id ?? a?.name;
    }
    function p3(a) {
      return (0, a0.jsx)('svg', {
        width: 24,
        height: 24,
        fill: 'none',
        xmlns: 'http://www.w3.org/2000/svg',
        ...a,
        children: (0, a0.jsx)('path', {
          d: 'M7.57 12.262c0 .341.13.629.403.895l5.175 5.059c.204.205.45.307.751.307.609 0 1.101-.485 1.101-1.087 0-.293-.123-.574-.349-.8L10.14 12.27l4.511-4.375A1.13 1.13 0 0 0 15 7.087C15 6.485 14.508 6 13.9 6c-.295 0-.54.103-.752.308l-5.175 5.058c-.28.28-.404.56-.404.896Z',
          fill: 'currentColor',
        }),
      });
    }
    function p4(a) {
      return (0, a0.jsx)('svg', {
        width: 10,
        height: 10,
        fill: 'none',
        xmlns: 'http://www.w3.org/2000/svg',
        ...a,
        children: (0, a0.jsx)('path', {
          d: 'M9.708.292a.999.999 0 0 0-1.413 0l-3.289 3.29L1.717.291A.999.999 0 0 0 .305 1.705l3.289 3.289-3.29 3.289a.999.999 0 1 0 1.413 1.412l3.29-3.289 3.288 3.29a.999.999 0 0 0 1.413-1.413l-3.29-3.29 3.29-3.288a.999.999 0 0 0 0-1.413Z',
          fill: 'currentColor',
        }),
      });
    }
    var p5 = 'data-dapp-kit',
      p6 = `[${p5}]`,
      p7 = { [p5]: '' };
    (A = null != (y = pX()) ? pN(pR(y)) : {}),
      ((a, b, c, d) => {
        if ((b && 'object' == typeof b) || 'function' == typeof b)
          for (let e of pQ(b))
            pS.call(a, e) ||
              e === c ||
              pO(a, e, { get: () => b[e], enumerable: !(d = pP(b, e)) || d.enumerable });
      })(!z && y && y.__esModule ? A : pO(A, 'default', { value: y, enumerable: !0 }), y);
    var p8 = (0, aX.forwardRef)(({ children: a, ...b }, c) =>
      (0, a0.jsx)(dK, { ref: c, ...b, ...p7, children: a })
    );
    p8.displayName = 'StyleMarker';
    var p9 = dR({
        defaultClassName: 'Heading__12b5l8i0',
        variantClassNames: {
          size: {
            sm: 'Heading_headingVariants_size_sm__12b5l8i1',
            md: 'Heading_headingVariants_size_md__12b5l8i2',
            lg: 'Heading_headingVariants_size_lg__12b5l8i3',
            xl: 'Heading_headingVariants_size_xl__12b5l8i4',
          },
          weight: {
            normal: 'Heading_headingVariants_weight_normal__12b5l8i5',
            bold: 'Heading_headingVariants_weight_bold__12b5l8i6',
          },
          truncate: { true: 'Heading_headingVariants_truncate_true__12b5l8i7' },
        },
        defaultVariants: { size: 'lg', weight: 'bold' },
        compoundVariants: [],
      }),
      qa = (0, aX.forwardRef)(
        (
          {
            children: a,
            className: b,
            asChild: c = !1,
            as: d = 'h1',
            size: e,
            weight: f,
            truncate: g,
            ...h
          },
          i
        ) =>
          (0, a0.jsx)(dK, {
            ...h,
            ref: i,
            className: cJ(p9({ size: e, weight: f, truncate: g }), b),
            children: c ? a : (0, a0.jsx)(d, { children: a }),
          })
      );
    qa.displayName = 'Heading';
    var qb = (0, aX.forwardRef)(({ className: a, asChild: b = !1, ...c }, d) => {
      let e = b ? dK : 'button';
      return (0, a0.jsx)(e, { ...c, className: cJ('IconButton_container__ap1qll0', a), ref: d });
    });
    qb.displayName = 'Button';
    var qc = dR({
        defaultClassName: 'Button_buttonVariants__ctbx2n0',
        variantClassNames: {
          variant: {
            primary: 'Button_buttonVariants_variant_primary__ctbx2n1',
            outline: 'Button_buttonVariants_variant_outline__ctbx2n2',
          },
          size: {
            md: 'Button_buttonVariants_size_md__ctbx2n3',
            lg: 'Button_buttonVariants_size_lg__ctbx2n4',
          },
        },
        defaultVariants: { variant: 'primary', size: 'md' },
        compoundVariants: [],
      }),
      qd = (0, aX.forwardRef)(({ className: a, variant: b, size: c, asChild: d = !1, ...e }, f) => {
        let g = d ? dK : 'button';
        return (0, a0.jsx)(g, { ...e, className: cJ(qc({ variant: b, size: c }), a), ref: f });
      });
    qd.displayName = 'Button';
    var qe = dR({
        defaultClassName: 'Text__aprhbd0',
        variantClassNames: {
          size: { sm: 'Text_textVariants_size_sm__aprhbd1' },
          weight: {
            normal: 'Text_textVariants_weight_normal__aprhbd2',
            medium: 'Text_textVariants_weight_medium__aprhbd3',
            bold: 'Text_textVariants_weight_bold__aprhbd4',
          },
          color: {
            muted: 'Text_textVariants_color_muted__aprhbd5',
            danger: 'Text_textVariants_color_danger__aprhbd6',
          },
          mono: { true: 'Text_textVariants_mono_true__aprhbd7' },
        },
        defaultVariants: { size: 'sm', weight: 'normal' },
        compoundVariants: [],
      }),
      qf = (0, aX.forwardRef)(
        (
          {
            children: a,
            className: b,
            asChild: c = !1,
            as: d = 'div',
            size: e,
            weight: f,
            color: g,
            mono: h,
            ...i
          },
          j
        ) =>
          (0, a0.jsx)(dK, {
            ...i,
            ref: j,
            className: cJ(qe({ size: e, weight: f, color: g, mono: h }), b),
            children: c ? a : (0, a0.jsx)(d, { children: a }),
          })
      );
    function qg({ selectedWallet: a, hadConnectionError: b, onRetryConnection: c }) {
      return (0, a0.jsxs)('div', {
        className: 'ConnectionStatus_container__c5q1ll0',
        children: [
          (0, a0.jsx)('img', {
            className: 'ConnectionStatus_walletIcon__c5q1ll1',
            src: a.icon,
            alt: `${a.name} logo`,
          }),
          (0, a0.jsx)('div', {
            className: 'ConnectionStatus_title__c5q1ll2',
            children: (0, a0.jsxs)(qa, { as: 'h2', size: 'xl', children: ['Opening ', a.name] }),
          }),
          (0, a0.jsx)('div', {
            className: 'ConnectionStatus_connectionStatus__c5q1ll3',
            children: b
              ? (0, a0.jsx)(qf, { color: 'danger', children: 'Connection failed' })
              : (0, a0.jsx)(qf, {
                  color: 'muted',
                  children: 'Confirm connection in the wallet...',
                }),
          }),
          b
            ? (0, a0.jsx)('div', {
                className: 'ConnectionStatus_retryButtonContainer__c5q1ll4',
                children: (0, a0.jsx)(qd, {
                  type: 'button',
                  variant: 'primary',
                  onClick: () => c(a),
                  children: 'Retry Connection',
                }),
              })
            : null,
        ],
      });
    }
    function qh({ title: a, children: b }) {
      return (0, a0.jsxs)('section', {
        className: 'InfoSection_container__1d1nrmt0',
        children: [
          (0, a0.jsx)(qa, { as: 'h3', size: 'sm', weight: 'normal', children: a }),
          (0, a0.jsx)(qf, { weight: 'medium', color: 'muted', children: b }),
        ],
      });
    }
    function qi() {
      return (0, a0.jsxs)('div', {
        className: 'GettingStarted_container__qu36t90',
        children: [
          (0, a0.jsx)(qa, { as: 'h2', children: 'Get Started with IOTA' }),
          (0, a0.jsxs)('div', {
            className: 'GettingStarted_content__qu36t91',
            children: [
              (0, a0.jsx)(qh, {
                title: 'Install the IOTA Wallet Extension',
                children: 'We recommend pinning IOTA Wallet to your taskbar for quicker access.',
              }),
              (0, a0.jsx)(qh, {
                title: 'Create or Import a Wallet',
                children:
                  'Be sure to back up your wallet using a secure method. Never share your secret phrase with anyone.',
              }),
              (0, a0.jsx)(qh, {
                title: 'Refresh Your Browser',
                children:
                  'Once you set up your wallet, refresh this window browser to load up the extension.',
              }),
              (0, a0.jsx)('div', {
                className: 'GettingStarted_installButtonContainer__qu36t92',
                children: (0, a0.jsx)(qd, {
                  variant: 'primary',
                  asChild: !0,
                  children: (0, a0.jsx)('a', {
                    href: 'https://chrome.google.com/webstore/detail/iota-wallet/iidjkmdceolghepehaaddojmnjnkkija',
                    target: '_blank',
                    rel: 'noreferrer',
                    children: 'Install Wallet Extension',
                  }),
                }),
              }),
            ],
          }),
        ],
      });
    }
    function qj() {
      return (0, a0.jsxs)('div', {
        className: 'WhatIsAWallet_container__1kdcimq0',
        children: [
          (0, a0.jsx)(qa, { as: 'h2', children: 'What is a Wallet' }),
          (0, a0.jsxs)('div', {
            className: 'WhatIsAWallet_content__1kdcimq1',
            children: [
              (0, a0.jsx)(qh, {
                title: 'Easy Login',
                children:
                  'No need to create new accounts and passwords for every website. Just connect your wallet and get going.',
              }),
              (0, a0.jsx)(qh, {
                title: 'Store your Digital Assets',
                children:
                  'Send, receive, store, and display your digital assets like NFTs & coins.',
              }),
            ],
          }),
        ],
      });
    }
    function qk() {
      return p_((a) => a.wallets);
    }
    function ql(a) {
      return (0, a0.jsx)('svg', {
        xmlns: 'http://www.w3.org/2000/svg',
        width: '28px',
        height: '28px',
        fill: 'none',
        viewBox: '0 0 24 24',
        ...a,
        children: (0, a0.jsx)('path', {
          fill: '#171d26',
          d: 'M18.27 2.259c0 .695-.568 1.259-1.268 1.259s-1.267-.564-1.267-1.259S16.302 1 17.002 1s1.268.564 1.268 1.259m1.425 17.785c0 .695-.568 1.259-1.268 1.259s-1.267-.564-1.267-1.26c0-.695.567-1.258 1.267-1.258s1.268.563 1.268 1.259m-2.33-13.379a1.06 1.06 0 0 0 1.063-1.056 1.06 1.06 0 0 0-1.063-1.057A1.06 1.06 0 0 0 16.3 5.61a1.06 1.06 0 0 0 1.064 1.056Zm3.891-.651a1.06 1.06 0 0 1-1.063 1.056 1.06 1.06 0 0 1-1.064-1.056 1.06 1.06 0 0 1 1.064-1.057 1.06 1.06 0 0 1 1.063 1.057m-4.253 3.329c.5 0 .905-.403.905-.9 0-.496-.405-.9-.905-.9s-.906.404-.906.9c0 .497.406.9.906.9m3.734-.52c0 .497-.405.9-.905.9a.903.903 0 0 1-.906-.9c0-.496.405-.9.906-.9.5 0 .905.404.905.9m1.357 1.777c.5 0 .906-.402.906-.899s-.405-.9-.906-.9c-.5 0-.905.403-.905.9s.405.9.905.9Zm-2.309.495a.79.79 0 0 1-.792.787.79.79 0 0 1-.791-.787c0-.434.354-.786.791-.786s.792.352.792.786m-3.62.404a.79.79 0 0 0 .792-.787.79.79 0 0 0-.792-.786.79.79 0 0 0-.791.786c0 .435.354.787.791.787m5.907.471a.79.79 0 0 1-.791.787.79.79 0 0 1-.792-.786.79.79 0 0 1 .792-.787.79.79 0 0 1 .791.787Zm-4.21 1.554c.375 0 .68-.302.68-.675a.677.677 0 0 0-.68-.675.68.68 0 0 0-.68.675c0 .373.304.675.68.675m2.968.178a.68.68 0 0 1-.68.676.677.677 0 0 1-.68-.676c0-.373.304-.675.68-.675.375 0 .68.302.68.675m-5.774-.582c.375 0 .68-.302.68-.675a.68.68 0 0 0-.68-.675.68.68 0 0 0-.68.675c0 .373.304.675.68.675m2.127.943c0 .31-.254.561-.566.561a.564.564 0 0 1-.566-.562c0-.31.253-.561.566-.561s.566.251.566.562m.407 2.114a.496.496 0 0 0 .498-.494.496.496 0 0 0-.498-.495.496.496 0 0 0-.498.495c0 .273.223.494.498.494m-.791-.09a.407.407 0 0 1-.408.405.407.407 0 0 1-.408-.405c0-.223.182-.405.408-.405s.408.181.408.405m-1.472-.765a.496.496 0 0 0 .498-.494.496.496 0 0 0-.498-.495.496.496 0 0 0-.498.495c0 .273.223.494.498.494m-.973-1.64c0 .31-.254.562-.566.562a.564.564 0 0 1-.566-.562c0-.31.253-.562.566-.562s.566.251.566.562m-.588-3.666a.564.564 0 0 0 .566-.562.564.564 0 0 0-.566-.562.564.564 0 0 0-.565.562c0 .31.253.562.565.562m.745-2.473a.496.496 0 0 1-.497.494.496.496 0 0 1-.498-.494c0-.273.223-.494.498-.494s.498.22.498.494Zm.047-1.123a.406.406 0 0 0 .407-.406.406.406 0 0 0-.407-.405.407.407 0 0 0-.408.405c0 .224.182.406.408.406m-.452-1.26a.496.496 0 0 1-.498.494.496.496 0 0 1-.498-.494c0-.273.223-.494.498-.494s.498.22.498.494m4.776 10.32a.564.564 0 0 0 .566-.561.564.564 0 0 0-.566-.562.564.564 0 0 0-.566.562c0 .31.253.562.566.562ZM12.883 4.439c0 .31-.254.562-.566.562a.564.564 0 0 1-.566-.562c0-.31.254-.562.566-.562s.566.251.566.562m-.18 2.945a.564.564 0 0 0 .566-.562.564.564 0 0 0-.566-.561.564.564 0 0 0-.566.561c0 .31.253.562.566.562m.045 1.597a.677.677 0 0 1-.68.676.68.68 0 0 1-.679-.676c0-.373.304-.675.68-.675.375 0 .68.302.68.675Zm-2.74.676a.79.79 0 0 0 .791-.786.79.79 0 0 0-.791-.787.79.79 0 0 0-.792.787c0 .434.354.786.792.786m-1.494-.36c0 .497-.405.9-.905.9a.903.903 0 0 1-.906-.9c0-.497.406-.9.906-.9s.905.403.905.9m-3.529 2.18a1.06 1.06 0 0 0 1.063-1.056 1.06 1.06 0 0 0-1.063-1.056A1.06 1.06 0 0 0 3.92 10.42a1.06 1.06 0 0 0 1.064 1.056Zm-1.45.9c0 .696-.568 1.26-1.268 1.26S1 13.073 1 12.377c0-.695.567-1.259 1.267-1.259s1.268.564 1.268 1.26Zm.386-3.531A1.06 1.06 0 0 0 4.985 7.79 1.06 1.06 0 0 0 3.92 6.733 1.06 1.06 0 0 0 2.858 7.79 1.06 1.06 0 0 0 3.92 8.846Zm3.53-2.181c0 .497-.405.9-.906.9a.903.903 0 0 1-.905-.9c0-.496.405-.9.905-.9s.906.404.906.9M6.162 5.182c.5 0 .905-.403.905-.9 0-.496-.405-.9-.905-.9s-.906.404-.906.9c0 .497.406.9.906.9m3.19-1.326a.79.79 0 0 1-.791.787.79.79 0 0 1-.792-.787c0-.434.354-.786.792-.786.437 0 .791.352.791.786m1.268.788c.375 0 .68-.303.68-.675a.677.677 0 0 0-.68-.676.68.68 0 0 0-.68.675c0 .373.304.676.68.676m1.063 1.708a.68.68 0 0 1-.68.675.677.677 0 0 1-.68-.675c0-.373.305-.675.68-.675s.68.302.68.675m-2.739.695a.79.79 0 0 0 .792-.786.79.79 0 0 0-.792-.786.79.79 0 0 0-.791.786c0 .434.354.786.791.786m-1.832 5.578a.407.407 0 0 1-.408.405.407.407 0 0 1-.408-.405c0-.223.182-.405.408-.405s.408.181.408.405m1.221.201a.496.496 0 0 0 .497-.494.496.496 0 0 0-.497-.495.496.496 0 0 0-.498.495c0 .273.223.494.498.494m2.354-1.236c0 .31-.253.562-.565.562a.564.564 0 0 1-.566-.562c0-.31.253-.562.566-.562s.565.252.565.562m-.135 2.361c.375 0 .68-.302.68-.675a.677.677 0 0 0-.68-.675.677.677 0 0 0-.68.675c0 .373.304.675.68.675m-1.608-.135c0 .31-.253.562-.566.562a.564.564 0 0 1-.565-.562c0-.31.253-.562.565-.562.313 0 .566.252.566.562m-2.488.538a.496.496 0 0 0 .498-.494.496.496 0 0 0-.498-.495.496.496 0 0 0-.498.495c0 .273.223.494.498.494m.588.991c0 .31-.254.562-.566.562a.564.564 0 0 1-.566-.562c0-.31.253-.562.566-.562s.566.252.566.562m1.742.855c.376 0 .68-.303.68-.675a.677.677 0 0 0-.68-.676.677.677 0 0 0-.68.675c0 .373.305.676.68.676m3.484-1.08a.79.79 0 0 1-.79.786.79.79 0 0 1-.792-.786c0-.435.354-.787.791-.787s.792.352.792.787Zm.794 2.743c.5 0 .906-.402.906-.9 0-.496-.406-.899-.906-.899s-.905.403-.905.9.405.9.905.9Zm-2.536-.518a.79.79 0 0 1-.792.786.79.79 0 0 1-.792-.787.79.79 0 0 1 .792-.786.79.79 0 0 1 .792.787m-2.669 2.316a.79.79 0 0 0 .791-.786.79.79 0 0 0-.792-.786.79.79 0 0 0-.791.786c0 .434.354.786.792.786m2.466 1.079c0 .497-.405.9-.905.9a.903.903 0 0 1-.906-.9c0-.496.405-.9.906-.9.5 0 .905.404.905.9M13.584 22a1.06 1.06 0 0 0 1.064-1.056 1.06 1.06 0 0 0-1.064-1.057 1.06 1.06 0 0 0-1.063 1.057A1.06 1.06 0 0 0 13.584 22m-1.379-2.788c0 .497-.405.9-.905.9a.903.903 0 0 1-.906-.9c0-.497.405-.9.905-.9s.906.403.906.9m3.123.54a1.06 1.06 0 0 0 1.063-1.057 1.06 1.06 0 0 0-1.063-1.056 1.06 1.06 0 0 0-1.064 1.056 1.06 1.06 0 0 0 1.064 1.057m-7.741-2.699a.677.677 0 0 1-.68.676.677.677 0 0 1-.68-.676c0-.373.305-.675.68-.675s.68.302.68.675',
        }),
      });
    }
    function qm({ name: a, icon: b, onClick: c, isSelected: d = !1 }) {
      return (0, a0.jsx)('li', {
        className: 'WalletListItem_container__1vrvezk0',
        children: (0, a0.jsxs)('button', {
          className: cJ('WalletListItem_walletItem__1vrvezk1', {
            WalletListItem_selectedWalletItem__1vrvezk2: d,
          }),
          type: 'button',
          onClick: c,
          children: [
            'string' == typeof b
              ? (0, a0.jsx)('img', {
                  className: 'WalletListItem_walletIcon__1vrvezk3',
                  src: b,
                  alt: `${a} logo`,
                })
              : b,
            (0, a0.jsx)(qa, {
              size: 'md',
              truncate: !0,
              asChild: !0,
              children: (0, a0.jsx)('div', { children: a }),
            }),
          ],
        }),
      });
    }
    function qn({ selectedWalletName: a, onPlaceholderClick: b, onSelect: c }) {
      let d = qk();
      return (0, a0.jsx)('ul', {
        className: 'WalletList_container__1tkdegw0',
        children:
          d.length > 0
            ? d.map((b) =>
                (0, a0.jsx)(
                  qm,
                  { name: b.name, icon: b.icon, isSelected: p2(b) === a, onClick: () => c(b) },
                  p2(b)
                )
              )
            : (0, a0.jsx)(qm, {
                name: 'IOTA Wallet',
                icon: (0, a0.jsx)(ql, { className: 'WalletList_icon__1tkdegw1' }),
                onClick: b,
                isSelected: !0,
              }),
      });
    }
    function qo({ trigger: a, open: b, defaultOpen: c, onOpenChange: d }) {
      let e,
        [f, g] = (0, aX.useState)(b ?? c),
        [h, i] = (0, aX.useState)(),
        [j, k] = (0, aX.useState)(),
        { mutate: l, isError: m } = p0(),
        n = () => {
          k(void 0), i(void 0);
        },
        o = (a) => {
          a || n(), g(a), d?.(a);
        },
        p = (a) => {
          i('connection-status'), l({ wallet: a, silent: !1 }, { onSuccess: () => o(!1) });
        };
      switch (h) {
        case 'what-is-a-wallet':
        default:
          e = (0, a0.jsx)(qj, {});
          break;
        case 'getting-started':
          e = (0, a0.jsx)(qi, {});
          break;
        case 'connection-status':
          e = (0, a0.jsx)(qg, { selectedWallet: j, hadConnectionError: m, onRetryConnection: p });
      }
      return (0, a0.jsxs)(ci, {
        open: b ?? f,
        onOpenChange: o,
        children: [
          (0, a0.jsx)(ck, { asChild: !0, children: a }),
          (0, a0.jsx)(co, {
            children: (0, a0.jsx)(p8, {
              children: (0, a0.jsx)(cq, {
                className: 'ConnectModal_overlay__17mljma0',
                children: (0, a0.jsxs)(cu, {
                  className: 'ConnectModal_content__17mljma2',
                  'aria-describedby': void 0,
                  children: [
                    (0, a0.jsxs)('div', {
                      className: cJ('ConnectModal_walletListContainer__17mljma9', {
                        ConnectModal_walletListContainerWithViewSelected__17mljmaa: !!h,
                      }),
                      children: [
                        (0, a0.jsxs)('div', {
                          className: 'ConnectModal_walletListContent__17mljma8',
                          children: [
                            (0, a0.jsx)(cz, {
                              className: 'ConnectModal_title__17mljma1',
                              asChild: !0,
                              children: (0, a0.jsx)(qa, { as: 'h2', children: 'Connect a Wallet' }),
                            }),
                            (0, a0.jsx)(qn, {
                              selectedWalletName: p2(j),
                              onPlaceholderClick: () => i('getting-started'),
                              onSelect: (a) => {
                                p2(j) !== p2(a) && (k(a), p(a));
                              },
                            }),
                          ],
                        }),
                        (0, a0.jsx)('button', {
                          className: 'ConnectModal_whatIsAWalletButton__17mljma3',
                          onClick: () => i('what-is-a-wallet'),
                          type: 'button',
                          children: 'What is a Wallet?',
                        }),
                      ],
                    }),
                    (0, a0.jsxs)('div', {
                      className: cJ('ConnectModal_viewContainer__17mljma4', {
                        ConnectModal_selectedViewContainer__17mljma5: !!h,
                      }),
                      children: [
                        (0, a0.jsx)('div', {
                          className: 'ConnectModal_backButtonContainer__17mljma6',
                          children: (0, a0.jsx)(qb, {
                            type: 'button',
                            'aria-label': 'Back',
                            onClick: () => n(),
                            children: (0, a0.jsx)(p3, {}),
                          }),
                        }),
                        e,
                      ],
                    }),
                    (0, a0.jsx)(cC, {
                      className: 'ConnectModal_closeButtonContainer__17mljma7',
                      asChild: !0,
                      children: (0, a0.jsx)(qb, {
                        type: 'button',
                        'aria-label': 'Close',
                        children: (0, a0.jsx)(p4, {}),
                      }),
                    }),
                  ],
                }),
              }),
            }),
          }),
        ],
      });
    }
    function qp() {
      return p_((a) => a.currentAccount);
    }
    qf.displayName = 'Text';
    var qq = class extends Error {},
      qr = class extends Error {},
      qs = class extends Error {},
      qt = class extends Error {};
    function qu() {
      let a = p_((a) => a.currentWallet),
        b = p_((a) => a.connectionStatus),
        c = p_((a) => a.supportedIntents);
      switch (b) {
        case 'connecting':
          return {
            connectionStatus: b,
            currentWallet: null,
            isDisconnected: !1,
            isConnecting: !0,
            isConnected: !1,
            supportedIntents: [],
          };
        case 'disconnected':
          return {
            connectionStatus: b,
            currentWallet: null,
            isDisconnected: !0,
            isConnecting: !1,
            isConnected: !1,
            supportedIntents: [],
          };
        case 'connected':
          return {
            connectionStatus: b,
            currentWallet: a,
            isDisconnected: !1,
            isConnecting: !1,
            isConnected: !0,
            supportedIntents: c,
          };
      }
    }
    var qv = 'AccountDropdownMenu_menuItem__1x0gmpf4';
    function qw(a) {
      return (0, a0.jsx)('svg', {
        xmlns: 'http://www.w3.org/2000/svg',
        width: 16,
        height: 16,
        fill: 'none',
        ...a,
        children: (0, a0.jsx)('path', {
          fill: 'currentColor',
          d: 'm11.726 5.048-4.73 5.156-1.722-1.879a.72.72 0 0 0-.529-.23.722.722 0 0 0-.525.24.858.858 0 0 0-.22.573.86.86 0 0 0 .211.576l2.255 2.458c.14.153.332.24.53.24.2 0 .391-.087.532-.24l5.261-5.735A.86.86 0 0 0 13 5.63a.858.858 0 0 0-.22-.572.722.722 0 0 0-.525-.24.72.72 0 0 0-.529.23Z',
        }),
      });
    }
    function qx(a) {
      return (0, a0.jsx)('svg', {
        xmlns: 'http://www.w3.org/2000/svg',
        width: 16,
        height: 16,
        fill: 'none',
        ...a,
        children: (0, a0.jsx)('path', {
          stroke: '#A0B6C3',
          strokeLinecap: 'round',
          strokeLinejoin: 'round',
          strokeWidth: 1.5,
          d: 'm4 6 4 4 4-4',
        }),
      });
    }
    var qy = (0, aX.createContext)(null),
      qz = { localnet: { url: g1(g0.Localnet)?.url } },
      qA = function (a, b) {
        return 'object' == typeof b && null !== b && !0 === b[m3] ? b : new m4(b);
      };
    function qB(a) {
      let { onNetworkChange: b, network: c, children: d } = a,
        e = a.networks ?? qz,
        f = a.createClient ?? qA,
        [g, h] = (0, aX.useState)(a.network ?? a.defaultNetwork ?? Object.keys(e)[0]),
        i = a.network ?? g,
        j = (0, aX.useMemo)(() => f(i, e[i]), [f, i, e]),
        k = (0, aX.useMemo)(
          () => ({
            client: j,
            networks: e,
            network: i,
            config: e[i] instanceof m4 ? null : e[i],
            selectNetwork: (a) => {
              i !== a && (c || a === g || h(a), b?.(a));
            },
          }),
          [j, e, g, i, c, b]
        );
      return (0, a0.jsx)(qy.Provider, { value: k, children: d });
    }
    function qC() {
      let a = (0, aX.useContext)(qy);
      if (!a)
        throw Error(
          'Could not find IotaClientContext. Ensure that you have set up the IotaClientProvider'
        );
      return a;
    }
    function qD() {
      return qC().client;
    }
    function qE(a, b) {
      let c = g1(qC().network),
        d = (0, aX.useMemo)(
          () => new j2({ graphQlClient: new np({ url: c.graphql }), network: c.id }),
          [c.id]
        ),
        e = !!d.config;
      return hd({
        queryKey: ['iota-name', 'default-name', a],
        queryFn: async () => {
          if (!a) return null;
          let b = await d?.getDefaultName(a);
          return b ? j0(b) : b;
        },
        enabled: !!d && !!a && b && e,
        staleTime: 6e5,
      });
    }
    function qF({ currentAccount: a, size: b = 'lg', iotaNamesEnabled: c }) {
      let { mutate: d } = (function ({ mutationKey: a, ...b } = {}) {
          let { currentWallet: c } = qu(),
            d = p_((a) => a.setWalletDisconnected);
          return ds({
            mutationKey: pY.disconnectWallet(a),
            mutationFn: async () => {
              if (!c) throw new qq('No wallet is connected.');
              try {
                await c.features['standard:disconnect']?.disconnect();
              } catch (a) {
                console.error('Failed to disconnect the application from the current wallet.', a);
              }
              d();
            },
            ...b,
          });
        })(),
        e = p_((a) => a.accounts),
        { data: f } = qE(a.address, c),
        g = f ?? a.label ?? d_(a.address);
      return (0, a0.jsxs)(gU, {
        modal: !1,
        children: [
          (0, a0.jsx)(p8, {
            children: (0, a0.jsx)(gW, {
              asChild: !0,
              children: (0, a0.jsxs)(qd, {
                size: b,
                className: 'AccountDropdownMenu_connectedAccount__1x0gmpf0',
                children: [
                  (0, a0.jsx)(qf, { mono: !0, weight: 'bold', children: g }),
                  (0, a0.jsx)(qx, {}),
                ],
              }),
            }),
          }),
          (0, a0.jsx)(gX, {
            children: (0, a0.jsx)(p8, {
              className: 'AccountDropdownMenu_menuContainer__1x0gmpf1',
              children: (0, a0.jsxs)(gZ, {
                className: 'AccountDropdownMenu_menuContent__1x0gmpf2',
                children: [
                  (0, a0.jsx)('div', {
                    className: 'AccountDropdownMenu_scrollableContent__1x0gmpf3',
                    children: e.map((b) =>
                      (0, a0.jsx)(
                        qG,
                        { account: b, active: a.address === b.address, iotaNamesEnabled: c },
                        b.address
                      )
                    ),
                  }),
                  (0, a0.jsx)(g_, { className: 'AccountDropdownMenu_separator__1x0gmpf6' }),
                  (0, a0.jsx)(g$, {
                    className: cJ(qv),
                    onSelect: () => d(),
                    children: 'Disconnect',
                  }),
                ],
              }),
            }),
          }),
        ],
      });
    }
    function qG({ account: a, active: b, iotaNamesEnabled: c }) {
      let { mutate: d } = (function ({ mutationKey: a, ...b } = {}) {
          let { currentWallet: c } = qu(),
            d = p_((a) => a.setAccountSwitched);
          return ds({
            mutationKey: pY.switchAccount(a),
            mutationFn: async ({ account: a }) => {
              if (!c) throw new qq('No wallet is connected.');
              let b = c.accounts.find((b) => b.address === a.address);
              if (!b)
                throw new qt(`No account with address ${a.address} is connected to ${c.name}.`);
              d(b);
            },
            ...b,
          });
        })(),
        { data: e } = qE(a.address, c),
        f = e ?? a.label ?? d_(a.address);
      return (0, a0.jsxs)(g$, {
        className: cJ(qv, 'AccountDropdownMenu_switchAccountMenuItem__1x0gmpf5'),
        onSelect: () => d({ account: a }),
        children: [(0, a0.jsx)(qf, { mono: !0, children: f }), b ? (0, a0.jsx)(qw, {}) : null],
      });
    }
    function qH({ connectText: a = 'Connect Wallet', size: b, iotaNamesEnabled: c = !0, ...d }) {
      let e = qp();
      return e
        ? (0, a0.jsx)(qF, { currentAccount: e, size: b, iotaNamesEnabled: c })
        : (0, a0.jsx)(qo, {
            trigger: (0, a0.jsx)(p8, { children: (0, a0.jsx)(qd, { ...d, size: b, children: a }) }),
          });
    }
    function qI() {
      let a = new Map();
      return {
        getItem: (b) => a.get(b),
        setItem(b, c) {
          a.set(b, c);
        },
        removeItem(b) {
          a.delete(b);
        },
      };
    }
    var qJ = qI(),
      qK = ['iota:signTransaction'],
      qL = (a) => qK.some((b) => a.features[b]),
      qM = ['IOTA Wallet'],
      qN = 'Unsafe Burner Wallet',
      qO = {
        blurs: { modalOverlay: 'blur(0)' },
        backgroundColors: {
          primaryButton: '#F6F7F9',
          primaryButtonHover: '#F0F2F5',
          outlineButtonHover: '#F4F4F5',
          modalOverlay: 'rgba(24 36 53 / 20%)',
          modalPrimary: 'white',
          modalSecondary: '#F7F8F8',
          iconButton: 'transparent',
          dropdownMenu: '#FFFFFF',
          dropdownMenuSeparator: '#F3F6F8',
          walletItemSelected: 'white',
          walletItemHover: '#3C424226',
          scrollThumb: '#cad4e2',
        },
        borderColors: { outlineButton: '#E4E4E7' },
        colors: {
          primaryButton: '#373737',
          outlineButtonHover: '#373737',
          iconButton: '#000000',
          body: '#182435',
          bodyMuted: '#767A81',
          bodyDanger: '#FF794B',
        },
        radii: { small: '6px', medium: '8px', large: '12px', xlarge: '16px', full: '120px' },
        fontWeights: { normal: '400', medium: '500', bold: '600' },
        fontSizes: { small: '14px', medium: '16px', large: '18px', xlarge: '20px' },
        typography: {
          fontFamily:
            'ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji"',
          fontStyle: 'normal',
          lineHeight: '24px',
          letterSpacing: '0.1px',
        },
        spacing: {
          xxsmall: '4px',
          xsmall: '8px',
          small: '12px',
          medium: '16px',
          large: '24px',
          xlarge: '32px',
        },
      },
      qP =
        ((W = {
          blurs: { modalOverlay: '' },
          backgroundColors: {
            primaryButton: '',
            primaryButtonHover: '',
            outlineButtonHover: '',
            walletItemHover: '',
            walletItemSelected: '',
            modalOverlay: '',
            modalPrimary: '',
            modalSecondary: '',
            iconButton: '',
            dropdownMenu: '',
            dropdownMenuSeparator: '',
            scrollThumb: '',
          },
          borderColors: { outlineButton: '' },
          colors: {
            primaryButton: '',
            outlineButtonHover: '',
            body: '',
            bodyMuted: '',
            bodyDanger: '',
            iconButton: '',
          },
          radii: { small: '', medium: '', large: '', xlarge: '', full: '' },
          fontWeights: { normal: '', medium: '', bold: '' },
          fontSizes: { small: '', medium: '', large: '', xlarge: '' },
          typography: { fontFamily: '', fontStyle: '', lineHeight: '', letterSpacing: '' },
          spacing: { xxsmall: '', xsmall: '', small: '', medium: '', large: '', xlarge: '' },
        }),
        (X = (a, b) => `dapp-kit-${b.join('-')}`),
        pr(W, (a, b) => {
          var c = X(a, b),
            d = 'string' == typeof c ? c.replace(/^\-\-/, '') : null;
          if ('string' != typeof d || d !== (0, ps.default)(d, { isIdentifier: !0 }))
            throw Error('Invalid variable name for "'.concat(b.join('.'), '": ').concat(d));
          return 'var(--'.concat(d, ')');
        }));
    function qQ({ theme: a }) {
      let b = Array.isArray(a)
        ? a
            .map(({ mediaQuery: a, selector: b, variables: c }) => {
              let d = qR(c),
                e = b ? `${b} ${d}` : d;
              return a ? `@media ${a}{${e}}` : e;
            })
            .join(' ')
        : qR(a);
      return (0, a0.jsx)('style', {
        precedence: 'default',
        href: 'iota-dapp-kit-theme',
        dangerouslySetInnerHTML: { __html: b },
      });
    }
    function qR(a) {
      return `${p6} {${Object.entries(
        (function (a, b) {
          var c = {};
          if ('object' == typeof b)
            pr(b, (b, d) => {
              null != b &&
                (c[
                  pq(
                    (function (a, b) {
                      var c = a;
                      for (var d of b) {
                        if (!(d in c))
                          throw Error('Path '.concat(b.join(' -> '), ' does not exist in object'));
                        c = c[d];
                      }
                      return c;
                    })(a, d)
                  )
                ] = String(b));
            });
          else
            for (var d in a) {
              var e = a[d];
              null != e && (c[pq(d)] = e);
            }
          return (
            Object.defineProperty(c, 'toString', {
              value: function () {
                return Object.keys(this)
                  .map((a) => ''.concat(a, ':').concat(this[a]))
                  .join(';');
              },
              writable: !1,
            }),
            c
          );
        })(qP, a)
      )
        .map(([a, b]) => `${a}:${b};`)
        .join('')}}`;
    }
    function qS({
      preferredWallets: a = qM,
      walletFilter: b = qL,
      storage: c = qJ,
      storageKey: d = 'iota-dapp-kit:wallet-connection-info',
      enableUnsafeBurner: e = !1,
      autoConnect: f = !1,
      theme: g = qO,
      children: h,
      chain: i,
    }) {
      let j = (0, aX.useRef)(
        (function ({ wallets: a, storage: b, storageKey: c, autoConnectEnabled: d, chain: e }) {
          let f;
          return (f ? du(f) : du)(
            ((a, b) => {
              if ('getStorage' in b || 'serialize' in b || 'deserialize' in b)
                return (
                  (pn.env ? pn.env.MODE : void 0) !== 'production' &&
                    console.warn(
                      '[DEPRECATED] `getStorage`, `serialize` and `deserialize` options are deprecated. Use `storage` option instead.'
                    ),
                  (c, d, e) => {
                    let f,
                      g,
                      h = {
                        getStorage: () => localStorage,
                        serialize: JSON.stringify,
                        deserialize: JSON.parse,
                        partialize: (a) => a,
                        version: 0,
                        merge: (a, b) => ({ ...b, ...a }),
                        ...b,
                      },
                      i = !1,
                      j = new Set(),
                      k = new Set();
                    try {
                      f = h.getStorage();
                    } catch (a) {}
                    if (!f)
                      return a(
                        (...a) => {
                          console.warn(
                            `[zustand persist middleware] Unable to update item '${h.name}', the given storage is currently unavailable.`
                          ),
                            c(...a);
                        },
                        d,
                        e
                      );
                    let l = pp(h.serialize),
                      m = () => {
                        let a,
                          b = l({ state: h.partialize({ ...d() }), version: h.version })
                            .then((a) => f.setItem(h.name, a))
                            .catch((b) => {
                              a = b;
                            });
                        if (a) throw a;
                        return b;
                      },
                      n = e.setState;
                    e.setState = (a, b) => {
                      n(a, b), m();
                    };
                    let o = a(
                        (...a) => {
                          c(...a), m();
                        },
                        d,
                        e
                      ),
                      p = () => {
                        var a;
                        if (!f) return;
                        (i = !1), j.forEach((a) => a(d()));
                        let b =
                          (null == (a = h.onRehydrateStorage) ? void 0 : a.call(h, d())) || void 0;
                        return pp(f.getItem.bind(f))(h.name)
                          .then((a) => {
                            if (a) return h.deserialize(a);
                          })
                          .then((a) => {
                            if (a)
                              if ('number' != typeof a.version || a.version === h.version)
                                return a.state;
                              else {
                                if (h.migrate) return h.migrate(a.state, a.version);
                                console.error(
                                  "State loaded from storage couldn't be migrated since no migrate function was provided"
                                );
                              }
                          })
                          .then((a) => {
                            var b;
                            return c((g = h.merge(a, null != (b = d()) ? b : o)), !0), m();
                          })
                          .then(() => {
                            null == b || b(g, void 0), (i = !0), k.forEach((a) => a(g));
                          })
                          .catch((a) => {
                            null == b || b(void 0, a);
                          });
                      };
                    return (
                      (e.persist = {
                        setOptions: (a) => {
                          (h = { ...h, ...a }), a.getStorage && (f = a.getStorage());
                        },
                        clearStorage: () => {
                          null == f || f.removeItem(h.name);
                        },
                        getOptions: () => h,
                        rehydrate: () => p(),
                        hasHydrated: () => i,
                        onHydrate: (a) => (
                          j.add(a),
                          () => {
                            j.delete(a);
                          }
                        ),
                        onFinishHydration: (a) => (
                          k.add(a),
                          () => {
                            k.delete(a);
                          }
                        ),
                      }),
                      p(),
                      g || o
                    );
                  }
                );
              return (c, d, e) => {
                let f,
                  g = {
                    storage: po(() => localStorage),
                    partialize: (a) => a,
                    version: 0,
                    merge: (a, b) => ({ ...b, ...a }),
                    ...b,
                  },
                  h = !1,
                  i = new Set(),
                  j = new Set(),
                  k = g.storage;
                if (!k)
                  return a(
                    (...a) => {
                      console.warn(
                        `[zustand persist middleware] Unable to update item '${g.name}', the given storage is currently unavailable.`
                      ),
                        c(...a);
                    },
                    d,
                    e
                  );
                let l = () => {
                    let a = g.partialize({ ...d() });
                    return k.setItem(g.name, { state: a, version: g.version });
                  },
                  m = e.setState;
                e.setState = (a, b) => {
                  m(a, b), l();
                };
                let n = a(
                  (...a) => {
                    c(...a), l();
                  },
                  d,
                  e
                );
                e.getInitialState = () => n;
                let o = () => {
                  var a, b;
                  if (!k) return;
                  (h = !1),
                    i.forEach((a) => {
                      var b;
                      return a(null != (b = d()) ? b : n);
                    });
                  let e =
                    (null == (b = g.onRehydrateStorage)
                      ? void 0
                      : b.call(g, null != (a = d()) ? a : n)) || void 0;
                  return pp(k.getItem.bind(k))(g.name)
                    .then((a) => {
                      if (a)
                        if ('number' != typeof a.version || a.version === g.version)
                          return [!1, a.state];
                        else {
                          if (g.migrate) return [!0, g.migrate(a.state, a.version)];
                          console.error(
                            "State loaded from storage couldn't be migrated since no migrate function was provided"
                          );
                        }
                      return [!1, void 0];
                    })
                    .then((a) => {
                      var b;
                      let [e, h] = a;
                      if ((c((f = g.merge(h, null != (b = d()) ? b : n)), !0), e)) return l();
                    })
                    .then(() => {
                      null == e || e(f, void 0), (f = d()), (h = !0), j.forEach((a) => a(f));
                    })
                    .catch((a) => {
                      null == e || e(void 0, a);
                    });
                };
                return (
                  (e.persist = {
                    setOptions: (a) => {
                      (g = { ...g, ...a }), a.storage && (k = a.storage);
                    },
                    clearStorage: () => {
                      null == k || k.removeItem(g.name);
                    },
                    getOptions: () => g,
                    rehydrate: () => o(),
                    hasHydrated: () => h,
                    onHydrate: (a) => (
                      i.add(a),
                      () => {
                        i.delete(a);
                      }
                    ),
                    onFinishHydration: (a) => (
                      j.add(a),
                      () => {
                        j.delete(a);
                      }
                    ),
                  }),
                  g.skipHydration || o(),
                  f || n
                );
              };
            })(
              (b, c) => ({
                autoConnectEnabled: d,
                wallets: a,
                accounts: [],
                currentWallet: null,
                currentAccount: null,
                lastConnectedAccountAddress: null,
                lastConnectedWalletName: null,
                connectionStatus: 'disconnected',
                supportedIntents: [],
                chain: e,
                setConnectionStatus(a) {
                  b(() => ({ connectionStatus: a }));
                },
                setWalletConnected(a, c, d, e = []) {
                  b(() => ({
                    accounts: c,
                    currentWallet: a,
                    currentAccount: d,
                    lastConnectedWalletName: p2(a),
                    lastConnectedAccountAddress: d?.address,
                    connectionStatus: 'connected',
                    supportedIntents: e,
                  }));
                },
                setWalletDisconnected() {
                  b(() => ({
                    accounts: [],
                    currentWallet: null,
                    currentAccount: null,
                    lastConnectedWalletName: null,
                    lastConnectedAccountAddress: null,
                    connectionStatus: 'disconnected',
                    supportedIntents: [],
                  }));
                },
                setAccountSwitched(a) {
                  b(() => ({ currentAccount: a, lastConnectedAccountAddress: a.address }));
                },
                setWalletRegistered(a) {
                  b(() => ({ wallets: a }));
                },
                setWalletUnregistered(a, d) {
                  d === c().currentWallet
                    ? b(() => ({
                        wallets: a,
                        accounts: [],
                        currentWallet: null,
                        currentAccount: null,
                        lastConnectedWalletName: null,
                        lastConnectedAccountAddress: null,
                        connectionStatus: 'disconnected',
                        supportedIntents: [],
                      }))
                    : b(() => ({ wallets: a }));
                },
                updateWalletAccounts(a) {
                  let d = c().currentAccount;
                  b(() => ({
                    accounts: a,
                    currentAccount: (d && a.find(({ address: a }) => a === d.address)) || a[0],
                  }));
                },
              }),
              {
                name: c,
                storage: po(() => b),
                partialize: ({ lastConnectedWalletName: a, lastConnectedAccountAddress: b }) => ({
                  lastConnectedWalletName: a,
                  lastConnectedAccountAddress: b,
                }),
              }
            )
          );
        })({
          autoConnectEnabled: f,
          wallets: p1(a, b),
          storage: c || qI(),
          storageKey: d,
          chain: i,
        })
      );
      return (0, a0.jsx)(p$.Provider, {
        value: j.current,
        children: (0, a0.jsxs)(qT, {
          preferredWallets: a,
          walletFilter: b,
          enableUnsafeBurner: e,
          children: [g ? (0, a0.jsx)(qQ, { theme: g }) : null, h],
        }),
      });
    }
    function qT({
      preferredWallets: a = qM,
      walletFilter: b = qL,
      enableUnsafeBurner: c = !1,
      children: d,
    }) {
      let e, f, g;
      return (
        (e = p_((a) => a.setWalletRegistered)),
        (f = p_((a) => a.setWalletUnregistered)),
        (0, aX.useEffect)(() => {
          let c = dB();
          e(p1(a, b));
          let d = c.on('register', () => {
              e(p1(a, b));
            }),
            g = c.on('unregister', (c) => {
              f(p1(a, b), c);
            });
          return () => {
            d(), g();
          };
        }, [a, b, e, f]),
        (function () {
          let { currentWallet: a } = qu(),
            b = p_((a) => a.updateWalletAccounts);
          (0, aX.useEffect)(
            () =>
              a?.features['standard:events'].on('change', ({ accounts: a }) => {
                a && b(a);
              }),
            [a?.features, b]
          );
        })(),
        (g = qD()),
        (0, aX.useEffect)(() => {
          if (c)
            return (function (a) {
              var b, c, d, e, f;
              let g = dB();
              if (g.get().find((a) => a.name === qN))
                return void console.warn(
                  'registerUnsafeBurnerWallet: Unsafe Burner Wallet already registered, skipping duplicate registration.'
                );
              console.warn(
                'Your application is currently using the unsafe burner wallet. Make sure that this wallet is disabled in production.'
              );
              let h = new pj(),
                i = new pm({
                  address: h.getPublicKey().toIotaAddress(),
                  publicKey: h.getPublicKey().toIotaBytes(),
                  chains: ['iota:unknown'],
                  features: ['iota:signTransaction', 'iota:signAndExecuteTransaction'],
                });
              return (
                (b = new WeakMap()),
                (c = new WeakMap()),
                (d = new WeakMap()),
                (e = new WeakMap()),
                (f = new WeakMap()),
                g.register(
                  new (class {
                    constructor() {
                      pV(this, b, () => () => {}),
                        pV(this, c, async () => ({ accounts: this.accounts })),
                        pV(this, d, async (a) => {
                          let { bytes: b, signature: c } = await h.signPersonalMessage(a.message);
                          return { bytes: b, signature: c };
                        }),
                        pV(this, e, async (b) => {
                          let { bytes: c, signature: d } = await mL
                            .from(await b.transaction.toJSON())
                            .sign({ client: a, signer: h });
                          return b.signal?.throwIfAborted(), { bytes: c, signature: d };
                        }),
                        pV(this, f, async (b) => {
                          let { bytes: c, signature: d } = await mL
                            .from(await b.transaction.toJSON())
                            .sign({ client: a, signer: h });
                          b.signal?.throwIfAborted();
                          let { rawEffects: e, digest: f } = await a.executeTransactionBlock({
                            signature: d,
                            transactionBlock: c,
                            options: { showRawEffects: !0 },
                          });
                          return {
                            bytes: c,
                            signature: d,
                            digest: f,
                            effects: dU(new Uint8Array(e)),
                          };
                        });
                    }
                    get version() {
                      return '1.0.0';
                    }
                    get name() {
                      return qN;
                    }
                    get icon() {
                      return 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADwAAAA8CAYAAAA6/NlyAAAJrElEQVR42tWbe2xT1x3H7UxAyD3XrdrSbGXlUbKWsq5rWdVuVOMRSEqSOmnVRZMmJqZNYv1nf3R/jWmVmVrtRRM/YwPd1nVTNcrE3pQCoikrIRAC4VVNY0hlD9ZOo1uCfe3ra9979v0dcy3s5Pper76Oh/STE+495/4+5/c85zqe2f7HAx5vKsS+monJj/CdHi/f4/HWW4f6AwdblmXjTM0NyS+movKtw9v+j6C5gKhyTMTTpA2x15Qwy+Pz75motOGdgKep8WF5ATgVZIt5NeO2wMqD0hfVGNPh3oYaYflsjG0l63PeyLCDnqbsLpZIhaRNFI+Ox+Le5KB0RybK8gDmJOkI07U4i/FhT1NDQl8Me5rUIfaDfELOJ0NsFa/SJQHm1WLsHcDqRWiy9BCL8s0N5t6UWWFVvxplejYm60hC91cNjPtzCTZsAptCVoeLP8PDDQJNCSodap6H+LtE8ZcdkvVkkD38vwDn4/Jvy4EhBhZSvRaUHiTXn31gJJxkUPoClBKKFizM+inhVA2cYIdM4HJouPvoe9s9H+KzDhyGK6KkmIqitBhww2C11rjQL2L4kgUwFxk8yPyzauUA3Pk/353XnA6zKbKCaQ2UlMvJF6W5uF5F8yHfZWZpC9HRmBziaEpm1bpY9XvhxuWJRldC7Mt03WlZwpjnkZUNa2DMG2EaPj9MGd2l2mofd0hQ7ZSopsXckHxVCUp32fXGdD0ZktrgFUmMqwhcWFjp87RArsD+9bn585IRaSHAKgBL3SZwOTRc8BKg7yYoskp5OJDiiPmF2Sj7ox0siYJ7lJA04EqvzZ9B1xSVt6PlW0IxZgUMJdZYAJuWngLQt9IRuZXmoTEkmci8ZtTXTViUKyasA9FRun5d8z6bfw0gYWm9mmCXxZatQgxfC7I2NVpRYQOxKWppLs4mcgn5NcibgL1K40xYp8CYY5TXEpjcb3LAJ0OZyyg3+2nySm6fjEtzkEz+7VBx3RTb+60z9dma7pkvwO2QQL5HzTtAdpKF7euw/HuzfrosBHy+ZsBimzbQshjWTVMDgez53B5MbjcGbr1ZjdUJOM5O0SLXzJ2R+uOA1dMAVoLsm5zb73JSId8t8Aa1LsAJdoTCrCaw6e3NC2DdFMUXWRg173mysJNOSUNskUJ1cOlXa2LhcbgmSszXYSn9hl3KSxTDjrZ2cbbfbWDyumsh9m3e7zCG7a3ETt+gtI7fx6lEOanZKDVvuA2cjYmt5xNOd2Louz3IQ12UZ2Zo3lkb9cDlvSs6m4Vk5Yqlabs0B97wT7PUuCXQz0Bnt9QxMPTW4iwBtmUlY8hFsHJPlzcQ1xuG75CVK1kXofCUGnU9fg1aVD7kfE9MoabtYkcAvIUYS2op3Hc3TTrDQzIAeojugTVLFolWDR6wFPtY0R66n6HltwjCIawnE2ymresk9NtN+pfUUi0mX6RJLfrh9zMRaRPOqubSA8W2MNzC0mHpK7j2ruuw5mYkxl5+2+HGQeg4yNYg7vNg+xMxFsuRMuiTsRJZG3cysAl4D9n4aC4un8L9qUyVvbCyYwFXX1nGUxFf1cCiEQqy75O+TpMwYKNKSPQUqhLyyWLsRbESLctx0YnixgfphRWA8pOPc+N4F9d+eV9V4OlCX/As5w5g+wtGhJGukp5go2R3D7EW9rSDcnGL56YgJHj+8GcFND/Vy41jj/H0jxc6HU/AA2QlR01UlH3D7CmITQnJq4lVWBi1yl8XYEh278c5H++F+Iui7r7bYR8tH/gbqoJN7fVODUhLYVVxzmYCEyOxFg7RUVa0egCHZZ55eRHnp/tKgMna6s/bbMdTxZgMzl9CCcmq7k690OzDfaeSN4QcsREjsQpgXHwyWyfg9K5WE7hc6JqTWjyihObfygOFOkv6i5K5TZx8LsL1sVS4NL8ItiB7sgAcEKcWHfUCVhK3kUVnBNbfXIs4l5xAv5sJs234eTUy93L0Au2otQOw5ORMyfQ6WwexFupVSHowG6uThXfebmlhWojMS3fazmMeGxEI6S2SUti6RAo2vKohVuH3qUG5FWm/PjH8kzutgSH5g58xrVwzIbZkxHf7OFjFC+wrMDXcpOqOKX/g01U/XPvVJyxdWsiJblqYmnZoWbDxAcR56X5WPuh4ewcL5PY9JBRUYjc7fzjG6Uc3mHBWbg23X1BLaFHOSnrw4bWiNAXSEWcWRntIignXTP/oDsfKZX66mMbZAPfhviU1AyYmJLYAMZa/QXjUSeIiixpj3UUFtd884KytjN7EjdGNNMbWwtlf3FvbQ4OQtIoYSzbxqVDLXMTxP8jnnbiyKcaJLvueGLD6kXW2sKZov1tpn7hwXf3ZUvq0K2FXOM7Op/Xgb6PhxsWIErYGVuK3WGXWkkwMMZVCVl5kWtax5A6usgemvnx4DelUcYcFC0eIbcbXKzggeyBjeXIhkftaKknJKLtnuSg7KmKQsrH+1nqbmLWY6w/tBGy/8xrruR5SM99LLIjfT/4ZbNZnQEPssIVb21rKTGRIPDagNoLdFMKgcuLc/TF6Bulk6c7ovg4TU+XvS6FNw1tDfVqH9MOPmBDui0hcK6wz744FlDjNe0m3aVldJYagtI6YbF+3ZGPsQHlN1vbeh8lJofqJ+uo9Zi4wXZxKFiXKGxbHT7pNq71oNg4Qi6MviE0FpRVqjGXILYoJ4tCjdYU1rWeMdPLc/ochj3B9pGNGL4NupGPRlUl35KMVxFLNO6ZnxYlBsUPqoMkbUqAb6VhMVKQ7MVT1dYdrL8hzEAcjpmvjHKphgaFb0ZVJZw7dwVD9q5fkgPTRbBxnzmGfgRLQsMCkG+moQdcp6GzzZsL2MGyllvBNGWM9RqMCk26kI7aBK526csVShZTfzid6FEzeiNAGP92jpCPQEbrW7EW5MbZxAz/fN9lg0IbQaaxrQ83/VoKPb/HqJx67Hw+43CDQBPsX0gm6ufXNvH4vP9rZapzx7+Nn+oxZAjfo2caZ3n350c5W6FSEdQ86sNarj3c/jRV+H42AXsdGRBfPPIlnb/mUtxzWXfALn/PmRze2Gud6E/xsXwYtnlsWN8Tc5/oyxjn/jvyJrlY82xLUfWuPr/TqxzuXQZkIP9M7CXiyuP4B4WmsTnNhzinjrD+WO9bRhmdZWLXe4EKRtV5tpN3Hx3s2G+d79/MJf4qff0LnE72kfFEs4ITQvWLMab8C131dP9n9Je1Yx000Nz2jAf+UJwCBchc3NvGR1Qx71XXY2Ww1Jvx7YalzAPkX9rp5E5Z+pv+ja8bE43uN491b9dHO9Xx4lUxziLn21Nai/wXWM6t9vkvtrwAAAABJRU5ErkJggg==';
                    }
                    get chains() {
                      return cL;
                    }
                    get accounts() {
                      return [i];
                    }
                    get features() {
                      return {
                        'standard:connect': { version: '1.0.0', connect: pU(this, c) },
                        'standard:events': { version: '1.0.0', on: pU(this, b) },
                        'iota:signPersonalMessage': {
                          version: '1.0.0',
                          signPersonalMessage: pU(this, d),
                        },
                        'iota:signTransaction': { version: '2.0.0', signTransaction: pU(this, e) },
                        'iota:signAndExecuteTransaction': {
                          version: '2.0.0',
                          signAndExecuteTransaction: pU(this, f),
                        },
                      };
                    }
                  })()
                )
              );
            })(g);
        }, [c, g]),
        !(function () {
          let { mutateAsync: a } = p0(),
            b = p_((a) => a.autoConnectEnabled),
            c = p_((a) => a.lastConnectedWalletName),
            d = p_((a) => a.lastConnectedAccountAddress),
            e = qk(),
            { isConnected: f } = qu(),
            [g, h] = (0, aX.useState)(!1);
          (0, aX.useLayoutEffect)(() => {
            h(!0);
          }, []);
          let { data: i, isError: j } = hd({
            queryKey: [
              '@iota/dapp-kit',
              'autoconnect',
              {
                isConnected: f,
                autoConnectEnabled: b,
                lastConnectedWalletName: c,
                lastConnectedAccountAddress: d,
                walletCount: e.length,
              },
            ],
            queryFn: async () => {
              if (!b) return 'disabled';
              if (!c || !d || f) return 'attempted';
              let g = e.find((a) => p2(a) === c);
              return g && (await a({ wallet: g, accountAddress: d, silent: !0 })), 'attempted';
            },
            enabled: b,
            persister: void 0,
            gcTime: 0,
            staleTime: 0,
            networkMode: 'always',
            retry: !1,
            retryOnMount: !1,
            refetchInterval: !1,
            refetchIntervalInBackground: !1,
            refetchOnMount: !1,
            refetchOnReconnect: !1,
            refetchOnWindowFocus: !1,
          });
        })(),
        d
      );
    }
    function qU(a) {
      function b() {
        let { config: a } = qC();
        if (!a) throw Error('No network config found');
        return a;
      }
      function c() {
        let { variables: a } = b();
        return a ?? {};
      }
      return {
        networkConfig: a,
        useNetworkConfig: b,
        useNetworkVariables: c,
        useNetworkVariable: function (a) {
          return c()[a];
        },
      };
    }
    function qV(...a) {
      let [b, c, { queryKey: d = [], ...e } = {}] = a,
        f = qC();
      return hd({
        ...e,
        queryKey: [f.network, b, c, ...d],
        queryFn: async () => await f.client[b](c),
      });
    }
    function qW({ mutationKey: a, execute: b, ...c } = {}) {
      let d = p_((a) => a.chain),
        { currentWallet: e, supportedIntents: f } = qu(),
        g = qp(),
        h = qD(),
        { mutate: i } = (function ({ mutationKey: a, ...b } = {}) {
          let { currentWallet: c } = qu(),
            d = qp();
          return ds({
            mutationKey: pY.reportTransactionEffects(a),
            mutationFn: async ({ effects: a, chain: b = c?.chains[0], account: e = d }) => {
              if (!c) throw new qq('No wallet is connected.');
              if (!e)
                throw new qr('No wallet account is selected to report transaction effects for');
              let f = c.features['iota:reportTransactionEffects'];
              if (f)
                return await f.reportTransactionEffects({
                  effects: Array.isArray(a) ? dU(new Uint8Array(a)) : a,
                  account: e,
                  chain: b ?? c?.chains[0],
                });
            },
            ...b,
          });
        })(),
        j =
          b ??
          (async ({ bytes: a, signature: b }) => {
            let { digest: c, rawEffects: d } = await h.executeTransactionBlock({
              transactionBlock: a,
              signature: b,
              options: { showRawEffects: !0 },
            });
            return {
              digest: c,
              rawEffects: d,
              effects: dU(new Uint8Array(d)),
              bytes: a,
              signature: b,
            };
          });
      return ds({
        mutationKey: pY.signAndExecuteTransaction(a),
        mutationFn: async ({ transaction: a, ...b }) => {
          let c;
          if (!e) throw new qq('No wallet is connected.');
          let k = b.account ?? g;
          if (!k) throw new qr('No wallet account is selected to sign the transaction with.');
          if (!e.features['iota:signTransaction'])
            throw new qs("This wallet doesn't support the `signTransaction` feature.");
          let l = b.chain ?? d ?? k?.chains[0],
            { signature: m, bytes: n } = await pM(e, {
              ...b,
              transaction: {
                toJSON: async () =>
                  'string' == typeof a ? a : await a.toJSON({ supportedIntents: f, client: h }),
              },
              account: k,
              chain: l,
            }),
            o = await j({ bytes: n, signature: m });
          if ('effects' in o && o.effects?.bcs) c = o.effects.bcs;
          else if ('rawEffects' in o) c = dU(new Uint8Array(o.rawEffects));
          else throw Error('Could not parse effects from transaction result.');
          return (
            i({ effects: c, account: k, chain: l }),
            b.waitForTransaction &&
              'digest' in o &&
              (await h.waitForTransaction({ digest: o.digest })),
            o
          );
        },
        ...c,
      });
    }
    a.s(
      [
        'ConnectButton',
        () => qH,
        'IotaClientProvider',
        () => qB,
        'WalletProvider',
        () => qS,
        'createNetworkConfig',
        () => qU,
        'useCurrentAccount',
        () => qp,
        'useIotaClient',
        () => qD,
        'useIotaClientQuery',
        () => qV,
        'useSignAndExecuteTransaction',
        () => qW,
      ],
      98912
    );
  },
  28525,
  (a, b, c) => {
    !(function () {
      'use strict';
      var c = {}.hasOwnProperty;
      function d() {
        for (var a = '', b = 0; b < arguments.length; b++) {
          var f = arguments[b];
          f &&
            (a = e(
              a,
              (function (a) {
                if ('string' == typeof a || 'number' == typeof a) return a;
                if ('object' != typeof a) return '';
                if (Array.isArray(a)) return d.apply(null, a);
                if (
                  a.toString !== Object.prototype.toString &&
                  !a.toString.toString().includes('[native code]')
                )
                  return a.toString();
                var b = '';
                for (var f in a) c.call(a, f) && a[f] && (b = e(b, f));
                return b;
              })(f)
            ));
        }
        return a;
      }
      function e(a, b) {
        return b ? (a ? a + ' ' + b : a + b) : a;
      }
      if (b.exports) (d.default = d), (b.exports = d);
      else if ('function' == typeof define && 'object' == typeof define.amd && define.amd)
        void 0 !== d && a.v(d);
      else window.classNames = d;
    })();
  },
  88289,
  (a) => {
    'use strict';
    var b = a.i(72131),
      c = a.i(70121),
      d = a.i(87924);
    function e(a) {
      var e;
      let f,
        g =
          ((e = a),
          ((f = b.forwardRef((a, d) => {
            let { children: e, ...f } = a;
            if (b.isValidElement(e)) {
              var g;
              let a,
                h,
                i =
                  ((g = e),
                  (h =
                    (a = Object.getOwnPropertyDescriptor(g.props, 'ref')?.get) &&
                    'isReactWarning' in a &&
                    a.isReactWarning)
                    ? g.ref
                    : (h =
                        (a = Object.getOwnPropertyDescriptor(g, 'ref')?.get) &&
                        'isReactWarning' in a &&
                        a.isReactWarning)
                    ? g.props.ref
                    : g.props.ref || g.ref),
                j = (function (a, b) {
                  let c = { ...b };
                  for (let d in b) {
                    let e = a[d],
                      f = b[d];
                    /^on[A-Z]/.test(d)
                      ? e && f
                        ? (c[d] = (...a) => {
                            let b = f(...a);
                            return e(...a), b;
                          })
                        : e && (c[d] = e)
                      : 'style' === d
                      ? (c[d] = { ...e, ...f })
                      : 'className' === d && (c[d] = [e, f].filter(Boolean).join(' '));
                  }
                  return { ...a, ...c };
                })(f, e.props);
              return (
                e.type !== b.Fragment && (j.ref = d ? (0, c.composeRefs)(d, i) : i),
                b.cloneElement(e, j)
              );
            }
            return b.Children.count(e) > 1 ? b.Children.only(null) : null;
          })).displayName = `${e}.SlotClone`),
          f),
        h = b.forwardRef((a, c) => {
          let { children: e, ...f } = a,
            h = b.Children.toArray(e),
            i = h.find(j);
          if (i) {
            let a = i.props.children,
              e = h.map((c) =>
                c !== i
                  ? c
                  : b.Children.count(a) > 1
                  ? b.Children.only(null)
                  : b.isValidElement(a)
                  ? a.props.children
                  : null
              );
            return (0, d.jsx)(g, {
              ...f,
              ref: c,
              children: b.isValidElement(a) ? b.cloneElement(a, void 0, e) : null,
            });
          }
          return (0, d.jsx)(g, { ...f, ref: c, children: e });
        });
      return (h.displayName = `${a}.Slot`), h;
    }
    var f = e('Slot'),
      g = Symbol('radix.slottable');
    function h(a) {
      let b = ({ children: a }) => (0, d.jsx)(d.Fragment, { children: a });
      return (b.displayName = `${a}.Slottable`), (b.__radixId = g), b;
    }
    var i = h('Slottable');
    function j(a) {
      return (
        b.isValidElement(a) &&
        'function' == typeof a.type &&
        '__radixId' in a.type &&
        a.type.__radixId === g
      );
    }
    a.s(
      [
        'Root',
        () => f,
        'Slot',
        () => f,
        'Slottable',
        () => i,
        'createSlot',
        () => e,
        'createSlottable',
        () => h,
      ],
      15466
    );
    var k = a.i(15466);
    a.s(['Slot', 0, k], 88289);
  },
  28094,
  (a) => {
    'use strict';
    var b = a.i(72131),
      c = a.i(30553),
      d = a.i(87924),
      e = Object.freeze({
        position: 'absolute',
        border: 0,
        width: 1,
        height: 1,
        padding: 0,
        margin: -1,
        overflow: 'hidden',
        clip: 'rect(0, 0, 0, 0)',
        whiteSpace: 'nowrap',
        wordWrap: 'normal',
      }),
      f = b.forwardRef((a, b) =>
        (0, d.jsx)(c.Primitive.span, { ...a, ref: b, style: { ...e, ...a.style } })
      );
    (f.displayName = 'VisuallyHidden'),
      a.s(['Root', () => f, 'VISUALLY_HIDDEN_STYLES', () => e, 'VisuallyHidden', () => f]);
  },
  71680,
  5707,
  88023,
  (a) => {
    'use strict';
    let b = { asChild: { type: 'boolean' } };
    a.s(['asChildPropDef', () => b], 71680);
    let c = [
        'gray',
        'gold',
        'bronze',
        'brown',
        'yellow',
        'amber',
        'orange',
        'tomato',
        'red',
        'ruby',
        'crimson',
        'pink',
        'plum',
        'purple',
        'violet',
        'iris',
        'indigo',
        'blue',
        'cyan',
        'teal',
        'jade',
        'green',
        'grass',
        'lime',
        'mint',
        'sky',
      ],
      d = ['auto', 'gray', 'mauve', 'slate', 'sage', 'olive', 'sand'],
      e = { color: { type: 'enum', values: c, default: void 0 } },
      f = { color: { type: 'enum', values: c, default: '' } };
    a.s(
      [
        'accentColorPropDef',
        () => f,
        'accentColors',
        () => c,
        'colorPropDef',
        () => e,
        'grayColors',
        () => d,
      ],
      5707
    );
    let g = ['none', 'small', 'medium', 'large', 'full'],
      h = { radius: { type: 'enum', values: g, default: void 0 } };
    a.s(['radii', () => g, 'radiusPropDef', () => h], 88023);
  },
  38847,
  (a) => {
    'use strict';
    var b,
      c =
        (((b = c || {}).Mainnet = 'mainnet'),
        (b.Devnet = 'devnet'),
        (b.Testnet = 'testnet'),
        (b.Localnet = 'localnet'),
        (b.Custom = 'custom'),
        b);
    function d(a) {
      return (
        (function () {
          let a;
          try {
            a = JSON.parse(
              '{\n    "mainnet": {\n        "id": "mainnet",\n        "name": "Mainnet",\n        "url": "https://api.mainnet.iota.cafe",\n        "graphql": "https://graphql.mainnet.iota.cafe",\n        "explorer": "https://explorer.rebased.iota.org",\n        "chain": "iota:mainnet"\n    },\n    "testnet": {\n        "id": "testnet",\n        "name": "Testnet",\n        "url": "https://api.testnet.iota.cafe",\n        "graphql": "https://graphql.testnet.iota.cafe",\n        "explorer": "https://explorer.rebased.iota.org",\n        "chain": "iota:testnet",\n        "faucet": "https://faucet.testnet.iota.cafe",\n        "kiosk": {\n            "royaltyRulePackageId": "0x975f749f57701209454e4b9b9e33825ccb6a9abf57de2ce86979e5fa86c343f2",\n            "kioskLockRulePackageId": "0x975f749f57701209454e4b9b9e33825ccb6a9abf57de2ce86979e5fa86c343f2",\n            "floorPriceRulePackageId": "0x975f749f57701209454e4b9b9e33825ccb6a9abf57de2ce86979e5fa86c343f2",\n            "personalKioskRulePackageId": "0x975f749f57701209454e4b9b9e33825ccb6a9abf57de2ce86979e5fa86c343f2"\n        }\n    },\n    "devnet": {\n        "id": "devnet",\n        "name": "Devnet",\n        "url": "https://api.devnet.iota.cafe",\n        "graphql": "https://graphql.devnet.iota.cafe",\n        "explorer": "https://explorer.rebased.iota.org",\n        "chain": "iota:devnet",\n        "faucet": "https://faucet.devnet.iota.cafe"\n    },\n    "localnet": {\n        "id": "localnet",\n        "name": "Localnet",\n        "url": "http://localhost:9000",\n        "graphql": "http://localhost:9125",\n        "explorer": "http://localhost:3000",\n        "chain": "iota:local",\n        "faucet": "http://localhost:9123"\n    }\n}'
            );
          } catch {
            throw Error('Failed to parse env var "IOTA_NETWORKS".');
          }
          return a;
        })()[a] ?? a
      ).url;
    }
    let {
      networkConfig: e,
      useNetworkVariable: f,
      useNetworkVariables: g,
    } = (0, a.i(98912).createNetworkConfig)({
      devnet: {
        url: d('devnet'),
        variables: {
          packageId: '0x9db832e7c6fba2bab1459ebec461e381a5f59f6f39d56eb5d1f852b7aaac768a',
        },
      },
      testnet: {
        url: d('testnet'),
        variables: {
          packageId: '0x2448997aae116858911c172aabd061f615984f8b3692d4df7e2926c82ada1d73',
        },
      },
      mainnet: { url: d('mainnet'), variables: { packageId: '' } },
    });
    a.s(['networkConfig', () => e, 'useNetworkVariable', () => f], 38847);
  },
];

//# sourceMappingURL=%5Broot-of-the-server%5D__d49a18c4._.js.map
