(globalThis.TURBOPACK || (globalThis.TURBOPACK = [])).push([
  'object' == typeof document ? document.currentScript : void 0,
  55838,
  (e, t, n) => {
    'use strict';
    var i = e.r(71645),
      a =
        'function' == typeof Object.is
          ? Object.is
          : function (e, t) {
              return (e === t && (0 !== e || 1 / e == 1 / t)) || (e != e && t != t);
            },
      o = i.useState,
      s = i.useEffect,
      l = i.useLayoutEffect,
      u = i.useDebugValue;
    function c(e) {
      var t = e.getSnapshot;
      e = e.value;
      try {
        var n = t();
        return !a(e, n);
      } catch (e) {
        return !0;
      }
    }
    var d =
      'undefined' == typeof window ||
      void 0 === window.document ||
      void 0 === window.document.createElement
        ? function (e, t) {
            return t();
          }
        : function (e, t) {
            var n = t(),
              i = o({ inst: { value: n, getSnapshot: t } }),
              a = i[0].inst,
              d = i[1];
            return (
              l(
                function () {
                  (a.value = n), (a.getSnapshot = t), c(a) && d({ inst: a });
                },
                [e, n, t]
              ),
              s(
                function () {
                  return (
                    c(a) && d({ inst: a }),
                    e(function () {
                      c(a) && d({ inst: a });
                    })
                  );
                },
                [e]
              ),
              u(n),
              n
            );
          };
    n.useSyncExternalStore = void 0 !== i.useSyncExternalStore ? i.useSyncExternalStore : d;
  },
  2239,
  (e, t, n) => {
    'use strict';
    t.exports = e.r(55838);
  },
  52822,
  (e, t, n) => {
    'use strict';
    var i = e.r(71645),
      a = e.r(2239),
      o =
        'function' == typeof Object.is
          ? Object.is
          : function (e, t) {
              return (e === t && (0 !== e || 1 / e == 1 / t)) || (e != e && t != t);
            },
      s = a.useSyncExternalStore,
      l = i.useRef,
      u = i.useEffect,
      c = i.useMemo,
      d = i.useDebugValue;
    n.useSyncExternalStoreWithSelector = function (e, t, n, i, a) {
      var f = l(null);
      if (null === f.current) {
        var h = { hasValue: !1, value: null };
        f.current = h;
      } else h = f.current;
      var p = s(
        e,
        (f = c(
          function () {
            function e(e) {
              if (!u) {
                if (((u = !0), (s = e), (e = i(e)), void 0 !== a && h.hasValue)) {
                  var t = h.value;
                  if (a(t, e)) return (l = t);
                }
                return (l = e);
              }
              if (((t = l), o(s, e))) return t;
              var n = i(e);
              return void 0 !== a && a(t, n) ? ((s = e), t) : ((s = e), (l = n));
            }
            var s,
              l,
              u = !1,
              c = void 0 === n ? null : n;
            return [
              function () {
                return e(t());
              },
              null === c
                ? void 0
                : function () {
                    return e(c());
                  },
            ];
          },
          [t, n, i, a]
        ))[0],
        f[1]
      );
      return (
        u(
          function () {
            (h.hasValue = !0), (h.value = p);
          },
          [p]
        ),
        d(p),
        p
      );
    };
  },
  30224,
  (e, t, n) => {
    'use strict';
    t.exports = e.r(52822);
  },
  96510,
  (e, t, n) => {
    !(function (e) {
      'use strict';
      var t,
        n = function (e) {
          var t,
            n = new Float64Array(16);
          if (e) for (t = 0; t < e.length; t++) n[t] = e[t];
          return n;
        },
        i = function () {
          throw Error('no PRNG');
        },
        a = new Uint8Array(16),
        o = new Uint8Array(32);
      o[0] = 9;
      var s = n(),
        l = n([1]),
        u = n([56129, 1]),
        c = n([
          30883, 4953, 19914, 30187, 55467, 16705, 2637, 112, 59544, 30585, 16505, 36039, 65139,
          11119, 27886, 20995,
        ]),
        d = n([
          61785, 9906, 39828, 60374, 45398, 33411, 5274, 224, 53552, 61171, 33010, 6542, 64743,
          22239, 55772, 9222,
        ]),
        f = n([
          54554, 36645, 11616, 51542, 42930, 38181, 51040, 26924, 56412, 64982, 57905, 49316, 21502,
          52590, 14035, 8553,
        ]),
        h = n([
          26200, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214,
          26214, 26214, 26214,
        ]),
        p = n([
          41136, 18958, 6951, 50414, 58488, 44335, 6150, 12099, 55207, 15867, 153, 11085, 57099,
          20417, 9344, 11139,
        ]);
      function m(e, t, n, i) {
        (e[t] = (n >> 24) & 255),
          (e[t + 1] = (n >> 16) & 255),
          (e[t + 2] = (n >> 8) & 255),
          (e[t + 3] = 255 & n),
          (e[t + 4] = (i >> 24) & 255),
          (e[t + 5] = (i >> 16) & 255),
          (e[t + 6] = (i >> 8) & 255),
          (e[t + 7] = 255 & i);
      }
      function g(e, t, n, i, a) {
        var o,
          s = 0;
        for (o = 0; o < a; o++) s |= e[t + o] ^ n[i + o];
        return (1 & ((s - 1) >>> 8)) - 1;
      }
      function y(e, t, n, i) {
        return g(e, t, n, i, 16);
      }
      function b(e, t, n, i) {
        return g(e, t, n, i, 32);
      }
      function v(e, t, n, i) {
        !(function (e, t, n, i) {
          for (
            var a,
              o = (255 & i[0]) | ((255 & i[1]) << 8) | ((255 & i[2]) << 16) | ((255 & i[3]) << 24),
              s = (255 & n[0]) | ((255 & n[1]) << 8) | ((255 & n[2]) << 16) | ((255 & n[3]) << 24),
              l = (255 & n[4]) | ((255 & n[5]) << 8) | ((255 & n[6]) << 16) | ((255 & n[7]) << 24),
              u =
                (255 & n[8]) | ((255 & n[9]) << 8) | ((255 & n[10]) << 16) | ((255 & n[11]) << 24),
              c =
                (255 & n[12]) |
                ((255 & n[13]) << 8) |
                ((255 & n[14]) << 16) |
                ((255 & n[15]) << 24),
              d = (255 & i[4]) | ((255 & i[5]) << 8) | ((255 & i[6]) << 16) | ((255 & i[7]) << 24),
              f = (255 & t[0]) | ((255 & t[1]) << 8) | ((255 & t[2]) << 16) | ((255 & t[3]) << 24),
              h = (255 & t[4]) | ((255 & t[5]) << 8) | ((255 & t[6]) << 16) | ((255 & t[7]) << 24),
              p =
                (255 & t[8]) | ((255 & t[9]) << 8) | ((255 & t[10]) << 16) | ((255 & t[11]) << 24),
              m =
                (255 & t[12]) |
                ((255 & t[13]) << 8) |
                ((255 & t[14]) << 16) |
                ((255 & t[15]) << 24),
              g =
                (255 & i[8]) | ((255 & i[9]) << 8) | ((255 & i[10]) << 16) | ((255 & i[11]) << 24),
              y =
                (255 & n[16]) |
                ((255 & n[17]) << 8) |
                ((255 & n[18]) << 16) |
                ((255 & n[19]) << 24),
              b =
                (255 & n[20]) |
                ((255 & n[21]) << 8) |
                ((255 & n[22]) << 16) |
                ((255 & n[23]) << 24),
              v =
                (255 & n[24]) |
                ((255 & n[25]) << 8) |
                ((255 & n[26]) << 16) |
                ((255 & n[27]) << 24),
              w =
                (255 & n[28]) |
                ((255 & n[29]) << 8) |
                ((255 & n[30]) << 16) |
                ((255 & n[31]) << 24),
              x =
                (255 & i[12]) |
                ((255 & i[13]) << 8) |
                ((255 & i[14]) << 16) |
                ((255 & i[15]) << 24),
              E = o,
              S = s,
              C = l,
              k = u,
              O = c,
              A = d,
              I = f,
              j = h,
              T = p,
              R = m,
              M = g,
              P = y,
              N = b,
              _ = v,
              D = w,
              B = x,
              U = 0;
            U < 20;
            U += 2
          )
            (O ^= ((a = (E + N) | 0) << 7) | (a >>> 25)),
              (T ^= ((a = (O + E) | 0) << 9) | (a >>> 23)),
              (N ^= ((a = (T + O) | 0) << 13) | (a >>> 19)),
              (E ^= ((a = (N + T) | 0) << 18) | (a >>> 14)),
              (R ^= ((a = (A + S) | 0) << 7) | (a >>> 25)),
              (_ ^= ((a = (R + A) | 0) << 9) | (a >>> 23)),
              (S ^= ((a = (_ + R) | 0) << 13) | (a >>> 19)),
              (A ^= ((a = (S + _) | 0) << 18) | (a >>> 14)),
              (D ^= ((a = (M + I) | 0) << 7) | (a >>> 25)),
              (C ^= ((a = (D + M) | 0) << 9) | (a >>> 23)),
              (I ^= ((a = (C + D) | 0) << 13) | (a >>> 19)),
              (M ^= ((a = (I + C) | 0) << 18) | (a >>> 14)),
              (k ^= ((a = (B + P) | 0) << 7) | (a >>> 25)),
              (j ^= ((a = (k + B) | 0) << 9) | (a >>> 23)),
              (P ^= ((a = (j + k) | 0) << 13) | (a >>> 19)),
              (B ^= ((a = (P + j) | 0) << 18) | (a >>> 14)),
              (S ^= ((a = (E + k) | 0) << 7) | (a >>> 25)),
              (C ^= ((a = (S + E) | 0) << 9) | (a >>> 23)),
              (k ^= ((a = (C + S) | 0) << 13) | (a >>> 19)),
              (E ^= ((a = (k + C) | 0) << 18) | (a >>> 14)),
              (I ^= ((a = (A + O) | 0) << 7) | (a >>> 25)),
              (j ^= ((a = (I + A) | 0) << 9) | (a >>> 23)),
              (O ^= ((a = (j + I) | 0) << 13) | (a >>> 19)),
              (A ^= ((a = (O + j) | 0) << 18) | (a >>> 14)),
              (P ^= ((a = (M + R) | 0) << 7) | (a >>> 25)),
              (T ^= ((a = (P + M) | 0) << 9) | (a >>> 23)),
              (R ^= ((a = (T + P) | 0) << 13) | (a >>> 19)),
              (M ^= ((a = (R + T) | 0) << 18) | (a >>> 14)),
              (N ^= ((a = (B + D) | 0) << 7) | (a >>> 25)),
              (_ ^= ((a = (N + B) | 0) << 9) | (a >>> 23)),
              (D ^= ((a = (_ + N) | 0) << 13) | (a >>> 19)),
              (B ^= ((a = (D + _) | 0) << 18) | (a >>> 14));
          (E = (E + o) | 0),
            (S = (S + s) | 0),
            (C = (C + l) | 0),
            (k = (k + u) | 0),
            (O = (O + c) | 0),
            (A = (A + d) | 0),
            (I = (I + f) | 0),
            (j = (j + h) | 0),
            (T = (T + p) | 0),
            (R = (R + m) | 0),
            (M = (M + g) | 0),
            (P = (P + y) | 0),
            (N = (N + b) | 0),
            (_ = (_ + v) | 0),
            (D = (D + w) | 0),
            (B = (B + x) | 0),
            (e[0] = (E >>> 0) & 255),
            (e[1] = (E >>> 8) & 255),
            (e[2] = (E >>> 16) & 255),
            (e[3] = (E >>> 24) & 255),
            (e[4] = (S >>> 0) & 255),
            (e[5] = (S >>> 8) & 255),
            (e[6] = (S >>> 16) & 255),
            (e[7] = (S >>> 24) & 255),
            (e[8] = (C >>> 0) & 255),
            (e[9] = (C >>> 8) & 255),
            (e[10] = (C >>> 16) & 255),
            (e[11] = (C >>> 24) & 255),
            (e[12] = (k >>> 0) & 255),
            (e[13] = (k >>> 8) & 255),
            (e[14] = (k >>> 16) & 255),
            (e[15] = (k >>> 24) & 255),
            (e[16] = (O >>> 0) & 255),
            (e[17] = (O >>> 8) & 255),
            (e[18] = (O >>> 16) & 255),
            (e[19] = (O >>> 24) & 255),
            (e[20] = (A >>> 0) & 255),
            (e[21] = (A >>> 8) & 255),
            (e[22] = (A >>> 16) & 255),
            (e[23] = (A >>> 24) & 255),
            (e[24] = (I >>> 0) & 255),
            (e[25] = (I >>> 8) & 255),
            (e[26] = (I >>> 16) & 255),
            (e[27] = (I >>> 24) & 255),
            (e[28] = (j >>> 0) & 255),
            (e[29] = (j >>> 8) & 255),
            (e[30] = (j >>> 16) & 255),
            (e[31] = (j >>> 24) & 255),
            (e[32] = (T >>> 0) & 255),
            (e[33] = (T >>> 8) & 255),
            (e[34] = (T >>> 16) & 255),
            (e[35] = (T >>> 24) & 255),
            (e[36] = (R >>> 0) & 255),
            (e[37] = (R >>> 8) & 255),
            (e[38] = (R >>> 16) & 255),
            (e[39] = (R >>> 24) & 255),
            (e[40] = (M >>> 0) & 255),
            (e[41] = (M >>> 8) & 255),
            (e[42] = (M >>> 16) & 255),
            (e[43] = (M >>> 24) & 255),
            (e[44] = (P >>> 0) & 255),
            (e[45] = (P >>> 8) & 255),
            (e[46] = (P >>> 16) & 255),
            (e[47] = (P >>> 24) & 255),
            (e[48] = (N >>> 0) & 255),
            (e[49] = (N >>> 8) & 255),
            (e[50] = (N >>> 16) & 255),
            (e[51] = (N >>> 24) & 255),
            (e[52] = (_ >>> 0) & 255),
            (e[53] = (_ >>> 8) & 255),
            (e[54] = (_ >>> 16) & 255),
            (e[55] = (_ >>> 24) & 255),
            (e[56] = (D >>> 0) & 255),
            (e[57] = (D >>> 8) & 255),
            (e[58] = (D >>> 16) & 255),
            (e[59] = (D >>> 24) & 255),
            (e[60] = (B >>> 0) & 255),
            (e[61] = (B >>> 8) & 255),
            (e[62] = (B >>> 16) & 255),
            (e[63] = (B >>> 24) & 255);
        })(e, t, n, i);
      }
      function w(e, t, n, i) {
        !(function (e, t, n, i) {
          for (
            var a,
              o = (255 & i[0]) | ((255 & i[1]) << 8) | ((255 & i[2]) << 16) | ((255 & i[3]) << 24),
              s = (255 & n[0]) | ((255 & n[1]) << 8) | ((255 & n[2]) << 16) | ((255 & n[3]) << 24),
              l = (255 & n[4]) | ((255 & n[5]) << 8) | ((255 & n[6]) << 16) | ((255 & n[7]) << 24),
              u =
                (255 & n[8]) | ((255 & n[9]) << 8) | ((255 & n[10]) << 16) | ((255 & n[11]) << 24),
              c =
                (255 & n[12]) |
                ((255 & n[13]) << 8) |
                ((255 & n[14]) << 16) |
                ((255 & n[15]) << 24),
              d = (255 & i[4]) | ((255 & i[5]) << 8) | ((255 & i[6]) << 16) | ((255 & i[7]) << 24),
              f = (255 & t[0]) | ((255 & t[1]) << 8) | ((255 & t[2]) << 16) | ((255 & t[3]) << 24),
              h = (255 & t[4]) | ((255 & t[5]) << 8) | ((255 & t[6]) << 16) | ((255 & t[7]) << 24),
              p =
                (255 & t[8]) | ((255 & t[9]) << 8) | ((255 & t[10]) << 16) | ((255 & t[11]) << 24),
              m =
                (255 & t[12]) |
                ((255 & t[13]) << 8) |
                ((255 & t[14]) << 16) |
                ((255 & t[15]) << 24),
              g =
                (255 & i[8]) | ((255 & i[9]) << 8) | ((255 & i[10]) << 16) | ((255 & i[11]) << 24),
              y =
                (255 & n[16]) |
                ((255 & n[17]) << 8) |
                ((255 & n[18]) << 16) |
                ((255 & n[19]) << 24),
              b =
                (255 & n[20]) |
                ((255 & n[21]) << 8) |
                ((255 & n[22]) << 16) |
                ((255 & n[23]) << 24),
              v =
                (255 & n[24]) |
                ((255 & n[25]) << 8) |
                ((255 & n[26]) << 16) |
                ((255 & n[27]) << 24),
              w =
                (255 & n[28]) |
                ((255 & n[29]) << 8) |
                ((255 & n[30]) << 16) |
                ((255 & n[31]) << 24),
              x =
                (255 & i[12]) |
                ((255 & i[13]) << 8) |
                ((255 & i[14]) << 16) |
                ((255 & i[15]) << 24),
              E = o,
              S = s,
              C = l,
              k = u,
              O = c,
              A = d,
              I = f,
              j = h,
              T = p,
              R = m,
              M = g,
              P = y,
              N = b,
              _ = v,
              D = w,
              B = x,
              U = 0;
            U < 20;
            U += 2
          )
            (O ^= ((a = (E + N) | 0) << 7) | (a >>> 25)),
              (T ^= ((a = (O + E) | 0) << 9) | (a >>> 23)),
              (N ^= ((a = (T + O) | 0) << 13) | (a >>> 19)),
              (E ^= ((a = (N + T) | 0) << 18) | (a >>> 14)),
              (R ^= ((a = (A + S) | 0) << 7) | (a >>> 25)),
              (_ ^= ((a = (R + A) | 0) << 9) | (a >>> 23)),
              (S ^= ((a = (_ + R) | 0) << 13) | (a >>> 19)),
              (A ^= ((a = (S + _) | 0) << 18) | (a >>> 14)),
              (D ^= ((a = (M + I) | 0) << 7) | (a >>> 25)),
              (C ^= ((a = (D + M) | 0) << 9) | (a >>> 23)),
              (I ^= ((a = (C + D) | 0) << 13) | (a >>> 19)),
              (M ^= ((a = (I + C) | 0) << 18) | (a >>> 14)),
              (k ^= ((a = (B + P) | 0) << 7) | (a >>> 25)),
              (j ^= ((a = (k + B) | 0) << 9) | (a >>> 23)),
              (P ^= ((a = (j + k) | 0) << 13) | (a >>> 19)),
              (B ^= ((a = (P + j) | 0) << 18) | (a >>> 14)),
              (S ^= ((a = (E + k) | 0) << 7) | (a >>> 25)),
              (C ^= ((a = (S + E) | 0) << 9) | (a >>> 23)),
              (k ^= ((a = (C + S) | 0) << 13) | (a >>> 19)),
              (E ^= ((a = (k + C) | 0) << 18) | (a >>> 14)),
              (I ^= ((a = (A + O) | 0) << 7) | (a >>> 25)),
              (j ^= ((a = (I + A) | 0) << 9) | (a >>> 23)),
              (O ^= ((a = (j + I) | 0) << 13) | (a >>> 19)),
              (A ^= ((a = (O + j) | 0) << 18) | (a >>> 14)),
              (P ^= ((a = (M + R) | 0) << 7) | (a >>> 25)),
              (T ^= ((a = (P + M) | 0) << 9) | (a >>> 23)),
              (R ^= ((a = (T + P) | 0) << 13) | (a >>> 19)),
              (M ^= ((a = (R + T) | 0) << 18) | (a >>> 14)),
              (N ^= ((a = (B + D) | 0) << 7) | (a >>> 25)),
              (_ ^= ((a = (N + B) | 0) << 9) | (a >>> 23)),
              (D ^= ((a = (_ + N) | 0) << 13) | (a >>> 19)),
              (B ^= ((a = (D + _) | 0) << 18) | (a >>> 14));
          (e[0] = (E >>> 0) & 255),
            (e[1] = (E >>> 8) & 255),
            (e[2] = (E >>> 16) & 255),
            (e[3] = (E >>> 24) & 255),
            (e[4] = (A >>> 0) & 255),
            (e[5] = (A >>> 8) & 255),
            (e[6] = (A >>> 16) & 255),
            (e[7] = (A >>> 24) & 255),
            (e[8] = (M >>> 0) & 255),
            (e[9] = (M >>> 8) & 255),
            (e[10] = (M >>> 16) & 255),
            (e[11] = (M >>> 24) & 255),
            (e[12] = (B >>> 0) & 255),
            (e[13] = (B >>> 8) & 255),
            (e[14] = (B >>> 16) & 255),
            (e[15] = (B >>> 24) & 255),
            (e[16] = (I >>> 0) & 255),
            (e[17] = (I >>> 8) & 255),
            (e[18] = (I >>> 16) & 255),
            (e[19] = (I >>> 24) & 255),
            (e[20] = (j >>> 0) & 255),
            (e[21] = (j >>> 8) & 255),
            (e[22] = (j >>> 16) & 255),
            (e[23] = (j >>> 24) & 255),
            (e[24] = (T >>> 0) & 255),
            (e[25] = (T >>> 8) & 255),
            (e[26] = (T >>> 16) & 255),
            (e[27] = (T >>> 24) & 255),
            (e[28] = (R >>> 0) & 255),
            (e[29] = (R >>> 8) & 255),
            (e[30] = (R >>> 16) & 255),
            (e[31] = (R >>> 24) & 255);
        })(e, t, n, i);
      }
      var x = new Uint8Array([
        101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107,
      ]);
      function E(e, t, n, i, a, o, s) {
        var l,
          u,
          c = new Uint8Array(16),
          d = new Uint8Array(64);
        for (u = 0; u < 16; u++) c[u] = 0;
        for (u = 0; u < 8; u++) c[u] = o[u];
        for (; a >= 64; ) {
          for (v(d, c, s, x), u = 0; u < 64; u++) e[t + u] = n[i + u] ^ d[u];
          for (u = 8, l = 1; u < 16; u++)
            (l = (l + (255 & c[u])) | 0), (c[u] = 255 & l), (l >>>= 8);
          (a -= 64), (t += 64), (i += 64);
        }
        if (a > 0) for (v(d, c, s, x), u = 0; u < a; u++) e[t + u] = n[i + u] ^ d[u];
        return 0;
      }
      function S(e, t, n, i, a) {
        var o,
          s,
          l = new Uint8Array(16),
          u = new Uint8Array(64);
        for (s = 0; s < 16; s++) l[s] = 0;
        for (s = 0; s < 8; s++) l[s] = i[s];
        for (; n >= 64; ) {
          for (v(u, l, a, x), s = 0; s < 64; s++) e[t + s] = u[s];
          for (s = 8, o = 1; s < 16; s++)
            (o = (o + (255 & l[s])) | 0), (l[s] = 255 & o), (o >>>= 8);
          (n -= 64), (t += 64);
        }
        if (n > 0) for (v(u, l, a, x), s = 0; s < n; s++) e[t + s] = u[s];
        return 0;
      }
      function C(e, t, n, i, a) {
        var o = new Uint8Array(32);
        w(o, i, a, x);
        for (var s = new Uint8Array(8), l = 0; l < 8; l++) s[l] = i[l + 16];
        return S(e, t, n, s, o);
      }
      function k(e, t, n, i, a, o, s) {
        var l = new Uint8Array(32);
        w(l, o, s, x);
        for (var u = new Uint8Array(8), c = 0; c < 8; c++) u[c] = o[c + 16];
        return E(e, t, n, i, a, u, l);
      }
      var O = function (e) {
        var t, n, i, a, o, s, l, u;
        (this.buffer = new Uint8Array(16)),
          (this.r = new Uint16Array(10)),
          (this.h = new Uint16Array(10)),
          (this.pad = new Uint16Array(8)),
          (this.leftover = 0),
          (this.fin = 0),
          (t = (255 & e[0]) | ((255 & e[1]) << 8)),
          (this.r[0] = 8191 & t),
          (n = (255 & e[2]) | ((255 & e[3]) << 8)),
          (this.r[1] = ((t >>> 13) | (n << 3)) & 8191),
          (i = (255 & e[4]) | ((255 & e[5]) << 8)),
          (this.r[2] = ((n >>> 10) | (i << 6)) & 7939),
          (a = (255 & e[6]) | ((255 & e[7]) << 8)),
          (this.r[3] = ((i >>> 7) | (a << 9)) & 8191),
          (o = (255 & e[8]) | ((255 & e[9]) << 8)),
          (this.r[4] = ((a >>> 4) | (o << 12)) & 255),
          (this.r[5] = (o >>> 1) & 8190),
          (s = (255 & e[10]) | ((255 & e[11]) << 8)),
          (this.r[6] = ((o >>> 14) | (s << 2)) & 8191),
          (l = (255 & e[12]) | ((255 & e[13]) << 8)),
          (this.r[7] = ((s >>> 11) | (l << 5)) & 8065),
          (u = (255 & e[14]) | ((255 & e[15]) << 8)),
          (this.r[8] = ((l >>> 8) | (u << 8)) & 8191),
          (this.r[9] = (u >>> 5) & 127),
          (this.pad[0] = (255 & e[16]) | ((255 & e[17]) << 8)),
          (this.pad[1] = (255 & e[18]) | ((255 & e[19]) << 8)),
          (this.pad[2] = (255 & e[20]) | ((255 & e[21]) << 8)),
          (this.pad[3] = (255 & e[22]) | ((255 & e[23]) << 8)),
          (this.pad[4] = (255 & e[24]) | ((255 & e[25]) << 8)),
          (this.pad[5] = (255 & e[26]) | ((255 & e[27]) << 8)),
          (this.pad[6] = (255 & e[28]) | ((255 & e[29]) << 8)),
          (this.pad[7] = (255 & e[30]) | ((255 & e[31]) << 8));
      };
      function A(e, t, n, i, a, o) {
        var s = new O(o);
        return s.update(n, i, a), s.finish(e, t), 0;
      }
      function I(e, t, n, i, a, o) {
        var s = new Uint8Array(16);
        return A(s, 0, n, i, a, o), y(e, t, s, 0);
      }
      function j(e, t, n, i, a) {
        var o;
        if (n < 32) return -1;
        for (k(e, 0, t, 0, n, i, a), A(e, 16, e, 32, n - 32, e), o = 0; o < 16; o++) e[o] = 0;
        return 0;
      }
      function T(e, t, n, i, a) {
        var o,
          s = new Uint8Array(32);
        if (n < 32 || (C(s, 0, 32, i, a), 0 !== I(t, 16, t, 32, n - 32, s))) return -1;
        for (k(e, 0, t, 0, n, i, a), o = 0; o < 32; o++) e[o] = 0;
        return 0;
      }
      function R(e, t) {
        var n;
        for (n = 0; n < 16; n++) e[n] = 0 | t[n];
      }
      function M(e) {
        var t,
          n,
          i = 1;
        for (t = 0; t < 16; t++)
          (i = Math.floor((n = e[t] + i + 65535) / 65536)), (e[t] = n - 65536 * i);
        e[0] += i - 1 + 37 * (i - 1);
      }
      function P(e, t, n) {
        for (var i, a = ~(n - 1), o = 0; o < 16; o++)
          (i = a & (e[o] ^ t[o])), (e[o] ^= i), (t[o] ^= i);
      }
      function N(e, t) {
        var i,
          a,
          o,
          s = n(),
          l = n();
        for (i = 0; i < 16; i++) l[i] = t[i];
        for (M(l), M(l), M(l), a = 0; a < 2; a++) {
          for (i = 1, s[0] = l[0] - 65517; i < 15; i++)
            (s[i] = l[i] - 65535 - ((s[i - 1] >> 16) & 1)), (s[i - 1] &= 65535);
          (s[15] = l[15] - 32767 - ((s[14] >> 16) & 1)),
            (o = (s[15] >> 16) & 1),
            (s[14] &= 65535),
            P(l, s, 1 - o);
        }
        for (i = 0; i < 16; i++) (e[2 * i] = 255 & l[i]), (e[2 * i + 1] = l[i] >> 8);
      }
      function _(e, t) {
        var n = new Uint8Array(32),
          i = new Uint8Array(32);
        return N(n, e), N(i, t), b(n, 0, i, 0);
      }
      function D(e) {
        var t = new Uint8Array(32);
        return N(t, e), 1 & t[0];
      }
      function B(e, t) {
        var n;
        for (n = 0; n < 16; n++) e[n] = t[2 * n] + (t[2 * n + 1] << 8);
        e[15] &= 32767;
      }
      function U(e, t, n) {
        for (var i = 0; i < 16; i++) e[i] = t[i] + n[i];
      }
      function F(e, t, n) {
        for (var i = 0; i < 16; i++) e[i] = t[i] - n[i];
      }
      function L(e, t, n) {
        var i,
          a,
          o = 0,
          s = 0,
          l = 0,
          u = 0,
          c = 0,
          d = 0,
          f = 0,
          h = 0,
          p = 0,
          m = 0,
          g = 0,
          y = 0,
          b = 0,
          v = 0,
          w = 0,
          x = 0,
          E = 0,
          S = 0,
          C = 0,
          k = 0,
          O = 0,
          A = 0,
          I = 0,
          j = 0,
          T = 0,
          R = 0,
          M = 0,
          P = 0,
          N = 0,
          _ = 0,
          D = 0,
          B = n[0],
          U = n[1],
          F = n[2],
          L = n[3],
          z = n[4],
          V = n[5],
          $ = n[6],
          W = n[7],
          q = n[8],
          K = n[9],
          G = n[10],
          H = n[11],
          Z = n[12],
          Y = n[13],
          Q = n[14],
          X = n[15];
        (o += (i = t[0]) * B),
          (s += i * U),
          (l += i * F),
          (u += i * L),
          (c += i * z),
          (d += i * V),
          (f += i * $),
          (h += i * W),
          (p += i * q),
          (m += i * K),
          (g += i * G),
          (y += i * H),
          (b += i * Z),
          (v += i * Y),
          (w += i * Q),
          (x += i * X),
          (s += (i = t[1]) * B),
          (l += i * U),
          (u += i * F),
          (c += i * L),
          (d += i * z),
          (f += i * V),
          (h += i * $),
          (p += i * W),
          (m += i * q),
          (g += i * K),
          (y += i * G),
          (b += i * H),
          (v += i * Z),
          (w += i * Y),
          (x += i * Q),
          (E += i * X),
          (l += (i = t[2]) * B),
          (u += i * U),
          (c += i * F),
          (d += i * L),
          (f += i * z),
          (h += i * V),
          (p += i * $),
          (m += i * W),
          (g += i * q),
          (y += i * K),
          (b += i * G),
          (v += i * H),
          (w += i * Z),
          (x += i * Y),
          (E += i * Q),
          (S += i * X),
          (u += (i = t[3]) * B),
          (c += i * U),
          (d += i * F),
          (f += i * L),
          (h += i * z),
          (p += i * V),
          (m += i * $),
          (g += i * W),
          (y += i * q),
          (b += i * K),
          (v += i * G),
          (w += i * H),
          (x += i * Z),
          (E += i * Y),
          (S += i * Q),
          (C += i * X),
          (c += (i = t[4]) * B),
          (d += i * U),
          (f += i * F),
          (h += i * L),
          (p += i * z),
          (m += i * V),
          (g += i * $),
          (y += i * W),
          (b += i * q),
          (v += i * K),
          (w += i * G),
          (x += i * H),
          (E += i * Z),
          (S += i * Y),
          (C += i * Q),
          (k += i * X),
          (d += (i = t[5]) * B),
          (f += i * U),
          (h += i * F),
          (p += i * L),
          (m += i * z),
          (g += i * V),
          (y += i * $),
          (b += i * W),
          (v += i * q),
          (w += i * K),
          (x += i * G),
          (E += i * H),
          (S += i * Z),
          (C += i * Y),
          (k += i * Q),
          (O += i * X),
          (f += (i = t[6]) * B),
          (h += i * U),
          (p += i * F),
          (m += i * L),
          (g += i * z),
          (y += i * V),
          (b += i * $),
          (v += i * W),
          (w += i * q),
          (x += i * K),
          (E += i * G),
          (S += i * H),
          (C += i * Z),
          (k += i * Y),
          (O += i * Q),
          (A += i * X),
          (h += (i = t[7]) * B),
          (p += i * U),
          (m += i * F),
          (g += i * L),
          (y += i * z),
          (b += i * V),
          (v += i * $),
          (w += i * W),
          (x += i * q),
          (E += i * K),
          (S += i * G),
          (C += i * H),
          (k += i * Z),
          (O += i * Y),
          (A += i * Q),
          (I += i * X),
          (p += (i = t[8]) * B),
          (m += i * U),
          (g += i * F),
          (y += i * L),
          (b += i * z),
          (v += i * V),
          (w += i * $),
          (x += i * W),
          (E += i * q),
          (S += i * K),
          (C += i * G),
          (k += i * H),
          (O += i * Z),
          (A += i * Y),
          (I += i * Q),
          (j += i * X),
          (m += (i = t[9]) * B),
          (g += i * U),
          (y += i * F),
          (b += i * L),
          (v += i * z),
          (w += i * V),
          (x += i * $),
          (E += i * W),
          (S += i * q),
          (C += i * K),
          (k += i * G),
          (O += i * H),
          (A += i * Z),
          (I += i * Y),
          (j += i * Q),
          (T += i * X),
          (g += (i = t[10]) * B),
          (y += i * U),
          (b += i * F),
          (v += i * L),
          (w += i * z),
          (x += i * V),
          (E += i * $),
          (S += i * W),
          (C += i * q),
          (k += i * K),
          (O += i * G),
          (A += i * H),
          (I += i * Z),
          (j += i * Y),
          (T += i * Q),
          (R += i * X),
          (y += (i = t[11]) * B),
          (b += i * U),
          (v += i * F),
          (w += i * L),
          (x += i * z),
          (E += i * V),
          (S += i * $),
          (C += i * W),
          (k += i * q),
          (O += i * K),
          (A += i * G),
          (I += i * H),
          (j += i * Z),
          (T += i * Y),
          (R += i * Q),
          (M += i * X),
          (b += (i = t[12]) * B),
          (v += i * U),
          (w += i * F),
          (x += i * L),
          (E += i * z),
          (S += i * V),
          (C += i * $),
          (k += i * W),
          (O += i * q),
          (A += i * K),
          (I += i * G),
          (j += i * H),
          (T += i * Z),
          (R += i * Y),
          (M += i * Q),
          (P += i * X),
          (v += (i = t[13]) * B),
          (w += i * U),
          (x += i * F),
          (E += i * L),
          (S += i * z),
          (C += i * V),
          (k += i * $),
          (O += i * W),
          (A += i * q),
          (I += i * K),
          (j += i * G),
          (T += i * H),
          (R += i * Z),
          (M += i * Y),
          (P += i * Q),
          (N += i * X),
          (w += (i = t[14]) * B),
          (x += i * U),
          (E += i * F),
          (S += i * L),
          (C += i * z),
          (k += i * V),
          (O += i * $),
          (A += i * W),
          (I += i * q),
          (j += i * K),
          (T += i * G),
          (R += i * H),
          (M += i * Z),
          (P += i * Y),
          (N += i * Q),
          (_ += i * X),
          (x += (i = t[15]) * B),
          (E += i * U),
          (S += i * F),
          (C += i * L),
          (k += i * z),
          (O += i * V),
          (A += i * $),
          (I += i * W),
          (j += i * q),
          (T += i * K),
          (R += i * G),
          (M += i * H),
          (P += i * Z),
          (N += i * Y),
          (_ += i * Q),
          (D += i * X),
          (o += 38 * E),
          (s += 38 * S),
          (l += 38 * C),
          (u += 38 * k),
          (c += 38 * O),
          (d += 38 * A),
          (f += 38 * I),
          (h += 38 * j),
          (p += 38 * T),
          (m += 38 * R),
          (g += 38 * M),
          (y += 38 * P),
          (b += 38 * N),
          (v += 38 * _),
          (w += 38 * D),
          (a = Math.floor((i = o + (a = 1) + 65535) / 65536)),
          (o = i - 65536 * a),
          (a = Math.floor((i = s + a + 65535) / 65536)),
          (s = i - 65536 * a),
          (a = Math.floor((i = l + a + 65535) / 65536)),
          (l = i - 65536 * a),
          (a = Math.floor((i = u + a + 65535) / 65536)),
          (u = i - 65536 * a),
          (a = Math.floor((i = c + a + 65535) / 65536)),
          (c = i - 65536 * a),
          (a = Math.floor((i = d + a + 65535) / 65536)),
          (d = i - 65536 * a),
          (a = Math.floor((i = f + a + 65535) / 65536)),
          (f = i - 65536 * a),
          (a = Math.floor((i = h + a + 65535) / 65536)),
          (h = i - 65536 * a),
          (a = Math.floor((i = p + a + 65535) / 65536)),
          (p = i - 65536 * a),
          (a = Math.floor((i = m + a + 65535) / 65536)),
          (m = i - 65536 * a),
          (a = Math.floor((i = g + a + 65535) / 65536)),
          (g = i - 65536 * a),
          (a = Math.floor((i = y + a + 65535) / 65536)),
          (y = i - 65536 * a),
          (a = Math.floor((i = b + a + 65535) / 65536)),
          (b = i - 65536 * a),
          (a = Math.floor((i = v + a + 65535) / 65536)),
          (v = i - 65536 * a),
          (a = Math.floor((i = w + a + 65535) / 65536)),
          (w = i - 65536 * a),
          (a = Math.floor((i = x + a + 65535) / 65536)),
          (x = i - 65536 * a),
          (o += a - 1 + 37 * (a - 1)),
          (a = Math.floor((i = o + (a = 1) + 65535) / 65536)),
          (o = i - 65536 * a),
          (a = Math.floor((i = s + a + 65535) / 65536)),
          (s = i - 65536 * a),
          (a = Math.floor((i = l + a + 65535) / 65536)),
          (l = i - 65536 * a),
          (a = Math.floor((i = u + a + 65535) / 65536)),
          (u = i - 65536 * a),
          (a = Math.floor((i = c + a + 65535) / 65536)),
          (c = i - 65536 * a),
          (a = Math.floor((i = d + a + 65535) / 65536)),
          (d = i - 65536 * a),
          (a = Math.floor((i = f + a + 65535) / 65536)),
          (f = i - 65536 * a),
          (a = Math.floor((i = h + a + 65535) / 65536)),
          (h = i - 65536 * a),
          (a = Math.floor((i = p + a + 65535) / 65536)),
          (p = i - 65536 * a),
          (a = Math.floor((i = m + a + 65535) / 65536)),
          (m = i - 65536 * a),
          (a = Math.floor((i = g + a + 65535) / 65536)),
          (g = i - 65536 * a),
          (a = Math.floor((i = y + a + 65535) / 65536)),
          (y = i - 65536 * a),
          (a = Math.floor((i = b + a + 65535) / 65536)),
          (b = i - 65536 * a),
          (a = Math.floor((i = v + a + 65535) / 65536)),
          (v = i - 65536 * a),
          (a = Math.floor((i = w + a + 65535) / 65536)),
          (w = i - 65536 * a),
          (a = Math.floor((i = x + a + 65535) / 65536)),
          (x = i - 65536 * a),
          (o += a - 1 + 37 * (a - 1)),
          (e[0] = o),
          (e[1] = s),
          (e[2] = l),
          (e[3] = u),
          (e[4] = c),
          (e[5] = d),
          (e[6] = f),
          (e[7] = h),
          (e[8] = p),
          (e[9] = m),
          (e[10] = g),
          (e[11] = y),
          (e[12] = b),
          (e[13] = v),
          (e[14] = w),
          (e[15] = x);
      }
      function z(e, t) {
        L(e, t, t);
      }
      function V(e, t) {
        var i,
          a = n();
        for (i = 0; i < 16; i++) a[i] = t[i];
        for (i = 253; i >= 0; i--) z(a, a), 2 !== i && 4 !== i && L(a, a, t);
        for (i = 0; i < 16; i++) e[i] = a[i];
      }
      function $(e, t) {
        var i,
          a = n();
        for (i = 0; i < 16; i++) a[i] = t[i];
        for (i = 250; i >= 0; i--) z(a, a), 1 !== i && L(a, a, t);
        for (i = 0; i < 16; i++) e[i] = a[i];
      }
      function W(e, t, i) {
        var a,
          o,
          s = new Uint8Array(32),
          l = new Float64Array(80),
          c = n(),
          d = n(),
          f = n(),
          h = n(),
          p = n(),
          m = n();
        for (o = 0; o < 31; o++) s[o] = t[o];
        for (s[31] = (127 & t[31]) | 64, s[0] &= 248, B(l, i), o = 0; o < 16; o++)
          (d[o] = l[o]), (h[o] = c[o] = f[o] = 0);
        for (o = 254, c[0] = h[0] = 1; o >= 0; --o)
          P(c, d, (a = (s[o >>> 3] >>> (7 & o)) & 1)),
            P(f, h, a),
            U(p, c, f),
            F(c, c, f),
            U(f, d, h),
            F(d, d, h),
            z(h, p),
            z(m, c),
            L(c, f, c),
            L(f, d, p),
            U(p, c, f),
            F(c, c, f),
            z(d, c),
            F(f, h, m),
            L(c, f, u),
            U(c, c, h),
            L(f, f, c),
            L(c, h, m),
            L(h, d, l),
            z(d, p),
            P(c, d, a),
            P(f, h, a);
        for (o = 0; o < 16; o++)
          (l[o + 16] = c[o]), (l[o + 32] = f[o]), (l[o + 48] = d[o]), (l[o + 64] = h[o]);
        var g = l.subarray(32),
          y = l.subarray(16);
        return V(g, g), L(y, y, g), N(e, y), 0;
      }
      function q(e, t) {
        return W(e, t, o);
      }
      function K(e, t) {
        return i(t, 32), q(e, t);
      }
      function G(e, t, n) {
        var i = new Uint8Array(32);
        return W(i, n, t), w(e, a, i, x);
      }
      (O.prototype.blocks = function (e, t, n) {
        for (
          var i,
            a,
            o,
            s,
            l,
            u,
            c,
            d,
            f,
            h,
            p,
            m,
            g,
            y,
            b,
            v,
            w,
            x,
            E,
            S = 2048 * !this.fin,
            C = this.h[0],
            k = this.h[1],
            O = this.h[2],
            A = this.h[3],
            I = this.h[4],
            j = this.h[5],
            T = this.h[6],
            R = this.h[7],
            M = this.h[8],
            P = this.h[9],
            N = this.r[0],
            _ = this.r[1],
            D = this.r[2],
            B = this.r[3],
            U = this.r[4],
            F = this.r[5],
            L = this.r[6],
            z = this.r[7],
            V = this.r[8],
            $ = this.r[9];
          n >= 16;

        )
          (C += 8191 & (i = (255 & e[t + 0]) | ((255 & e[t + 1]) << 8))),
            (k += ((i >>> 13) | ((a = (255 & e[t + 2]) | ((255 & e[t + 3]) << 8)) << 3)) & 8191),
            (O += ((a >>> 10) | ((o = (255 & e[t + 4]) | ((255 & e[t + 5]) << 8)) << 6)) & 8191),
            (A += ((o >>> 7) | ((s = (255 & e[t + 6]) | ((255 & e[t + 7]) << 8)) << 9)) & 8191),
            (I += ((s >>> 4) | ((l = (255 & e[t + 8]) | ((255 & e[t + 9]) << 8)) << 12)) & 8191),
            (j += (l >>> 1) & 8191),
            (T += ((l >>> 14) | ((u = (255 & e[t + 10]) | ((255 & e[t + 11]) << 8)) << 2)) & 8191),
            (R += ((u >>> 11) | ((c = (255 & e[t + 12]) | ((255 & e[t + 13]) << 8)) << 5)) & 8191),
            (M += ((c >>> 8) | ((d = (255 & e[t + 14]) | ((255 & e[t + 15]) << 8)) << 8)) & 8191),
            (P += (d >>> 5) | S),
            (f = (h = (f = 0) + C * N + 5 * $ * k + 5 * V * O + 5 * z * A + 5 * L * I) >>> 13),
            (h &= 8191),
            (h += 5 * F * j),
            (h += 5 * U * T),
            (h += 5 * B * R),
            (h += 5 * D * M),
            (h += 5 * _ * P),
            (f += h >>> 13),
            (h &= 8191),
            (f = (p = f + C * _ + k * N + 5 * $ * O + 5 * V * A + 5 * z * I) >>> 13),
            (p &= 8191),
            (p += 5 * L * j),
            (p += 5 * F * T),
            (p += 5 * U * R),
            (p += 5 * B * M),
            (p += 5 * D * P),
            (f += p >>> 13),
            (p &= 8191),
            (f = (m = f + C * D + k * _ + O * N + 5 * $ * A + 5 * V * I) >>> 13),
            (m &= 8191),
            (m += 5 * z * j),
            (m += 5 * L * T),
            (m += 5 * F * R),
            (m += 5 * U * M),
            (m += 5 * B * P),
            (f += m >>> 13),
            (m &= 8191),
            (f = (g = f + C * B + k * D + O * _ + A * N + 5 * $ * I) >>> 13),
            (g &= 8191),
            (g += 5 * V * j),
            (g += 5 * z * T),
            (g += 5 * L * R),
            (g += 5 * F * M),
            (g += 5 * U * P),
            (f += g >>> 13),
            (g &= 8191),
            (f = (y = f + C * U + k * B + O * D + A * _ + I * N) >>> 13),
            (y &= 8191),
            (y += 5 * $ * j),
            (y += 5 * V * T),
            (y += 5 * z * R),
            (y += 5 * L * M),
            (y += 5 * F * P),
            (f += y >>> 13),
            (y &= 8191),
            (f = (b = f + C * F + k * U + O * B + A * D + I * _) >>> 13),
            (b &= 8191),
            (b += j * N),
            (b += 5 * $ * T),
            (b += 5 * V * R),
            (b += 5 * z * M),
            (b += 5 * L * P),
            (f += b >>> 13),
            (b &= 8191),
            (f = (v = f + C * L + k * F + O * U + A * B + I * D) >>> 13),
            (v &= 8191),
            (v += j * _),
            (v += T * N),
            (v += 5 * $ * R),
            (v += 5 * V * M),
            (v += 5 * z * P),
            (f += v >>> 13),
            (v &= 8191),
            (f = (w = f + C * z + k * L + O * F + A * U + I * B) >>> 13),
            (w &= 8191),
            (w += j * D),
            (w += T * _),
            (w += R * N),
            (w += 5 * $ * M),
            (w += 5 * V * P),
            (f += w >>> 13),
            (w &= 8191),
            (f = (x = f + C * V + k * z + O * L + A * F + I * U) >>> 13),
            (x &= 8191),
            (x += j * B),
            (x += T * D),
            (x += R * _),
            (x += M * N),
            (x += 5 * $ * P),
            (f += x >>> 13),
            (x &= 8191),
            (f = (E = f + C * $ + k * V + O * z + A * L + I * F) >>> 13),
            (E &= 8191),
            (E += j * U),
            (E += T * B),
            (E += R * D),
            (E += M * _),
            (E += P * N),
            (f += E >>> 13),
            (E &= 8191),
            (h = 8191 & (f = ((f = ((f << 2) + f) | 0) + h) | 0)),
            (f >>>= 13),
            (p += f),
            (C = h),
            (k = p),
            (O = m),
            (A = g),
            (I = y),
            (j = b),
            (T = v),
            (R = w),
            (M = x),
            (P = E),
            (t += 16),
            (n -= 16);
        (this.h[0] = C),
          (this.h[1] = k),
          (this.h[2] = O),
          (this.h[3] = A),
          (this.h[4] = I),
          (this.h[5] = j),
          (this.h[6] = T),
          (this.h[7] = R),
          (this.h[8] = M),
          (this.h[9] = P);
      }),
        (O.prototype.finish = function (e, t) {
          var n,
            i,
            a,
            o,
            s = new Uint16Array(10);
          if (this.leftover) {
            for (o = this.leftover, this.buffer[o++] = 1; o < 16; o++) this.buffer[o] = 0;
            (this.fin = 1), this.blocks(this.buffer, 0, 16);
          }
          for (n = this.h[1] >>> 13, this.h[1] &= 8191, o = 2; o < 10; o++)
            (this.h[o] += n), (n = this.h[o] >>> 13), (this.h[o] &= 8191);
          for (
            this.h[0] += 5 * n,
              n = this.h[0] >>> 13,
              this.h[0] &= 8191,
              this.h[1] += n,
              n = this.h[1] >>> 13,
              this.h[1] &= 8191,
              this.h[2] += n,
              s[0] = this.h[0] + 5,
              n = s[0] >>> 13,
              s[0] &= 8191,
              o = 1;
            o < 10;
            o++
          )
            (s[o] = this.h[o] + n), (n = s[o] >>> 13), (s[o] &= 8191);
          for (s[9] -= 8192, i = (1 ^ n) - 1, o = 0; o < 10; o++) s[o] &= i;
          for (o = 0, i = ~i; o < 10; o++) this.h[o] = (this.h[o] & i) | s[o];
          for (
            o = 1,
              this.h[0] = (this.h[0] | (this.h[1] << 13)) & 65535,
              this.h[1] = ((this.h[1] >>> 3) | (this.h[2] << 10)) & 65535,
              this.h[2] = ((this.h[2] >>> 6) | (this.h[3] << 7)) & 65535,
              this.h[3] = ((this.h[3] >>> 9) | (this.h[4] << 4)) & 65535,
              this.h[4] = ((this.h[4] >>> 12) | (this.h[5] << 1) | (this.h[6] << 14)) & 65535,
              this.h[5] = ((this.h[6] >>> 2) | (this.h[7] << 11)) & 65535,
              this.h[6] = ((this.h[7] >>> 5) | (this.h[8] << 8)) & 65535,
              this.h[7] = ((this.h[8] >>> 8) | (this.h[9] << 5)) & 65535,
              a = this.h[0] + this.pad[0],
              this.h[0] = 65535 & a;
            o < 8;
            o++
          )
            (a = (((this.h[o] + this.pad[o]) | 0) + (a >>> 16)) | 0), (this.h[o] = 65535 & a);
          (e[t + 0] = (this.h[0] >>> 0) & 255),
            (e[t + 1] = (this.h[0] >>> 8) & 255),
            (e[t + 2] = (this.h[1] >>> 0) & 255),
            (e[t + 3] = (this.h[1] >>> 8) & 255),
            (e[t + 4] = (this.h[2] >>> 0) & 255),
            (e[t + 5] = (this.h[2] >>> 8) & 255),
            (e[t + 6] = (this.h[3] >>> 0) & 255),
            (e[t + 7] = (this.h[3] >>> 8) & 255),
            (e[t + 8] = (this.h[4] >>> 0) & 255),
            (e[t + 9] = (this.h[4] >>> 8) & 255),
            (e[t + 10] = (this.h[5] >>> 0) & 255),
            (e[t + 11] = (this.h[5] >>> 8) & 255),
            (e[t + 12] = (this.h[6] >>> 0) & 255),
            (e[t + 13] = (this.h[6] >>> 8) & 255),
            (e[t + 14] = (this.h[7] >>> 0) & 255),
            (e[t + 15] = (this.h[7] >>> 8) & 255);
        }),
        (O.prototype.update = function (e, t, n) {
          var i, a;
          if (this.leftover) {
            for ((a = 16 - this.leftover) > n && (a = n), i = 0; i < a; i++)
              this.buffer[this.leftover + i] = e[t + i];
            if (((n -= a), (t += a), (this.leftover += a), this.leftover < 16)) return;
            this.blocks(this.buffer, 0, 16), (this.leftover = 0);
          }
          if ((n >= 16 && ((a = n - (n % 16)), this.blocks(e, t, a), (t += a), (n -= a)), n)) {
            for (i = 0; i < n; i++) this.buffer[this.leftover + i] = e[t + i];
            this.leftover += n;
          }
        });
      var H = [
        0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd, 0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5,
        0x8189dbbc, 0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019, 0x923f82a4, 0xaf194f9b,
        0xab1c5ed5, 0xda6d8118, 0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe, 0x243185be,
        0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2, 0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,
        0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694, 0xe49b69c1, 0x9ef14ad2, 0xefbe4786,
        0x384f25e3, 0xfc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65, 0x2de92c6f, 0x592b0275,
        0x4a7484aa, 0x6ea6e483, 0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5, 0x983e5152,
        0xee66dfab, 0xa831c66d, 0x2db43210, 0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,
        0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725, 0x6ca6351, 0xe003826f, 0x14292967,
        0xa0e6e70, 0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926, 0x4d2c6dfc, 0x5ac42aed,
        0x53380d13, 0x9d95b3df, 0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8, 0x81c2c92e,
        0x47edaee6, 0x92722c85, 0x1482353b, 0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,
        0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x654be30, 0xd192e819, 0xd6ef5218, 0xd6990624,
        0x5565a910, 0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8, 0x19a4c116, 0xb8d2d0c8,
        0x1e376c08, 0x5141ab53, 0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8, 0x391c0cb3,
        0xc5c95a63, 0x4ed8aa4a, 0xe3418acb, 0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,
        0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60, 0x84c87814, 0xa1f0ab72, 0x8cc70208,
        0x1a6439ec, 0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9, 0xbef9a3f7, 0xb2c67915,
        0xc67178f2, 0xe372532b, 0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207, 0xeada7dd6,
        0xcde0eb1e, 0xf57d4f7f, 0xee6ed178, 0x6f067aa, 0x72176fba, 0xa637dc5, 0xa2c898a6,
        0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b, 0x28db77f5, 0x23047d84, 0x32caab7b,
        0x40c72493, 0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c, 0x4cc5d4be, 0xcb3e42b6,
        0x597f299c, 0xfc657e2a, 0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817,
      ];
      function Z(e, t, n, i) {
        for (
          var a,
            o,
            s,
            l,
            u,
            c,
            d,
            f,
            h,
            p,
            m,
            g,
            y,
            b,
            v,
            w,
            x,
            E,
            S,
            C,
            k,
            O,
            A,
            I,
            j,
            T,
            R = new Int32Array(16),
            M = new Int32Array(16),
            P = e[0],
            N = e[1],
            _ = e[2],
            D = e[3],
            B = e[4],
            U = e[5],
            F = e[6],
            L = e[7],
            z = t[0],
            V = t[1],
            $ = t[2],
            W = t[3],
            q = t[4],
            K = t[5],
            G = t[6],
            Z = t[7],
            Y = 0;
          i >= 128;

        ) {
          for (S = 0; S < 16; S++)
            (C = 8 * S + Y),
              (R[S] = (n[C + 0] << 24) | (n[C + 1] << 16) | (n[C + 2] << 8) | n[C + 3]),
              (M[S] = (n[C + 4] << 24) | (n[C + 5] << 16) | (n[C + 6] << 8) | n[C + 7]);
          for (S = 0; S < 80; S++)
            if (
              ((a = P),
              (o = N),
              (s = _),
              (l = D),
              (u = B),
              (c = U),
              (d = F),
              (f = L),
              (h = z),
              (p = V),
              (m = $),
              (g = W),
              (y = q),
              (b = K),
              (v = G),
              (w = Z),
              (k = L),
              (A = 65535 & (O = Z)),
              (I = O >>> 16),
              (j = 65535 & k),
              (T = k >>> 16),
              (k = ((B >>> 14) | (q << 18)) ^ ((B >>> 18) | (q << 14)) ^ ((q >>> 9) | (B << 23))),
              (A +=
                65535 &
                (O =
                  ((q >>> 14) | (B << 18)) ^ ((q >>> 18) | (B << 14)) ^ ((B >>> 9) | (q << 23)))),
              (I += O >>> 16),
              (j += 65535 & k),
              (T += k >>> 16),
              (k = (B & U) ^ (~B & F)),
              (A += 65535 & (O = (q & K) ^ (~q & G))),
              (I += O >>> 16),
              (j += 65535 & k),
              (T += k >>> 16),
              (k = H[2 * S]),
              (A += 65535 & (O = H[2 * S + 1])),
              (I += O >>> 16),
              (j += 65535 & k),
              (T += k >>> 16),
              (k = R[S % 16]),
              (A += 65535 & (O = M[S % 16])),
              (I += O >>> 16),
              (j += 65535 & k),
              (T += k >>> 16),
              (I += A >>> 16),
              (j += I >>> 16),
              (T += j >>> 16),
              (x = (65535 & j) | (T << 16)),
              (E = (65535 & A) | (I << 16)),
              (k = x),
              (A = 65535 & (O = E)),
              (I = O >>> 16),
              (j = 65535 & k),
              (T = k >>> 16),
              (k = ((P >>> 28) | (z << 4)) ^ ((z >>> 2) | (P << 30)) ^ ((z >>> 7) | (P << 25))),
              (A +=
                65535 &
                (O = ((z >>> 28) | (P << 4)) ^ ((P >>> 2) | (z << 30)) ^ ((P >>> 7) | (z << 25)))),
              (I += O >>> 16),
              (j += 65535 & k),
              (T += k >>> 16),
              (k = (P & N) ^ (P & _) ^ (N & _)),
              (A += 65535 & (O = (z & V) ^ (z & $) ^ (V & $))),
              (I += O >>> 16),
              (j += 65535 & k),
              (T += k >>> 16),
              (I += A >>> 16),
              (j += I >>> 16),
              (T += j >>> 16),
              (f = (65535 & j) | (T << 16)),
              (w = (65535 & A) | (I << 16)),
              (k = l),
              (A = 65535 & (O = g)),
              (I = O >>> 16),
              (j = 65535 & k),
              (T = k >>> 16),
              (k = x),
              (A += 65535 & (O = E)),
              (I += O >>> 16),
              (j += 65535 & k),
              (T += k >>> 16),
              (I += A >>> 16),
              (j += I >>> 16),
              (T += j >>> 16),
              (l = (65535 & j) | (T << 16)),
              (g = (65535 & A) | (I << 16)),
              (N = a),
              (_ = o),
              (D = s),
              (B = l),
              (U = u),
              (F = c),
              (L = d),
              (P = f),
              (V = h),
              ($ = p),
              (W = m),
              (q = g),
              (K = y),
              (G = b),
              (Z = v),
              (z = w),
              S % 16 == 15)
            )
              for (C = 0; C < 16; C++)
                (k = R[C]),
                  (A = 65535 & (O = M[C])),
                  (I = O >>> 16),
                  (j = 65535 & k),
                  (T = k >>> 16),
                  (k = R[(C + 9) % 16]),
                  (A += 65535 & (O = M[(C + 9) % 16])),
                  (I += O >>> 16),
                  (j += 65535 & k),
                  (T += k >>> 16),
                  (k =
                    (((x = R[(C + 1) % 16]) >>> 1) | ((E = M[(C + 1) % 16]) << 31)) ^
                    ((x >>> 8) | (E << 24)) ^
                    (x >>> 7)),
                  (A +=
                    65535 &
                    (O =
                      ((E >>> 1) | (x << 31)) ^ ((E >>> 8) | (x << 24)) ^ ((E >>> 7) | (x << 25)))),
                  (I += O >>> 16),
                  (j += 65535 & k),
                  (T += k >>> 16),
                  (k =
                    (((x = R[(C + 14) % 16]) >>> 19) | ((E = M[(C + 14) % 16]) << 13)) ^
                    ((E >>> 29) | (x << 3)) ^
                    (x >>> 6)),
                  (A +=
                    65535 &
                    (O =
                      ((E >>> 19) | (x << 13)) ^
                      ((x >>> 29) | (E << 3)) ^
                      ((E >>> 6) | (x << 26)))),
                  (I += O >>> 16),
                  (j += 65535 & k),
                  (T += k >>> 16),
                  (I += A >>> 16),
                  (j += I >>> 16),
                  (T += j >>> 16),
                  (R[C] = (65535 & j) | (T << 16)),
                  (M[C] = (65535 & A) | (I << 16));
          (k = P),
            (A = 65535 & (O = z)),
            (I = O >>> 16),
            (j = 65535 & k),
            (T = k >>> 16),
            (k = e[0]),
            (A += 65535 & (O = t[0])),
            (I += O >>> 16),
            (j += 65535 & k),
            (T += k >>> 16),
            (I += A >>> 16),
            (j += I >>> 16),
            (T += j >>> 16),
            (e[0] = P = (65535 & j) | (T << 16)),
            (t[0] = z = (65535 & A) | (I << 16)),
            (k = N),
            (A = 65535 & (O = V)),
            (I = O >>> 16),
            (j = 65535 & k),
            (T = k >>> 16),
            (k = e[1]),
            (A += 65535 & (O = t[1])),
            (I += O >>> 16),
            (j += 65535 & k),
            (T += k >>> 16),
            (I += A >>> 16),
            (j += I >>> 16),
            (T += j >>> 16),
            (e[1] = N = (65535 & j) | (T << 16)),
            (t[1] = V = (65535 & A) | (I << 16)),
            (k = _),
            (A = 65535 & (O = $)),
            (I = O >>> 16),
            (j = 65535 & k),
            (T = k >>> 16),
            (k = e[2]),
            (A += 65535 & (O = t[2])),
            (I += O >>> 16),
            (j += 65535 & k),
            (T += k >>> 16),
            (I += A >>> 16),
            (j += I >>> 16),
            (T += j >>> 16),
            (e[2] = _ = (65535 & j) | (T << 16)),
            (t[2] = $ = (65535 & A) | (I << 16)),
            (k = D),
            (A = 65535 & (O = W)),
            (I = O >>> 16),
            (j = 65535 & k),
            (T = k >>> 16),
            (k = e[3]),
            (A += 65535 & (O = t[3])),
            (I += O >>> 16),
            (j += 65535 & k),
            (T += k >>> 16),
            (I += A >>> 16),
            (j += I >>> 16),
            (T += j >>> 16),
            (e[3] = D = (65535 & j) | (T << 16)),
            (t[3] = W = (65535 & A) | (I << 16)),
            (k = B),
            (A = 65535 & (O = q)),
            (I = O >>> 16),
            (j = 65535 & k),
            (T = k >>> 16),
            (k = e[4]),
            (A += 65535 & (O = t[4])),
            (I += O >>> 16),
            (j += 65535 & k),
            (T += k >>> 16),
            (I += A >>> 16),
            (j += I >>> 16),
            (T += j >>> 16),
            (e[4] = B = (65535 & j) | (T << 16)),
            (t[4] = q = (65535 & A) | (I << 16)),
            (k = U),
            (A = 65535 & (O = K)),
            (I = O >>> 16),
            (j = 65535 & k),
            (T = k >>> 16),
            (k = e[5]),
            (A += 65535 & (O = t[5])),
            (I += O >>> 16),
            (j += 65535 & k),
            (T += k >>> 16),
            (I += A >>> 16),
            (j += I >>> 16),
            (T += j >>> 16),
            (e[5] = U = (65535 & j) | (T << 16)),
            (t[5] = K = (65535 & A) | (I << 16)),
            (k = F),
            (A = 65535 & (O = G)),
            (I = O >>> 16),
            (j = 65535 & k),
            (T = k >>> 16),
            (k = e[6]),
            (A += 65535 & (O = t[6])),
            (I += O >>> 16),
            (j += 65535 & k),
            (T += k >>> 16),
            (I += A >>> 16),
            (j += I >>> 16),
            (T += j >>> 16),
            (e[6] = F = (65535 & j) | (T << 16)),
            (t[6] = G = (65535 & A) | (I << 16)),
            (k = L),
            (A = 65535 & (O = Z)),
            (I = O >>> 16),
            (j = 65535 & k),
            (T = k >>> 16),
            (k = e[7]),
            (A += 65535 & (O = t[7])),
            (I += O >>> 16),
            (j += 65535 & k),
            (T += k >>> 16),
            (I += A >>> 16),
            (j += I >>> 16),
            (T += j >>> 16),
            (e[7] = L = (65535 & j) | (T << 16)),
            (t[7] = Z = (65535 & A) | (I << 16)),
            (Y += 128),
            (i -= 128);
        }
        return i;
      }
      function Y(e, t, n) {
        var i,
          a = new Int32Array(8),
          o = new Int32Array(8),
          s = new Uint8Array(256),
          l = n;
        for (
          a[0] = 0x6a09e667,
            a[1] = 0xbb67ae85,
            a[2] = 0x3c6ef372,
            a[3] = 0xa54ff53a,
            a[4] = 0x510e527f,
            a[5] = 0x9b05688c,
            a[6] = 0x1f83d9ab,
            a[7] = 0x5be0cd19,
            o[0] = 0xf3bcc908,
            o[1] = 0x84caa73b,
            o[2] = 0xfe94f82b,
            o[3] = 0x5f1d36f1,
            o[4] = 0xade682d1,
            o[5] = 0x2b3e6c1f,
            o[6] = 0xfb41bd6b,
            o[7] = 0x137e2179,
            Z(a, o, t, n),
            n %= 128,
            i = 0;
          i < n;
          i++
        )
          s[i] = t[l - n + i];
        for (
          s[n] = 128,
            s[(n = 256 - (n < 112) * 128) - 9] = 0,
            m(s, n - 8, (l / 0x20000000) | 0, l << 3),
            Z(a, o, s, n),
            i = 0;
          i < 8;
          i++
        )
          m(e, 8 * i, a[i], o[i]);
        return 0;
      }
      function Q(e, t) {
        var i = n(),
          a = n(),
          o = n(),
          s = n(),
          l = n(),
          u = n(),
          c = n(),
          f = n(),
          h = n();
        F(i, e[1], e[0]),
          F(h, t[1], t[0]),
          L(i, i, h),
          U(a, e[0], e[1]),
          U(h, t[0], t[1]),
          L(a, a, h),
          L(o, e[3], t[3]),
          L(o, o, d),
          L(s, e[2], t[2]),
          U(s, s, s),
          F(l, a, i),
          F(u, s, o),
          U(c, s, o),
          U(f, a, i),
          L(e[0], l, u),
          L(e[1], f, c),
          L(e[2], c, u),
          L(e[3], l, f);
      }
      function X(e, t, n) {
        var i;
        for (i = 0; i < 4; i++) P(e[i], t[i], n);
      }
      function J(e, t) {
        var i = n(),
          a = n(),
          o = n();
        V(o, t[2]), L(i, t[0], o), L(a, t[1], o), N(e, a), (e[31] ^= D(i) << 7);
      }
      function ee(e, t, n) {
        var i, a;
        for (R(e[0], s), R(e[1], l), R(e[2], l), R(e[3], s), a = 255; a >= 0; --a)
          X(e, t, (i = (n[(a / 8) | 0] >> (7 & a)) & 1)), Q(t, e), Q(e, e), X(e, t, i);
      }
      function et(e, t) {
        var i = [n(), n(), n(), n()];
        R(i[0], f), R(i[1], h), R(i[2], l), L(i[3], f, h), ee(e, i, t);
      }
      function er(e, t, a) {
        var o,
          s = new Uint8Array(64),
          l = [n(), n(), n(), n()];
        for (
          a || i(t, 32),
            Y(s, t, 32),
            s[0] &= 248,
            s[31] &= 127,
            s[31] |= 64,
            et(l, s),
            J(e, l),
            o = 0;
          o < 32;
          o++
        )
          t[o + 32] = e[o];
        return 0;
      }
      var en = new Float64Array([
        237, 211, 245, 92, 26, 99, 18, 88, 214, 156, 247, 162, 222, 249, 222, 20, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 16,
      ]);
      function ei(e, t) {
        var n, i, a, o;
        for (i = 63; i >= 32; --i) {
          for (n = 0, a = i - 32, o = i - 12; a < o; ++a)
            (t[a] += n - 16 * t[i] * en[a - (i - 32)]),
              (n = Math.floor((t[a] + 128) / 256)),
              (t[a] -= 256 * n);
          (t[a] += n), (t[i] = 0);
        }
        for (a = 0, n = 0; a < 32; a++)
          (t[a] += n - (t[31] >> 4) * en[a]), (n = t[a] >> 8), (t[a] &= 255);
        for (a = 0; a < 32; a++) t[a] -= n * en[a];
        for (i = 0; i < 32; i++) (t[i + 1] += t[i] >> 8), (e[i] = 255 & t[i]);
      }
      function ea(e) {
        var t,
          n = new Float64Array(64);
        for (t = 0; t < 64; t++) n[t] = e[t];
        for (t = 0; t < 64; t++) e[t] = 0;
        ei(e, n);
      }
      function eo(e, t, i, a) {
        var o,
          s,
          l = new Uint8Array(64),
          u = new Uint8Array(64),
          c = new Uint8Array(64),
          d = new Float64Array(64),
          f = [n(), n(), n(), n()];
        for (Y(l, a, 32), l[0] &= 248, l[31] &= 127, l[31] |= 64, o = 0; o < i; o++)
          e[64 + o] = t[o];
        for (o = 0; o < 32; o++) e[32 + o] = l[32 + o];
        for (Y(c, e.subarray(32), i + 32), ea(c), et(f, c), J(e, f), o = 32; o < 64; o++)
          e[o] = a[o];
        for (Y(u, e, i + 64), ea(u), o = 0; o < 64; o++) d[o] = 0;
        for (o = 0; o < 32; o++) d[o] = c[o];
        for (o = 0; o < 32; o++) for (s = 0; s < 32; s++) d[o + s] += u[o] * l[s];
        return ei(e.subarray(32), d), i + 64;
      }
      function es(e, t, i, a) {
        var o,
          u,
          d,
          f,
          h,
          m,
          g,
          y,
          v = new Uint8Array(32),
          w = new Uint8Array(64),
          x = [n(), n(), n(), n()],
          E = [n(), n(), n(), n()];
        if (
          i < 64 ||
          ((o = n()),
          (u = n()),
          (d = n()),
          (f = n()),
          (h = n()),
          (m = n()),
          (g = n()),
          (R(E[2], l),
          B(E[1], a),
          z(d, E[1]),
          L(f, d, c),
          F(d, d, E[2]),
          U(f, E[2], f),
          z(h, f),
          z(m, h),
          L(g, m, h),
          L(o, g, d),
          L(o, o, f),
          $(o, o),
          L(o, o, d),
          L(o, o, f),
          L(o, o, f),
          L(E[0], o, f),
          z(u, E[0]),
          L(u, u, f),
          _(u, d) && L(E[0], E[0], p),
          z(u, E[0]),
          L(u, u, f),
          _(u, d))
            ? -1
            : (D(E[0]) === a[31] >> 7 && F(E[0], s, E[0]), L(E[3], E[0], E[1]), 0))
        )
          return -1;
        for (y = 0; y < i; y++) e[y] = t[y];
        for (y = 0; y < 32; y++) e[y + 32] = a[y];
        if (
          (Y(w, e, i),
          ea(w),
          ee(x, E, w),
          et(E, t.subarray(32)),
          Q(x, E),
          J(v, x),
          (i -= 64),
          b(t, 0, v, 0))
        ) {
          for (y = 0; y < i; y++) e[y] = 0;
          return -1;
        }
        for (y = 0; y < i; y++) e[y] = t[y + 64];
        return i;
      }
      function el(e, t) {
        if (32 !== e.length) throw Error('bad key size');
        if (24 !== t.length) throw Error('bad nonce size');
      }
      function eu() {
        for (var e = 0; e < arguments.length; e++)
          if (!(arguments[e] instanceof Uint8Array))
            throw TypeError('unexpected type, use Uint8Array');
      }
      function ec(e) {
        for (var t = 0; t < e.length; t++) e[t] = 0;
      }
      (e.lowlevel = {
        crypto_core_hsalsa20: w,
        crypto_stream_xor: k,
        crypto_stream: C,
        crypto_stream_salsa20_xor: E,
        crypto_stream_salsa20: S,
        crypto_onetimeauth: A,
        crypto_onetimeauth_verify: I,
        crypto_verify_16: y,
        crypto_verify_32: b,
        crypto_secretbox: j,
        crypto_secretbox_open: T,
        crypto_scalarmult: W,
        crypto_scalarmult_base: q,
        crypto_box_beforenm: G,
        crypto_box_afternm: j,
        crypto_box: function (e, t, n, i, a, o) {
          var s = new Uint8Array(32);
          return G(s, a, o), j(e, t, n, i, s);
        },
        crypto_box_open: function (e, t, n, i, a, o) {
          var s = new Uint8Array(32);
          return G(s, a, o), T(e, t, n, i, s);
        },
        crypto_box_keypair: K,
        crypto_hash: Y,
        crypto_sign: eo,
        crypto_sign_keypair: er,
        crypto_sign_open: es,
        crypto_secretbox_KEYBYTES: 32,
        crypto_secretbox_NONCEBYTES: 24,
        crypto_secretbox_ZEROBYTES: 32,
        crypto_secretbox_BOXZEROBYTES: 16,
        crypto_scalarmult_BYTES: 32,
        crypto_scalarmult_SCALARBYTES: 32,
        crypto_box_PUBLICKEYBYTES: 32,
        crypto_box_SECRETKEYBYTES: 32,
        crypto_box_BEFORENMBYTES: 32,
        crypto_box_NONCEBYTES: 24,
        crypto_box_ZEROBYTES: 32,
        crypto_box_BOXZEROBYTES: 16,
        crypto_sign_BYTES: 64,
        crypto_sign_PUBLICKEYBYTES: 32,
        crypto_sign_SECRETKEYBYTES: 64,
        crypto_sign_SEEDBYTES: 32,
        crypto_hash_BYTES: 64,
        gf: n,
        D: c,
        L: en,
        pack25519: N,
        unpack25519: B,
        M: L,
        A: U,
        S: z,
        Z: F,
        pow2523: $,
        add: Q,
        set25519: R,
        modL: ei,
        scalarmult: ee,
        scalarbase: et,
      }),
        (e.randomBytes = function (e) {
          var t = new Uint8Array(e);
          return i(t, e), t;
        }),
        (e.secretbox = function (e, t, n) {
          eu(e, t, n), el(n, t);
          for (
            var i = new Uint8Array(32 + e.length), a = new Uint8Array(i.length), o = 0;
            o < e.length;
            o++
          )
            i[o + 32] = e[o];
          return j(a, i, i.length, t, n), a.subarray(16);
        }),
        (e.secretbox.open = function (e, t, n) {
          eu(e, t, n), el(n, t);
          for (
            var i = new Uint8Array(16 + e.length), a = new Uint8Array(i.length), o = 0;
            o < e.length;
            o++
          )
            i[o + 16] = e[o];
          return i.length < 32 || 0 !== T(a, i, i.length, t, n) ? null : a.subarray(32);
        }),
        (e.secretbox.keyLength = 32),
        (e.secretbox.nonceLength = 24),
        (e.secretbox.overheadLength = 16),
        (e.scalarMult = function (e, t) {
          if ((eu(e, t), 32 !== e.length)) throw Error('bad n size');
          if (32 !== t.length) throw Error('bad p size');
          var n = new Uint8Array(32);
          return W(n, e, t), n;
        }),
        (e.scalarMult.base = function (e) {
          if ((eu(e), 32 !== e.length)) throw Error('bad n size');
          var t = new Uint8Array(32);
          return q(t, e), t;
        }),
        (e.scalarMult.scalarLength = 32),
        (e.scalarMult.groupElementLength = 32),
        (e.box = function (t, n, i, a) {
          var o = e.box.before(i, a);
          return e.secretbox(t, n, o);
        }),
        (e.box.before = function (e, t) {
          eu(e, t);
          if (32 !== e.length) throw Error('bad public key size');
          if (32 !== t.length) throw Error('bad secret key size');
          var n = new Uint8Array(32);
          return G(n, e, t), n;
        }),
        (e.box.after = e.secretbox),
        (e.box.open = function (t, n, i, a) {
          var o = e.box.before(i, a);
          return e.secretbox.open(t, n, o);
        }),
        (e.box.open.after = e.secretbox.open),
        (e.box.keyPair = function () {
          var e = new Uint8Array(32),
            t = new Uint8Array(32);
          return K(e, t), { publicKey: e, secretKey: t };
        }),
        (e.box.keyPair.fromSecretKey = function (e) {
          if ((eu(e), 32 !== e.length)) throw Error('bad secret key size');
          var t = new Uint8Array(32);
          return q(t, e), { publicKey: t, secretKey: new Uint8Array(e) };
        }),
        (e.box.publicKeyLength = 32),
        (e.box.secretKeyLength = 32),
        (e.box.sharedKeyLength = 32),
        (e.box.nonceLength = 24),
        (e.box.overheadLength = e.secretbox.overheadLength),
        (e.sign = function (e, t) {
          if ((eu(e, t), 64 !== t.length)) throw Error('bad secret key size');
          var n = new Uint8Array(64 + e.length);
          return eo(n, e, e.length, t), n;
        }),
        (e.sign.open = function (e, t) {
          if ((eu(e, t), 32 !== t.length)) throw Error('bad public key size');
          var n = new Uint8Array(e.length),
            i = es(n, e, e.length, t);
          if (i < 0) return null;
          for (var a = new Uint8Array(i), o = 0; o < a.length; o++) a[o] = n[o];
          return a;
        }),
        (e.sign.detached = function (t, n) {
          for (var i = e.sign(t, n), a = new Uint8Array(64), o = 0; o < a.length; o++) a[o] = i[o];
          return a;
        }),
        (e.sign.detached.verify = function (e, t, n) {
          if ((eu(e, t, n), 64 !== t.length)) throw Error('bad signature size');
          if (32 !== n.length) throw Error('bad public key size');
          var i,
            a = new Uint8Array(64 + e.length),
            o = new Uint8Array(64 + e.length);
          for (i = 0; i < 64; i++) a[i] = t[i];
          for (i = 0; i < e.length; i++) a[i + 64] = e[i];
          return es(o, a, a.length, n) >= 0;
        }),
        (e.sign.keyPair = function () {
          var e = new Uint8Array(32),
            t = new Uint8Array(64);
          return er(e, t), { publicKey: e, secretKey: t };
        }),
        (e.sign.keyPair.fromSecretKey = function (e) {
          if ((eu(e), 64 !== e.length)) throw Error('bad secret key size');
          for (var t = new Uint8Array(32), n = 0; n < t.length; n++) t[n] = e[32 + n];
          return { publicKey: t, secretKey: new Uint8Array(e) };
        }),
        (e.sign.keyPair.fromSeed = function (e) {
          if ((eu(e), 32 !== e.length)) throw Error('bad seed size');
          for (var t = new Uint8Array(32), n = new Uint8Array(64), i = 0; i < 32; i++) n[i] = e[i];
          return er(t, n, !0), { publicKey: t, secretKey: n };
        }),
        (e.sign.publicKeyLength = 32),
        (e.sign.secretKeyLength = 64),
        (e.sign.seedLength = 32),
        (e.sign.signatureLength = 64),
        (e.hash = function (e) {
          eu(e);
          var t = new Uint8Array(64);
          return Y(t, e, e.length), t;
        }),
        (e.hash.hashLength = 64),
        (e.verify = function (e, t) {
          return (
            eu(e, t),
            0 !== e.length &&
              0 !== t.length &&
              e.length === t.length &&
              0 === g(e, 0, t, 0, e.length)
          );
        }),
        (e.setPRNG = function (e) {
          i = e;
        }),
        (t = 'undefined' != typeof self ? self.crypto || self.msCrypto : null) && t.getRandomValues
          ? e.setPRNG(function (e, n) {
              var i,
                a = new Uint8Array(n);
              for (i = 0; i < n; i += 65536)
                t.getRandomValues(a.subarray(i, i + Math.min(n - i, 65536)));
              for (i = 0; i < n; i++) e[i] = a[i];
              ec(a);
            })
          : (t = {}).randomBytes &&
            e.setPRNG(function (e, n) {
              var i,
                a = t.randomBytes(n);
              for (i = 0; i < n; i++) e[i] = a[i];
              ec(a);
            });
    })(t.exports ? t.exports : (self.nacl = self.nacl || {}));
  },
  93453,
  (e, t, n) => {
    'use strict';
    Object.defineProperty(n, '__esModule', { value: !0 }), (n.bech32m = n.bech32 = void 0);
    let i = 'qpzry9x8gf2tvdw0s3jn54khce6mua7l',
      a = {};
    for (let e = 0; e < i.length; e++) a[i.charAt(e)] = e;
    function o(e) {
      let t = e >> 25;
      return (
        ((0x1ffffff & e) << 5) ^
        (0x3b6a57b2 & -(1 & t)) ^
        (0x26508e6d & -((t >> 1) & 1)) ^
        (0x1ea119fa & -((t >> 2) & 1)) ^
        (0x3d4233dd & -((t >> 3) & 1)) ^
        (0x2a1462b3 & -((t >> 4) & 1))
      );
    }
    function s(e) {
      let t = 1;
      for (let n = 0; n < e.length; ++n) {
        let i = e.charCodeAt(n);
        if (i < 33 || i > 126) return 'Invalid prefix (' + e + ')';
        t = o(t) ^ (i >> 5);
      }
      t = o(t);
      for (let n = 0; n < e.length; ++n) {
        let i = e.charCodeAt(n);
        t = o(t) ^ (31 & i);
      }
      return t;
    }
    function l(e, t, n, i) {
      let a = 0,
        o = 0,
        s = (1 << n) - 1,
        l = [];
      for (let i = 0; i < e.length; ++i)
        for (a = (a << t) | e[i], o += t; o >= n; ) l.push((a >> (o -= n)) & s);
      if (i) o > 0 && l.push((a << (n - o)) & s);
      else {
        if (o >= t) return 'Excess padding';
        if ((a << (n - o)) & s) return 'Non-zero padding';
      }
      return l;
    }
    function u(e) {
      return l(e, 8, 5, !0);
    }
    function c(e) {
      let t = l(e, 5, 8, !1);
      if (Array.isArray(t)) return t;
    }
    function d(e) {
      let t = l(e, 5, 8, !1);
      if (Array.isArray(t)) return t;
      throw Error(t);
    }
    function f(e) {
      let t;
      function n(e, n) {
        if (((n = n || 90), e.length < 8)) return e + ' too short';
        if (e.length > n) return 'Exceeds length limit';
        let i = e.toLowerCase(),
          l = e.toUpperCase();
        if (e !== i && e !== l) return 'Mixed-case string ' + e;
        let u = (e = i).lastIndexOf('1');
        if (-1 === u) return 'No separator character for ' + e;
        if (0 === u) return 'Missing prefix for ' + e;
        let c = e.slice(0, u),
          d = e.slice(u + 1);
        if (d.length < 6) return 'Data too short';
        let f = s(c);
        if ('string' == typeof f) return f;
        let h = [];
        for (let e = 0; e < d.length; ++e) {
          let t = d.charAt(e),
            n = a[t];
          if (void 0 === n) return 'Unknown character ' + t;
          (f = o(f) ^ n), e + 6 >= d.length || h.push(n);
        }
        return f !== t ? 'Invalid checksum for ' + e : { prefix: c, words: h };
      }
      return (
        (t = 'bech32' === e ? 1 : 0x2bc830a3),
        {
          decodeUnsafe: function (e, t) {
            let i = n(e, t);
            if ('object' == typeof i) return i;
          },
          decode: function (e, t) {
            let i = n(e, t);
            if ('object' == typeof i) return i;
            throw Error(i);
          },
          encode: function (e, n, a) {
            if (((a = a || 90), e.length + 7 + n.length > a))
              throw TypeError('Exceeds length limit');
            let l = s((e = e.toLowerCase()));
            if ('string' == typeof l) throw Error(l);
            let u = e + '1';
            for (let e = 0; e < n.length; ++e) {
              let t = n[e];
              if (t >> 5 != 0) throw Error('Non 5-bit word');
              (l = o(l) ^ t), (u += i.charAt(t));
            }
            for (let e = 0; e < 6; ++e) l = o(l);
            l ^= t;
            for (let e = 0; e < 6; ++e) {
              let t = (l >> ((5 - e) * 5)) & 31;
              u += i.charAt(t);
            }
            return u;
          },
          toWords: u,
          fromWordsUnsafe: c,
          fromWords: d,
        }
      );
    }
    (n.bech32 = f('bech32')), (n.bech32m = f('bech32m'));
  },
  20412,
  (e, t, n) => {
    'use strict';
    var i = {}.hasOwnProperty,
      a = function (e, t) {
        if (!e) return t;
        var n = {};
        for (var a in t) n[a] = i.call(e, a) ? e[a] : t[a];
        return n;
      },
      o = /[ -,\.\/:-@\[-\^`\{-~]/,
      s = /[ -,\.\/:-@\[\]\^`\{-~]/,
      l = /(^|\\+)?(\\[A-F0-9]{1,6})\x20(?![a-fA-F0-9\x20])/g,
      u = function e(t, n) {
        'single' != (n = a(n, e.options)).quotes && 'double' != n.quotes && (n.quotes = 'single');
        for (
          var i = 'double' == n.quotes ? '"' : "'",
            u = n.isIdentifier,
            c = t.charAt(0),
            d = '',
            f = 0,
            h = t.length;
          f < h;

        ) {
          var p = t.charAt(f++),
            m = p.charCodeAt(),
            g = void 0;
          if (m < 32 || m > 126) {
            if (m >= 55296 && m <= 56319 && f < h) {
              var y = t.charCodeAt(f++);
              (64512 & y) == 56320 ? (m = ((1023 & m) << 10) + (1023 & y) + 65536) : f--;
            }
            g = '\\' + m.toString(16).toUpperCase() + ' ';
          } else
            g = n.escapeEverything
              ? o.test(p)
                ? '\\' + p
                : '\\' + m.toString(16).toUpperCase() + ' '
              : /[\t\n\f\r\x0B]/.test(p)
              ? '\\' + m.toString(16).toUpperCase() + ' '
              : '\\' == p ||
                (!u && (('"' == p && i == p) || ("'" == p && i == p))) ||
                (u && s.test(p))
              ? '\\' + p
              : p;
          d += g;
        }
        return (u &&
          (/^-[-\d]/.test(d)
            ? (d = '\\-' + d.slice(1))
            : /\d/.test(c) && (d = '\\3' + c + ' ' + d.slice(1))),
        (d = d.replace(l, function (e, t, n) {
          return t && t.length % 2 ? e : (t || '') + n;
        })),
        !u && n.wrap)
          ? i + d + i
          : d;
      };
    (u.options = { escapeEverything: !1, isIdentifier: !1, quotes: 'single', wrap: !1 }),
      (u.version = '3.0.0'),
      (t.exports = u);
  },
  2031,
  (e, t, n) => {
    var i = String,
      a = function () {
        return {
          isColorSupported: !1,
          reset: i,
          bold: i,
          dim: i,
          italic: i,
          underline: i,
          inverse: i,
          hidden: i,
          strikethrough: i,
          black: i,
          red: i,
          green: i,
          yellow: i,
          blue: i,
          magenta: i,
          cyan: i,
          white: i,
          gray: i,
          bgBlack: i,
          bgRed: i,
          bgGreen: i,
          bgYellow: i,
          bgBlue: i,
          bgMagenta: i,
          bgCyan: i,
          bgWhite: i,
          blackBright: i,
          redBright: i,
          greenBright: i,
          yellowBright: i,
          blueBright: i,
          magentaBright: i,
          cyanBright: i,
          whiteBright: i,
          bgBlackBright: i,
          bgRedBright: i,
          bgGreenBright: i,
          bgYellowBright: i,
          bgBlueBright: i,
          bgMagentaBright: i,
          bgCyanBright: i,
          bgWhiteBright: i,
        };
      };
    (t.exports = a()), (t.exports.createColors = a);
  },
  30860,
  (e, t, n) => {
    'use strict';
    var i = function (e) {
        var t, n, i;
        return (
          !!(t = e) &&
          'object' == typeof t &&
          ((n = e),
          '[object RegExp]' !== (i = Object.prototype.toString.call(n)) &&
            '[object Date]' !== i &&
            n.$$typeof !== a)
        );
      },
      a = 'function' == typeof Symbol && Symbol.for ? Symbol.for('react.element') : 60103;
    function o(e, t) {
      return !1 !== t.clone && t.isMergeableObject(e) ? c(Array.isArray(e) ? [] : {}, e, t) : e;
    }
    function s(e, t, n) {
      return e.concat(t).map(function (e) {
        return o(e, n);
      });
    }
    function l(e) {
      return Object.keys(e).concat(
        Object.getOwnPropertySymbols
          ? Object.getOwnPropertySymbols(e).filter(function (t) {
              return Object.propertyIsEnumerable.call(e, t);
            })
          : []
      );
    }
    function u(e, t) {
      try {
        return t in e;
      } catch (e) {
        return !1;
      }
    }
    function c(e, t, n) {
      ((n = n || {}).arrayMerge = n.arrayMerge || s),
        (n.isMergeableObject = n.isMergeableObject || i),
        (n.cloneUnlessOtherwiseSpecified = o);
      var a,
        d,
        f = Array.isArray(t);
      return f !== Array.isArray(e)
        ? o(t, n)
        : f
        ? n.arrayMerge(e, t, n)
        : ((d = {}),
          (a = n).isMergeableObject(e) &&
            l(e).forEach(function (t) {
              d[t] = o(e[t], a);
            }),
          l(t).forEach(function (n) {
            (u(e, n) &&
              !(Object.hasOwnProperty.call(e, n) && Object.propertyIsEnumerable.call(e, n))) ||
              (u(e, n) && a.isMergeableObject(t[n])
                ? (d[n] = (function (e, t) {
                    if (!t.customMerge) return c;
                    var n = t.customMerge(e);
                    return 'function' == typeof n ? n : c;
                  })(n, a)(e[n], t[n], a))
                : (d[n] = o(t[n], a)));
          }),
          d);
    }
    (c.all = function (e, t) {
      if (!Array.isArray(e)) throw Error('first argument should be an array');
      return e.reduce(function (e, n) {
        return c(e, n, t);
      }, {});
    }),
      (t.exports = c);
  },
  29391,
  81140,
  20783,
  30030,
  10772,
  69340,
  48425,
  26330,
  74606,
  96626,
  40143,
  19273,
  15823,
  75555,
  14448,
  14272,
  12598,
  86318,
  53660,
  86491,
  17423,
  36416,
  69010,
  10297,
  58112,
  35566,
  43240,
  51001,
  92571,
  (e) => {
    'use strict';
    let t, n, i, a, o, s, l, u, c, d, f, h, p, m, g, y, b, v, w, x, E, S, C, k, O, A, I, j, T;
    var R,
      M,
      P,
      N,
      _,
      D,
      B,
      U,
      F,
      L,
      z,
      V,
      $,
      W,
      q,
      K,
      G,
      H,
      Z,
      Y,
      Q,
      X,
      J,
      ee,
      et,
      er,
      en,
      ei,
      ea,
      eo,
      es,
      el,
      eu,
      ec,
      ed,
      ef,
      eh,
      ep,
      em,
      eg,
      ey,
      eb,
      ev,
      ew,
      ex,
      eE,
      eS,
      eC,
      ek,
      eO,
      eA,
      eI,
      ej,
      eT,
      eR,
      eM,
      eP,
      eN,
      e_,
      eD,
      eB,
      eU,
      eF,
      eL,
      ez,
      eV,
      e$,
      eW,
      eq,
      eK,
      eG,
      eH,
      eZ,
      eY,
      eQ,
      eX = e.i(71645);
    function eJ(e, t, { checkForDefaultPrevented: n = !0 } = {}) {
      return function (i) {
        if ((e?.(i), !1 === n || !i.defaultPrevented)) return t?.(i);
      };
    }
    function e0(e, t) {
      if ('function' == typeof e) return e(t);
      null != e && (e.current = t);
    }
    function e1(...e) {
      return (t) => {
        let n = !1,
          i = e.map((e) => {
            let i = e0(e, t);
            return n || 'function' != typeof i || (n = !0), i;
          });
        if (n)
          return () => {
            for (let t = 0; t < i.length; t++) {
              let n = i[t];
              'function' == typeof n ? n() : e0(e[t], null);
            }
          };
      };
    }
    function e5(...e) {
      return eX.useCallback(e1(...e), e);
    }
    'undefined' != typeof window && window.document && window.document.createElement,
      e.s(['composeEventHandlers', () => eJ], 81140),
      e.s(['composeRefs', () => e1, 'useComposedRefs', () => e5], 20783);
    var e2 = e.i(43476);
    function e6(e, t) {
      let n = eX.createContext(t),
        i = (e) => {
          let { children: t, ...i } = e,
            a = eX.useMemo(() => i, Object.values(i));
          return (0, e2.jsx)(n.Provider, { value: a, children: t });
        };
      return (
        (i.displayName = e + 'Provider'),
        [
          i,
          function (i) {
            let a = eX.useContext(n);
            if (a) return a;
            if (void 0 !== t) return t;
            throw Error(`\`${i}\` must be used within \`${e}\``);
          },
        ]
      );
    }
    function e3(e, t = []) {
      let n = [],
        i = () => {
          let t = n.map((e) => eX.createContext(e));
          return function (n) {
            let i = n?.[e] || t;
            return eX.useMemo(() => ({ [`__scope${e}`]: { ...n, [e]: i } }), [n, i]);
          };
        };
      return (
        (i.scopeName = e),
        [
          function (t, i) {
            let a = eX.createContext(i),
              o = n.length;
            n = [...n, i];
            let s = (t) => {
              let { scope: n, children: i, ...s } = t,
                l = n?.[e]?.[o] || a,
                u = eX.useMemo(() => s, Object.values(s));
              return (0, e2.jsx)(l.Provider, { value: u, children: i });
            };
            return (
              (s.displayName = t + 'Provider'),
              [
                s,
                function (n, s) {
                  let l = s?.[e]?.[o] || a,
                    u = eX.useContext(l);
                  if (u) return u;
                  if (void 0 !== i) return i;
                  throw Error(`\`${n}\` must be used within \`${t}\``);
                },
              ]
            );
          },
          (function (...e) {
            let t = e[0];
            if (1 === e.length) return t;
            let n = () => {
              let n = e.map((e) => ({ useScope: e(), scopeName: e.scopeName }));
              return function (e) {
                let i = n.reduce((t, { useScope: n, scopeName: i }) => {
                  let a = n(e)[`__scope${i}`];
                  return { ...t, ...a };
                }, {});
                return eX.useMemo(() => ({ [`__scope${t.scopeName}`]: i }), [i]);
              };
            };
            return (n.scopeName = t.scopeName), n;
          })(i, ...t),
        ]
      );
    }
    e.s(['createContext', () => e6, 'createContextScope', () => e3], 30030);
    var e4 = globalThis?.document ? eX.useLayoutEffect : () => {},
      e8 = eX[' useId '.trim().toString()] || (() => void 0),
      e9 = 0;
    function e7(e) {
      let [t, n] = eX.useState(e8());
      return (
        e4(() => {
          e || n((e) => e ?? String(e9++));
        }, [e]),
        e || (t ? `radix-${t}` : '')
      );
    }
    e.s(['useId', () => e7], 10772),
      eX[' useEffectEvent '.trim().toString()],
      eX[' useInsertionEffect '.trim().toString()];
    var te = eX[' useInsertionEffect '.trim().toString()] || e4;
    function tt({ prop: e, defaultProp: t, onChange: n = () => {}, caller: i }) {
      let [a, o, s] = (function ({ defaultProp: e, onChange: t }) {
          let [n, i] = eX.useState(e),
            a = eX.useRef(n),
            o = eX.useRef(t);
          return (
            te(() => {
              o.current = t;
            }, [t]),
            eX.useEffect(() => {
              a.current !== n && (o.current?.(n), (a.current = n));
            }, [n, a]),
            [n, i, o]
          );
        })({ defaultProp: t, onChange: n }),
        l = void 0 !== e,
        u = l ? e : a;
      {
        let t = eX.useRef(void 0 !== e);
        eX.useEffect(() => {
          let e = t.current;
          if (e !== l) {
            let t = l ? 'controlled' : 'uncontrolled';
            console.warn(
              `${i} is changing from ${
                e ? 'controlled' : 'uncontrolled'
              } to ${t}. Components should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled value for the lifetime of the component.`
            );
          }
          t.current = l;
        }, [l, i]);
      }
      return [
        u,
        eX.useCallback(
          (t) => {
            if (l) {
              let n = 'function' == typeof t ? t(e) : t;
              n !== e && s.current?.(n);
            } else o(t);
          },
          [l, e, o, s]
        ),
      ];
    }
    Symbol('RADIX:SYNC_STATE'), e.s(['useControllableState', () => tt], 69340);
    var tr = e.i(74080),
      tn = Symbol('radix.slottable');
    function ti(e) {
      return (
        eX.isValidElement(e) &&
        'function' == typeof e.type &&
        '__radixId' in e.type &&
        e.type.__radixId === tn
      );
    }
    var ta = [
      'a',
      'button',
      'div',
      'form',
      'h2',
      'h3',
      'img',
      'input',
      'label',
      'li',
      'nav',
      'ol',
      'p',
      'select',
      'span',
      'svg',
      'ul',
    ].reduce((e, t) => {
      var n, i;
      let a,
        o,
        s,
        l =
          ((i = n = `Primitive.${t}`),
          ((a = eX.forwardRef((e, t) => {
            let { children: n, ...i } = e;
            if (eX.isValidElement(n)) {
              var a;
              let e,
                o,
                s =
                  ((a = n),
                  (o =
                    (e = Object.getOwnPropertyDescriptor(a.props, 'ref')?.get) &&
                    'isReactWarning' in e &&
                    e.isReactWarning)
                    ? a.ref
                    : (o =
                        (e = Object.getOwnPropertyDescriptor(a, 'ref')?.get) &&
                        'isReactWarning' in e &&
                        e.isReactWarning)
                    ? a.props.ref
                    : a.props.ref || a.ref),
                l = (function (e, t) {
                  let n = { ...t };
                  for (let i in t) {
                    let a = e[i],
                      o = t[i];
                    /^on[A-Z]/.test(i)
                      ? a && o
                        ? (n[i] = (...e) => {
                            let t = o(...e);
                            return a(...e), t;
                          })
                        : a && (n[i] = a)
                      : 'style' === i
                      ? (n[i] = { ...a, ...o })
                      : 'className' === i && (n[i] = [a, o].filter(Boolean).join(' '));
                  }
                  return { ...e, ...n };
                })(i, n.props);
              return n.type !== eX.Fragment && (l.ref = t ? e1(t, s) : s), eX.cloneElement(n, l);
            }
            return eX.Children.count(n) > 1 ? eX.Children.only(null) : null;
          })).displayName = `${i}.SlotClone`),
          (o = a),
          ((s = eX.forwardRef((e, t) => {
            let { children: n, ...i } = e,
              a = eX.Children.toArray(n),
              s = a.find(ti);
            if (s) {
              let e = s.props.children,
                n = a.map((t) =>
                  t !== s
                    ? t
                    : eX.Children.count(e) > 1
                    ? eX.Children.only(null)
                    : eX.isValidElement(e)
                    ? e.props.children
                    : null
                );
              return (0, e2.jsx)(o, {
                ...i,
                ref: t,
                children: eX.isValidElement(e) ? eX.cloneElement(e, void 0, n) : null,
              });
            }
            return (0, e2.jsx)(o, { ...i, ref: t, children: n });
          })).displayName = `${n}.Slot`),
          s),
        u = eX.forwardRef((e, n) => {
          let { asChild: i, ...a } = e;
          return (
            'undefined' != typeof window && (window[Symbol.for('radix-ui')] = !0),
            (0, e2.jsx)(i ? l : t, { ...a, ref: n })
          );
        });
      return (u.displayName = `Primitive.${t}`), { ...e, [t]: u };
    }, {});
    function to(e, t) {
      e && tr.flushSync(() => e.dispatchEvent(t));
    }
    function ts(e) {
      let t = eX.useRef(e);
      return (
        eX.useEffect(() => {
          t.current = e;
        }),
        eX.useMemo(
          () =>
            (...e) =>
              t.current?.(...e),
          []
        )
      );
    }
    e.s(['Primitive', () => ta, 'dispatchDiscreteCustomEvent', () => to], 48425);
    var tl = 'dismissableLayer.update',
      tu = eX.createContext({
        layers: new Set(),
        layersWithOutsidePointerEventsDisabled: new Set(),
        branches: new Set(),
      }),
      tc = eX.forwardRef((e, t) => {
        let {
            disableOutsidePointerEvents: n = !1,
            onEscapeKeyDown: i,
            onPointerDownOutside: a,
            onFocusOutside: o,
            onInteractOutside: s,
            onDismiss: l,
            ...u
          } = e,
          c = eX.useContext(tu),
          [d, f] = eX.useState(null),
          h = d?.ownerDocument ?? globalThis?.document,
          [, p] = eX.useState({}),
          m = e5(t, (e) => f(e)),
          g = Array.from(c.layers),
          [y] = [...c.layersWithOutsidePointerEventsDisabled].slice(-1),
          b = g.indexOf(y),
          v = d ? g.indexOf(d) : -1,
          w = c.layersWithOutsidePointerEventsDisabled.size > 0,
          x = v >= b,
          E = (function (e, t = globalThis?.document) {
            let n = ts(e),
              i = eX.useRef(!1),
              a = eX.useRef(() => {});
            return (
              eX.useEffect(() => {
                let e = (e) => {
                    if (e.target && !i.current) {
                      let i = function () {
                          tf('dismissableLayer.pointerDownOutside', n, o, { discrete: !0 });
                        },
                        o = { originalEvent: e };
                      'touch' === e.pointerType
                        ? (t.removeEventListener('click', a.current),
                          (a.current = i),
                          t.addEventListener('click', a.current, { once: !0 }))
                        : i();
                    } else t.removeEventListener('click', a.current);
                    i.current = !1;
                  },
                  o = window.setTimeout(() => {
                    t.addEventListener('pointerdown', e);
                  }, 0);
                return () => {
                  window.clearTimeout(o),
                    t.removeEventListener('pointerdown', e),
                    t.removeEventListener('click', a.current);
                };
              }, [t, n]),
              { onPointerDownCapture: () => (i.current = !0) }
            );
          })((e) => {
            let t = e.target,
              n = [...c.branches].some((e) => e.contains(t));
            x && !n && (a?.(e), s?.(e), e.defaultPrevented || l?.());
          }, h),
          S = (function (e, t = globalThis?.document) {
            let n = ts(e),
              i = eX.useRef(!1);
            return (
              eX.useEffect(() => {
                let e = (e) => {
                  e.target &&
                    !i.current &&
                    tf('dismissableLayer.focusOutside', n, { originalEvent: e }, { discrete: !1 });
                };
                return t.addEventListener('focusin', e), () => t.removeEventListener('focusin', e);
              }, [t, n]),
              { onFocusCapture: () => (i.current = !0), onBlurCapture: () => (i.current = !1) }
            );
          })((e) => {
            let t = e.target;
            ![...c.branches].some((e) => e.contains(t)) &&
              (o?.(e), s?.(e), e.defaultPrevented || l?.());
          }, h);
        return (
          !(function (e, t = globalThis?.document) {
            let n = ts(e);
            eX.useEffect(() => {
              let e = (e) => {
                'Escape' === e.key && n(e);
              };
              return (
                t.addEventListener('keydown', e, { capture: !0 }),
                () => t.removeEventListener('keydown', e, { capture: !0 })
              );
            }, [n, t]);
          })((e) => {
            v === c.layers.size - 1 &&
              (i?.(e), !e.defaultPrevented && l && (e.preventDefault(), l()));
          }, h),
          eX.useEffect(() => {
            if (d)
              return (
                n &&
                  (0 === c.layersWithOutsidePointerEventsDisabled.size &&
                    ((Y = h.body.style.pointerEvents), (h.body.style.pointerEvents = 'none')),
                  c.layersWithOutsidePointerEventsDisabled.add(d)),
                c.layers.add(d),
                td(),
                () => {
                  n &&
                    1 === c.layersWithOutsidePointerEventsDisabled.size &&
                    (h.body.style.pointerEvents = Y);
                }
              );
          }, [d, h, n, c]),
          eX.useEffect(
            () => () => {
              d && (c.layers.delete(d), c.layersWithOutsidePointerEventsDisabled.delete(d), td());
            },
            [d, c]
          ),
          eX.useEffect(() => {
            let e = () => p({});
            return document.addEventListener(tl, e), () => document.removeEventListener(tl, e);
          }, []),
          (0, e2.jsx)(ta.div, {
            ...u,
            ref: m,
            style: { pointerEvents: w ? (x ? 'auto' : 'none') : void 0, ...e.style },
            onFocusCapture: eJ(e.onFocusCapture, S.onFocusCapture),
            onBlurCapture: eJ(e.onBlurCapture, S.onBlurCapture),
            onPointerDownCapture: eJ(e.onPointerDownCapture, E.onPointerDownCapture),
          })
        );
      });
    function td() {
      let e = new CustomEvent(tl);
      document.dispatchEvent(e);
    }
    function tf(e, t, n, { discrete: i }) {
      let a = n.originalEvent.target,
        o = new CustomEvent(e, { bubbles: !1, cancelable: !0, detail: n });
      t && a.addEventListener(e, t, { once: !0 }), i ? to(a, o) : a.dispatchEvent(o);
    }
    (tc.displayName = 'DismissableLayer'),
      (eX.forwardRef((e, t) => {
        let n = eX.useContext(tu),
          i = eX.useRef(null),
          a = e5(t, i);
        return (
          eX.useEffect(() => {
            let e = i.current;
            if (e)
              return (
                n.branches.add(e),
                () => {
                  n.branches.delete(e);
                }
              );
          }, [n.branches]),
          (0, e2.jsx)(ta.div, { ...e, ref: a })
        );
      }).displayName = 'DismissableLayerBranch'),
      e.s(['DismissableLayer', () => tc], 26330);
    var th = 'focusScope.autoFocusOnMount',
      tp = 'focusScope.autoFocusOnUnmount',
      tm = { bubbles: !1, cancelable: !0 },
      tg = eX.forwardRef((e, t) => {
        let { loop: n = !1, trapped: i = !1, onMountAutoFocus: a, onUnmountAutoFocus: o, ...s } = e,
          [l, u] = eX.useState(null),
          c = ts(a),
          d = ts(o),
          f = eX.useRef(null),
          h = e5(t, (e) => u(e)),
          p = eX.useRef({
            paused: !1,
            pause() {
              this.paused = !0;
            },
            resume() {
              this.paused = !1;
            },
          }).current;
        eX.useEffect(() => {
          if (i) {
            let e = function (e) {
                if (p.paused || !l) return;
                let t = e.target;
                l.contains(t) ? (f.current = t) : tv(f.current, { select: !0 });
              },
              t = function (e) {
                if (p.paused || !l) return;
                let t = e.relatedTarget;
                null !== t && (l.contains(t) || tv(f.current, { select: !0 }));
              };
            document.addEventListener('focusin', e), document.addEventListener('focusout', t);
            let n = new MutationObserver(function (e) {
              if (document.activeElement === document.body)
                for (let t of e) t.removedNodes.length > 0 && tv(l);
            });
            return (
              l && n.observe(l, { childList: !0, subtree: !0 }),
              () => {
                document.removeEventListener('focusin', e),
                  document.removeEventListener('focusout', t),
                  n.disconnect();
              }
            );
          }
        }, [i, l, p.paused]),
          eX.useEffect(() => {
            if (l) {
              tw.add(p);
              let e = document.activeElement;
              if (!l.contains(e)) {
                let t = new CustomEvent(th, tm);
                l.addEventListener(th, c),
                  l.dispatchEvent(t),
                  t.defaultPrevented ||
                    ((function (e, { select: t = !1 } = {}) {
                      let n = document.activeElement;
                      for (let i of e)
                        if ((tv(i, { select: t }), document.activeElement !== n)) return;
                    })(
                      ty(l).filter((e) => 'A' !== e.tagName),
                      { select: !0 }
                    ),
                    document.activeElement === e && tv(l));
              }
              return () => {
                l.removeEventListener(th, c),
                  setTimeout(() => {
                    let t = new CustomEvent(tp, tm);
                    l.addEventListener(tp, d),
                      l.dispatchEvent(t),
                      t.defaultPrevented || tv(e ?? document.body, { select: !0 }),
                      l.removeEventListener(tp, d),
                      tw.remove(p);
                  }, 0);
              };
            }
          }, [l, c, d, p]);
        let m = eX.useCallback(
          (e) => {
            if ((!n && !i) || p.paused) return;
            let t = 'Tab' === e.key && !e.altKey && !e.ctrlKey && !e.metaKey,
              a = document.activeElement;
            if (t && a) {
              var o;
              let t,
                i = e.currentTarget,
                [s, l] = [tb((t = ty((o = i))), o), tb(t.reverse(), o)];
              s && l
                ? e.shiftKey || a !== l
                  ? e.shiftKey && a === s && (e.preventDefault(), n && tv(l, { select: !0 }))
                  : (e.preventDefault(), n && tv(s, { select: !0 }))
                : a === i && e.preventDefault();
            }
          },
          [n, i, p.paused]
        );
        return (0, e2.jsx)(ta.div, { tabIndex: -1, ...s, ref: h, onKeyDown: m });
      });
    function ty(e) {
      let t = [],
        n = document.createTreeWalker(e, NodeFilter.SHOW_ELEMENT, {
          acceptNode: (e) => {
            let t = 'INPUT' === e.tagName && 'hidden' === e.type;
            return e.disabled || e.hidden || t
              ? NodeFilter.FILTER_SKIP
              : e.tabIndex >= 0
              ? NodeFilter.FILTER_ACCEPT
              : NodeFilter.FILTER_SKIP;
          },
        });
      for (; n.nextNode(); ) t.push(n.currentNode);
      return t;
    }
    function tb(e, t) {
      for (let n of e)
        if (
          !(function (e, { upTo: t }) {
            if ('hidden' === getComputedStyle(e).visibility) return !0;
            for (; e && (void 0 === t || e !== t); ) {
              if ('none' === getComputedStyle(e).display) return !0;
              e = e.parentElement;
            }
            return !1;
          })(n, { upTo: t })
        )
          return n;
    }
    function tv(e, { select: t = !1 } = {}) {
      if (e && e.focus) {
        var n;
        let i = document.activeElement;
        e.focus({ preventScroll: !0 }),
          e !== i && (n = e) instanceof HTMLInputElement && 'select' in n && t && e.select();
      }
    }
    tg.displayName = 'FocusScope';
    var tw =
      ((A = []),
      {
        add(e) {
          let t = A[0];
          e !== t && t?.pause(), (A = tx(A, e)).unshift(e);
        },
        remove(e) {
          (A = tx(A, e)), A[0]?.resume();
        },
      });
    function tx(e, t) {
      let n = [...e],
        i = n.indexOf(t);
      return -1 !== i && n.splice(i, 1), n;
    }
    var tE = eX.forwardRef((e, t) => {
      let { container: n, ...i } = e,
        [a, o] = eX.useState(!1);
      e4(() => o(!0), []);
      let s = n || (a && globalThis?.document?.body);
      return s ? tr.default.createPortal((0, e2.jsx)(ta.div, { ...i, ref: t }), s) : null;
    });
    (tE.displayName = 'Portal'), e.s(['Portal', () => tE], 74606);
    var tS = (e) => {
      var t;
      let n,
        i,
        { present: a, children: o } = e,
        s = (function (e) {
          var t, n;
          let [i, a] = eX.useState(),
            o = eX.useRef(null),
            s = eX.useRef(e),
            l = eX.useRef('none'),
            [u, c] =
              ((t = e ? 'mounted' : 'unmounted'),
              (n = {
                mounted: { UNMOUNT: 'unmounted', ANIMATION_OUT: 'unmountSuspended' },
                unmountSuspended: { MOUNT: 'mounted', ANIMATION_END: 'unmounted' },
                unmounted: { MOUNT: 'mounted' },
              }),
              eX.useReducer((e, t) => n[e][t] ?? e, t));
          return (
            eX.useEffect(() => {
              let e = tC(o.current);
              l.current = 'mounted' === u ? e : 'none';
            }, [u]),
            e4(() => {
              let t = o.current,
                n = s.current;
              if (n !== e) {
                let i = l.current,
                  a = tC(t);
                e
                  ? c('MOUNT')
                  : 'none' === a || t?.display === 'none'
                  ? c('UNMOUNT')
                  : n && i !== a
                  ? c('ANIMATION_OUT')
                  : c('UNMOUNT'),
                  (s.current = e);
              }
            }, [e, c]),
            e4(() => {
              if (i) {
                let e,
                  t = i.ownerDocument.defaultView ?? window,
                  n = (n) => {
                    let a = tC(o.current).includes(CSS.escape(n.animationName));
                    if (n.target === i && a && (c('ANIMATION_END'), !s.current)) {
                      let n = i.style.animationFillMode;
                      (i.style.animationFillMode = 'forwards'),
                        (e = t.setTimeout(() => {
                          'forwards' === i.style.animationFillMode &&
                            (i.style.animationFillMode = n);
                        }));
                    }
                  },
                  a = (e) => {
                    e.target === i && (l.current = tC(o.current));
                  };
                return (
                  i.addEventListener('animationstart', a),
                  i.addEventListener('animationcancel', n),
                  i.addEventListener('animationend', n),
                  () => {
                    t.clearTimeout(e),
                      i.removeEventListener('animationstart', a),
                      i.removeEventListener('animationcancel', n),
                      i.removeEventListener('animationend', n);
                  }
                );
              }
              c('ANIMATION_END');
            }, [i, c]),
            {
              isPresent: ['mounted', 'unmountSuspended'].includes(u),
              ref: eX.useCallback((e) => {
                (o.current = e ? getComputedStyle(e) : null), a(e);
              }, []),
            }
          );
        })(a),
        l = 'function' == typeof o ? o({ present: s.isPresent }) : eX.Children.only(o),
        u = e5(
          s.ref,
          ((t = l),
          (i =
            (n = Object.getOwnPropertyDescriptor(t.props, 'ref')?.get) &&
            'isReactWarning' in n &&
            n.isReactWarning)
            ? t.ref
            : (i =
                (n = Object.getOwnPropertyDescriptor(t, 'ref')?.get) &&
                'isReactWarning' in n &&
                n.isReactWarning)
            ? t.props.ref
            : t.props.ref || t.ref)
        );
      return 'function' == typeof o || s.isPresent ? eX.cloneElement(l, { ref: u }) : null;
    };
    function tC(e) {
      return e?.animationName || 'none';
    }
    (tS.displayName = 'Presence'), e.s(['Presence', () => tS], 96626);
    var tk = 0;
    function tO() {
      eX.useEffect(() => {
        let e = document.querySelectorAll('[data-radix-focus-guard]');
        return (
          document.body.insertAdjacentElement('afterbegin', e[0] ?? tA()),
          document.body.insertAdjacentElement('beforeend', e[1] ?? tA()),
          tk++,
          () => {
            1 === tk &&
              document.querySelectorAll('[data-radix-focus-guard]').forEach((e) => e.remove()),
              tk--;
          }
        );
      }, []);
    }
    function tA() {
      let e = document.createElement('span');
      return (
        e.setAttribute('data-radix-focus-guard', ''),
        (e.tabIndex = 0),
        (e.style.outline = 'none'),
        (e.style.opacity = '0'),
        (e.style.position = 'fixed'),
        (e.style.pointerEvents = 'none'),
        e
      );
    }
    var tI = function () {
      return (tI =
        Object.assign ||
        function (e) {
          for (var t, n = 1, i = arguments.length; n < i; n++)
            for (var a in (t = arguments[n]))
              Object.prototype.hasOwnProperty.call(t, a) && (e[a] = t[a]);
          return e;
        }).apply(this, arguments);
    };
    function tj(e, t) {
      var n = {};
      for (var i in e)
        Object.prototype.hasOwnProperty.call(e, i) && 0 > t.indexOf(i) && (n[i] = e[i]);
      if (null != e && 'function' == typeof Object.getOwnPropertySymbols)
        for (var a = 0, i = Object.getOwnPropertySymbols(e); a < i.length; a++)
          0 > t.indexOf(i[a]) &&
            Object.prototype.propertyIsEnumerable.call(e, i[a]) &&
            (n[i[a]] = e[i[a]]);
      return n;
    }
    var tT = ('function' == typeof SuppressedError && SuppressedError, 'right-scroll-bar-position'),
      tR = 'width-before-scroll-bar';
    function tM(e, t) {
      return 'function' == typeof e ? e(t) : e && (e.current = t), e;
    }
    var tP = 'undefined' != typeof window ? eX.useLayoutEffect : eX.useEffect,
      tN = new WeakMap(),
      t_ =
        (void 0 === R && (R = {}),
        ((void 0 === M &&
          (M = function (e) {
            return e;
          }),
        (P = []),
        (N = !1),
        (_ = {
          read: function () {
            if (N)
              throw Error(
                'Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.'
              );
            return P.length ? P[P.length - 1] : null;
          },
          useMedium: function (e) {
            var t = M(e, N);
            return (
              P.push(t),
              function () {
                P = P.filter(function (e) {
                  return e !== t;
                });
              }
            );
          },
          assignSyncMedium: function (e) {
            for (N = !0; P.length; ) {
              var t = P;
              (P = []), t.forEach(e);
            }
            P = {
              push: function (t) {
                return e(t);
              },
              filter: function () {
                return P;
              },
            };
          },
          assignMedium: function (e) {
            N = !0;
            var t = [];
            if (P.length) {
              var n = P;
              (P = []), n.forEach(e), (t = P);
            }
            var i = function () {
                var n = t;
                (t = []), n.forEach(e);
              },
              a = function () {
                return Promise.resolve().then(i);
              };
            a(),
              (P = {
                push: function (e) {
                  t.push(e), a();
                },
                filter: function (e) {
                  return (t = t.filter(e)), P;
                },
              });
          },
        })).options = tI({ async: !0, ssr: !1 }, R)),
        _),
      tD = function () {},
      tB = eX.forwardRef(function (e, t) {
        var n,
          i,
          a,
          o,
          s = eX.useRef(null),
          l = eX.useState({ onScrollCapture: tD, onWheelCapture: tD, onTouchMoveCapture: tD }),
          u = l[0],
          c = l[1],
          d = e.forwardProps,
          f = e.children,
          h = e.className,
          p = e.removeScrollBar,
          m = e.enabled,
          g = e.shards,
          y = e.sideCar,
          b = e.noRelative,
          v = e.noIsolation,
          w = e.inert,
          x = e.allowPinchZoom,
          E = e.as,
          S = e.gapMode,
          C = tj(e, [
            'forwardProps',
            'children',
            'className',
            'removeScrollBar',
            'enabled',
            'shards',
            'sideCar',
            'noRelative',
            'noIsolation',
            'inert',
            'allowPinchZoom',
            'as',
            'gapMode',
          ]),
          k =
            ((n = [s, t]),
            (i = function (e) {
              return n.forEach(function (t) {
                return tM(t, e);
              });
            }),
            ((a = (0, eX.useState)(function () {
              return {
                value: null,
                callback: i,
                facade: {
                  get current() {
                    return a.value;
                  },
                  set current(value) {
                    var e = a.value;
                    e !== value && ((a.value = value), a.callback(value, e));
                  },
                },
              };
            })[0]).callback = i),
            (o = a.facade),
            tP(
              function () {
                var e = tN.get(o);
                if (e) {
                  var t = new Set(e),
                    i = new Set(n),
                    a = o.current;
                  t.forEach(function (e) {
                    i.has(e) || tM(e, null);
                  }),
                    i.forEach(function (e) {
                      t.has(e) || tM(e, a);
                    });
                }
                tN.set(o, n);
              },
              [n]
            ),
            o),
          O = tI(tI({}, C), u);
        return eX.createElement(
          eX.Fragment,
          null,
          m &&
            eX.createElement(y, {
              sideCar: t_,
              removeScrollBar: p,
              shards: g,
              noRelative: b,
              noIsolation: v,
              inert: w,
              setCallbacks: c,
              allowPinchZoom: !!x,
              lockRef: s,
              gapMode: S,
            }),
          d
            ? eX.cloneElement(eX.Children.only(f), tI(tI({}, O), { ref: k }))
            : eX.createElement(void 0 === E ? 'div' : E, tI({}, O, { className: h, ref: k }), f)
        );
      });
    (tB.defaultProps = { enabled: !0, removeScrollBar: !0, inert: !1 }),
      (tB.classNames = { fullWidth: tR, zeroRight: tT });
    var tU = function (e) {
      var t = e.sideCar,
        n = tj(e, ['sideCar']);
      if (!t) throw Error('Sidecar: please provide `sideCar` property to import the right car');
      var i = t.read();
      if (!i) throw Error('Sidecar medium not found');
      return eX.createElement(i, tI({}, n));
    };
    tU.isSideCarExport = !0;
    var tF = function () {
        var e = 0,
          t = null;
        return {
          add: function (n) {
            if (
              0 == e &&
              (t = (function () {
                if (!document) return null;
                var e = document.createElement('style');
                e.type = 'text/css';
                var t = Q || ('undefined' != typeof __webpack_nonce__ ? __webpack_nonce__ : void 0);
                return t && e.setAttribute('nonce', t), e;
              })())
            ) {
              var i, a;
              (i = t).styleSheet
                ? (i.styleSheet.cssText = n)
                : i.appendChild(document.createTextNode(n)),
                (a = t),
                (document.head || document.getElementsByTagName('head')[0]).appendChild(a);
            }
            e++;
          },
          remove: function () {
            --e || !t || (t.parentNode && t.parentNode.removeChild(t), (t = null));
          },
        };
      },
      tL = function () {
        var e = tF();
        return function (t, n) {
          eX.useEffect(
            function () {
              return (
                e.add(t),
                function () {
                  e.remove();
                }
              );
            },
            [t && n]
          );
        };
      },
      tz = function () {
        var e = tL();
        return function (t) {
          return e(t.styles, t.dynamic), null;
        };
      },
      tV = { left: 0, top: 0, right: 0, gap: 0 },
      t$ = function (e) {
        return parseInt(e || '', 10) || 0;
      },
      tW = function (e) {
        var t = window.getComputedStyle(document.body),
          n = t['padding' === e ? 'paddingLeft' : 'marginLeft'],
          i = t['padding' === e ? 'paddingTop' : 'marginTop'],
          a = t['padding' === e ? 'paddingRight' : 'marginRight'];
        return [t$(n), t$(i), t$(a)];
      },
      tq = function (e) {
        if ((void 0 === e && (e = 'margin'), 'undefined' == typeof window)) return tV;
        var t = tW(e),
          n = document.documentElement.clientWidth,
          i = window.innerWidth;
        return { left: t[0], top: t[1], right: t[2], gap: Math.max(0, i - n + t[2] - t[0]) };
      },
      tK = tz(),
      tG = 'data-scroll-locked',
      tH = function (e, t, n, i) {
        var a = e.left,
          o = e.top,
          s = e.right,
          l = e.gap;
        return (
          void 0 === n && (n = 'margin'),
          '\n  .'
            .concat('with-scroll-bars-hidden', ' {\n   overflow: hidden ')
            .concat(i, ';\n   padding-right: ')
            .concat(l, 'px ')
            .concat(i, ';\n  }\n  body[')
            .concat(tG, '] {\n    overflow: hidden ')
            .concat(i, ';\n    overscroll-behavior: contain;\n    ')
            .concat(
              [
                t && 'position: relative '.concat(i, ';'),
                'margin' === n &&
                  '\n    padding-left: '
                    .concat(a, 'px;\n    padding-top: ')
                    .concat(o, 'px;\n    padding-right: ')
                    .concat(s, 'px;\n    margin-left:0;\n    margin-top:0;\n    margin-right: ')
                    .concat(l, 'px ')
                    .concat(i, ';\n    '),
                'padding' === n && 'padding-right: '.concat(l, 'px ').concat(i, ';'),
              ]
                .filter(Boolean)
                .join(''),
              '\n  }\n  \n  .'
            )
            .concat(tT, ' {\n    right: ')
            .concat(l, 'px ')
            .concat(i, ';\n  }\n  \n  .')
            .concat(tR, ' {\n    margin-right: ')
            .concat(l, 'px ')
            .concat(i, ';\n  }\n  \n  .')
            .concat(tT, ' .')
            .concat(tT, ' {\n    right: 0 ')
            .concat(i, ';\n  }\n  \n  .')
            .concat(tR, ' .')
            .concat(tR, ' {\n    margin-right: 0 ')
            .concat(i, ';\n  }\n  \n  body[')
            .concat(tG, '] {\n    ')
            .concat('--removed-body-scroll-bar-size', ': ')
            .concat(l, 'px;\n  }\n')
        );
      },
      tZ = function () {
        var e = parseInt(document.body.getAttribute(tG) || '0', 10);
        return isFinite(e) ? e : 0;
      },
      tY = function () {
        eX.useEffect(function () {
          return (
            document.body.setAttribute(tG, (tZ() + 1).toString()),
            function () {
              var e = tZ() - 1;
              e <= 0
                ? document.body.removeAttribute(tG)
                : document.body.setAttribute(tG, e.toString());
            }
          );
        }, []);
      },
      tQ = function (e) {
        var t = e.noRelative,
          n = e.noImportant,
          i = e.gapMode,
          a = void 0 === i ? 'margin' : i;
        tY();
        var o = eX.useMemo(
          function () {
            return tq(a);
          },
          [a]
        );
        return eX.createElement(tK, { styles: tH(o, !t, a, n ? '' : '!important') });
      },
      tX = !1;
    if ('undefined' != typeof window)
      try {
        var tJ = Object.defineProperty({}, 'passive', {
          get: function () {
            return (tX = !0), !0;
          },
        });
        window.addEventListener('test', tJ, tJ), window.removeEventListener('test', tJ, tJ);
      } catch (e) {
        tX = !1;
      }
    var t0 = !!tX && { passive: !1 },
      t1 = function (e, t) {
        if (!(e instanceof Element)) return !1;
        var n = window.getComputedStyle(e);
        return (
          'hidden' !== n[t] &&
          (n.overflowY !== n.overflowX || 'TEXTAREA' === e.tagName || 'visible' !== n[t])
        );
      },
      t5 = function (e, t) {
        var n = t.ownerDocument,
          i = t;
        do {
          if (
            ('undefined' != typeof ShadowRoot && i instanceof ShadowRoot && (i = i.host), t2(e, i))
          ) {
            var a = t6(e, i);
            if (a[1] > a[2]) return !0;
          }
          i = i.parentNode;
        } while (i && i !== n.body);
        return !1;
      },
      t2 = function (e, t) {
        return 'v' === e ? t1(t, 'overflowY') : t1(t, 'overflowX');
      },
      t6 = function (e, t) {
        return 'v' === e
          ? [t.scrollTop, t.scrollHeight, t.clientHeight]
          : [t.scrollLeft, t.scrollWidth, t.clientWidth];
      },
      t3 = function (e, t, n, i, a) {
        var o,
          s = ((o = window.getComputedStyle(t).direction), 'h' === e && 'rtl' === o ? -1 : 1),
          l = s * i,
          u = n.target,
          c = t.contains(u),
          d = !1,
          f = l > 0,
          h = 0,
          p = 0;
        do {
          if (!u) break;
          var m = t6(e, u),
            g = m[0],
            y = m[1] - m[2] - s * g;
          (g || y) && t2(e, u) && ((h += y), (p += g));
          var b = u.parentNode;
          u = b && b.nodeType === Node.DOCUMENT_FRAGMENT_NODE ? b.host : b;
        } while ((!c && u !== document.body) || (c && (t.contains(u) || t === u)));
        return (
          f && ((a && 1 > Math.abs(h)) || (!a && l > h))
            ? (d = !0)
            : !f && ((a && 1 > Math.abs(p)) || (!a && -l > p)) && (d = !0),
          d
        );
      },
      t4 = function (e) {
        return 'changedTouches' in e
          ? [e.changedTouches[0].clientX, e.changedTouches[0].clientY]
          : [0, 0];
      },
      t8 = function (e) {
        return [e.deltaX, e.deltaY];
      },
      t9 = function (e) {
        return e && 'current' in e ? e.current : e;
      },
      t7 = 0,
      re = [];
    let rt =
      ((D = function (e) {
        var t = eX.useRef([]),
          n = eX.useRef([0, 0]),
          i = eX.useRef(),
          a = eX.useState(t7++)[0],
          o = eX.useState(tz)[0],
          s = eX.useRef(e);
        eX.useEffect(
          function () {
            s.current = e;
          },
          [e]
        ),
          eX.useEffect(
            function () {
              if (e.inert) {
                document.body.classList.add('block-interactivity-'.concat(a));
                var t = (function (e, t, n) {
                  if (n || 2 == arguments.length)
                    for (var i, a = 0, o = t.length; a < o; a++)
                      (!i && a in t) ||
                        (i || (i = Array.prototype.slice.call(t, 0, a)), (i[a] = t[a]));
                  return e.concat(i || Array.prototype.slice.call(t));
                })([e.lockRef.current], (e.shards || []).map(t9), !0).filter(Boolean);
                return (
                  t.forEach(function (e) {
                    return e.classList.add('allow-interactivity-'.concat(a));
                  }),
                  function () {
                    document.body.classList.remove('block-interactivity-'.concat(a)),
                      t.forEach(function (e) {
                        return e.classList.remove('allow-interactivity-'.concat(a));
                      });
                  }
                );
              }
            },
            [e.inert, e.lockRef.current, e.shards]
          );
        var l = eX.useCallback(function (e, t) {
            if (('touches' in e && 2 === e.touches.length) || ('wheel' === e.type && e.ctrlKey))
              return !s.current.allowPinchZoom;
            var a,
              o = t4(e),
              l = n.current,
              u = 'deltaX' in e ? e.deltaX : l[0] - o[0],
              c = 'deltaY' in e ? e.deltaY : l[1] - o[1],
              d = e.target,
              f = Math.abs(u) > Math.abs(c) ? 'h' : 'v';
            if ('touches' in e && 'h' === f && 'range' === d.type) return !1;
            var h = window.getSelection(),
              p = h && h.anchorNode;
            if (p && (p === d || p.contains(d))) return !1;
            var m = t5(f, d);
            if (!m) return !0;
            if ((m ? (a = f) : ((a = 'v' === f ? 'h' : 'v'), (m = t5(f, d))), !m)) return !1;
            if ((!i.current && 'changedTouches' in e && (u || c) && (i.current = a), !a)) return !0;
            var g = i.current || a;
            return t3(g, t, e, 'h' === g ? u : c, !0);
          }, []),
          u = eX.useCallback(function (e) {
            if (re.length && re[re.length - 1] === o) {
              var n = 'deltaY' in e ? t8(e) : t4(e),
                i = t.current.filter(function (t) {
                  var i;
                  return (
                    t.name === e.type &&
                    (t.target === e.target || e.target === t.shadowParent) &&
                    ((i = t.delta), i[0] === n[0] && i[1] === n[1])
                  );
                })[0];
              if (i && i.should) {
                e.cancelable && e.preventDefault();
                return;
              }
              if (!i) {
                var a = (s.current.shards || [])
                  .map(t9)
                  .filter(Boolean)
                  .filter(function (t) {
                    return t.contains(e.target);
                  });
                (a.length > 0 ? l(e, a[0]) : !s.current.noIsolation) &&
                  e.cancelable &&
                  e.preventDefault();
              }
            }
          }, []),
          c = eX.useCallback(function (e, n, i, a) {
            var o = {
              name: e,
              delta: n,
              target: i,
              should: a,
              shadowParent: (function (e) {
                for (var t = null; null !== e; )
                  e instanceof ShadowRoot && ((t = e.host), (e = e.host)), (e = e.parentNode);
                return t;
              })(i),
            };
            t.current.push(o),
              setTimeout(function () {
                t.current = t.current.filter(function (e) {
                  return e !== o;
                });
              }, 1);
          }, []),
          d = eX.useCallback(function (e) {
            (n.current = t4(e)), (i.current = void 0);
          }, []),
          f = eX.useCallback(function (t) {
            c(t.type, t8(t), t.target, l(t, e.lockRef.current));
          }, []),
          h = eX.useCallback(function (t) {
            c(t.type, t4(t), t.target, l(t, e.lockRef.current));
          }, []);
        eX.useEffect(function () {
          return (
            re.push(o),
            e.setCallbacks({ onScrollCapture: f, onWheelCapture: f, onTouchMoveCapture: h }),
            document.addEventListener('wheel', u, t0),
            document.addEventListener('touchmove', u, t0),
            document.addEventListener('touchstart', d, t0),
            function () {
              (re = re.filter(function (e) {
                return e !== o;
              })),
                document.removeEventListener('wheel', u, t0),
                document.removeEventListener('touchmove', u, t0),
                document.removeEventListener('touchstart', d, t0);
            }
          );
        }, []);
        var p = e.removeScrollBar,
          m = e.inert;
        return eX.createElement(
          eX.Fragment,
          null,
          m
            ? eX.createElement(o, {
                styles: '\n  .block-interactivity-'
                  .concat(a, ' {pointer-events: none;}\n  .allow-interactivity-')
                  .concat(a, ' {pointer-events: all;}\n'),
              })
            : null,
          p ? eX.createElement(tQ, { noRelative: e.noRelative, gapMode: e.gapMode }) : null
        );
      }),
      t_.useMedium(D),
      tU);
    var rr = eX.forwardRef(function (e, t) {
      return eX.createElement(tB, tI({}, e, { ref: t, sideCar: rt }));
    });
    rr.classNames = tB.classNames;
    var rn = new WeakMap(),
      ri = new WeakMap(),
      ra = {},
      ro = 0,
      rs = function (e) {
        return e && (e.host || rs(e.parentNode));
      },
      rl = function (e, t, n, i) {
        var a = (Array.isArray(e) ? e : [e])
          .map(function (e) {
            if (t.contains(e)) return e;
            var n = rs(e);
            return n && t.contains(n)
              ? n
              : (console.error('aria-hidden', e, 'in not contained inside', t, '. Doing nothing'),
                null);
          })
          .filter(function (e) {
            return !!e;
          });
        ra[n] || (ra[n] = new WeakMap());
        var o = ra[n],
          s = [],
          l = new Set(),
          u = new Set(a),
          c = function (e) {
            !e || l.has(e) || (l.add(e), c(e.parentNode));
          };
        a.forEach(c);
        var d = function (e) {
          !e ||
            u.has(e) ||
            Array.prototype.forEach.call(e.children, function (e) {
              if (l.has(e)) d(e);
              else
                try {
                  var t = e.getAttribute(i),
                    a = null !== t && 'false' !== t,
                    u = (rn.get(e) || 0) + 1,
                    c = (o.get(e) || 0) + 1;
                  rn.set(e, u),
                    o.set(e, c),
                    s.push(e),
                    1 === u && a && ri.set(e, !0),
                    1 === c && e.setAttribute(n, 'true'),
                    a || e.setAttribute(i, 'true');
                } catch (t) {
                  console.error('aria-hidden: cannot operate on ', e, t);
                }
            });
        };
        return (
          d(t),
          l.clear(),
          ro++,
          function () {
            s.forEach(function (e) {
              var t = rn.get(e) - 1,
                a = o.get(e) - 1;
              rn.set(e, t),
                o.set(e, a),
                t || (ri.has(e) || e.removeAttribute(i), ri.delete(e)),
                a || e.removeAttribute(n);
            }),
              --ro || ((rn = new WeakMap()), (rn = new WeakMap()), (ri = new WeakMap()), (ra = {}));
          }
        );
      },
      ru = function (e, t, n) {
        void 0 === n && (n = 'data-aria-hidden');
        var i = Array.from(Array.isArray(e) ? e : [e]),
          a =
            t ||
            ('undefined' == typeof document
              ? null
              : (Array.isArray(e) ? e[0] : e).ownerDocument.body);
        return a
          ? (i.push.apply(i, Array.from(a.querySelectorAll('[aria-live], script'))),
            rl(i, a, n, 'aria-hidden'))
          : function () {
              return null;
            };
      },
      rc = Symbol('radix.slottable');
    function rd(e) {
      return (
        eX.isValidElement(e) &&
        'function' == typeof e.type &&
        '__radixId' in e.type &&
        e.type.__radixId === rc
      );
    }
    var rf = 'Dialog',
      [rh, rp] = e3(rf),
      [rm, rg] = rh(rf),
      ry = (e) => {
        let {
            __scopeDialog: t,
            children: n,
            open: i,
            defaultOpen: a,
            onOpenChange: o,
            modal: s = !0,
          } = e,
          l = eX.useRef(null),
          u = eX.useRef(null),
          [c, d] = tt({ prop: i, defaultProp: a ?? !1, onChange: o, caller: rf });
        return (0, e2.jsx)(rm, {
          scope: t,
          triggerRef: l,
          contentRef: u,
          contentId: e7(),
          titleId: e7(),
          descriptionId: e7(),
          open: c,
          onOpenChange: d,
          onOpenToggle: eX.useCallback(() => d((e) => !e), [d]),
          modal: s,
          children: n,
        });
      };
    ry.displayName = rf;
    var rb = 'DialogTrigger',
      rv = eX.forwardRef((e, t) => {
        let { __scopeDialog: n, ...i } = e,
          a = rg(rb, n),
          o = e5(t, a.triggerRef);
        return (0, e2.jsx)(ta.button, {
          type: 'button',
          'aria-haspopup': 'dialog',
          'aria-expanded': a.open,
          'aria-controls': a.contentId,
          'data-state': rU(a.open),
          ...i,
          ref: o,
          onClick: eJ(e.onClick, a.onOpenToggle),
        });
      });
    rv.displayName = rb;
    var rw = 'DialogPortal',
      [rx, rE] = rh(rw, { forceMount: void 0 }),
      rS = (e) => {
        let { __scopeDialog: t, forceMount: n, children: i, container: a } = e,
          o = rg(rw, t);
        return (0, e2.jsx)(rx, {
          scope: t,
          forceMount: n,
          children: eX.Children.map(i, (e) =>
            (0, e2.jsx)(tS, {
              present: n || o.open,
              children: (0, e2.jsx)(tE, { asChild: !0, container: a, children: e }),
            })
          ),
        });
      };
    rS.displayName = rw;
    var rC = 'DialogOverlay',
      rk = eX.forwardRef((e, t) => {
        let n = rE(rC, e.__scopeDialog),
          { forceMount: i = n.forceMount, ...a } = e,
          o = rg(rC, e.__scopeDialog);
        return o.modal
          ? (0, e2.jsx)(tS, { present: i || o.open, children: (0, e2.jsx)(rA, { ...a, ref: t }) })
          : null;
      });
    rk.displayName = rC;
    var rO =
        (((I = eX.forwardRef((e, t) => {
          let { children: n, ...i } = e;
          if (eX.isValidElement(n)) {
            var a;
            let e,
              o,
              s =
                ((a = n),
                (o =
                  (e = Object.getOwnPropertyDescriptor(a.props, 'ref')?.get) &&
                  'isReactWarning' in e &&
                  e.isReactWarning)
                  ? a.ref
                  : (o =
                      (e = Object.getOwnPropertyDescriptor(a, 'ref')?.get) &&
                      'isReactWarning' in e &&
                      e.isReactWarning)
                  ? a.props.ref
                  : a.props.ref || a.ref),
              l = (function (e, t) {
                let n = { ...t };
                for (let i in t) {
                  let a = e[i],
                    o = t[i];
                  /^on[A-Z]/.test(i)
                    ? a && o
                      ? (n[i] = (...e) => {
                          let t = o(...e);
                          return a(...e), t;
                        })
                      : a && (n[i] = a)
                    : 'style' === i
                    ? (n[i] = { ...a, ...o })
                    : 'className' === i && (n[i] = [a, o].filter(Boolean).join(' '));
                }
                return { ...e, ...n };
              })(i, n.props);
            return n.type !== eX.Fragment && (l.ref = t ? e1(t, s) : s), eX.cloneElement(n, l);
          }
          return eX.Children.count(n) > 1 ? eX.Children.only(null) : null;
        })).displayName = 'DialogOverlay.RemoveScroll.SlotClone'),
        (n = I),
        ((i = eX.forwardRef((e, t) => {
          let { children: i, ...a } = e,
            o = eX.Children.toArray(i),
            s = o.find(rd);
          if (s) {
            let e = s.props.children,
              i = o.map((t) =>
                t !== s
                  ? t
                  : eX.Children.count(e) > 1
                  ? eX.Children.only(null)
                  : eX.isValidElement(e)
                  ? e.props.children
                  : null
              );
            return (0, e2.jsx)(n, {
              ...a,
              ref: t,
              children: eX.isValidElement(e) ? eX.cloneElement(e, void 0, i) : null,
            });
          }
          return (0, e2.jsx)(n, { ...a, ref: t, children: i });
        })).displayName = 'DialogOverlay.RemoveScroll.Slot'),
        i),
      rA = eX.forwardRef((e, t) => {
        let { __scopeDialog: n, ...i } = e,
          a = rg(rC, n);
        return (0, e2.jsx)(rr, {
          as: rO,
          allowPinchZoom: !0,
          shards: [a.contentRef],
          children: (0, e2.jsx)(ta.div, {
            'data-state': rU(a.open),
            ...i,
            ref: t,
            style: { pointerEvents: 'auto', ...i.style },
          }),
        });
      }),
      rI = 'DialogContent',
      rj = eX.forwardRef((e, t) => {
        let n = rE(rI, e.__scopeDialog),
          { forceMount: i = n.forceMount, ...a } = e,
          o = rg(rI, e.__scopeDialog);
        return (0, e2.jsx)(tS, {
          present: i || o.open,
          children: o.modal ? (0, e2.jsx)(rT, { ...a, ref: t }) : (0, e2.jsx)(rR, { ...a, ref: t }),
        });
      });
    rj.displayName = rI;
    var rT = eX.forwardRef((e, t) => {
        let n = rg(rI, e.__scopeDialog),
          i = eX.useRef(null),
          a = e5(t, n.contentRef, i);
        return (
          eX.useEffect(() => {
            let e = i.current;
            if (e) return ru(e);
          }, []),
          (0, e2.jsx)(rM, {
            ...e,
            ref: a,
            trapFocus: n.open,
            disableOutsidePointerEvents: !0,
            onCloseAutoFocus: eJ(e.onCloseAutoFocus, (e) => {
              e.preventDefault(), n.triggerRef.current?.focus();
            }),
            onPointerDownOutside: eJ(e.onPointerDownOutside, (e) => {
              let t = e.detail.originalEvent,
                n = 0 === t.button && !0 === t.ctrlKey;
              (2 === t.button || n) && e.preventDefault();
            }),
            onFocusOutside: eJ(e.onFocusOutside, (e) => e.preventDefault()),
          })
        );
      }),
      rR = eX.forwardRef((e, t) => {
        let n = rg(rI, e.__scopeDialog),
          i = eX.useRef(!1),
          a = eX.useRef(!1);
        return (0, e2.jsx)(rM, {
          ...e,
          ref: t,
          trapFocus: !1,
          disableOutsidePointerEvents: !1,
          onCloseAutoFocus: (t) => {
            e.onCloseAutoFocus?.(t),
              t.defaultPrevented ||
                (i.current || n.triggerRef.current?.focus(), t.preventDefault()),
              (i.current = !1),
              (a.current = !1);
          },
          onInteractOutside: (t) => {
            e.onInteractOutside?.(t),
              t.defaultPrevented ||
                ((i.current = !0),
                'pointerdown' === t.detail.originalEvent.type && (a.current = !0));
            let o = t.target;
            n.triggerRef.current?.contains(o) && t.preventDefault(),
              'focusin' === t.detail.originalEvent.type && a.current && t.preventDefault();
          },
        });
      }),
      rM = eX.forwardRef((e, t) => {
        let { __scopeDialog: n, trapFocus: i, onOpenAutoFocus: a, onCloseAutoFocus: o, ...s } = e,
          l = rg(rI, n),
          u = eX.useRef(null),
          c = e5(t, u);
        return (
          tO(),
          (0, e2.jsxs)(e2.Fragment, {
            children: [
              (0, e2.jsx)(tg, {
                asChild: !0,
                loop: !0,
                trapped: i,
                onMountAutoFocus: a,
                onUnmountAutoFocus: o,
                children: (0, e2.jsx)(tc, {
                  role: 'dialog',
                  id: l.contentId,
                  'aria-describedby': l.descriptionId,
                  'aria-labelledby': l.titleId,
                  'data-state': rU(l.open),
                  ...s,
                  ref: c,
                  onDismiss: () => l.onOpenChange(!1),
                }),
              }),
              (0, e2.jsxs)(e2.Fragment, {
                children: [
                  (0, e2.jsx)(rV, { titleId: l.titleId }),
                  (0, e2.jsx)(r$, { contentRef: u, descriptionId: l.descriptionId }),
                ],
              }),
            ],
          })
        );
      }),
      rP = 'DialogTitle',
      rN = eX.forwardRef((e, t) => {
        let { __scopeDialog: n, ...i } = e,
          a = rg(rP, n);
        return (0, e2.jsx)(ta.h2, { id: a.titleId, ...i, ref: t });
      });
    rN.displayName = rP;
    var r_ = 'DialogDescription';
    eX.forwardRef((e, t) => {
      let { __scopeDialog: n, ...i } = e,
        a = rg(r_, n);
      return (0, e2.jsx)(ta.p, { id: a.descriptionId, ...i, ref: t });
    }).displayName = r_;
    var rD = 'DialogClose',
      rB = eX.forwardRef((e, t) => {
        let { __scopeDialog: n, ...i } = e,
          a = rg(rD, n);
        return (0, e2.jsx)(ta.button, {
          type: 'button',
          ...i,
          ref: t,
          onClick: eJ(e.onClick, () => a.onOpenChange(!1)),
        });
      });
    function rU(e) {
      return e ? 'open' : 'closed';
    }
    rB.displayName = rD;
    var rF = 'DialogTitleWarning',
      [rL, rz] = e6(rF, { contentName: rI, titleName: rP, docsSlug: 'dialog' }),
      rV = ({ titleId: e }) => {
        let t = rz(rF),
          n = `\`${t.contentName}\` requires a \`${t.titleName}\` for the component to be accessible for screen reader users.

If you want to hide the \`${t.titleName}\`, you can wrap it with our VisuallyHidden component.

For more information, see https://radix-ui.com/primitives/docs/components/${t.docsSlug}`;
        return (
          eX.useEffect(() => {
            e && (document.getElementById(e) || console.error(n));
          }, [n, e]),
          null
        );
      },
      r$ = ({ contentRef: e, descriptionId: t }) => {
        let n = rz('DialogDescriptionWarning'),
          i = `Warning: Missing \`Description\` or \`aria-describedby={undefined}\` for {${n.contentName}}.`;
        return (
          eX.useEffect(() => {
            let n = e.current?.getAttribute('aria-describedby');
            t && n && (document.getElementById(t) || console.warn(i));
          }, [i, e, t]),
          null
        );
      };
    function rW() {
      for (var e, t, n = 0, i = '', a = arguments.length; n < a; n++)
        (e = arguments[n]) &&
          (t = (function e(t) {
            var n,
              i,
              a = '';
            if ('string' == typeof t || 'number' == typeof t) a += t;
            else if ('object' == typeof t)
              if (Array.isArray(t)) {
                var o = t.length;
                for (n = 0; n < o; n++) t[n] && (i = e(t[n])) && (a && (a += ' '), (a += i));
              } else for (i in t) t[i] && (a && (a += ' '), (a += i));
            return a;
          })(e)) &&
          (i && (i += ' '), (i += t));
      return i;
    }
    var rq =
      (((B = rq || {}).Mainnet = 'mainnet'),
      (B.Devnet = 'devnet'),
      (B.Testnet = 'testnet'),
      (B.Localnet = 'localnet'),
      (B.Custom = 'custom'),
      B);
    let rK = Object.values(
      (function () {
        let e;
        try {
          e = JSON.parse(
            '{\n    "mainnet": {\n        "id": "mainnet",\n        "name": "Mainnet",\n        "url": "https://api.mainnet.iota.cafe",\n        "graphql": "https://graphql.mainnet.iota.cafe",\n        "explorer": "https://explorer.rebased.iota.org",\n        "chain": "iota:mainnet"\n    },\n    "testnet": {\n        "id": "testnet",\n        "name": "Testnet",\n        "url": "https://api.testnet.iota.cafe",\n        "graphql": "https://graphql.testnet.iota.cafe",\n        "explorer": "https://explorer.rebased.iota.org",\n        "chain": "iota:testnet",\n        "faucet": "https://faucet.testnet.iota.cafe",\n        "kiosk": {\n            "royaltyRulePackageId": "0x975f749f57701209454e4b9b9e33825ccb6a9abf57de2ce86979e5fa86c343f2",\n            "kioskLockRulePackageId": "0x975f749f57701209454e4b9b9e33825ccb6a9abf57de2ce86979e5fa86c343f2",\n            "floorPriceRulePackageId": "0x975f749f57701209454e4b9b9e33825ccb6a9abf57de2ce86979e5fa86c343f2",\n            "personalKioskRulePackageId": "0x975f749f57701209454e4b9b9e33825ccb6a9abf57de2ce86979e5fa86c343f2"\n        }\n    },\n    "devnet": {\n        "id": "devnet",\n        "name": "Devnet",\n        "url": "https://api.devnet.iota.cafe",\n        "graphql": "https://graphql.devnet.iota.cafe",\n        "explorer": "https://explorer.rebased.iota.org",\n        "chain": "iota:devnet",\n        "faucet": "https://faucet.devnet.iota.cafe"\n    },\n    "localnet": {\n        "id": "localnet",\n        "name": "Localnet",\n        "url": "http://localhost:9000",\n        "graphql": "http://localhost:9125",\n        "explorer": "http://localhost:3000",\n        "chain": "iota:local",\n        "faucet": "http://localhost:9123"\n    }\n}'
          );
        } catch {
          throw Error('Failed to parse env var "IOTA_NETWORKS".');
        }
        return e;
      })()
    ).map((e) => e.chain);
    function rG(e) {
      return rK.includes(e) || 'iota' === e.split(':')[0];
    }
    var rH = e.i(47167),
      rZ = {
        setTimeout: (e, t) => setTimeout(e, t),
        clearTimeout: (e) => clearTimeout(e),
        setInterval: (e, t) => setInterval(e, t),
        clearInterval: (e) => clearInterval(e),
      },
      rY = new (class {
        #e = rZ;
        #t = !1;
        setTimeoutProvider(e) {
          this.#e = e;
        }
        setTimeout(e, t) {
          return this.#e.setTimeout(e, t);
        }
        clearTimeout(e) {
          this.#e.clearTimeout(e);
        }
        setInterval(e, t) {
          return this.#e.setInterval(e, t);
        }
        clearInterval(e) {
          this.#e.clearInterval(e);
        }
      })(),
      rQ =
        ((a = []),
        (o = 0),
        (s = (e) => {
          e();
        }),
        (l = (e) => {
          e();
        }),
        (u = function (e) {
          setTimeout(e, 0);
        }),
        {
          batch: (e) => {
            let t;
            o++;
            try {
              t = e();
            } finally {
              let e;
              --o ||
                ((e = a),
                (a = []),
                e.length &&
                  u(() => {
                    l(() => {
                      e.forEach((e) => {
                        s(e);
                      });
                    });
                  }));
            }
            return t;
          },
          batchCalls:
            (e) =>
            (...t) => {
              c(() => {
                e(...t);
              });
            },
          schedule: (c = (e) => {
            o
              ? a.push(e)
              : u(() => {
                  s(e);
                });
          }),
          setNotifyFunction: (e) => {
            s = e;
          },
          setBatchNotifyFunction: (e) => {
            l = e;
          },
          setScheduler: (e) => {
            u = e;
          },
        });
    e.s(['notifyManager', () => rQ], 40143);
    var rX = 'undefined' == typeof window || 'Deno' in globalThis;
    function rJ() {}
    function r0(e, t) {
      return 'function' == typeof e ? e(t) : e;
    }
    function r1(e) {
      return 'number' == typeof e && e >= 0 && e !== 1 / 0;
    }
    function r5(e, t) {
      return Math.max(e + (t || 0) - Date.now(), 0);
    }
    function r2(e, t) {
      return 'function' == typeof e ? e(t) : e;
    }
    function r6(e, t) {
      return 'function' == typeof e ? e(t) : e;
    }
    function r3(e, t) {
      let { type: n = 'all', exact: i, fetchStatus: a, predicate: o, queryKey: s, stale: l } = e;
      if (s) {
        if (i) {
          if (t.queryHash !== r8(s, t.options)) return !1;
        } else if (!r7(t.queryKey, s)) return !1;
      }
      if ('all' !== n) {
        let e = t.isActive();
        if (('active' === n && !e) || ('inactive' === n && e)) return !1;
      }
      return (
        ('boolean' != typeof l || t.isStale() === l) &&
        (!a || a === t.state.fetchStatus) &&
        (!o || !!o(t))
      );
    }
    function r4(e, t) {
      let { exact: n, status: i, predicate: a, mutationKey: o } = e;
      if (o) {
        if (!t.options.mutationKey) return !1;
        if (n) {
          if (r9(t.options.mutationKey) !== r9(o)) return !1;
        } else if (!r7(t.options.mutationKey, o)) return !1;
      }
      return (!i || t.state.status === i) && (!a || !!a(t));
    }
    function r8(e, t) {
      return (t?.queryKeyHashFn || r9)(e);
    }
    function r9(e) {
      return JSON.stringify(e, (e, t) =>
        ni(t)
          ? Object.keys(t)
              .sort()
              .reduce((e, n) => ((e[n] = t[n]), e), {})
          : t
      );
    }
    function r7(e, t) {
      return (
        e === t ||
        (typeof e == typeof t &&
          !!e &&
          !!t &&
          'object' == typeof e &&
          'object' == typeof t &&
          Object.keys(t).every((n) => r7(e[n], t[n])))
      );
    }
    var ne = Object.prototype.hasOwnProperty;
    function nt(e, t) {
      if (e === t) return e;
      let n = nn(e) && nn(t);
      if (!n && !(ni(e) && ni(t))) return t;
      let i = (n ? e : Object.keys(e)).length,
        a = n ? t : Object.keys(t),
        o = a.length,
        s = n ? Array(o) : {},
        l = 0;
      for (let u = 0; u < o; u++) {
        let o = n ? u : a[u],
          c = e[o],
          d = t[o];
        if (c === d) {
          (s[o] = c), (n ? u < i : ne.call(e, o)) && l++;
          continue;
        }
        if (null === c || null === d || 'object' != typeof c || 'object' != typeof d) {
          s[o] = d;
          continue;
        }
        let f = nt(c, d);
        (s[o] = f), f === c && l++;
      }
      return i === o && l === i ? e : s;
    }
    function nr(e, t) {
      if (!t || Object.keys(e).length !== Object.keys(t).length) return !1;
      for (let n in e) if (e[n] !== t[n]) return !1;
      return !0;
    }
    function nn(e) {
      return Array.isArray(e) && e.length === Object.keys(e).length;
    }
    function ni(e) {
      if (!na(e)) return !1;
      let t = e.constructor;
      if (void 0 === t) return !0;
      let n = t.prototype;
      return (
        !!na(n) &&
        !!n.hasOwnProperty('isPrototypeOf') &&
        Object.getPrototypeOf(e) === Object.prototype
      );
    }
    function na(e) {
      return '[object Object]' === Object.prototype.toString.call(e);
    }
    function no(e) {
      return new Promise((t) => {
        rY.setTimeout(t, e);
      });
    }
    function ns(e, t, n) {
      return 'function' == typeof n.structuralSharing
        ? n.structuralSharing(e, t)
        : !1 !== n.structuralSharing
        ? nt(e, t)
        : t;
    }
    function nl(e, t, n = 0) {
      let i = [...e, t];
      return n && i.length > n ? i.slice(1) : i;
    }
    function nu(e, t, n = 0) {
      let i = [t, ...e];
      return n && i.length > n ? i.slice(0, -1) : i;
    }
    var nc = Symbol();
    function nd(e, t) {
      return !e.queryFn && t?.initialPromise
        ? () => t.initialPromise
        : e.queryFn && e.queryFn !== nc
        ? e.queryFn
        : () => Promise.reject(Error(`Missing queryFn: '${e.queryHash}'`));
    }
    function nf(e, t) {
      return 'function' == typeof e ? e(...t) : !!e;
    }
    e.s(
      [
        'addToEnd',
        () => nl,
        'addToStart',
        () => nu,
        'ensureQueryFn',
        () => nd,
        'functionalUpdate',
        () => r0,
        'hashKey',
        () => r9,
        'hashQueryKeyByOptions',
        () => r8,
        'isServer',
        () => rX,
        'isValidTimeout',
        () => r1,
        'matchMutation',
        () => r4,
        'matchQuery',
        () => r3,
        'noop',
        () => rJ,
        'partialMatchKey',
        () => r7,
        'replaceData',
        () => ns,
        'replaceEqualDeep',
        () => nt,
        'resolveEnabled',
        () => r6,
        'resolveStaleTime',
        () => r2,
        'shallowEqualObjects',
        () => nr,
        'shouldThrowError',
        () => nf,
        'skipToken',
        () => nc,
        'sleep',
        () => no,
        'timeUntilStale',
        () => r5,
      ],
      19273
    );
    var nh = class {
        #r;
        destroy() {
          this.clearGcTimeout();
        }
        scheduleGc() {
          this.clearGcTimeout(),
            r1(this.gcTime) &&
              (this.#r = rY.setTimeout(() => {
                this.optionalRemove();
              }, this.gcTime));
        }
        updateGcTime(e) {
          this.gcTime = Math.max(this.gcTime || 0, e ?? (rX ? 1 / 0 : 3e5));
        }
        clearGcTimeout() {
          this.#r && (rY.clearTimeout(this.#r), (this.#r = void 0));
        }
      },
      np = class {
        constructor() {
          (this.listeners = new Set()), (this.subscribe = this.subscribe.bind(this));
        }
        subscribe(e) {
          return (
            this.listeners.add(e),
            this.onSubscribe(),
            () => {
              this.listeners.delete(e), this.onUnsubscribe();
            }
          );
        }
        hasListeners() {
          return this.listeners.size > 0;
        }
        onSubscribe() {}
        onUnsubscribe() {}
      };
    e.s(['Subscribable', () => np], 15823);
    var nm = new (class extends np {
      #n;
      #i;
      #a;
      constructor() {
        super(),
          (this.#a = (e) => {
            if (!rX && window.addEventListener) {
              let t = () => e();
              return (
                window.addEventListener('visibilitychange', t, !1),
                () => {
                  window.removeEventListener('visibilitychange', t);
                }
              );
            }
          });
      }
      onSubscribe() {
        this.#i || this.setEventListener(this.#a);
      }
      onUnsubscribe() {
        this.hasListeners() || (this.#i?.(), (this.#i = void 0));
      }
      setEventListener(e) {
        (this.#a = e),
          this.#i?.(),
          (this.#i = e((e) => {
            'boolean' == typeof e ? this.setFocused(e) : this.onFocus();
          }));
      }
      setFocused(e) {
        this.#n !== e && ((this.#n = e), this.onFocus());
      }
      onFocus() {
        let e = this.isFocused();
        this.listeners.forEach((t) => {
          t(e);
        });
      }
      isFocused() {
        return 'boolean' == typeof this.#n
          ? this.#n
          : globalThis.document?.visibilityState !== 'hidden';
      }
    })();
    e.s(['focusManager', () => nm], 75555);
    var ng = new (class extends np {
      #o = !0;
      #i;
      #a;
      constructor() {
        super(),
          (this.#a = (e) => {
            if (!rX && window.addEventListener) {
              let t = () => e(!0),
                n = () => e(!1);
              return (
                window.addEventListener('online', t, !1),
                window.addEventListener('offline', n, !1),
                () => {
                  window.removeEventListener('online', t), window.removeEventListener('offline', n);
                }
              );
            }
          });
      }
      onSubscribe() {
        this.#i || this.setEventListener(this.#a);
      }
      onUnsubscribe() {
        this.hasListeners() || (this.#i?.(), (this.#i = void 0));
      }
      setEventListener(e) {
        (this.#a = e), this.#i?.(), (this.#i = e(this.setOnline.bind(this)));
      }
      setOnline(e) {
        this.#o !== e &&
          ((this.#o = e),
          this.listeners.forEach((t) => {
            t(e);
          }));
      }
      isOnline() {
        return this.#o;
      }
    })();
    function ny() {
      let e,
        t,
        n = new Promise((n, i) => {
          (e = n), (t = i);
        });
      function i(e) {
        Object.assign(n, e), delete n.resolve, delete n.reject;
      }
      return (
        (n.status = 'pending'),
        n.catch(() => {}),
        (n.resolve = (t) => {
          i({ status: 'fulfilled', value: t }), e(t);
        }),
        (n.reject = (e) => {
          i({ status: 'rejected', reason: e }), t(e);
        }),
        n
      );
    }
    function nb(e) {
      return Math.min(1e3 * 2 ** e, 3e4);
    }
    function nv(e) {
      return (e ?? 'online') !== 'online' || ng.isOnline();
    }
    e.s(['onlineManager', () => ng], 14448);
    var nw = class extends Error {
      constructor(e) {
        super('CancelledError'), (this.revert = e?.revert), (this.silent = e?.silent);
      }
    };
    function nx(e) {
      let t,
        n = !1,
        i = 0,
        a = ny(),
        o = () => nm.isFocused() && ('always' === e.networkMode || ng.isOnline()) && e.canRun(),
        s = () => nv(e.networkMode) && e.canRun(),
        l = (e) => {
          'pending' === a.status && (t?.(), a.resolve(e));
        },
        u = (e) => {
          'pending' === a.status && (t?.(), a.reject(e));
        },
        c = () =>
          new Promise((n) => {
            (t = (e) => {
              ('pending' !== a.status || o()) && n(e);
            }),
              e.onPause?.();
          }).then(() => {
            (t = void 0), 'pending' === a.status && e.onContinue?.();
          }),
        d = () => {
          let t;
          if ('pending' !== a.status) return;
          let s = 0 === i ? e.initialPromise : void 0;
          try {
            t = s ?? e.fn();
          } catch (e) {
            t = Promise.reject(e);
          }
          Promise.resolve(t)
            .then(l)
            .catch((t) => {
              if ('pending' !== a.status) return;
              let s = e.retry ?? 3 * !rX,
                l = e.retryDelay ?? nb,
                f = 'function' == typeof l ? l(i, t) : l,
                h =
                  !0 === s ||
                  ('number' == typeof s && i < s) ||
                  ('function' == typeof s && s(i, t));
              n || !h
                ? u(t)
                : (i++,
                  e.onFail?.(i, t),
                  no(f)
                    .then(() => (o() ? void 0 : c()))
                    .then(() => {
                      n ? u(t) : d();
                    }));
            });
        };
      return {
        promise: a,
        status: () => a.status,
        cancel: (t) => {
          if ('pending' === a.status) {
            let n = new nw(t);
            u(n), e.onCancel?.(n);
          }
        },
        continue: () => (t?.(), a),
        cancelRetry: () => {
          n = !0;
        },
        continueRetry: () => {
          n = !1;
        },
        canStart: s,
        start: () => (s() ? d() : c().then(d), a),
      };
    }
    var nE = class extends nh {
      #s;
      #l;
      #u;
      #c;
      constructor(e) {
        super(),
          (this.#s = e.client),
          (this.mutationId = e.mutationId),
          (this.#u = e.mutationCache),
          (this.#l = []),
          (this.state = e.state || nS()),
          this.setOptions(e.options),
          this.scheduleGc();
      }
      setOptions(e) {
        (this.options = e), this.updateGcTime(this.options.gcTime);
      }
      get meta() {
        return this.options.meta;
      }
      addObserver(e) {
        this.#l.includes(e) ||
          (this.#l.push(e),
          this.clearGcTimeout(),
          this.#u.notify({ type: 'observerAdded', mutation: this, observer: e }));
      }
      removeObserver(e) {
        (this.#l = this.#l.filter((t) => t !== e)),
          this.scheduleGc(),
          this.#u.notify({ type: 'observerRemoved', mutation: this, observer: e });
      }
      optionalRemove() {
        this.#l.length ||
          ('pending' === this.state.status ? this.scheduleGc() : this.#u.remove(this));
      }
      continue() {
        return this.#c?.continue() ?? this.execute(this.state.variables);
      }
      async execute(e) {
        let t = () => {
            this.#d({ type: 'continue' });
          },
          n = { client: this.#s, meta: this.options.meta, mutationKey: this.options.mutationKey };
        this.#c = nx({
          fn: () =>
            this.options.mutationFn
              ? this.options.mutationFn(e, n)
              : Promise.reject(Error('No mutationFn found')),
          onFail: (e, t) => {
            this.#d({ type: 'failed', failureCount: e, error: t });
          },
          onPause: () => {
            this.#d({ type: 'pause' });
          },
          onContinue: t,
          retry: this.options.retry ?? 0,
          retryDelay: this.options.retryDelay,
          networkMode: this.options.networkMode,
          canRun: () => this.#u.canRun(this),
        });
        let i = 'pending' === this.state.status,
          a = !this.#c.canStart();
        try {
          if (i) t();
          else {
            this.#d({ type: 'pending', variables: e, isPaused: a }),
              await this.#u.config.onMutate?.(e, this, n);
            let t = await this.options.onMutate?.(e, n);
            t !== this.state.context &&
              this.#d({ type: 'pending', context: t, variables: e, isPaused: a });
          }
          let o = await this.#c.start();
          return (
            await this.#u.config.onSuccess?.(o, e, this.state.context, this, n),
            await this.options.onSuccess?.(o, e, this.state.context, n),
            await this.#u.config.onSettled?.(
              o,
              null,
              this.state.variables,
              this.state.context,
              this,
              n
            ),
            await this.options.onSettled?.(o, null, e, this.state.context, n),
            this.#d({ type: 'success', data: o }),
            o
          );
        } catch (t) {
          try {
            throw (
              (await this.#u.config.onError?.(t, e, this.state.context, this, n),
              await this.options.onError?.(t, e, this.state.context, n),
              await this.#u.config.onSettled?.(
                void 0,
                t,
                this.state.variables,
                this.state.context,
                this,
                n
              ),
              await this.options.onSettled?.(void 0, t, e, this.state.context, n),
              t)
            );
          } finally {
            this.#d({ type: 'error', error: t });
          }
        } finally {
          this.#u.runNext(this);
        }
      }
      #d(e) {
        (this.state = ((t) => {
          switch (e.type) {
            case 'failed':
              return { ...t, failureCount: e.failureCount, failureReason: e.error };
            case 'pause':
              return { ...t, isPaused: !0 };
            case 'continue':
              return { ...t, isPaused: !1 };
            case 'pending':
              return {
                ...t,
                context: e.context,
                data: void 0,
                failureCount: 0,
                failureReason: null,
                error: null,
                isPaused: e.isPaused,
                status: 'pending',
                variables: e.variables,
                submittedAt: Date.now(),
              };
            case 'success':
              return {
                ...t,
                data: e.data,
                failureCount: 0,
                failureReason: null,
                error: null,
                status: 'success',
                isPaused: !1,
              };
            case 'error':
              return {
                ...t,
                data: void 0,
                error: e.error,
                failureCount: t.failureCount + 1,
                failureReason: e.error,
                isPaused: !1,
                status: 'error',
              };
          }
        })(this.state)),
          rQ.batch(() => {
            this.#l.forEach((t) => {
              t.onMutationUpdate(e);
            }),
              this.#u.notify({ mutation: this, type: 'updated', action: e });
          });
      }
    };
    function nS() {
      return {
        context: void 0,
        data: void 0,
        error: null,
        failureCount: 0,
        failureReason: null,
        isPaused: !1,
        status: 'idle',
        variables: void 0,
        submittedAt: 0,
      };
    }
    e.s(['Mutation', () => nE, 'getDefaultState', () => nS], 14272);
    var nC = class extends np {
        #s;
        #f = void 0;
        #h;
        #p;
        constructor(e, t) {
          super(), (this.#s = e), this.setOptions(t), this.bindMethods(), this.#m();
        }
        bindMethods() {
          (this.mutate = this.mutate.bind(this)), (this.reset = this.reset.bind(this));
        }
        setOptions(e) {
          let t = this.options;
          (this.options = this.#s.defaultMutationOptions(e)),
            nr(this.options, t) ||
              this.#s
                .getMutationCache()
                .notify({ type: 'observerOptionsUpdated', mutation: this.#h, observer: this }),
            t?.mutationKey &&
            this.options.mutationKey &&
            r9(t.mutationKey) !== r9(this.options.mutationKey)
              ? this.reset()
              : this.#h?.state.status === 'pending' && this.#h.setOptions(this.options);
        }
        onUnsubscribe() {
          this.hasListeners() || this.#h?.removeObserver(this);
        }
        onMutationUpdate(e) {
          this.#m(), this.#g(e);
        }
        getCurrentResult() {
          return this.#f;
        }
        reset() {
          this.#h?.removeObserver(this), (this.#h = void 0), this.#m(), this.#g();
        }
        mutate(e, t) {
          return (
            (this.#p = t),
            this.#h?.removeObserver(this),
            (this.#h = this.#s.getMutationCache().build(this.#s, this.options)),
            this.#h.addObserver(this),
            this.#h.execute(e)
          );
        }
        #m() {
          let e = this.#h?.state ?? nS();
          this.#f = {
            ...e,
            isPending: 'pending' === e.status,
            isSuccess: 'success' === e.status,
            isError: 'error' === e.status,
            isIdle: 'idle' === e.status,
            mutate: this.mutate,
            reset: this.reset,
          };
        }
        #g(e) {
          rQ.batch(() => {
            if (this.#p && this.hasListeners()) {
              let t = this.#f.variables,
                n = this.#f.context,
                i = {
                  client: this.#s,
                  meta: this.options.meta,
                  mutationKey: this.options.mutationKey,
                };
              e?.type === 'success'
                ? (this.#p.onSuccess?.(e.data, t, n, i), this.#p.onSettled?.(e.data, null, t, n, i))
                : e?.type === 'error' &&
                  (this.#p.onError?.(e.error, t, n, i),
                  this.#p.onSettled?.(void 0, e.error, t, n, i));
            }
            this.listeners.forEach((e) => {
              e(this.#f);
            });
          });
        }
      },
      nk = eX.createContext(void 0),
      nO = (e) => {
        let t = eX.useContext(nk);
        if (e) return e;
        if (!t) throw Error('No QueryClient set, use QueryClientProvider to set one');
        return t;
      },
      nA = ({ client: e, children: t }) => (
        eX.useEffect(
          () => (
            e.mount(),
            () => {
              e.unmount();
            }
          ),
          [e]
        ),
        (0, e2.jsx)(nk.Provider, { value: e, children: t })
      );
    function nI(e, t) {
      let n = nO(t),
        [i] = eX.useState(() => new nC(n, e));
      eX.useEffect(() => {
        i.setOptions(e);
      }, [i, e]);
      let a = eX.useSyncExternalStore(
          eX.useCallback((e) => i.subscribe(rQ.batchCalls(e)), [i]),
          () => i.getCurrentResult(),
          () => i.getCurrentResult()
        ),
        o = eX.useCallback(
          (e, t) => {
            i.mutate(e, t).catch(rJ);
          },
          [i]
        );
      if (a.error && nf(i.options.throwOnError, [a.error])) throw a.error;
      return { ...a, mutate: o, mutateAsync: a.mutate };
    }
    e.s(['QueryClientProvider', () => nA, 'useQueryClient', () => nO], 12598);
    let nj = {
        get url() {
          return `file://${e.P('node_modules/zustand/esm/vanilla.mjs')}`;
        },
      },
      nT = (e) => {
        let t,
          n = new Set(),
          i = (e, i) => {
            let a = 'function' == typeof e ? e(t) : e;
            if (!Object.is(a, t)) {
              let e = t;
              (t = (null != i ? i : 'object' != typeof a || null === a)
                ? a
                : Object.assign({}, t, a)),
                n.forEach((n) => n(t, e));
            }
          },
          a = () => t,
          o = {
            setState: i,
            getState: a,
            getInitialState: () => s,
            subscribe: (e) => (n.add(e), () => n.delete(e)),
            destroy: () => {
              (nj.env ? nj.env.MODE : void 0) !== 'production' &&
                console.warn(
                  '[DEPRECATED] The `destroy` method will be unsupported in a future version. Instead use unsubscribe function returned by subscribe. Everything will be garbage-collected if store is garbage-collected.'
                ),
                n.clear();
            },
          },
          s = (t = e(i, a, o));
        return o;
      };
    var nR = e.i(30224);
    let nM = {
        get url() {
          return `file://${e.P('node_modules/zustand/esm/index.mjs')}`;
        },
      },
      { useDebugValue: nP } = eX.default,
      { useSyncExternalStoreWithSelector: nN } = nR.default;
    var n_ = function (e, t, n, i) {
        if ('a' === n && !i) throw TypeError('Private accessor was defined without a getter');
        if ('function' == typeof t ? e !== t || !i : !t.has(e))
          throw TypeError(
            'Cannot read private member from an object whose class did not declare it'
          );
        return 'm' === n ? i : 'a' === n ? i.call(e) : i ? i.value : t.get(e);
      },
      nD = function (e, t, n, i, a) {
        if ('m' === i) throw TypeError('Private method is not writable');
        if ('a' === i && !a) throw TypeError('Private accessor was defined without a setter');
        if ('function' == typeof t ? e !== t || !a : !t.has(e))
          throw TypeError(
            'Cannot write private member to an object whose class did not declare it'
          );
        return 'a' === i ? a.call(e, n) : a ? (a.value = n) : t.set(e, n), n;
      };
    let nB = new Set(),
      nU = {};
    function nF() {
      if (
        d ||
        ((d = Object.freeze({ register: nL, get: nz, on: nV })), 'undefined' == typeof window)
      )
        return d;
      let e = Object.freeze({ register: nL });
      try {
        window.addEventListener('wallet-standard:register-wallet', ({ detail: t }) => t(e));
      } catch (e) {
        console.error('wallet-standard:register-wallet event listener could not be added\n', e);
      }
      try {
        window.dispatchEvent(new nW(e));
      } catch (e) {
        console.error('wallet-standard:app-ready event could not be dispatched\n', e);
      }
      return d;
    }
    function nL(...e) {
      return (e = e.filter((e) => !nB.has(e))).length
        ? (e.forEach((e) => {
            (t = void 0), nB.add(e);
          }),
          nU.register?.forEach((t) => n$(() => t(...e))),
          function () {
            e.forEach((e) => {
              (t = void 0), nB.delete(e);
            }),
              nU.unregister?.forEach((t) => n$(() => t(...e)));
          })
        : () => {};
    }
    function nz() {
      return t || (t = [...nB]), t;
    }
    function nV(e, t) {
      return (
        nU[e]?.push(t) || (nU[e] = [t]),
        function () {
          nU[e] = nU[e]?.filter((e) => t !== e);
        }
      );
    }
    function n$(e) {
      try {
        e();
      } catch (e) {
        console.error(e);
      }
    }
    class nW extends Event {
      get detail() {
        return n_(this, X, 'f');
      }
      get type() {
        return 'wallet-standard:app-ready';
      }
      constructor(e) {
        super('wallet-standard:app-ready', { bubbles: !1, cancelable: !1, composed: !1 }),
          X.set(this, void 0),
          nD(this, X, e, 'f');
      }
      preventDefault() {
        throw Error('preventDefault cannot be called');
      }
      stopImmediatePropagation() {
        throw Error('stopImmediatePropagation cannot be called');
      }
      stopPropagation() {
        throw Error('stopPropagation cannot be called');
      }
    }
    X = new WeakMap();
    let nq = ['standard:connect', 'standard:events'];
    var nK = Symbol.for('react.lazy'),
      nG = eX[' use '.trim().toString()];
    function nH(e) {
      var t;
      return (
        null != e &&
        'object' == typeof e &&
        '$$typeof' in e &&
        e.$$typeof === nK &&
        '_payload' in e &&
        'object' == typeof (t = e._payload) &&
        null !== t &&
        'then' in t
      );
    }
    var nZ =
        (((j = eX.forwardRef((e, t) => {
          let { children: n, ...i } = e;
          if ((nH(n) && 'function' == typeof nG && (n = nG(n._payload)), eX.isValidElement(n))) {
            var a;
            let e,
              o,
              s =
                ((a = n),
                (o =
                  (e = Object.getOwnPropertyDescriptor(a.props, 'ref')?.get) &&
                  'isReactWarning' in e &&
                  e.isReactWarning)
                  ? a.ref
                  : (o =
                      (e = Object.getOwnPropertyDescriptor(a, 'ref')?.get) &&
                      'isReactWarning' in e &&
                      e.isReactWarning)
                  ? a.props.ref
                  : a.props.ref || a.ref),
              l = (function (e, t) {
                let n = { ...t };
                for (let i in t) {
                  let a = e[i],
                    o = t[i];
                  /^on[A-Z]/.test(i)
                    ? a && o
                      ? (n[i] = (...e) => {
                          let t = o(...e);
                          return a(...e), t;
                        })
                      : a && (n[i] = a)
                    : 'style' === i
                    ? (n[i] = { ...a, ...o })
                    : 'className' === i && (n[i] = [a, o].filter(Boolean).join(' '));
                }
                return { ...e, ...n };
              })(i, n.props);
            return n.type !== eX.Fragment && (l.ref = t ? e1(t, s) : s), eX.cloneElement(n, l);
          }
          return eX.Children.count(n) > 1 ? eX.Children.only(null) : null;
        })).displayName = 'Slot.SlotClone'),
        (f = j),
        ((h = eX.forwardRef((e, t) => {
          let { children: n, ...i } = e;
          nH(n) && 'function' == typeof nG && (n = nG(n._payload));
          let a = eX.Children.toArray(n),
            o = a.find(nQ);
          if (o) {
            let e = o.props.children,
              n = a.map((t) =>
                t !== o
                  ? t
                  : eX.Children.count(e) > 1
                  ? eX.Children.only(null)
                  : eX.isValidElement(e)
                  ? e.props.children
                  : null
              );
            return (0, e2.jsx)(f, {
              ...i,
              ref: t,
              children: eX.isValidElement(e) ? eX.cloneElement(e, void 0, n) : null,
            });
          }
          return (0, e2.jsx)(f, { ...i, ref: t, children: n });
        })).displayName = 'Slot.Slot'),
        h),
      nY = Symbol('radix.slottable');
    function nQ(e) {
      return (
        eX.isValidElement(e) &&
        'function' == typeof e.type &&
        '__radixId' in e.type &&
        e.type.__radixId === nY
      );
    }
    function nX(e, t) {
      var n = Object.keys(e);
      if (Object.getOwnPropertySymbols) {
        var i = Object.getOwnPropertySymbols(e);
        t &&
          (i = i.filter(function (t) {
            return Object.getOwnPropertyDescriptor(e, t).enumerable;
          })),
          n.push.apply(n, i);
      }
      return n;
    }
    function nJ(e) {
      for (var t = 1; t < arguments.length; t++) {
        var n = null != arguments[t] ? arguments[t] : {};
        t % 2
          ? nX(Object(n), !0).forEach(function (t) {
              !(function (e, t, n) {
                var i;
                (t =
                  'symbol' ==
                  typeof (i = (function (e, t) {
                    if ('object' != typeof e || !e) return e;
                    var n = e[Symbol.toPrimitive];
                    if (void 0 !== n) {
                      var i = n.call(e, t || 'default');
                      if ('object' != typeof i) return i;
                      throw TypeError('@@toPrimitive must return a primitive value.');
                    }
                    return ('string' === t ? String : Number)(e);
                  })(t, 'string'))
                    ? i
                    : String(i)) in e
                  ? Object.defineProperty(e, t, {
                      value: n,
                      enumerable: !0,
                      configurable: !0,
                      writable: !0,
                    })
                  : (e[t] = n);
              })(e, t, n[t]);
            })
          : Object.getOwnPropertyDescriptors
          ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n))
          : nX(Object(n)).forEach(function (t) {
              Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t));
            });
      }
      return e;
    }
    function n0(e, t) {
      var n = {};
      for (var i in e) n[i] = t(e[i], i);
      return n;
    }
    var n1 = (e, t, n) => {
        for (var i of Object.keys(e)) {
          var a;
          if (e[i] !== (null != (a = t[i]) ? a : n[i])) return !1;
        }
        return !0;
      },
      n5 = (e) => {
        var t = (t) => {
          var n = e.defaultClassName,
            i = nJ(nJ({}, e.defaultVariants), t);
          for (var a in i) {
            var o,
              s = null != (o = i[a]) ? o : e.defaultVariants[a];
            if (null != s) {
              var l = s;
              'boolean' == typeof l && (l = !0 === l ? 'true' : 'false');
              var u = e.variantClassNames[a][l];
              u && (n += ' ' + u);
            }
          }
          for (var [c, d] of e.compoundVariants) n1(c, i, e.defaultVariants) && (n += ' ' + d);
          return n;
        };
        return (
          (t.variants = () => Object.keys(e.variantClassNames)),
          (t.classNames = {
            get base() {
              return e.defaultClassName.split(' ')[0];
            },
            get variants() {
              return n0(e.variantClassNames, (e) => n0(e, (e) => e.split(' ')[0]));
            },
          }),
          t
        );
      };
    let n2 = (function (e) {
      if (e.length >= 255) throw TypeError('Alphabet too long');
      let t = new Uint8Array(256);
      for (let e = 0; e < t.length; e++) t[e] = 255;
      for (let n = 0; n < e.length; n++) {
        let i = e.charAt(n),
          a = i.charCodeAt(0);
        if (255 !== t[a]) throw TypeError(i + ' is ambiguous');
        t[a] = n;
      }
      let n = e.length,
        i = e.charAt(0),
        a = Math.log(n) / Math.log(256),
        o = Math.log(256) / Math.log(n);
      function s(e) {
        if ('string' != typeof e) throw TypeError('Expected String');
        if (0 === e.length) return new Uint8Array();
        let o = 0,
          s = 0,
          l = 0;
        for (; e[o] === i; ) s++, o++;
        let u = ((e.length - o) * a + 1) >>> 0,
          c = new Uint8Array(u);
        for (; o < e.length; ) {
          let i = e.charCodeAt(o);
          if (i > 255) return;
          let a = t[i];
          if (255 === a) return;
          let s = 0;
          for (let e = u - 1; (0 !== a || s < l) && -1 !== e; e--, s++)
            (a += (n * c[e]) >>> 0), (c[e] = a % 256 >>> 0), (a = (a / 256) >>> 0);
          if (0 !== a) throw Error('Non-zero carry');
          (l = s), o++;
        }
        let d = u - l;
        for (; d !== u && 0 === c[d]; ) d++;
        let f = new Uint8Array(s + (u - d)),
          h = s;
        for (; d !== u; ) f[h++] = c[d++];
        return f;
      }
      return {
        encode: function (t) {
          if (
            (t instanceof Uint8Array ||
              (ArrayBuffer.isView(t)
                ? (t = new Uint8Array(t.buffer, t.byteOffset, t.byteLength))
                : Array.isArray(t) && (t = Uint8Array.from(t))),
            !(t instanceof Uint8Array))
          )
            throw TypeError('Expected Uint8Array');
          if (0 === t.length) return '';
          let a = 0,
            s = 0,
            l = 0,
            u = t.length;
          for (; l !== u && 0 === t[l]; ) l++, a++;
          let c = ((u - l) * o + 1) >>> 0,
            d = new Uint8Array(c);
          for (; l !== u; ) {
            let e = t[l],
              i = 0;
            for (let t = c - 1; (0 !== e || i < s) && -1 !== t; t--, i++)
              (e += (256 * d[t]) >>> 0), (d[t] = e % n >>> 0), (e = (e / n) >>> 0);
            if (0 !== e) throw Error('Non-zero carry');
            (s = i), l++;
          }
          let f = c - s;
          for (; f !== c && 0 === d[f]; ) f++;
          let h = i.repeat(a);
          for (; f < c; ++f) h += e.charAt(d[f]);
          return h;
        },
        decodeUnsafe: s,
        decode: function (e) {
          let t = s(e);
          if (t) return t;
          throw Error('Non-base' + n + ' character');
        },
      };
    })('123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz');
    function n6(e) {
      return Uint8Array.from(atob(e), (e) => e.charCodeAt(0));
    }
    function n3(e) {
      if (e.length < 8192) return btoa(String.fromCharCode(...e));
      let t = '';
      for (let n = 0; n < e.length; n += 8192) t += String.fromCharCode(...e.slice(n, n + 8192));
      return btoa(t);
    }
    function n4(e) {
      let t = e.startsWith('0x') ? e.slice(2) : e,
        n = t.length % 2 == 0 ? t : `0${t}}`,
        i = n.match(/.{2}/g)?.map((e) => parseInt(e, 16)) ?? [];
      return Uint8Array.from(i);
    }
    function n8(e) {
      return e.reduce((e, t) => e + t.toString(16).padStart(2, '0'), '');
    }
    function n9(e) {
      try {
        let t;
        return 32 === ((t = e), n2.decode(t)).length;
      } catch (e) {
        return !1;
      }
    }
    function n7(e) {
      var t, n;
      return (
        (t = e),
        /^(0x|0X)?[a-fA-F0-9]+$/.test(t) &&
          t.length % 2 == 0 &&
          32 == ((n = e), /^(0x|0X)/.test(n) ? (n.length - 2) / 2 : n.length / 2)
      );
    }
    function ie(e, t = !1, n = !1) {
      let i = e.toLowerCase().replace(/ /g, '');
      if (
        (!t && i.startsWith('0x') && (i = i.slice(2)),
        (i = `0x${i.padStart(64, '0')}`),
        !n || n7(i))
      )
        return i;
      throw Error(`Invalid IOTA address: ${e}`);
    }
    function it(e, t = !1, n = !1) {
      return ie(e, t, n);
    }
    function ir(e) {
      if (e.length <= 6) return e;
      let t = 2 * !!e.startsWith('0x');
      return `0x${e.slice(t, t + 4)}\u2026${e.slice(-4)}`;
    }
    function ii(e) {
      var t;
      let n,
        i =
          ((t = e),
          ((n = eX.forwardRef((e, t) => {
            let { children: n, ...i } = e;
            if (eX.isValidElement(n)) {
              var a;
              let e,
                o,
                s =
                  ((a = n),
                  (o =
                    (e = Object.getOwnPropertyDescriptor(a.props, 'ref')?.get) &&
                    'isReactWarning' in e &&
                    e.isReactWarning)
                    ? a.ref
                    : (o =
                        (e = Object.getOwnPropertyDescriptor(a, 'ref')?.get) &&
                        'isReactWarning' in e &&
                        e.isReactWarning)
                    ? a.props.ref
                    : a.props.ref || a.ref),
                l = (function (e, t) {
                  let n = { ...t };
                  for (let i in t) {
                    let a = e[i],
                      o = t[i];
                    /^on[A-Z]/.test(i)
                      ? a && o
                        ? (n[i] = (...e) => {
                            let t = o(...e);
                            return a(...e), t;
                          })
                        : a && (n[i] = a)
                      : 'style' === i
                      ? (n[i] = { ...a, ...o })
                      : 'className' === i && (n[i] = [a, o].filter(Boolean).join(' '));
                  }
                  return { ...e, ...n };
                })(i, n.props);
              return n.type !== eX.Fragment && (l.ref = t ? e1(t, s) : s), eX.cloneElement(n, l);
            }
            return eX.Children.count(n) > 1 ? eX.Children.only(null) : null;
          })).displayName = `${t}.SlotClone`),
          n),
        a = eX.forwardRef((e, t) => {
          let { children: n, ...a } = e,
            o = eX.Children.toArray(n),
            s = o.find(io);
          if (s) {
            let e = s.props.children,
              n = o.map((t) =>
                t !== s
                  ? t
                  : eX.Children.count(e) > 1
                  ? eX.Children.only(null)
                  : eX.isValidElement(e)
                  ? e.props.children
                  : null
              );
            return (0, e2.jsx)(i, {
              ...a,
              ref: t,
              children: eX.isValidElement(e) ? eX.cloneElement(e, void 0, n) : null,
            });
          }
          return (0, e2.jsx)(i, { ...a, ref: t, children: n });
        });
      return (a.displayName = `${e}.Slot`), a;
    }
    var ia = Symbol('radix.slottable');
    function io(e) {
      return (
        eX.isValidElement(e) &&
        'function' == typeof e.type &&
        '__radixId' in e.type &&
        e.type.__radixId === ia
      );
    }
    function is(e) {
      let t = e + 'CollectionProvider',
        [n, i] = e3(t),
        [a, o] = n(t, { collectionRef: { current: null }, itemMap: new Map() }),
        s = (e) => {
          let { scope: t, children: n } = e,
            i = eX.default.useRef(null),
            o = eX.default.useRef(new Map()).current;
          return (0, e2.jsx)(a, { scope: t, itemMap: o, collectionRef: i, children: n });
        };
      s.displayName = t;
      let l = e + 'CollectionSlot',
        u = ii(l),
        c = eX.default.forwardRef((e, t) => {
          let { scope: n, children: i } = e,
            a = e5(t, o(l, n).collectionRef);
          return (0, e2.jsx)(u, { ref: a, children: i });
        });
      c.displayName = l;
      let d = e + 'CollectionItemSlot',
        f = 'data-radix-collection-item',
        h = ii(d),
        p = eX.default.forwardRef((e, t) => {
          let { scope: n, children: i, ...a } = e,
            s = eX.default.useRef(null),
            l = e5(t, s),
            u = o(d, n);
          return (
            eX.default.useEffect(
              () => (u.itemMap.set(s, { ref: s, ...a }), () => void u.itemMap.delete(s))
            ),
            (0, e2.jsx)(h, { ...{ [f]: '' }, ref: l, children: i })
          );
        });
      return (
        (p.displayName = d),
        [
          { Provider: s, Slot: c, ItemSlot: p },
          function (t) {
            let n = o(e + 'CollectionConsumer', t);
            return eX.default.useCallback(() => {
              let e = n.collectionRef.current;
              if (!e) return [];
              let t = Array.from(e.querySelectorAll(`[${f}]`));
              return Array.from(n.itemMap.values()).sort(
                (e, n) => t.indexOf(e.ref.current) - t.indexOf(n.ref.current)
              );
            }, [n.collectionRef, n.itemMap]);
          },
          i,
        ]
      );
    }
    var il = new WeakMap();
    function iu(e, t) {
      var n, i;
      let a, o, s;
      if ('at' in Array.prototype) return Array.prototype.at.call(e, t);
      let l =
        ((n = e),
        (i = t),
        (a = n.length),
        (s = (o = ic(i)) >= 0 ? o : a + o) < 0 || s >= a ? -1 : s);
      return -1 === l ? void 0 : e[l];
    }
    function ic(e) {
      return e != e || 0 === e ? 0 : Math.trunc(e);
    }
    (class e extends Map {
      #y;
      constructor(e) {
        super(e), (this.#y = [...super.keys()]), il.set(this, !0);
      }
      set(e, t) {
        return (
          il.get(this) && (this.has(e) ? (this.#y[this.#y.indexOf(e)] = e) : this.#y.push(e)),
          super.set(e, t),
          this
        );
      }
      insert(e, t, n) {
        let i,
          a = this.has(t),
          o = this.#y.length,
          s = ic(e),
          l = s >= 0 ? s : o + s,
          u = l < 0 || l >= o ? -1 : l;
        if (u === this.size || (a && u === this.size - 1) || -1 === u) return this.set(t, n), this;
        let c = this.size + +!a;
        s < 0 && l++;
        let d = [...this.#y],
          f = !1;
        for (let e = l; e < c; e++)
          if (l === e) {
            let o = d[e];
            d[e] === t && (o = d[e + 1]), a && this.delete(t), (i = this.get(o)), this.set(t, n);
          } else {
            f || d[e - 1] !== t || (f = !0);
            let n = d[f ? e : e - 1],
              a = i;
            (i = this.get(n)), this.delete(n), this.set(n, a);
          }
        return this;
      }
      with(t, n, i) {
        let a = new e(this);
        return a.insert(t, n, i), a;
      }
      before(e) {
        let t = this.#y.indexOf(e) - 1;
        if (!(t < 0)) return this.entryAt(t);
      }
      setBefore(e, t, n) {
        let i = this.#y.indexOf(e);
        return -1 === i ? this : this.insert(i, t, n);
      }
      after(e) {
        let t = this.#y.indexOf(e);
        if (-1 !== (t = -1 === t || t === this.size - 1 ? -1 : t + 1)) return this.entryAt(t);
      }
      setAfter(e, t, n) {
        let i = this.#y.indexOf(e);
        return -1 === i ? this : this.insert(i + 1, t, n);
      }
      first() {
        return this.entryAt(0);
      }
      last() {
        return this.entryAt(-1);
      }
      clear() {
        return (this.#y = []), super.clear();
      }
      delete(e) {
        let t = super.delete(e);
        return t && this.#y.splice(this.#y.indexOf(e), 1), t;
      }
      deleteAt(e) {
        let t = this.keyAt(e);
        return void 0 !== t && this.delete(t);
      }
      at(e) {
        let t = iu(this.#y, e);
        if (void 0 !== t) return this.get(t);
      }
      entryAt(e) {
        let t = iu(this.#y, e);
        if (void 0 !== t) return [t, this.get(t)];
      }
      indexOf(e) {
        return this.#y.indexOf(e);
      }
      keyAt(e) {
        return iu(this.#y, e);
      }
      from(e, t) {
        let n = this.indexOf(e);
        if (-1 === n) return;
        let i = n + t;
        return i < 0 && (i = 0), i >= this.size && (i = this.size - 1), this.at(i);
      }
      keyFrom(e, t) {
        let n = this.indexOf(e);
        if (-1 === n) return;
        let i = n + t;
        return i < 0 && (i = 0), i >= this.size && (i = this.size - 1), this.keyAt(i);
      }
      find(e, t) {
        let n = 0;
        for (let i of this) {
          if (Reflect.apply(e, t, [i, n, this])) return i;
          n++;
        }
      }
      findIndex(e, t) {
        let n = 0;
        for (let i of this) {
          if (Reflect.apply(e, t, [i, n, this])) return n;
          n++;
        }
        return -1;
      }
      filter(t, n) {
        let i = [],
          a = 0;
        for (let e of this) Reflect.apply(t, n, [e, a, this]) && i.push(e), a++;
        return new e(i);
      }
      map(t, n) {
        let i = [],
          a = 0;
        for (let e of this) i.push([e[0], Reflect.apply(t, n, [e, a, this])]), a++;
        return new e(i);
      }
      reduce(...e) {
        let [t, n] = e,
          i = 0,
          a = n ?? this.at(0);
        for (let n of this)
          (a = 0 === i && 1 === e.length ? n : Reflect.apply(t, this, [a, n, i, this])), i++;
        return a;
      }
      reduceRight(...e) {
        let [t, n] = e,
          i = n ?? this.at(-1);
        for (let n = this.size - 1; n >= 0; n--) {
          let a = this.at(n);
          i = n === this.size - 1 && 1 === e.length ? a : Reflect.apply(t, this, [i, a, n, this]);
        }
        return i;
      }
      toSorted(t) {
        return new e([...this.entries()].sort(t));
      }
      toReversed() {
        let t = new e();
        for (let e = this.size - 1; e >= 0; e--) {
          let n = this.keyAt(e),
            i = this.get(n);
          t.set(n, i);
        }
        return t;
      }
      toSpliced(...t) {
        let n = [...this.entries()];
        return n.splice(...t), new e(n);
      }
      slice(t, n) {
        let i = new e(),
          a = this.size - 1;
        if (void 0 === t) return i;
        t < 0 && (t += this.size), void 0 !== n && n > 0 && (a = n - 1);
        for (let e = t; e <= a; e++) {
          let t = this.keyAt(e),
            n = this.get(t);
          i.set(t, n);
        }
        return i;
      }
      every(e, t) {
        let n = 0;
        for (let i of this) {
          if (!Reflect.apply(e, t, [i, n, this])) return !1;
          n++;
        }
        return !0;
      }
      some(e, t) {
        let n = 0;
        for (let i of this) {
          if (Reflect.apply(e, t, [i, n, this])) return !0;
          n++;
        }
        return !1;
      }
    });
    var id = eX.createContext(void 0),
      ih = (e) => {
        let { dir: t, children: n } = e;
        return (0, e2.jsx)(id.Provider, { value: t, children: n });
      };
    function ip(e) {
      let t = eX.useContext(id);
      return e || t || 'ltr';
    }
    e.s(['DirectionProvider', () => ih, 'Provider', () => ih, 'useDirection', () => ip], 86318);
    let im = ['top', 'right', 'bottom', 'left'],
      ig = Math.min,
      iy = Math.max,
      ib = Math.round,
      iv = Math.floor,
      iw = (e) => ({ x: e, y: e }),
      ix = { left: 'right', right: 'left', bottom: 'top', top: 'bottom' },
      iE = { start: 'end', end: 'start' };
    function iS(e, t) {
      return 'function' == typeof e ? e(t) : e;
    }
    function iC(e) {
      return e.split('-')[0];
    }
    function ik(e) {
      return e.split('-')[1];
    }
    function iO(e) {
      return 'x' === e ? 'y' : 'x';
    }
    function iA(e) {
      return 'y' === e ? 'height' : 'width';
    }
    let iI = new Set(['top', 'bottom']);
    function ij(e) {
      return iI.has(iC(e)) ? 'y' : 'x';
    }
    function iT(e) {
      return e.replace(/start|end/g, (e) => iE[e]);
    }
    let iR = ['left', 'right'],
      iM = ['right', 'left'],
      iP = ['top', 'bottom'],
      iN = ['bottom', 'top'];
    function i_(e) {
      return e.replace(/left|right|bottom|top/g, (e) => ix[e]);
    }
    function iD(e) {
      return 'number' != typeof e
        ? { top: 0, right: 0, bottom: 0, left: 0, ...e }
        : { top: e, right: e, bottom: e, left: e };
    }
    function iB(e) {
      let { x: t, y: n, width: i, height: a } = e;
      return { width: i, height: a, top: n, left: t, right: t + i, bottom: n + a, x: t, y: n };
    }
    function iU(e, t, n) {
      let i,
        { reference: a, floating: o } = e,
        s = ij(t),
        l = iO(ij(t)),
        u = iA(l),
        c = iC(t),
        d = 'y' === s,
        f = a.x + a.width / 2 - o.width / 2,
        h = a.y + a.height / 2 - o.height / 2,
        p = a[u] / 2 - o[u] / 2;
      switch (c) {
        case 'top':
          i = { x: f, y: a.y - o.height };
          break;
        case 'bottom':
          i = { x: f, y: a.y + a.height };
          break;
        case 'right':
          i = { x: a.x + a.width, y: h };
          break;
        case 'left':
          i = { x: a.x - o.width, y: h };
          break;
        default:
          i = { x: a.x, y: a.y };
      }
      switch (ik(t)) {
        case 'start':
          i[l] -= p * (n && d ? -1 : 1);
          break;
        case 'end':
          i[l] += p * (n && d ? -1 : 1);
      }
      return i;
    }
    let iF = async (e, t, n) => {
      let {
          placement: i = 'bottom',
          strategy: a = 'absolute',
          middleware: o = [],
          platform: s,
        } = n,
        l = o.filter(Boolean),
        u = await (null == s.isRTL ? void 0 : s.isRTL(t)),
        c = await s.getElementRects({ reference: e, floating: t, strategy: a }),
        { x: d, y: f } = iU(c, i, u),
        h = i,
        p = {},
        m = 0;
      for (let n = 0; n < l.length; n++) {
        let { name: o, fn: g } = l[n],
          {
            x: y,
            y: b,
            data: v,
            reset: w,
          } = await g({
            x: d,
            y: f,
            initialPlacement: i,
            placement: h,
            strategy: a,
            middlewareData: p,
            rects: c,
            platform: s,
            elements: { reference: e, floating: t },
          });
        (d = null != y ? y : d),
          (f = null != b ? b : f),
          (p = { ...p, [o]: { ...p[o], ...v } }),
          w &&
            m <= 50 &&
            (m++,
            'object' == typeof w &&
              (w.placement && (h = w.placement),
              w.rects &&
                (c =
                  !0 === w.rects
                    ? await s.getElementRects({ reference: e, floating: t, strategy: a })
                    : w.rects),
              ({ x: d, y: f } = iU(c, h, u))),
            (n = -1));
      }
      return { x: d, y: f, placement: h, strategy: a, middlewareData: p };
    };
    async function iL(e, t) {
      var n;
      void 0 === t && (t = {});
      let { x: i, y: a, platform: o, rects: s, elements: l, strategy: u } = e,
        {
          boundary: c = 'clippingAncestors',
          rootBoundary: d = 'viewport',
          elementContext: f = 'floating',
          altBoundary: h = !1,
          padding: p = 0,
        } = iS(t, e),
        m = iD(p),
        g = l[h ? ('floating' === f ? 'reference' : 'floating') : f],
        y = iB(
          await o.getClippingRect({
            element:
              null == (n = await (null == o.isElement ? void 0 : o.isElement(g))) || n
                ? g
                : g.contextElement ||
                  (await (null == o.getDocumentElement
                    ? void 0
                    : o.getDocumentElement(l.floating))),
            boundary: c,
            rootBoundary: d,
            strategy: u,
          })
        ),
        b =
          'floating' === f
            ? { x: i, y: a, width: s.floating.width, height: s.floating.height }
            : s.reference,
        v = await (null == o.getOffsetParent ? void 0 : o.getOffsetParent(l.floating)),
        w = ((await (null == o.isElement ? void 0 : o.isElement(v))) &&
          (await (null == o.getScale ? void 0 : o.getScale(v)))) || { x: 1, y: 1 },
        x = iB(
          o.convertOffsetParentRelativeRectToViewportRelativeRect
            ? await o.convertOffsetParentRelativeRectToViewportRelativeRect({
                elements: l,
                rect: b,
                offsetParent: v,
                strategy: u,
              })
            : b
        );
      return {
        top: (y.top - x.top + m.top) / w.y,
        bottom: (x.bottom - y.bottom + m.bottom) / w.y,
        left: (y.left - x.left + m.left) / w.x,
        right: (x.right - y.right + m.right) / w.x,
      };
    }
    function iz(e, t) {
      return {
        top: e.top - t.height,
        right: e.right - t.width,
        bottom: e.bottom - t.height,
        left: e.left - t.width,
      };
    }
    function iV(e) {
      return im.some((t) => e[t] >= 0);
    }
    let i$ = new Set(['left', 'top']);
    async function iW(e, t) {
      let { placement: n, platform: i, elements: a } = e,
        o = await (null == i.isRTL ? void 0 : i.isRTL(a.floating)),
        s = iC(n),
        l = ik(n),
        u = 'y' === ij(n),
        c = i$.has(s) ? -1 : 1,
        d = o && u ? -1 : 1,
        f = iS(t, e),
        {
          mainAxis: h,
          crossAxis: p,
          alignmentAxis: m,
        } = 'number' == typeof f
          ? { mainAxis: f, crossAxis: 0, alignmentAxis: null }
          : {
              mainAxis: f.mainAxis || 0,
              crossAxis: f.crossAxis || 0,
              alignmentAxis: f.alignmentAxis,
            };
      return (
        l && 'number' == typeof m && (p = 'end' === l ? -1 * m : m),
        u ? { x: p * d, y: h * c } : { x: h * c, y: p * d }
      );
    }
    function iq() {
      return 'undefined' != typeof window;
    }
    function iK(e) {
      return iZ(e) ? (e.nodeName || '').toLowerCase() : '#document';
    }
    function iG(e) {
      var t;
      return (null == e || null == (t = e.ownerDocument) ? void 0 : t.defaultView) || window;
    }
    function iH(e) {
      var t;
      return null == (t = (iZ(e) ? e.ownerDocument : e.document) || window.document)
        ? void 0
        : t.documentElement;
    }
    function iZ(e) {
      return !!iq() && (e instanceof Node || e instanceof iG(e).Node);
    }
    function iY(e) {
      return !!iq() && (e instanceof Element || e instanceof iG(e).Element);
    }
    function iQ(e) {
      return !!iq() && (e instanceof HTMLElement || e instanceof iG(e).HTMLElement);
    }
    function iX(e) {
      return (
        !!iq() &&
        'undefined' != typeof ShadowRoot &&
        (e instanceof ShadowRoot || e instanceof iG(e).ShadowRoot)
      );
    }
    let iJ = new Set(['inline', 'contents']);
    function i0(e) {
      let { overflow: t, overflowX: n, overflowY: i, display: a } = at(e);
      return /auto|scroll|overlay|hidden|clip/.test(t + i + n) && !iJ.has(a);
    }
    let i1 = new Set(['table', 'td', 'th']),
      i5 = [':popover-open', ':modal'];
    function i2(e) {
      return i5.some((t) => {
        try {
          return e.matches(t);
        } catch (e) {
          return !1;
        }
      });
    }
    let i6 = ['transform', 'translate', 'scale', 'rotate', 'perspective'],
      i3 = ['transform', 'translate', 'scale', 'rotate', 'perspective', 'filter'],
      i4 = ['paint', 'layout', 'strict', 'content'];
    function i8(e) {
      let t = i9(),
        n = iY(e) ? at(e) : e;
      return (
        i6.some((e) => !!n[e] && 'none' !== n[e]) ||
        (!!n.containerType && 'normal' !== n.containerType) ||
        (!t && !!n.backdropFilter && 'none' !== n.backdropFilter) ||
        (!t && !!n.filter && 'none' !== n.filter) ||
        i3.some((e) => (n.willChange || '').includes(e)) ||
        i4.some((e) => (n.contain || '').includes(e))
      );
    }
    function i9() {
      return (
        'undefined' != typeof CSS &&
        !!CSS.supports &&
        CSS.supports('-webkit-backdrop-filter', 'none')
      );
    }
    let i7 = new Set(['html', 'body', '#document']);
    function ae(e) {
      return i7.has(iK(e));
    }
    function at(e) {
      return iG(e).getComputedStyle(e);
    }
    function ar(e) {
      return iY(e)
        ? { scrollLeft: e.scrollLeft, scrollTop: e.scrollTop }
        : { scrollLeft: e.scrollX, scrollTop: e.scrollY };
    }
    function an(e) {
      if ('html' === iK(e)) return e;
      let t = e.assignedSlot || e.parentNode || (iX(e) && e.host) || iH(e);
      return iX(t) ? t.host : t;
    }
    function ai(e, t, n) {
      var i;
      void 0 === t && (t = []), void 0 === n && (n = !0);
      let a = (function e(t) {
          let n = an(t);
          return ae(n)
            ? t.ownerDocument
              ? t.ownerDocument.body
              : t.body
            : iQ(n) && i0(n)
            ? n
            : e(n);
        })(e),
        o = a === (null == (i = e.ownerDocument) ? void 0 : i.body),
        s = iG(a);
      if (o) {
        let e = aa(s);
        return t.concat(s, s.visualViewport || [], i0(a) ? a : [], e && n ? ai(e) : []);
      }
      return t.concat(a, ai(a, [], n));
    }
    function aa(e) {
      return e.parent && Object.getPrototypeOf(e.parent) ? e.frameElement : null;
    }
    function ao(e) {
      let t = at(e),
        n = parseFloat(t.width) || 0,
        i = parseFloat(t.height) || 0,
        a = iQ(e),
        o = a ? e.offsetWidth : n,
        s = a ? e.offsetHeight : i,
        l = ib(n) !== o || ib(i) !== s;
      return l && ((n = o), (i = s)), { width: n, height: i, $: l };
    }
    function as(e) {
      return iY(e) ? e : e.contextElement;
    }
    function al(e) {
      let t = as(e);
      if (!iQ(t)) return iw(1);
      let n = t.getBoundingClientRect(),
        { width: i, height: a, $: o } = ao(t),
        s = (o ? ib(n.width) : n.width) / i,
        l = (o ? ib(n.height) : n.height) / a;
      return (
        (s && Number.isFinite(s)) || (s = 1), (l && Number.isFinite(l)) || (l = 1), { x: s, y: l }
      );
    }
    let au = iw(0);
    function ac(e) {
      let t = iG(e);
      return i9() && t.visualViewport
        ? { x: t.visualViewport.offsetLeft, y: t.visualViewport.offsetTop }
        : au;
    }
    function ad(e, t, n, i) {
      var a;
      void 0 === t && (t = !1), void 0 === n && (n = !1);
      let o = e.getBoundingClientRect(),
        s = as(e),
        l = iw(1);
      t && (i ? iY(i) && (l = al(i)) : (l = al(e)));
      let u = (void 0 === (a = n) && (a = !1), i && (!a || i === iG(s)) && a) ? ac(s) : iw(0),
        c = (o.left + u.x) / l.x,
        d = (o.top + u.y) / l.y,
        f = o.width / l.x,
        h = o.height / l.y;
      if (s) {
        let e = iG(s),
          t = i && iY(i) ? iG(i) : i,
          n = e,
          a = aa(n);
        for (; a && i && t !== n; ) {
          let e = al(a),
            t = a.getBoundingClientRect(),
            i = at(a),
            o = t.left + (a.clientLeft + parseFloat(i.paddingLeft)) * e.x,
            s = t.top + (a.clientTop + parseFloat(i.paddingTop)) * e.y;
          (c *= e.x), (d *= e.y), (f *= e.x), (h *= e.y), (c += o), (d += s), (a = aa((n = iG(a))));
        }
      }
      return iB({ width: f, height: h, x: c, y: d });
    }
    function af(e, t) {
      let n = ar(e).scrollLeft;
      return t ? t.left + n : ad(iH(e)).left + n;
    }
    function ah(e, t) {
      let n = e.getBoundingClientRect();
      return { x: n.left + t.scrollLeft - af(e, n), y: n.top + t.scrollTop };
    }
    let ap = new Set(['absolute', 'fixed']);
    function am(e, t, n) {
      var i;
      let a;
      if ('viewport' === t)
        a = (function (e, t) {
          let n = iG(e),
            i = iH(e),
            a = n.visualViewport,
            o = i.clientWidth,
            s = i.clientHeight,
            l = 0,
            u = 0;
          if (a) {
            (o = a.width), (s = a.height);
            let e = i9();
            (!e || (e && 'fixed' === t)) && ((l = a.offsetLeft), (u = a.offsetTop));
          }
          let c = af(i);
          if (c <= 0) {
            let e = i.ownerDocument,
              t = e.body,
              n = getComputedStyle(t),
              a =
                ('CSS1Compat' === e.compatMode &&
                  parseFloat(n.marginLeft) + parseFloat(n.marginRight)) ||
                0,
              s = Math.abs(i.clientWidth - t.clientWidth - a);
            s <= 25 && (o -= s);
          } else c <= 25 && (o += c);
          return { width: o, height: s, x: l, y: u };
        })(e, n);
      else if ('document' === t) {
        let t, n, o, s, l, u, c;
        (i = iH(e)),
          (t = iH(i)),
          (n = ar(i)),
          (o = i.ownerDocument.body),
          (s = iy(t.scrollWidth, t.clientWidth, o.scrollWidth, o.clientWidth)),
          (l = iy(t.scrollHeight, t.clientHeight, o.scrollHeight, o.clientHeight)),
          (u = -n.scrollLeft + af(i)),
          (c = -n.scrollTop),
          'rtl' === at(o).direction && (u += iy(t.clientWidth, o.clientWidth) - s),
          (a = { width: s, height: l, x: u, y: c });
      } else if (iY(t)) {
        let e, i, o, s, l, u;
        (i = (e = ad(t, !0, 'fixed' === n)).top + t.clientTop),
          (o = e.left + t.clientLeft),
          (s = iQ(t) ? al(t) : iw(1)),
          (l = t.clientWidth * s.x),
          (u = t.clientHeight * s.y),
          (a = { width: l, height: u, x: o * s.x, y: i * s.y });
      } else {
        let n = ac(e);
        a = { x: t.x - n.x, y: t.y - n.y, width: t.width, height: t.height };
      }
      return iB(a);
    }
    function ag(e) {
      return 'static' === at(e).position;
    }
    function ay(e, t) {
      if (!iQ(e) || 'fixed' === at(e).position) return null;
      if (t) return t(e);
      let n = e.offsetParent;
      return iH(e) === n && (n = n.ownerDocument.body), n;
    }
    function ab(e, t) {
      var n;
      let i = iG(e);
      if (i2(e)) return i;
      if (!iQ(e)) {
        let t = an(e);
        for (; t && !ae(t); ) {
          if (iY(t) && !ag(t)) return t;
          t = an(t);
        }
        return i;
      }
      let a = ay(e, t);
      for (; a && ((n = a), i1.has(iK(n))) && ag(a); ) a = ay(a, t);
      return a && ae(a) && ag(a) && !i8(a)
        ? i
        : a ||
            (function (e) {
              let t = an(e);
              for (; iQ(t) && !ae(t); ) {
                if (i8(t)) return t;
                if (i2(t)) break;
                t = an(t);
              }
              return null;
            })(e) ||
            i;
    }
    let av = async function (e) {
        let t = this.getOffsetParent || ab,
          n = this.getDimensions,
          i = await n(e.floating);
        return {
          reference: (function (e, t, n) {
            let i = iQ(t),
              a = iH(t),
              o = 'fixed' === n,
              s = ad(e, !0, o, t),
              l = { scrollLeft: 0, scrollTop: 0 },
              u = iw(0);
            if (i || (!i && !o))
              if ((('body' !== iK(t) || i0(a)) && (l = ar(t)), i)) {
                let e = ad(t, !0, o, t);
                (u.x = e.x + t.clientLeft), (u.y = e.y + t.clientTop);
              } else a && (u.x = af(a));
            o && !i && a && (u.x = af(a));
            let c = !a || i || o ? iw(0) : ah(a, l);
            return {
              x: s.left + l.scrollLeft - u.x - c.x,
              y: s.top + l.scrollTop - u.y - c.y,
              width: s.width,
              height: s.height,
            };
          })(e.reference, await t(e.floating), e.strategy),
          floating: { x: 0, y: 0, width: i.width, height: i.height },
        };
      },
      aw = {
        convertOffsetParentRelativeRectToViewportRelativeRect: function (e) {
          let { elements: t, rect: n, offsetParent: i, strategy: a } = e,
            o = 'fixed' === a,
            s = iH(i),
            l = !!t && i2(t.floating);
          if (i === s || (l && o)) return n;
          let u = { scrollLeft: 0, scrollTop: 0 },
            c = iw(1),
            d = iw(0),
            f = iQ(i);
          if ((f || (!f && !o)) && (('body' !== iK(i) || i0(s)) && (u = ar(i)), iQ(i))) {
            let e = ad(i);
            (c = al(i)), (d.x = e.x + i.clientLeft), (d.y = e.y + i.clientTop);
          }
          let h = !s || f || o ? iw(0) : ah(s, u);
          return {
            width: n.width * c.x,
            height: n.height * c.y,
            x: n.x * c.x - u.scrollLeft * c.x + d.x + h.x,
            y: n.y * c.y - u.scrollTop * c.y + d.y + h.y,
          };
        },
        getDocumentElement: iH,
        getClippingRect: function (e) {
          let { element: t, boundary: n, rootBoundary: i, strategy: a } = e,
            o = [
              ...('clippingAncestors' === n
                ? i2(t)
                  ? []
                  : (function (e, t) {
                      let n = t.get(e);
                      if (n) return n;
                      let i = ai(e, [], !1).filter((e) => iY(e) && 'body' !== iK(e)),
                        a = null,
                        o = 'fixed' === at(e).position,
                        s = o ? an(e) : e;
                      for (; iY(s) && !ae(s); ) {
                        let t = at(s),
                          n = i8(s);
                        n || 'fixed' !== t.position || (a = null),
                          (
                            o
                              ? !n && !a
                              : (!n && 'static' === t.position && !!a && ap.has(a.position)) ||
                                (i0(s) &&
                                  !n &&
                                  (function e(t, n) {
                                    let i = an(t);
                                    return (
                                      !(i === n || !iY(i) || ae(i)) &&
                                      ('fixed' === at(i).position || e(i, n))
                                    );
                                  })(e, s))
                          )
                            ? (i = i.filter((e) => e !== s))
                            : (a = t),
                          (s = an(s));
                      }
                      return t.set(e, i), i;
                    })(t, this._c)
                : [].concat(n)),
              i,
            ],
            s = o[0],
            l = o.reduce((e, n) => {
              let i = am(t, n, a);
              return (
                (e.top = iy(i.top, e.top)),
                (e.right = ig(i.right, e.right)),
                (e.bottom = ig(i.bottom, e.bottom)),
                (e.left = iy(i.left, e.left)),
                e
              );
            }, am(t, s, a));
          return { width: l.right - l.left, height: l.bottom - l.top, x: l.left, y: l.top };
        },
        getOffsetParent: ab,
        getElementRects: av,
        getClientRects: function (e) {
          return Array.from(e.getClientRects());
        },
        getDimensions: function (e) {
          let { width: t, height: n } = ao(e);
          return { width: t, height: n };
        },
        getScale: al,
        isElement: iY,
        isRTL: function (e) {
          return 'rtl' === at(e).direction;
        },
      };
    function ax(e, t) {
      return e.x === t.x && e.y === t.y && e.width === t.width && e.height === t.height;
    }
    let aE = (e) => ({
      name: 'arrow',
      options: e,
      async fn(t) {
        let { x: n, y: i, placement: a, rects: o, platform: s, elements: l, middlewareData: u } = t,
          { element: c, padding: d = 0 } = iS(e, t) || {};
        if (null == c) return {};
        let f = iD(d),
          h = { x: n, y: i },
          p = iO(ij(a)),
          m = iA(p),
          g = await s.getDimensions(c),
          y = 'y' === p,
          b = y ? 'clientHeight' : 'clientWidth',
          v = o.reference[m] + o.reference[p] - h[p] - o.floating[m],
          w = h[p] - o.reference[p],
          x = await (null == s.getOffsetParent ? void 0 : s.getOffsetParent(c)),
          E = x ? x[b] : 0;
        (E && (await (null == s.isElement ? void 0 : s.isElement(x)))) ||
          (E = l.floating[b] || o.floating[m]);
        let S = E / 2 - g[m] / 2 - 1,
          C = ig(f[y ? 'top' : 'left'], S),
          k = ig(f[y ? 'bottom' : 'right'], S),
          O = E - g[m] - k,
          A = E / 2 - g[m] / 2 + (v / 2 - w / 2),
          I = iy(C, ig(A, O)),
          j =
            !u.arrow &&
            null != ik(a) &&
            A !== I &&
            o.reference[m] / 2 - (A < C ? C : k) - g[m] / 2 < 0,
          T = j ? (A < C ? A - C : A - O) : 0;
        return {
          [p]: h[p] + T,
          data: { [p]: I, centerOffset: A - I - T, ...(j && { alignmentOffset: T }) },
          reset: j,
        };
      },
    });
    var aS = 'undefined' != typeof document ? eX.useLayoutEffect : function () {};
    function aC(e, t) {
      let n, i, a;
      if (e === t) return !0;
      if (typeof e != typeof t) return !1;
      if ('function' == typeof e && e.toString() === t.toString()) return !0;
      if (e && t && 'object' == typeof e) {
        if (Array.isArray(e)) {
          if ((n = e.length) !== t.length) return !1;
          for (i = n; 0 != i--; ) if (!aC(e[i], t[i])) return !1;
          return !0;
        }
        if ((n = (a = Object.keys(e)).length) !== Object.keys(t).length) return !1;
        for (i = n; 0 != i--; ) if (!{}.hasOwnProperty.call(t, a[i])) return !1;
        for (i = n; 0 != i--; ) {
          let n = a[i];
          if (('_owner' !== n || !e.$$typeof) && !aC(e[n], t[n])) return !1;
        }
        return !0;
      }
      return e != e && t != t;
    }
    function ak(e) {
      return 'undefined' == typeof window
        ? 1
        : (e.ownerDocument.defaultView || window).devicePixelRatio || 1;
    }
    function aO(e, t) {
      let n = ak(e);
      return Math.round(t * n) / n;
    }
    function aA(e) {
      let t = eX.useRef(e);
      return (
        aS(() => {
          t.current = e;
        }),
        t
      );
    }
    var aI = eX.forwardRef((e, t) => {
      let { children: n, width: i = 10, height: a = 5, ...o } = e;
      return (0, e2.jsx)(ta.svg, {
        ...o,
        ref: t,
        width: i,
        height: a,
        viewBox: '0 0 30 10',
        preserveAspectRatio: 'none',
        children: e.asChild ? n : (0, e2.jsx)('polygon', { points: '0,0 30,0 15,10' }),
      });
    });
    aI.displayName = 'Arrow';
    var aj = 'Popper',
      [aT, aR] = e3(aj),
      [aM, aP] = aT(aj),
      aN = (e) => {
        let { __scopePopper: t, children: n } = e,
          [i, a] = eX.useState(null);
        return (0, e2.jsx)(aM, { scope: t, anchor: i, onAnchorChange: a, children: n });
      };
    aN.displayName = aj;
    var a_ = 'PopperAnchor',
      aD = eX.forwardRef((e, t) => {
        let { __scopePopper: n, virtualRef: i, ...a } = e,
          o = aP(a_, n),
          s = eX.useRef(null),
          l = e5(t, s),
          u = eX.useRef(null);
        return (
          eX.useEffect(() => {
            let e = u.current;
            (u.current = i?.current || s.current), e !== u.current && o.onAnchorChange(u.current);
          }),
          i ? null : (0, e2.jsx)(ta.div, { ...a, ref: l })
        );
      });
    aD.displayName = a_;
    var aB = 'PopperContent',
      [aU, aF] = aT(aB),
      aL = eX.forwardRef((e, t) => {
        var n, i, a, o, s, l, u, c, d, f, h, p, m, g, y, b, v, w, x, E, S;
        let {
            __scopePopper: C,
            side: k = 'bottom',
            sideOffset: O = 0,
            align: A = 'center',
            alignOffset: I = 0,
            arrowPadding: j = 0,
            avoidCollisions: T = !0,
            collisionBoundary: R = [],
            collisionPadding: M = 0,
            sticky: P = 'partial',
            hideWhenDetached: N = !1,
            updatePositionStrategy: _ = 'optimized',
            onPlaced: D,
            ...B
          } = e,
          U = aP(aB, C),
          [F, L] = eX.useState(null),
          z = e5(t, (e) => L(e)),
          [V, $] = eX.useState(null),
          W = (function (e) {
            let [t, n] = eX.useState(void 0);
            return (
              e4(() => {
                if (e) {
                  n({ width: e.offsetWidth, height: e.offsetHeight });
                  let t = new ResizeObserver((t) => {
                    let i, a;
                    if (!Array.isArray(t) || !t.length) return;
                    let o = t[0];
                    if ('borderBoxSize' in o) {
                      let e = o.borderBoxSize,
                        t = Array.isArray(e) ? e[0] : e;
                      (i = t.inlineSize), (a = t.blockSize);
                    } else (i = e.offsetWidth), (a = e.offsetHeight);
                    n({ width: i, height: a });
                  });
                  return t.observe(e, { box: 'border-box' }), () => t.unobserve(e);
                }
                n(void 0);
              }, [e]),
              t
            );
          })(V),
          q = W?.width ?? 0,
          K = W?.height ?? 0,
          G = 'number' == typeof M ? M : { top: 0, right: 0, bottom: 0, left: 0, ...M },
          H = Array.isArray(R) ? R : [R],
          Z = H.length > 0,
          Y = { padding: G, boundary: H.filter(aW), altBoundary: Z },
          {
            refs: Q,
            floatingStyles: X,
            placement: J,
            isPositioned: ee,
            middlewareData: et,
          } = (function (e) {
            void 0 === e && (e = {});
            let {
                placement: t = 'bottom',
                strategy: n = 'absolute',
                middleware: i = [],
                platform: a,
                elements: { reference: o, floating: s } = {},
                transform: l = !0,
                whileElementsMounted: u,
                open: c,
              } = e,
              [d, f] = eX.useState({
                x: 0,
                y: 0,
                strategy: n,
                placement: t,
                middlewareData: {},
                isPositioned: !1,
              }),
              [h, p] = eX.useState(i);
            aC(h, i) || p(i);
            let [m, g] = eX.useState(null),
              [y, b] = eX.useState(null),
              v = eX.useCallback((e) => {
                e !== S.current && ((S.current = e), g(e));
              }, []),
              w = eX.useCallback((e) => {
                e !== C.current && ((C.current = e), b(e));
              }, []),
              x = o || m,
              E = s || y,
              S = eX.useRef(null),
              C = eX.useRef(null),
              k = eX.useRef(d),
              O = null != u,
              A = aA(u),
              I = aA(a),
              j = aA(c),
              T = eX.useCallback(() => {
                var e, i;
                let a, o, s;
                if (!S.current || !C.current) return;
                let l = { placement: t, strategy: n, middleware: h };
                I.current && (l.platform = I.current),
                  ((e = S.current),
                  (i = C.current),
                  (a = new Map()),
                  (s = { ...(o = { platform: aw, ...l }).platform, _c: a }),
                  iF(e, i, { ...o, platform: s })).then((e) => {
                    let t = { ...e, isPositioned: !1 !== j.current };
                    R.current &&
                      !aC(k.current, t) &&
                      ((k.current = t),
                      tr.flushSync(() => {
                        f(t);
                      }));
                  });
              }, [h, t, n, I, j]);
            aS(() => {
              !1 === c &&
                k.current.isPositioned &&
                ((k.current.isPositioned = !1), f((e) => ({ ...e, isPositioned: !1 })));
            }, [c]);
            let R = eX.useRef(!1);
            aS(
              () => (
                (R.current = !0),
                () => {
                  R.current = !1;
                }
              ),
              []
            ),
              aS(() => {
                if ((x && (S.current = x), E && (C.current = E), x && E)) {
                  if (A.current) return A.current(x, E, T);
                  T();
                }
              }, [x, E, T, A, O]);
            let M = eX.useMemo(
                () => ({ reference: S, floating: C, setReference: v, setFloating: w }),
                [v, w]
              ),
              P = eX.useMemo(() => ({ reference: x, floating: E }), [x, E]),
              N = eX.useMemo(() => {
                let e = { position: n, left: 0, top: 0 };
                if (!P.floating) return e;
                let t = aO(P.floating, d.x),
                  i = aO(P.floating, d.y);
                return l
                  ? {
                      ...e,
                      transform: 'translate(' + t + 'px, ' + i + 'px)',
                      ...(ak(P.floating) >= 1.5 && { willChange: 'transform' }),
                    }
                  : { position: n, left: t, top: i };
              }, [n, l, P.floating, d.x, d.y]);
            return eX.useMemo(
              () => ({ ...d, update: T, refs: M, elements: P, floatingStyles: N }),
              [d, T, M, P, N]
            );
          })({
            strategy: 'fixed',
            placement: k + ('center' !== A ? '-' + A : ''),
            whileElementsMounted: (...e) =>
              (function (e, t, n, i) {
                let a;
                void 0 === i && (i = {});
                let {
                    ancestorScroll: o = !0,
                    ancestorResize: s = !0,
                    elementResize: l = 'function' == typeof ResizeObserver,
                    layoutShift: u = 'function' == typeof IntersectionObserver,
                    animationFrame: c = !1,
                  } = i,
                  d = as(e),
                  f = o || s ? [...(d ? ai(d) : []), ...ai(t)] : [];
                f.forEach((e) => {
                  o && e.addEventListener('scroll', n, { passive: !0 }),
                    s && e.addEventListener('resize', n);
                });
                let h =
                    d && u
                      ? (function (e, t) {
                          let n,
                            i = null,
                            a = iH(e);
                          function o() {
                            var e;
                            clearTimeout(n), null == (e = i) || e.disconnect(), (i = null);
                          }
                          return (
                            !(function s(l, u) {
                              void 0 === l && (l = !1), void 0 === u && (u = 1), o();
                              let c = e.getBoundingClientRect(),
                                { left: d, top: f, width: h, height: p } = c;
                              if ((l || t(), !h || !p)) return;
                              let m = {
                                  rootMargin:
                                    -iv(f) +
                                    'px ' +
                                    -iv(a.clientWidth - (d + h)) +
                                    'px ' +
                                    -iv(a.clientHeight - (f + p)) +
                                    'px ' +
                                    -iv(d) +
                                    'px',
                                  threshold: iy(0, ig(1, u)) || 1,
                                },
                                g = !0;
                              function y(t) {
                                let i = t[0].intersectionRatio;
                                if (i !== u) {
                                  if (!g) return s();
                                  i
                                    ? s(!1, i)
                                    : (n = setTimeout(() => {
                                        s(!1, 1e-7);
                                      }, 1e3));
                                }
                                1 !== i || ax(c, e.getBoundingClientRect()) || s(), (g = !1);
                              }
                              try {
                                i = new IntersectionObserver(y, { ...m, root: a.ownerDocument });
                              } catch (e) {
                                i = new IntersectionObserver(y, m);
                              }
                              i.observe(e);
                            })(!0),
                            o
                          );
                        })(d, n)
                      : null,
                  p = -1,
                  m = null;
                l &&
                  ((m = new ResizeObserver((e) => {
                    let [i] = e;
                    i &&
                      i.target === d &&
                      m &&
                      (m.unobserve(t),
                      cancelAnimationFrame(p),
                      (p = requestAnimationFrame(() => {
                        var e;
                        null == (e = m) || e.observe(t);
                      }))),
                      n();
                  })),
                  d && !c && m.observe(d),
                  m.observe(t));
                let g = c ? ad(e) : null;
                return (
                  c &&
                    (function t() {
                      let i = ad(e);
                      g && !ax(g, i) && n(), (g = i), (a = requestAnimationFrame(t));
                    })(),
                  n(),
                  () => {
                    var e;
                    f.forEach((e) => {
                      o && e.removeEventListener('scroll', n),
                        s && e.removeEventListener('resize', n);
                    }),
                      null == h || h(),
                      null == (e = m) || e.disconnect(),
                      (m = null),
                      c && cancelAnimationFrame(a);
                  }
                );
              })(...e, { animationFrame: 'always' === _ }),
            elements: { reference: U.anchor },
            middleware: [
              {
                ...{
                  name: 'offset',
                  options: (a = n = { mainAxis: O + K, alignmentAxis: I }),
                  async fn(e) {
                    var t, n;
                    let { x: i, y: o, placement: s, middlewareData: l } = e,
                      u = await iW(e, a);
                    return s === (null == (t = l.offset) ? void 0 : t.placement) &&
                      null != (n = l.arrow) &&
                      n.alignmentOffset
                      ? {}
                      : { x: i + u.x, y: o + u.y, data: { ...u, placement: s } };
                  },
                },
                options: [n, i],
              },
              T && {
                ...{
                  name: 'shift',
                  options:
                    (d = u =
                      {
                        mainAxis: !0,
                        crossAxis: !1,
                        limiter:
                          'partial' === P
                            ? {
                                ...(void 0 === (l = o) && (l = {}),
                                {
                                  options: l,
                                  fn(e) {
                                    let {
                                        x: t,
                                        y: n,
                                        placement: i,
                                        rects: a,
                                        middlewareData: o,
                                      } = e,
                                      {
                                        offset: s = 0,
                                        mainAxis: u = !0,
                                        crossAxis: c = !0,
                                      } = iS(l, e),
                                      d = { x: t, y: n },
                                      f = ij(i),
                                      h = iO(f),
                                      p = d[h],
                                      m = d[f],
                                      g = iS(s, e),
                                      y =
                                        'number' == typeof g
                                          ? { mainAxis: g, crossAxis: 0 }
                                          : { mainAxis: 0, crossAxis: 0, ...g };
                                    if (u) {
                                      let e = 'y' === h ? 'height' : 'width',
                                        t = a.reference[h] - a.floating[e] + y.mainAxis,
                                        n = a.reference[h] + a.reference[e] - y.mainAxis;
                                      p < t ? (p = t) : p > n && (p = n);
                                    }
                                    if (c) {
                                      var b, v;
                                      let e = 'y' === h ? 'width' : 'height',
                                        t = i$.has(iC(i)),
                                        n =
                                          a.reference[f] -
                                          a.floating[e] +
                                          ((t && (null == (b = o.offset) ? void 0 : b[f])) || 0) +
                                          (t ? 0 : y.crossAxis),
                                        s =
                                          a.reference[f] +
                                          a.reference[e] +
                                          (t ? 0 : (null == (v = o.offset) ? void 0 : v[f]) || 0) -
                                          (t ? y.crossAxis : 0);
                                      m < n ? (m = n) : m > s && (m = s);
                                    }
                                    return { [h]: p, [f]: m };
                                  },
                                }),
                                options: [o, s],
                              }
                            : void 0,
                        ...Y,
                      }),
                  async fn(e) {
                    let { x: t, y: n, placement: i } = e,
                      {
                        mainAxis: a = !0,
                        crossAxis: o = !1,
                        limiter: s = {
                          fn: (e) => {
                            let { x: t, y: n } = e;
                            return { x: t, y: n };
                          },
                        },
                        ...l
                      } = iS(d, e),
                      u = { x: t, y: n },
                      c = await iL(e, l),
                      f = ij(iC(i)),
                      h = iO(f),
                      p = u[h],
                      m = u[f];
                    if (a) {
                      let e = 'y' === h ? 'top' : 'left',
                        t = 'y' === h ? 'bottom' : 'right',
                        n = p + c[e],
                        i = p - c[t];
                      p = iy(n, ig(p, i));
                    }
                    if (o) {
                      let e = 'y' === f ? 'top' : 'left',
                        t = 'y' === f ? 'bottom' : 'right',
                        n = m + c[e],
                        i = m - c[t];
                      m = iy(n, ig(m, i));
                    }
                    let g = s.fn({ ...e, [h]: p, [f]: m });
                    return { ...g, data: { x: g.x - t, y: g.y - n, enabled: { [h]: a, [f]: o } } };
                  },
                },
                options: [u, c],
              },
              T && {
                ...{
                  name: 'flip',
                  options: (p = f = { ...Y }),
                  async fn(e) {
                    var t, n, i, a, o, s, l, u;
                    let c,
                      d,
                      f,
                      {
                        placement: h,
                        middlewareData: m,
                        rects: g,
                        initialPlacement: y,
                        platform: b,
                        elements: v,
                      } = e,
                      {
                        mainAxis: w = !0,
                        crossAxis: x = !0,
                        fallbackPlacements: E,
                        fallbackStrategy: S = 'bestFit',
                        fallbackAxisSideDirection: C = 'none',
                        flipAlignment: k = !0,
                        ...O
                      } = iS(p, e);
                    if (null != (t = m.arrow) && t.alignmentOffset) return {};
                    let A = iC(h),
                      I = ij(y),
                      j = iC(y) === y,
                      T = await (null == b.isRTL ? void 0 : b.isRTL(v.floating)),
                      R = E || (j || !k ? [i_(y)] : ((c = i_(y)), [iT(y), c, iT(c)])),
                      M = 'none' !== C;
                    !E &&
                      M &&
                      R.push(
                        ...((d = ik(y)),
                        (f = (function (e, t, n) {
                          switch (e) {
                            case 'top':
                            case 'bottom':
                              if (n) return t ? iM : iR;
                              return t ? iR : iM;
                            case 'left':
                            case 'right':
                              return t ? iP : iN;
                            default:
                              return [];
                          }
                        })(iC(y), 'start' === C, T)),
                        d && ((f = f.map((e) => e + '-' + d)), k && (f = f.concat(f.map(iT)))),
                        f)
                      );
                    let P = [y, ...R],
                      N = await iL(e, O),
                      _ = [],
                      D = (null == (n = m.flip) ? void 0 : n.overflows) || [];
                    if ((w && _.push(N[A]), x)) {
                      let e,
                        t,
                        n,
                        i,
                        a =
                          ((s = h),
                          (l = g),
                          void 0 === (u = T) && (u = !1),
                          (e = ik(s)),
                          (n = iA((t = iO(ij(s))))),
                          (i =
                            'x' === t
                              ? e === (u ? 'end' : 'start')
                                ? 'right'
                                : 'left'
                              : 'start' === e
                              ? 'bottom'
                              : 'top'),
                          l.reference[n] > l.floating[n] && (i = i_(i)),
                          [i, i_(i)]);
                      _.push(N[a[0]], N[a[1]]);
                    }
                    if (((D = [...D, { placement: h, overflows: _ }]), !_.every((e) => e <= 0))) {
                      let e = ((null == (i = m.flip) ? void 0 : i.index) || 0) + 1,
                        t = P[e];
                      if (
                        t &&
                        ('alignment' !== x ||
                          I === ij(t) ||
                          D.every((e) => ij(e.placement) !== I || e.overflows[0] > 0))
                      )
                        return { data: { index: e, overflows: D }, reset: { placement: t } };
                      let n =
                        null ==
                        (a = D.filter((e) => e.overflows[0] <= 0).sort(
                          (e, t) => e.overflows[1] - t.overflows[1]
                        )[0])
                          ? void 0
                          : a.placement;
                      if (!n)
                        switch (S) {
                          case 'bestFit': {
                            let e =
                              null ==
                              (o = D.filter((e) => {
                                if (M) {
                                  let t = ij(e.placement);
                                  return t === I || 'y' === t;
                                }
                                return !0;
                              })
                                .map((e) => [
                                  e.placement,
                                  e.overflows.filter((e) => e > 0).reduce((e, t) => e + t, 0),
                                ])
                                .sort((e, t) => e[1] - t[1])[0])
                                ? void 0
                                : o[0];
                            e && (n = e);
                            break;
                          }
                          case 'initialPlacement':
                            n = y;
                        }
                      if (h !== n) return { reset: { placement: n } };
                    }
                    return {};
                  },
                },
                options: [f, h],
              },
              {
                ...{
                  name: 'size',
                  options:
                    (y = m =
                      {
                        ...Y,
                        apply: ({
                          elements: e,
                          rects: t,
                          availableWidth: n,
                          availableHeight: i,
                        }) => {
                          let { width: a, height: o } = t.reference,
                            s = e.floating.style;
                          s.setProperty('--radix-popper-available-width', `${n}px`),
                            s.setProperty('--radix-popper-available-height', `${i}px`),
                            s.setProperty('--radix-popper-anchor-width', `${a}px`),
                            s.setProperty('--radix-popper-anchor-height', `${o}px`);
                        },
                      }),
                  async fn(e) {
                    var t, n;
                    let i,
                      a,
                      { placement: o, rects: s, platform: l, elements: u } = e,
                      { apply: c = () => {}, ...d } = iS(y, e),
                      f = await iL(e, d),
                      h = iC(o),
                      p = ik(o),
                      m = 'y' === ij(o),
                      { width: g, height: b } = s.floating;
                    'top' === h || 'bottom' === h
                      ? ((i = h),
                        (a =
                          p ===
                          ((await (null == l.isRTL ? void 0 : l.isRTL(u.floating)))
                            ? 'start'
                            : 'end')
                            ? 'left'
                            : 'right'))
                      : ((a = h), (i = 'end' === p ? 'top' : 'bottom'));
                    let v = b - f.top - f.bottom,
                      w = g - f.left - f.right,
                      x = ig(b - f[i], v),
                      E = ig(g - f[a], w),
                      S = !e.middlewareData.shift,
                      C = x,
                      k = E;
                    if (
                      (null != (t = e.middlewareData.shift) && t.enabled.x && (k = w),
                      null != (n = e.middlewareData.shift) && n.enabled.y && (C = v),
                      S && !p)
                    ) {
                      let e = iy(f.left, 0),
                        t = iy(f.right, 0),
                        n = iy(f.top, 0),
                        i = iy(f.bottom, 0);
                      m
                        ? (k = g - 2 * (0 !== e || 0 !== t ? e + t : iy(f.left, f.right)))
                        : (C = b - 2 * (0 !== n || 0 !== i ? n + i : iy(f.top, f.bottom)));
                    }
                    await c({ ...e, availableWidth: k, availableHeight: C });
                    let O = await l.getDimensions(u.floating);
                    return g !== O.width || b !== O.height ? { reset: { rects: !0 } } : {};
                  },
                },
                options: [m, g],
              },
              V && {
                ...{
                  name: 'arrow',
                  options: (w = b = { element: V, padding: j }),
                  fn(e) {
                    let { element: t, padding: n } = 'function' == typeof w ? w(e) : w;
                    return t && {}.hasOwnProperty.call(t, 'current')
                      ? null != t.current
                        ? aE({ element: t.current, padding: n }).fn(e)
                        : {}
                      : t
                      ? aE({ element: t, padding: n }).fn(e)
                      : {};
                  },
                },
                options: [b, v],
              },
              aq({ arrowWidth: q, arrowHeight: K }),
              N && {
                ...{
                  name: 'hide',
                  options: (S = x = { strategy: 'referenceHidden', ...Y }),
                  async fn(e) {
                    let { rects: t } = e,
                      { strategy: n = 'referenceHidden', ...i } = iS(S, e);
                    switch (n) {
                      case 'referenceHidden': {
                        let n = iz(await iL(e, { ...i, elementContext: 'reference' }), t.reference);
                        return { data: { referenceHiddenOffsets: n, referenceHidden: iV(n) } };
                      }
                      case 'escaped': {
                        let n = iz(await iL(e, { ...i, altBoundary: !0 }), t.floating);
                        return { data: { escapedOffsets: n, escaped: iV(n) } };
                      }
                      default:
                        return {};
                    }
                  },
                },
                options: [x, E],
              },
            ],
          }),
          [er, en] = aK(J),
          ei = ts(D);
        e4(() => {
          ee && ei?.();
        }, [ee, ei]);
        let ea = et.arrow?.x,
          eo = et.arrow?.y,
          es = et.arrow?.centerOffset !== 0,
          [el, eu] = eX.useState();
        return (
          e4(() => {
            F && eu(window.getComputedStyle(F).zIndex);
          }, [F]),
          (0, e2.jsx)('div', {
            ref: Q.setFloating,
            'data-radix-popper-content-wrapper': '',
            style: {
              ...X,
              transform: ee ? X.transform : 'translate(0, -200%)',
              minWidth: 'max-content',
              zIndex: el,
              '--radix-popper-transform-origin': [
                et.transformOrigin?.x,
                et.transformOrigin?.y,
              ].join(' '),
              ...(et.hide?.referenceHidden && { visibility: 'hidden', pointerEvents: 'none' }),
            },
            dir: e.dir,
            children: (0, e2.jsx)(aU, {
              scope: C,
              placedSide: er,
              onArrowChange: $,
              arrowX: ea,
              arrowY: eo,
              shouldHideArrow: es,
              children: (0, e2.jsx)(ta.div, {
                'data-side': er,
                'data-align': en,
                ...B,
                ref: z,
                style: { ...B.style, animation: ee ? void 0 : 'none' },
              }),
            }),
          })
        );
      });
    aL.displayName = aB;
    var az = 'PopperArrow',
      aV = { top: 'bottom', right: 'left', bottom: 'top', left: 'right' },
      a$ = eX.forwardRef(function (e, t) {
        let { __scopePopper: n, ...i } = e,
          a = aF(az, n),
          o = aV[a.placedSide];
        return (0,
        e2.jsx)('span', { ref: a.onArrowChange, style: { position: 'absolute', left: a.arrowX, top: a.arrowY, [o]: 0, transformOrigin: { top: '', right: '0 0', bottom: 'center 0', left: '100% 0' }[a.placedSide], transform: { top: 'translateY(100%)', right: 'translateY(50%) rotate(90deg) translateX(-50%)', bottom: 'rotate(180deg)', left: 'translateY(50%) rotate(-90deg) translateX(50%)' }[a.placedSide], visibility: a.shouldHideArrow ? 'hidden' : void 0 }, children: (0, e2.jsx)(aI, { ...i, ref: t, style: { ...i.style, display: 'block' } }) });
      });
    function aW(e) {
      return null !== e;
    }
    a$.displayName = az;
    var aq = (e) => ({
      name: 'transformOrigin',
      options: e,
      fn(t) {
        let { placement: n, rects: i, middlewareData: a } = t,
          o = a.arrow?.centerOffset !== 0,
          s = o ? 0 : e.arrowWidth,
          l = o ? 0 : e.arrowHeight,
          [u, c] = aK(n),
          d = { start: '0%', center: '50%', end: '100%' }[c],
          f = (a.arrow?.x ?? 0) + s / 2,
          h = (a.arrow?.y ?? 0) + l / 2,
          p = '',
          m = '';
        return (
          'bottom' === u
            ? ((p = o ? d : `${f}px`), (m = `${-l}px`))
            : 'top' === u
            ? ((p = o ? d : `${f}px`), (m = `${i.floating.height + l}px`))
            : 'right' === u
            ? ((p = `${-l}px`), (m = o ? d : `${h}px`))
            : 'left' === u && ((p = `${i.floating.width + l}px`), (m = o ? d : `${h}px`)),
          { data: { x: p, y: m } }
        );
      },
    });
    function aK(e) {
      let [t, n = 'center'] = e.split('-');
      return [t, n];
    }
    e.s(
      [
        'Anchor',
        () => aD,
        'Arrow',
        () => a$,
        'Content',
        () => aL,
        'Root',
        () => aN,
        'createPopperScope',
        () => aR,
      ],
      53660
    );
    var aG = 'rovingFocusGroup.onEntryFocus',
      aH = { bubbles: !1, cancelable: !0 },
      aZ = 'RovingFocusGroup',
      [aY, aQ, aX] = is(aZ),
      [aJ, a0] = e3(aZ, [aX]),
      [a1, a5] = aJ(aZ),
      a2 = eX.forwardRef((e, t) =>
        (0, e2.jsx)(aY.Provider, {
          scope: e.__scopeRovingFocusGroup,
          children: (0, e2.jsx)(aY.Slot, {
            scope: e.__scopeRovingFocusGroup,
            children: (0, e2.jsx)(a6, { ...e, ref: t }),
          }),
        })
      );
    a2.displayName = aZ;
    var a6 = eX.forwardRef((e, t) => {
        let {
            __scopeRovingFocusGroup: n,
            orientation: i,
            loop: a = !1,
            dir: o,
            currentTabStopId: s,
            defaultCurrentTabStopId: l,
            onCurrentTabStopIdChange: u,
            onEntryFocus: c,
            preventScrollOnEntryFocus: d = !1,
            ...f
          } = e,
          h = eX.useRef(null),
          p = e5(t, h),
          m = ip(o),
          [g, y] = tt({ prop: s, defaultProp: l ?? null, onChange: u, caller: aZ }),
          [b, v] = eX.useState(!1),
          w = ts(c),
          x = aQ(n),
          E = eX.useRef(!1),
          [S, C] = eX.useState(0);
        return (
          eX.useEffect(() => {
            let e = h.current;
            if (e) return e.addEventListener(aG, w), () => e.removeEventListener(aG, w);
          }, [w]),
          (0, e2.jsx)(a1, {
            scope: n,
            orientation: i,
            dir: m,
            loop: a,
            currentTabStopId: g,
            onItemFocus: eX.useCallback((e) => y(e), [y]),
            onItemShiftTab: eX.useCallback(() => v(!0), []),
            onFocusableItemAdd: eX.useCallback(() => C((e) => e + 1), []),
            onFocusableItemRemove: eX.useCallback(() => C((e) => e - 1), []),
            children: (0, e2.jsx)(ta.div, {
              tabIndex: b || 0 === S ? -1 : 0,
              'data-orientation': i,
              ...f,
              ref: p,
              style: { outline: 'none', ...e.style },
              onMouseDown: eJ(e.onMouseDown, () => {
                E.current = !0;
              }),
              onFocus: eJ(e.onFocus, (e) => {
                let t = !E.current;
                if (e.target === e.currentTarget && t && !b) {
                  let t = new CustomEvent(aG, aH);
                  if ((e.currentTarget.dispatchEvent(t), !t.defaultPrevented)) {
                    let e = x().filter((e) => e.focusable);
                    a9(
                      [e.find((e) => e.active), e.find((e) => e.id === g), ...e]
                        .filter(Boolean)
                        .map((e) => e.ref.current),
                      d
                    );
                  }
                }
                E.current = !1;
              }),
              onBlur: eJ(e.onBlur, () => v(!1)),
            }),
          })
        );
      }),
      a3 = 'RovingFocusGroupItem',
      a4 = eX.forwardRef((e, t) => {
        let {
            __scopeRovingFocusGroup: n,
            focusable: i = !0,
            active: a = !1,
            tabStopId: o,
            children: s,
            ...l
          } = e,
          u = e7(),
          c = o || u,
          d = a5(a3, n),
          f = d.currentTabStopId === c,
          h = aQ(n),
          { onFocusableItemAdd: p, onFocusableItemRemove: m, currentTabStopId: g } = d;
        return (
          eX.useEffect(() => {
            if (i) return p(), () => m();
          }, [i, p, m]),
          (0, e2.jsx)(aY.ItemSlot, {
            scope: n,
            id: c,
            focusable: i,
            active: a,
            children: (0, e2.jsx)(ta.span, {
              tabIndex: f ? 0 : -1,
              'data-orientation': d.orientation,
              ...l,
              ref: t,
              onMouseDown: eJ(e.onMouseDown, (e) => {
                i ? d.onItemFocus(c) : e.preventDefault();
              }),
              onFocus: eJ(e.onFocus, () => d.onItemFocus(c)),
              onKeyDown: eJ(e.onKeyDown, (e) => {
                if ('Tab' === e.key && e.shiftKey) return void d.onItemShiftTab();
                if (e.target !== e.currentTarget) return;
                let t = (function (e, t, n) {
                  var i;
                  let a =
                    ((i = e.key),
                    'rtl' !== n
                      ? i
                      : 'ArrowLeft' === i
                      ? 'ArrowRight'
                      : 'ArrowRight' === i
                      ? 'ArrowLeft'
                      : i);
                  if (
                    !('vertical' === t && ['ArrowLeft', 'ArrowRight'].includes(a)) &&
                    !('horizontal' === t && ['ArrowUp', 'ArrowDown'].includes(a))
                  )
                    return a8[a];
                })(e, d.orientation, d.dir);
                if (void 0 !== t) {
                  if (e.metaKey || e.ctrlKey || e.altKey || e.shiftKey) return;
                  e.preventDefault();
                  let a = h()
                    .filter((e) => e.focusable)
                    .map((e) => e.ref.current);
                  if ('last' === t) a.reverse();
                  else if ('prev' === t || 'next' === t) {
                    var n, i;
                    'prev' === t && a.reverse();
                    let o = a.indexOf(e.currentTarget);
                    a = d.loop
                      ? ((n = a), (i = o + 1), n.map((e, t) => n[(i + t) % n.length]))
                      : a.slice(o + 1);
                  }
                  setTimeout(() => a9(a));
                }
              }),
              children:
                'function' == typeof s ? s({ isCurrentTabStop: f, hasTabStop: null != g }) : s,
            }),
          })
        );
      });
    a4.displayName = a3;
    var a8 = {
      ArrowLeft: 'prev',
      ArrowUp: 'prev',
      ArrowRight: 'next',
      ArrowDown: 'next',
      PageUp: 'first',
      Home: 'first',
      PageDown: 'last',
      End: 'last',
    };
    function a9(e, t = !1) {
      let n = document.activeElement;
      for (let i of e)
        if (i === n || (i.focus({ preventScroll: t }), document.activeElement !== n)) return;
    }
    var a7 = Symbol('radix.slottable');
    function oe(e) {
      return (
        eX.isValidElement(e) &&
        'function' == typeof e.type &&
        '__radixId' in e.type &&
        e.type.__radixId === a7
      );
    }
    var ot = ['Enter', ' '],
      or = ['ArrowUp', 'PageDown', 'End'],
      on = ['ArrowDown', 'PageUp', 'Home', ...or],
      oi = { ltr: [...ot, 'ArrowRight'], rtl: [...ot, 'ArrowLeft'] },
      oa = { ltr: ['ArrowLeft'], rtl: ['ArrowRight'] },
      oo = 'Menu',
      [os, ol, ou] = is(oo),
      [oc, od] = e3(oo, [ou, aR, a0]),
      of = aR(),
      oh = a0(),
      [op, om] = oc(oo),
      [og, oy] = oc(oo),
      ob = (e) => {
        let {
            __scopeMenu: t,
            open: n = !1,
            children: i,
            dir: a,
            onOpenChange: o,
            modal: s = !0,
          } = e,
          l = of(t),
          [u, c] = eX.useState(null),
          d = eX.useRef(!1),
          f = ts(o),
          h = ip(a);
        return (
          eX.useEffect(() => {
            let e = () => {
                (d.current = !0),
                  document.addEventListener('pointerdown', t, { capture: !0, once: !0 }),
                  document.addEventListener('pointermove', t, { capture: !0, once: !0 });
              },
              t = () => (d.current = !1);
            return (
              document.addEventListener('keydown', e, { capture: !0 }),
              () => {
                document.removeEventListener('keydown', e, { capture: !0 }),
                  document.removeEventListener('pointerdown', t, { capture: !0 }),
                  document.removeEventListener('pointermove', t, { capture: !0 });
              }
            );
          }, []),
          (0, e2.jsx)(aN, {
            ...l,
            children: (0, e2.jsx)(op, {
              scope: t,
              open: n,
              onOpenChange: f,
              content: u,
              onContentChange: c,
              children: (0, e2.jsx)(og, {
                scope: t,
                onClose: eX.useCallback(() => f(!1), [f]),
                isUsingKeyboardRef: d,
                dir: h,
                modal: s,
                children: i,
              }),
            }),
          })
        );
      };
    ob.displayName = oo;
    var ov = eX.forwardRef((e, t) => {
      let { __scopeMenu: n, ...i } = e,
        a = of(n);
      return (0, e2.jsx)(aD, { ...a, ...i, ref: t });
    });
    ov.displayName = 'MenuAnchor';
    var ow = 'MenuPortal',
      [ox, oE] = oc(ow, { forceMount: void 0 }),
      oS = (e) => {
        let { __scopeMenu: t, forceMount: n, children: i, container: a } = e,
          o = om(ow, t);
        return (0, e2.jsx)(ox, {
          scope: t,
          forceMount: n,
          children: (0, e2.jsx)(tS, {
            present: n || o.open,
            children: (0, e2.jsx)(tE, { asChild: !0, container: a, children: i }),
          }),
        });
      };
    oS.displayName = ow;
    var oC = 'MenuContent',
      [ok, oO] = oc(oC),
      oA = eX.forwardRef((e, t) => {
        let n = oE(oC, e.__scopeMenu),
          { forceMount: i = n.forceMount, ...a } = e,
          o = om(oC, e.__scopeMenu),
          s = oy(oC, e.__scopeMenu);
        return (0, e2.jsx)(os.Provider, {
          scope: e.__scopeMenu,
          children: (0, e2.jsx)(tS, {
            present: i || o.open,
            children: (0, e2.jsx)(os.Slot, {
              scope: e.__scopeMenu,
              children: s.modal
                ? (0, e2.jsx)(oI, { ...a, ref: t })
                : (0, e2.jsx)(oj, { ...a, ref: t }),
            }),
          }),
        });
      }),
      oI = eX.forwardRef((e, t) => {
        let n = om(oC, e.__scopeMenu),
          i = eX.useRef(null),
          a = e5(t, i);
        return (
          eX.useEffect(() => {
            let e = i.current;
            if (e) return ru(e);
          }, []),
          (0, e2.jsx)(oR, {
            ...e,
            ref: a,
            trapFocus: n.open,
            disableOutsidePointerEvents: n.open,
            disableOutsideScroll: !0,
            onFocusOutside: eJ(e.onFocusOutside, (e) => e.preventDefault(), {
              checkForDefaultPrevented: !1,
            }),
            onDismiss: () => n.onOpenChange(!1),
          })
        );
      }),
      oj = eX.forwardRef((e, t) => {
        let n = om(oC, e.__scopeMenu);
        return (0, e2.jsx)(oR, {
          ...e,
          ref: t,
          trapFocus: !1,
          disableOutsidePointerEvents: !1,
          disableOutsideScroll: !1,
          onDismiss: () => n.onOpenChange(!1),
        });
      }),
      oT =
        (((T = eX.forwardRef((e, t) => {
          let { children: n, ...i } = e;
          if (eX.isValidElement(n)) {
            var a;
            let e,
              o,
              s =
                ((a = n),
                (o =
                  (e = Object.getOwnPropertyDescriptor(a.props, 'ref')?.get) &&
                  'isReactWarning' in e &&
                  e.isReactWarning)
                  ? a.ref
                  : (o =
                      (e = Object.getOwnPropertyDescriptor(a, 'ref')?.get) &&
                      'isReactWarning' in e &&
                      e.isReactWarning)
                  ? a.props.ref
                  : a.props.ref || a.ref),
              l = (function (e, t) {
                let n = { ...t };
                for (let i in t) {
                  let a = e[i],
                    o = t[i];
                  /^on[A-Z]/.test(i)
                    ? a && o
                      ? (n[i] = (...e) => {
                          let t = o(...e);
                          return a(...e), t;
                        })
                      : a && (n[i] = a)
                    : 'style' === i
                    ? (n[i] = { ...a, ...o })
                    : 'className' === i && (n[i] = [a, o].filter(Boolean).join(' '));
                }
                return { ...e, ...n };
              })(i, n.props);
            return n.type !== eX.Fragment && (l.ref = t ? e1(t, s) : s), eX.cloneElement(n, l);
          }
          return eX.Children.count(n) > 1 ? eX.Children.only(null) : null;
        })).displayName = 'MenuContent.ScrollLock.SlotClone'),
        (p = T),
        ((m = eX.forwardRef((e, t) => {
          let { children: n, ...i } = e,
            a = eX.Children.toArray(n),
            o = a.find(oe);
          if (o) {
            let e = o.props.children,
              n = a.map((t) =>
                t !== o
                  ? t
                  : eX.Children.count(e) > 1
                  ? eX.Children.only(null)
                  : eX.isValidElement(e)
                  ? e.props.children
                  : null
              );
            return (0, e2.jsx)(p, {
              ...i,
              ref: t,
              children: eX.isValidElement(e) ? eX.cloneElement(e, void 0, n) : null,
            });
          }
          return (0, e2.jsx)(p, { ...i, ref: t, children: n });
        })).displayName = 'MenuContent.ScrollLock.Slot'),
        m),
      oR = eX.forwardRef((e, t) => {
        let {
            __scopeMenu: n,
            loop: i = !1,
            trapFocus: a,
            onOpenAutoFocus: o,
            onCloseAutoFocus: s,
            disableOutsidePointerEvents: l,
            onEntryFocus: u,
            onEscapeKeyDown: c,
            onPointerDownOutside: d,
            onFocusOutside: f,
            onInteractOutside: h,
            onDismiss: p,
            disableOutsideScroll: m,
            ...g
          } = e,
          y = om(oC, n),
          b = oy(oC, n),
          v = of(n),
          w = oh(n),
          x = ol(n),
          [E, S] = eX.useState(null),
          C = eX.useRef(null),
          k = e5(t, C, y.onContentChange),
          O = eX.useRef(0),
          A = eX.useRef(''),
          I = eX.useRef(0),
          j = eX.useRef(null),
          T = eX.useRef('right'),
          R = eX.useRef(0),
          M = m ? rr : eX.Fragment;
        eX.useEffect(() => () => window.clearTimeout(O.current), []), tO();
        let P = eX.useCallback((e) => {
          var t, n;
          return (
            T.current === j.current?.side &&
            ((t = e),
            !!(n = j.current?.area) &&
              (function (e, t) {
                let { x: n, y: i } = e,
                  a = !1;
                for (let e = 0, o = t.length - 1; e < t.length; o = e++) {
                  let s = t[e],
                    l = t[o],
                    u = s.x,
                    c = s.y,
                    d = l.x,
                    f = l.y;
                  c > i != f > i && n < ((d - u) * (i - c)) / (f - c) + u && (a = !a);
                }
                return a;
              })({ x: t.clientX, y: t.clientY }, n))
          );
        }, []);
        return (0, e2.jsx)(ok, {
          scope: n,
          searchRef: A,
          onItemEnter: eX.useCallback(
            (e) => {
              P(e) && e.preventDefault();
            },
            [P]
          ),
          onItemLeave: eX.useCallback(
            (e) => {
              P(e) || (C.current?.focus(), S(null));
            },
            [P]
          ),
          onTriggerLeave: eX.useCallback(
            (e) => {
              P(e) && e.preventDefault();
            },
            [P]
          ),
          pointerGraceTimerRef: I,
          onPointerGraceIntentChange: eX.useCallback((e) => {
            j.current = e;
          }, []),
          children: (0, e2.jsx)(M, {
            ...(m ? { as: oT, allowPinchZoom: !0 } : void 0),
            children: (0, e2.jsx)(tg, {
              asChild: !0,
              trapped: a,
              onMountAutoFocus: eJ(o, (e) => {
                e.preventDefault(), C.current?.focus({ preventScroll: !0 });
              }),
              onUnmountAutoFocus: s,
              children: (0, e2.jsx)(tc, {
                asChild: !0,
                disableOutsidePointerEvents: l,
                onEscapeKeyDown: c,
                onPointerDownOutside: d,
                onFocusOutside: f,
                onInteractOutside: h,
                onDismiss: p,
                children: (0, e2.jsx)(a2, {
                  asChild: !0,
                  ...w,
                  dir: b.dir,
                  orientation: 'vertical',
                  loop: i,
                  currentTabStopId: E,
                  onCurrentTabStopIdChange: S,
                  onEntryFocus: eJ(u, (e) => {
                    b.isUsingKeyboardRef.current || e.preventDefault();
                  }),
                  preventScrollOnEntryFocus: !0,
                  children: (0, e2.jsx)(aL, {
                    role: 'menu',
                    'aria-orientation': 'vertical',
                    'data-state': o2(y.open),
                    'data-radix-menu-content': '',
                    dir: b.dir,
                    ...v,
                    ...g,
                    ref: k,
                    style: { outline: 'none', ...g.style },
                    onKeyDown: eJ(g.onKeyDown, (e) => {
                      let t = e.target.closest('[data-radix-menu-content]') === e.currentTarget,
                        n = e.ctrlKey || e.altKey || e.metaKey,
                        i = 1 === e.key.length;
                      if (t) {
                        var a;
                        let t, o, s, l, u, c;
                        'Tab' === e.key && e.preventDefault(),
                          !n &&
                            i &&
                            ((a = e.key),
                            (t = A.current + a),
                            (o = x().filter((e) => !e.disabled)),
                            (s = document.activeElement),
                            (l = o.find((e) => e.ref.current === s)?.textValue),
                            (u = (function (e, t, n) {
                              var i;
                              let a =
                                  t.length > 1 && Array.from(t).every((e) => e === t[0]) ? t[0] : t,
                                o = n ? e.indexOf(n) : -1,
                                s = ((i = Math.max(o, 0)), e.map((t, n) => e[(i + n) % e.length]));
                              1 === a.length && (s = s.filter((e) => e !== n));
                              let l = s.find((e) => e.toLowerCase().startsWith(a.toLowerCase()));
                              return l !== n ? l : void 0;
                            })(
                              o.map((e) => e.textValue),
                              t,
                              l
                            )),
                            (c = o.find((e) => e.textValue === u)?.ref.current),
                            (function e(t) {
                              (A.current = t),
                                window.clearTimeout(O.current),
                                '' !== t && (O.current = window.setTimeout(() => e(''), 1e3));
                            })(t),
                            c && setTimeout(() => c.focus()));
                      }
                      let o = C.current;
                      if (e.target !== o || !on.includes(e.key)) return;
                      e.preventDefault();
                      let s = x()
                        .filter((e) => !e.disabled)
                        .map((e) => e.ref.current);
                      or.includes(e.key) && s.reverse(),
                        (function (e) {
                          let t = document.activeElement;
                          for (let n of e)
                            if (n === t || (n.focus(), document.activeElement !== t)) return;
                        })(s);
                    }),
                    onBlur: eJ(e.onBlur, (e) => {
                      e.currentTarget.contains(e.target) ||
                        (window.clearTimeout(O.current), (A.current = ''));
                    }),
                    onPointerMove: eJ(
                      e.onPointerMove,
                      o4((e) => {
                        let t = e.target,
                          n = R.current !== e.clientX;
                        e.currentTarget.contains(t) &&
                          n &&
                          ((T.current = e.clientX > R.current ? 'right' : 'left'),
                          (R.current = e.clientX));
                      })
                    ),
                  }),
                }),
              }),
            }),
          }),
        });
      });
    oA.displayName = oC;
    var oM = eX.forwardRef((e, t) => {
      let { __scopeMenu: n, ...i } = e;
      return (0, e2.jsx)(ta.div, { role: 'group', ...i, ref: t });
    });
    oM.displayName = 'MenuGroup';
    var oP = eX.forwardRef((e, t) => {
      let { __scopeMenu: n, ...i } = e;
      return (0, e2.jsx)(ta.div, { ...i, ref: t });
    });
    oP.displayName = 'MenuLabel';
    var oN = 'MenuItem',
      o_ = 'menu.itemSelect',
      oD = eX.forwardRef((e, t) => {
        let { disabled: n = !1, onSelect: i, ...a } = e,
          o = eX.useRef(null),
          s = oy(oN, e.__scopeMenu),
          l = oO(oN, e.__scopeMenu),
          u = e5(t, o),
          c = eX.useRef(!1);
        return (0, e2.jsx)(oB, {
          ...a,
          ref: u,
          disabled: n,
          onClick: eJ(e.onClick, () => {
            let e = o.current;
            if (!n && e) {
              let t = new CustomEvent(o_, { bubbles: !0, cancelable: !0 });
              e.addEventListener(o_, (e) => i?.(e), { once: !0 }),
                to(e, t),
                t.defaultPrevented ? (c.current = !1) : s.onClose();
            }
          }),
          onPointerDown: (t) => {
            e.onPointerDown?.(t), (c.current = !0);
          },
          onPointerUp: eJ(e.onPointerUp, (e) => {
            c.current || e.currentTarget?.click();
          }),
          onKeyDown: eJ(e.onKeyDown, (e) => {
            let t = '' !== l.searchRef.current;
            n ||
              (t && ' ' === e.key) ||
              (ot.includes(e.key) && (e.currentTarget.click(), e.preventDefault()));
          }),
        });
      });
    oD.displayName = oN;
    var oB = eX.forwardRef((e, t) => {
        let { __scopeMenu: n, disabled: i = !1, textValue: a, ...o } = e,
          s = oO(oN, n),
          l = oh(n),
          u = eX.useRef(null),
          c = e5(t, u),
          [d, f] = eX.useState(!1),
          [h, p] = eX.useState('');
        return (
          eX.useEffect(() => {
            let e = u.current;
            e && p((e.textContent ?? '').trim());
          }, [o.children]),
          (0, e2.jsx)(os.ItemSlot, {
            scope: n,
            disabled: i,
            textValue: a ?? h,
            children: (0, e2.jsx)(a4, {
              asChild: !0,
              ...l,
              focusable: !i,
              children: (0, e2.jsx)(ta.div, {
                role: 'menuitem',
                'data-highlighted': d ? '' : void 0,
                'aria-disabled': i || void 0,
                'data-disabled': i ? '' : void 0,
                ...o,
                ref: c,
                onPointerMove: eJ(
                  e.onPointerMove,
                  o4((e) => {
                    i
                      ? s.onItemLeave(e)
                      : (s.onItemEnter(e),
                        e.defaultPrevented || e.currentTarget.focus({ preventScroll: !0 }));
                  })
                ),
                onPointerLeave: eJ(
                  e.onPointerLeave,
                  o4((e) => s.onItemLeave(e))
                ),
                onFocus: eJ(e.onFocus, () => f(!0)),
                onBlur: eJ(e.onBlur, () => f(!1)),
              }),
            }),
          })
        );
      }),
      oU = eX.forwardRef((e, t) => {
        let { checked: n = !1, onCheckedChange: i, ...a } = e;
        return (0, e2.jsx)(oK, {
          scope: e.__scopeMenu,
          checked: n,
          children: (0, e2.jsx)(oD, {
            role: 'menuitemcheckbox',
            'aria-checked': o6(n) ? 'mixed' : n,
            ...a,
            ref: t,
            'data-state': o3(n),
            onSelect: eJ(a.onSelect, () => i?.(!!o6(n) || !n), { checkForDefaultPrevented: !1 }),
          }),
        });
      });
    oU.displayName = 'MenuCheckboxItem';
    var oF = 'MenuRadioGroup',
      [oL, oz] = oc(oF, { value: void 0, onValueChange: () => {} }),
      oV = eX.forwardRef((e, t) => {
        let { value: n, onValueChange: i, ...a } = e,
          o = ts(i);
        return (0, e2.jsx)(oL, {
          scope: e.__scopeMenu,
          value: n,
          onValueChange: o,
          children: (0, e2.jsx)(oM, { ...a, ref: t }),
        });
      });
    oV.displayName = oF;
    var o$ = 'MenuRadioItem',
      oW = eX.forwardRef((e, t) => {
        let { value: n, ...i } = e,
          a = oz(o$, e.__scopeMenu),
          o = n === a.value;
        return (0, e2.jsx)(oK, {
          scope: e.__scopeMenu,
          checked: o,
          children: (0, e2.jsx)(oD, {
            role: 'menuitemradio',
            'aria-checked': o,
            ...i,
            ref: t,
            'data-state': o3(o),
            onSelect: eJ(i.onSelect, () => a.onValueChange?.(n), { checkForDefaultPrevented: !1 }),
          }),
        });
      });
    oW.displayName = o$;
    var oq = 'MenuItemIndicator',
      [oK, oG] = oc(oq, { checked: !1 }),
      oH = eX.forwardRef((e, t) => {
        let { __scopeMenu: n, forceMount: i, ...a } = e,
          o = oG(oq, n);
        return (0, e2.jsx)(tS, {
          present: i || o6(o.checked) || !0 === o.checked,
          children: (0, e2.jsx)(ta.span, { ...a, ref: t, 'data-state': o3(o.checked) }),
        });
      });
    oH.displayName = oq;
    var oZ = eX.forwardRef((e, t) => {
      let { __scopeMenu: n, ...i } = e;
      return (0, e2.jsx)(ta.div, {
        role: 'separator',
        'aria-orientation': 'horizontal',
        ...i,
        ref: t,
      });
    });
    oZ.displayName = 'MenuSeparator';
    var oY = eX.forwardRef((e, t) => {
      let { __scopeMenu: n, ...i } = e,
        a = of(n);
      return (0, e2.jsx)(a$, { ...a, ...i, ref: t });
    });
    oY.displayName = 'MenuArrow';
    var [oQ, oX] = oc('MenuSub'),
      oJ = 'MenuSubTrigger',
      o0 = eX.forwardRef((e, t) => {
        let n = om(oJ, e.__scopeMenu),
          i = oy(oJ, e.__scopeMenu),
          a = oX(oJ, e.__scopeMenu),
          o = oO(oJ, e.__scopeMenu),
          s = eX.useRef(null),
          { pointerGraceTimerRef: l, onPointerGraceIntentChange: u } = o,
          c = { __scopeMenu: e.__scopeMenu },
          d = eX.useCallback(() => {
            s.current && window.clearTimeout(s.current), (s.current = null);
          }, []);
        return (
          eX.useEffect(() => d, [d]),
          eX.useEffect(() => {
            let e = l.current;
            return () => {
              window.clearTimeout(e), u(null);
            };
          }, [l, u]),
          (0, e2.jsx)(ov, {
            asChild: !0,
            ...c,
            children: (0, e2.jsx)(oB, {
              id: a.triggerId,
              'aria-haspopup': 'menu',
              'aria-expanded': n.open,
              'aria-controls': a.contentId,
              'data-state': o2(n.open),
              ...e,
              ref: e1(t, a.onTriggerChange),
              onClick: (t) => {
                e.onClick?.(t),
                  e.disabled ||
                    t.defaultPrevented ||
                    (t.currentTarget.focus(), n.open || n.onOpenChange(!0));
              },
              onPointerMove: eJ(
                e.onPointerMove,
                o4((t) => {
                  o.onItemEnter(t),
                    !t.defaultPrevented &&
                      (e.disabled ||
                        n.open ||
                        s.current ||
                        (o.onPointerGraceIntentChange(null),
                        (s.current = window.setTimeout(() => {
                          n.onOpenChange(!0), d();
                        }, 100))));
                })
              ),
              onPointerLeave: eJ(
                e.onPointerLeave,
                o4((e) => {
                  d();
                  let t = n.content?.getBoundingClientRect();
                  if (t) {
                    let i = n.content?.dataset.side,
                      a = 'right' === i,
                      s = t[a ? 'left' : 'right'],
                      u = t[a ? 'right' : 'left'];
                    o.onPointerGraceIntentChange({
                      area: [
                        { x: e.clientX + (a ? -5 : 5), y: e.clientY },
                        { x: s, y: t.top },
                        { x: u, y: t.top },
                        { x: u, y: t.bottom },
                        { x: s, y: t.bottom },
                      ],
                      side: i,
                    }),
                      window.clearTimeout(l.current),
                      (l.current = window.setTimeout(
                        () => o.onPointerGraceIntentChange(null),
                        300
                      ));
                  } else {
                    if ((o.onTriggerLeave(e), e.defaultPrevented)) return;
                    o.onPointerGraceIntentChange(null);
                  }
                })
              ),
              onKeyDown: eJ(e.onKeyDown, (t) => {
                let a = '' !== o.searchRef.current;
                e.disabled ||
                  (a && ' ' === t.key) ||
                  (oi[i.dir].includes(t.key) &&
                    (n.onOpenChange(!0), n.content?.focus(), t.preventDefault()));
              }),
            }),
          })
        );
      });
    o0.displayName = oJ;
    var o1 = 'MenuSubContent',
      o5 = eX.forwardRef((e, t) => {
        let n = oE(oC, e.__scopeMenu),
          { forceMount: i = n.forceMount, ...a } = e,
          o = om(oC, e.__scopeMenu),
          s = oy(oC, e.__scopeMenu),
          l = oX(o1, e.__scopeMenu),
          u = eX.useRef(null),
          c = e5(t, u);
        return (0, e2.jsx)(os.Provider, {
          scope: e.__scopeMenu,
          children: (0, e2.jsx)(tS, {
            present: i || o.open,
            children: (0, e2.jsx)(os.Slot, {
              scope: e.__scopeMenu,
              children: (0, e2.jsx)(oR, {
                id: l.contentId,
                'aria-labelledby': l.triggerId,
                ...a,
                ref: c,
                align: 'start',
                side: 'rtl' === s.dir ? 'left' : 'right',
                disableOutsidePointerEvents: !1,
                disableOutsideScroll: !1,
                trapFocus: !1,
                onOpenAutoFocus: (e) => {
                  s.isUsingKeyboardRef.current && u.current?.focus(), e.preventDefault();
                },
                onCloseAutoFocus: (e) => e.preventDefault(),
                onFocusOutside: eJ(e.onFocusOutside, (e) => {
                  e.target !== l.trigger && o.onOpenChange(!1);
                }),
                onEscapeKeyDown: eJ(e.onEscapeKeyDown, (e) => {
                  s.onClose(), e.preventDefault();
                }),
                onKeyDown: eJ(e.onKeyDown, (e) => {
                  let t = e.currentTarget.contains(e.target),
                    n = oa[s.dir].includes(e.key);
                  t && n && (o.onOpenChange(!1), l.trigger?.focus(), e.preventDefault());
                }),
              }),
            }),
          }),
        });
      });
    function o2(e) {
      return e ? 'open' : 'closed';
    }
    function o6(e) {
      return 'indeterminate' === e;
    }
    function o3(e) {
      return o6(e) ? 'indeterminate' : e ? 'checked' : 'unchecked';
    }
    function o4(e) {
      return (t) => ('mouse' === t.pointerType ? e(t) : void 0);
    }
    o5.displayName = o1;
    var o8 = 'DropdownMenu',
      [o9, o7] = e3(o8, [od]),
      se = od(),
      [st, sr] = o9(o8),
      sn = (e) => {
        let {
            __scopeDropdownMenu: t,
            children: n,
            dir: i,
            open: a,
            defaultOpen: o,
            onOpenChange: s,
            modal: l = !0,
          } = e,
          u = se(t),
          c = eX.useRef(null),
          [d, f] = tt({ prop: a, defaultProp: o ?? !1, onChange: s, caller: o8 });
        return (0, e2.jsx)(st, {
          scope: t,
          triggerId: e7(),
          triggerRef: c,
          contentId: e7(),
          open: d,
          onOpenChange: f,
          onOpenToggle: eX.useCallback(() => f((e) => !e), [f]),
          modal: l,
          children: (0, e2.jsx)(ob, {
            ...u,
            open: d,
            onOpenChange: f,
            dir: i,
            modal: l,
            children: n,
          }),
        });
      };
    sn.displayName = o8;
    var si = 'DropdownMenuTrigger',
      sa = eX.forwardRef((e, t) => {
        let { __scopeDropdownMenu: n, disabled: i = !1, ...a } = e,
          o = sr(si, n),
          s = se(n);
        return (0, e2.jsx)(ov, {
          asChild: !0,
          ...s,
          children: (0, e2.jsx)(ta.button, {
            type: 'button',
            id: o.triggerId,
            'aria-haspopup': 'menu',
            'aria-expanded': o.open,
            'aria-controls': o.open ? o.contentId : void 0,
            'data-state': o.open ? 'open' : 'closed',
            'data-disabled': i ? '' : void 0,
            disabled: i,
            ...a,
            ref: e1(t, o.triggerRef),
            onPointerDown: eJ(e.onPointerDown, (e) => {
              !i &&
                0 === e.button &&
                !1 === e.ctrlKey &&
                (o.onOpenToggle(), o.open || e.preventDefault());
            }),
            onKeyDown: eJ(e.onKeyDown, (e) => {
              !i &&
                (['Enter', ' '].includes(e.key) && o.onOpenToggle(),
                'ArrowDown' === e.key && o.onOpenChange(!0),
                ['Enter', ' ', 'ArrowDown'].includes(e.key) && e.preventDefault());
            }),
          }),
        });
      });
    sa.displayName = si;
    var so = (e) => {
      let { __scopeDropdownMenu: t, ...n } = e,
        i = se(t);
      return (0, e2.jsx)(oS, { ...i, ...n });
    };
    so.displayName = 'DropdownMenuPortal';
    var ss = 'DropdownMenuContent',
      sl = eX.forwardRef((e, t) => {
        let { __scopeDropdownMenu: n, ...i } = e,
          a = sr(ss, n),
          o = se(n),
          s = eX.useRef(!1);
        return (0, e2.jsx)(oA, {
          id: a.contentId,
          'aria-labelledby': a.triggerId,
          ...o,
          ...i,
          ref: t,
          onCloseAutoFocus: eJ(e.onCloseAutoFocus, (e) => {
            s.current || a.triggerRef.current?.focus(), (s.current = !1), e.preventDefault();
          }),
          onInteractOutside: eJ(e.onInteractOutside, (e) => {
            let t = e.detail.originalEvent,
              n = 0 === t.button && !0 === t.ctrlKey,
              i = 2 === t.button || n;
            (!a.modal || i) && (s.current = !0);
          }),
          style: {
            ...e.style,
            '--radix-dropdown-menu-content-transform-origin':
              'var(--radix-popper-transform-origin)',
            '--radix-dropdown-menu-content-available-width': 'var(--radix-popper-available-width)',
            '--radix-dropdown-menu-content-available-height':
              'var(--radix-popper-available-height)',
            '--radix-dropdown-menu-trigger-width': 'var(--radix-popper-anchor-width)',
            '--radix-dropdown-menu-trigger-height': 'var(--radix-popper-anchor-height)',
          },
        });
      });
    (sl.displayName = ss),
      (eX.forwardRef((e, t) => {
        let { __scopeDropdownMenu: n, ...i } = e,
          a = se(n);
        return (0, e2.jsx)(oM, { ...a, ...i, ref: t });
      }).displayName = 'DropdownMenuGroup'),
      (eX.forwardRef((e, t) => {
        let { __scopeDropdownMenu: n, ...i } = e,
          a = se(n);
        return (0, e2.jsx)(oP, { ...a, ...i, ref: t });
      }).displayName = 'DropdownMenuLabel');
    var su = eX.forwardRef((e, t) => {
      let { __scopeDropdownMenu: n, ...i } = e,
        a = se(n);
      return (0, e2.jsx)(oD, { ...a, ...i, ref: t });
    });
    (su.displayName = 'DropdownMenuItem'),
      (eX.forwardRef((e, t) => {
        let { __scopeDropdownMenu: n, ...i } = e,
          a = se(n);
        return (0, e2.jsx)(oU, { ...a, ...i, ref: t });
      }).displayName = 'DropdownMenuCheckboxItem'),
      (eX.forwardRef((e, t) => {
        let { __scopeDropdownMenu: n, ...i } = e,
          a = se(n);
        return (0, e2.jsx)(oV, { ...a, ...i, ref: t });
      }).displayName = 'DropdownMenuRadioGroup'),
      (eX.forwardRef((e, t) => {
        let { __scopeDropdownMenu: n, ...i } = e,
          a = se(n);
        return (0, e2.jsx)(oW, { ...a, ...i, ref: t });
      }).displayName = 'DropdownMenuRadioItem'),
      (eX.forwardRef((e, t) => {
        let { __scopeDropdownMenu: n, ...i } = e,
          a = se(n);
        return (0, e2.jsx)(oH, { ...a, ...i, ref: t });
      }).displayName = 'DropdownMenuItemIndicator');
    var sc = eX.forwardRef((e, t) => {
      let { __scopeDropdownMenu: n, ...i } = e,
        a = se(n);
      return (0, e2.jsx)(oZ, { ...a, ...i, ref: t });
    });
    (sc.displayName = 'DropdownMenuSeparator'),
      (eX.forwardRef((e, t) => {
        let { __scopeDropdownMenu: n, ...i } = e,
          a = se(n);
        return (0, e2.jsx)(oY, { ...a, ...i, ref: t });
      }).displayName = 'DropdownMenuArrow'),
      (eX.forwardRef((e, t) => {
        let { __scopeDropdownMenu: n, ...i } = e,
          a = se(n);
        return (0, e2.jsx)(o0, { ...a, ...i, ref: t });
      }).displayName = 'DropdownMenuSubTrigger'),
      (eX.forwardRef((e, t) => {
        let { __scopeDropdownMenu: n, ...i } = e,
          a = se(n);
        return (0, e2.jsx)(o5, {
          ...a,
          ...i,
          ref: t,
          style: {
            ...e.style,
            '--radix-dropdown-menu-content-transform-origin':
              'var(--radix-popper-transform-origin)',
            '--radix-dropdown-menu-content-available-width': 'var(--radix-popper-available-width)',
            '--radix-dropdown-menu-content-available-height':
              'var(--radix-popper-available-height)',
            '--radix-dropdown-menu-trigger-width': 'var(--radix-popper-anchor-width)',
            '--radix-dropdown-menu-trigger-height': 'var(--radix-popper-anchor-height)',
          },
        });
      }).displayName = 'DropdownMenuSubContent');
    var sd =
      (((U = sd || {}).Mainnet = 'mainnet'),
      (U.Devnet = 'devnet'),
      (U.Testnet = 'testnet'),
      (U.Localnet = 'localnet'),
      (U.Custom = 'custom'),
      U);
    function sf(e) {
      return (
        (function () {
          let e;
          try {
            e = JSON.parse(
              '{\n    "mainnet": {\n        "id": "mainnet",\n        "name": "Mainnet",\n        "url": "https://api.mainnet.iota.cafe",\n        "graphql": "https://graphql.mainnet.iota.cafe",\n        "explorer": "https://explorer.rebased.iota.org",\n        "chain": "iota:mainnet"\n    },\n    "testnet": {\n        "id": "testnet",\n        "name": "Testnet",\n        "url": "https://api.testnet.iota.cafe",\n        "graphql": "https://graphql.testnet.iota.cafe",\n        "explorer": "https://explorer.rebased.iota.org",\n        "chain": "iota:testnet",\n        "faucet": "https://faucet.testnet.iota.cafe",\n        "kiosk": {\n            "royaltyRulePackageId": "0x975f749f57701209454e4b9b9e33825ccb6a9abf57de2ce86979e5fa86c343f2",\n            "kioskLockRulePackageId": "0x975f749f57701209454e4b9b9e33825ccb6a9abf57de2ce86979e5fa86c343f2",\n            "floorPriceRulePackageId": "0x975f749f57701209454e4b9b9e33825ccb6a9abf57de2ce86979e5fa86c343f2",\n            "personalKioskRulePackageId": "0x975f749f57701209454e4b9b9e33825ccb6a9abf57de2ce86979e5fa86c343f2"\n        }\n    },\n    "devnet": {\n        "id": "devnet",\n        "name": "Devnet",\n        "url": "https://api.devnet.iota.cafe",\n        "graphql": "https://graphql.devnet.iota.cafe",\n        "explorer": "https://explorer.rebased.iota.org",\n        "chain": "iota:devnet",\n        "faucet": "https://faucet.devnet.iota.cafe"\n    },\n    "localnet": {\n        "id": "localnet",\n        "name": "Localnet",\n        "url": "http://localhost:9000",\n        "graphql": "http://localhost:9125",\n        "explorer": "http://localhost:3000",\n        "chain": "iota:local",\n        "faucet": "http://localhost:9123"\n    }\n}'
            );
          } catch {
            throw Error('Failed to parse env var "IOTA_NETWORKS".');
          }
          return e;
        })()[e] ?? e
      );
    }
    var sh = class extends nh {
      #b;
      #v;
      #w;
      #s;
      #c;
      #x;
      #E;
      constructor(e) {
        super(),
          (this.#E = !1),
          (this.#x = e.defaultOptions),
          this.setOptions(e.options),
          (this.observers = []),
          (this.#s = e.client),
          (this.#w = this.#s.getQueryCache()),
          (this.queryKey = e.queryKey),
          (this.queryHash = e.queryHash),
          (this.#b = sg(this.options)),
          (this.state = e.state ?? this.#b),
          this.scheduleGc();
      }
      get meta() {
        return this.options.meta;
      }
      get promise() {
        return this.#c?.promise;
      }
      setOptions(e) {
        if (
          ((this.options = { ...this.#x, ...e }),
          this.updateGcTime(this.options.gcTime),
          this.state && void 0 === this.state.data)
        ) {
          let e = sg(this.options);
          void 0 !== e.data && (this.setState(sm(e.data, e.dataUpdatedAt)), (this.#b = e));
        }
      }
      optionalRemove() {
        this.observers.length || 'idle' !== this.state.fetchStatus || this.#w.remove(this);
      }
      setData(e, t) {
        let n = ns(this.state.data, e, this.options);
        return (
          this.#d({ data: n, type: 'success', dataUpdatedAt: t?.updatedAt, manual: t?.manual }), n
        );
      }
      setState(e, t) {
        this.#d({ type: 'setState', state: e, setStateOptions: t });
      }
      cancel(e) {
        let t = this.#c?.promise;
        return this.#c?.cancel(e), t ? t.then(rJ).catch(rJ) : Promise.resolve();
      }
      destroy() {
        super.destroy(), this.cancel({ silent: !0 });
      }
      reset() {
        this.destroy(), this.setState(this.#b);
      }
      isActive() {
        return this.observers.some((e) => !1 !== r6(e.options.enabled, this));
      }
      isDisabled() {
        return this.getObserversCount() > 0
          ? !this.isActive()
          : this.options.queryFn === nc ||
              this.state.dataUpdateCount + this.state.errorUpdateCount === 0;
      }
      isStatic() {
        return (
          this.getObserversCount() > 0 &&
          this.observers.some((e) => 'static' === r2(e.options.staleTime, this))
        );
      }
      isStale() {
        return this.getObserversCount() > 0
          ? this.observers.some((e) => e.getCurrentResult().isStale)
          : void 0 === this.state.data || this.state.isInvalidated;
      }
      isStaleByTime(e = 0) {
        return (
          void 0 === this.state.data ||
          ('static' !== e && (!!this.state.isInvalidated || !r5(this.state.dataUpdatedAt, e)))
        );
      }
      onFocus() {
        let e = this.observers.find((e) => e.shouldFetchOnWindowFocus());
        e?.refetch({ cancelRefetch: !1 }), this.#c?.continue();
      }
      onOnline() {
        let e = this.observers.find((e) => e.shouldFetchOnReconnect());
        e?.refetch({ cancelRefetch: !1 }), this.#c?.continue();
      }
      addObserver(e) {
        this.observers.includes(e) ||
          (this.observers.push(e),
          this.clearGcTimeout(),
          this.#w.notify({ type: 'observerAdded', query: this, observer: e }));
      }
      removeObserver(e) {
        this.observers.includes(e) &&
          ((this.observers = this.observers.filter((t) => t !== e)),
          this.observers.length ||
            (this.#c && (this.#E ? this.#c.cancel({ revert: !0 }) : this.#c.cancelRetry()),
            this.scheduleGc()),
          this.#w.notify({ type: 'observerRemoved', query: this, observer: e }));
      }
      getObserversCount() {
        return this.observers.length;
      }
      invalidate() {
        this.state.isInvalidated || this.#d({ type: 'invalidate' });
      }
      async fetch(e, t) {
        let n;
        if ('idle' !== this.state.fetchStatus && this.#c?.status() !== 'rejected') {
          if (void 0 !== this.state.data && t?.cancelRefetch) this.cancel({ silent: !0 });
          else if (this.#c) return this.#c.continueRetry(), this.#c.promise;
        }
        if ((e && this.setOptions(e), !this.options.queryFn)) {
          let e = this.observers.find((e) => e.options.queryFn);
          e && this.setOptions(e.options);
        }
        let i = new AbortController(),
          a = (e) => {
            Object.defineProperty(e, 'signal', {
              enumerable: !0,
              get: () => ((this.#E = !0), i.signal),
            });
          },
          o = () => {
            let e,
              n = nd(this.options, t),
              i = (a((e = { client: this.#s, queryKey: this.queryKey, meta: this.meta })), e);
            return ((this.#E = !1), this.options.persister)
              ? this.options.persister(n, i, this)
              : n(i);
          },
          s =
            (a(
              (n = {
                fetchOptions: t,
                options: this.options,
                queryKey: this.queryKey,
                client: this.#s,
                state: this.state,
                fetchFn: o,
              })
            ),
            n);
        this.options.behavior?.onFetch(s, this),
          (this.#v = this.state),
          ('idle' === this.state.fetchStatus || this.state.fetchMeta !== s.fetchOptions?.meta) &&
            this.#d({ type: 'fetch', meta: s.fetchOptions?.meta }),
          (this.#c = nx({
            initialPromise: t?.initialPromise,
            fn: s.fetchFn,
            onCancel: (e) => {
              e instanceof nw && e.revert && this.setState({ ...this.#v, fetchStatus: 'idle' }),
                i.abort();
            },
            onFail: (e, t) => {
              this.#d({ type: 'failed', failureCount: e, error: t });
            },
            onPause: () => {
              this.#d({ type: 'pause' });
            },
            onContinue: () => {
              this.#d({ type: 'continue' });
            },
            retry: s.options.retry,
            retryDelay: s.options.retryDelay,
            networkMode: s.options.networkMode,
            canRun: () => !0,
          }));
        try {
          let e = await this.#c.start();
          if (void 0 === e) throw Error(`${this.queryHash} data is undefined`);
          return (
            this.setData(e),
            this.#w.config.onSuccess?.(e, this),
            this.#w.config.onSettled?.(e, this.state.error, this),
            e
          );
        } catch (e) {
          if (e instanceof nw) {
            if (e.silent) return this.#c.promise;
            else if (e.revert) {
              if (void 0 === this.state.data) throw e;
              return this.state.data;
            }
          }
          throw (
            (this.#d({ type: 'error', error: e }),
            this.#w.config.onError?.(e, this),
            this.#w.config.onSettled?.(this.state.data, e, this),
            e)
          );
        } finally {
          this.scheduleGc();
        }
      }
      #d(e) {
        let t = (t) => {
          switch (e.type) {
            case 'failed':
              return { ...t, fetchFailureCount: e.failureCount, fetchFailureReason: e.error };
            case 'pause':
              return { ...t, fetchStatus: 'paused' };
            case 'continue':
              return { ...t, fetchStatus: 'fetching' };
            case 'fetch':
              return { ...t, ...sp(t.data, this.options), fetchMeta: e.meta ?? null };
            case 'success':
              let n = {
                ...t,
                ...sm(e.data, e.dataUpdatedAt),
                dataUpdateCount: t.dataUpdateCount + 1,
                ...(!e.manual && {
                  fetchStatus: 'idle',
                  fetchFailureCount: 0,
                  fetchFailureReason: null,
                }),
              };
              return (this.#v = e.manual ? n : void 0), n;
            case 'error':
              let i = e.error;
              return {
                ...t,
                error: i,
                errorUpdateCount: t.errorUpdateCount + 1,
                errorUpdatedAt: Date.now(),
                fetchFailureCount: t.fetchFailureCount + 1,
                fetchFailureReason: i,
                fetchStatus: 'idle',
                status: 'error',
              };
            case 'invalidate':
              return { ...t, isInvalidated: !0 };
            case 'setState':
              return { ...t, ...e.state };
          }
        };
        (this.state = t(this.state)),
          rQ.batch(() => {
            this.observers.forEach((e) => {
              e.onQueryUpdate();
            }),
              this.#w.notify({ query: this, type: 'updated', action: e });
          });
      }
    };
    function sp(e, t) {
      return {
        fetchFailureCount: 0,
        fetchFailureReason: null,
        fetchStatus: nv(t.networkMode) ? 'fetching' : 'paused',
        ...(void 0 === e && { error: null, status: 'pending' }),
      };
    }
    function sm(e, t) {
      return {
        data: e,
        dataUpdatedAt: t ?? Date.now(),
        error: null,
        isInvalidated: !1,
        status: 'success',
      };
    }
    function sg(e) {
      let t = 'function' == typeof e.initialData ? e.initialData() : e.initialData,
        n = void 0 !== t,
        i = n
          ? 'function' == typeof e.initialDataUpdatedAt
            ? e.initialDataUpdatedAt()
            : e.initialDataUpdatedAt
          : 0;
      return {
        data: t,
        dataUpdateCount: 0,
        dataUpdatedAt: n ? i ?? Date.now() : 0,
        error: null,
        errorUpdateCount: 0,
        errorUpdatedAt: 0,
        fetchFailureCount: 0,
        fetchFailureReason: null,
        fetchMeta: null,
        isInvalidated: !1,
        status: n ? 'success' : 'pending',
        fetchStatus: 'idle',
      };
    }
    e.s(['Query', () => sh, 'fetchState', () => sp], 86491);
    var sy = class extends np {
      constructor(e, t) {
        super(),
          (this.options = t),
          (this.#s = e),
          (this.#S = null),
          (this.#C = ny()),
          this.bindMethods(),
          this.setOptions(t);
      }
      #s;
      #k = void 0;
      #O = void 0;
      #f = void 0;
      #A;
      #I;
      #C;
      #S;
      #j;
      #T;
      #R;
      #M;
      #P;
      #N;
      #_ = new Set();
      bindMethods() {
        this.refetch = this.refetch.bind(this);
      }
      onSubscribe() {
        1 === this.listeners.size &&
          (this.#k.addObserver(this),
          sb(this.#k, this.options) ? this.#D() : this.updateResult(),
          this.#B());
      }
      onUnsubscribe() {
        this.hasListeners() || this.destroy();
      }
      shouldFetchOnReconnect() {
        return sv(this.#k, this.options, this.options.refetchOnReconnect);
      }
      shouldFetchOnWindowFocus() {
        return sv(this.#k, this.options, this.options.refetchOnWindowFocus);
      }
      destroy() {
        (this.listeners = new Set()), this.#U(), this.#F(), this.#k.removeObserver(this);
      }
      setOptions(e) {
        let t = this.options,
          n = this.#k;
        if (
          ((this.options = this.#s.defaultQueryOptions(e)),
          void 0 !== this.options.enabled &&
            'boolean' != typeof this.options.enabled &&
            'function' != typeof this.options.enabled &&
            'boolean' != typeof r6(this.options.enabled, this.#k))
        )
          throw Error('Expected enabled to be a boolean or a callback that returns a boolean');
        this.#L(),
          this.#k.setOptions(this.options),
          t._defaulted &&
            !nr(this.options, t) &&
            this.#s
              .getQueryCache()
              .notify({ type: 'observerOptionsUpdated', query: this.#k, observer: this });
        let i = this.hasListeners();
        i && sw(this.#k, n, this.options, t) && this.#D(),
          this.updateResult(),
          i &&
            (this.#k !== n ||
              r6(this.options.enabled, this.#k) !== r6(t.enabled, this.#k) ||
              r2(this.options.staleTime, this.#k) !== r2(t.staleTime, this.#k)) &&
            this.#z();
        let a = this.#V();
        i &&
          (this.#k !== n ||
            r6(this.options.enabled, this.#k) !== r6(t.enabled, this.#k) ||
            a !== this.#N) &&
          this.#$(a);
      }
      getOptimisticResult(e) {
        var t, n;
        let i = this.#s.getQueryCache().build(this.#s, e),
          a = this.createResult(i, e);
        return (
          (t = this),
          (n = a),
          nr(t.getCurrentResult(), n) ||
            ((this.#f = a), (this.#I = this.options), (this.#A = this.#k.state)),
          a
        );
      }
      getCurrentResult() {
        return this.#f;
      }
      trackResult(e, t) {
        return new Proxy(e, {
          get: (e, n) => (
            this.trackProp(n),
            t?.(n),
            'promise' === n &&
              (this.trackProp('data'),
              this.options.experimental_prefetchInRender ||
                'pending' !== this.#C.status ||
                this.#C.reject(Error('experimental_prefetchInRender feature flag is not enabled'))),
            Reflect.get(e, n)
          ),
        });
      }
      trackProp(e) {
        this.#_.add(e);
      }
      getCurrentQuery() {
        return this.#k;
      }
      refetch({ ...e } = {}) {
        return this.fetch({ ...e });
      }
      fetchOptimistic(e) {
        let t = this.#s.defaultQueryOptions(e),
          n = this.#s.getQueryCache().build(this.#s, t);
        return n.fetch().then(() => this.createResult(n, t));
      }
      fetch(e) {
        return this.#D({ ...e, cancelRefetch: e.cancelRefetch ?? !0 }).then(
          () => (this.updateResult(), this.#f)
        );
      }
      #D(e) {
        this.#L();
        let t = this.#k.fetch(this.options, e);
        return e?.throwOnError || (t = t.catch(rJ)), t;
      }
      #z() {
        this.#U();
        let e = r2(this.options.staleTime, this.#k);
        if (rX || this.#f.isStale || !r1(e)) return;
        let t = r5(this.#f.dataUpdatedAt, e);
        this.#M = rY.setTimeout(() => {
          this.#f.isStale || this.updateResult();
        }, t + 1);
      }
      #V() {
        return (
          ('function' == typeof this.options.refetchInterval
            ? this.options.refetchInterval(this.#k)
            : this.options.refetchInterval) ?? !1
        );
      }
      #$(e) {
        this.#F(),
          (this.#N = e),
          !rX &&
            !1 !== r6(this.options.enabled, this.#k) &&
            r1(this.#N) &&
            0 !== this.#N &&
            (this.#P = rY.setInterval(() => {
              (this.options.refetchIntervalInBackground || nm.isFocused()) && this.#D();
            }, this.#N));
      }
      #B() {
        this.#z(), this.#$(this.#V());
      }
      #U() {
        this.#M && (rY.clearTimeout(this.#M), (this.#M = void 0));
      }
      #F() {
        this.#P && (rY.clearInterval(this.#P), (this.#P = void 0));
      }
      createResult(e, t) {
        let n,
          i = this.#k,
          a = this.options,
          o = this.#f,
          s = this.#A,
          l = this.#I,
          u = e !== i ? e.state : this.#O,
          { state: c } = e,
          d = { ...c },
          f = !1;
        if (t._optimisticResults) {
          let n = this.hasListeners(),
            o = !n && sb(e, t),
            s = n && sw(e, i, t, a);
          (o || s) && (d = { ...d, ...sp(c.data, e.options) }),
            'isRestoring' === t._optimisticResults && (d.fetchStatus = 'idle');
        }
        let { error: h, errorUpdatedAt: p, status: m } = d;
        n = d.data;
        let g = !1;
        if (void 0 !== t.placeholderData && void 0 === n && 'pending' === m) {
          let e;
          o?.isPlaceholderData && t.placeholderData === l?.placeholderData
            ? ((e = o.data), (g = !0))
            : (e =
                'function' == typeof t.placeholderData
                  ? t.placeholderData(this.#R?.state.data, this.#R)
                  : t.placeholderData),
            void 0 !== e && ((m = 'success'), (n = ns(o?.data, e, t)), (f = !0));
        }
        if (t.select && void 0 !== n && !g)
          if (o && n === s?.data && t.select === this.#j) n = this.#T;
          else
            try {
              (this.#j = t.select),
                (n = t.select(n)),
                (n = ns(o?.data, n, t)),
                (this.#T = n),
                (this.#S = null);
            } catch (e) {
              this.#S = e;
            }
        this.#S && ((h = this.#S), (n = this.#T), (p = Date.now()), (m = 'error'));
        let y = 'fetching' === d.fetchStatus,
          b = 'pending' === m,
          v = 'error' === m,
          w = b && y,
          x = void 0 !== n,
          E = {
            status: m,
            fetchStatus: d.fetchStatus,
            isPending: b,
            isSuccess: 'success' === m,
            isError: v,
            isInitialLoading: w,
            isLoading: w,
            data: n,
            dataUpdatedAt: d.dataUpdatedAt,
            error: h,
            errorUpdatedAt: p,
            failureCount: d.fetchFailureCount,
            failureReason: d.fetchFailureReason,
            errorUpdateCount: d.errorUpdateCount,
            isFetched: d.dataUpdateCount > 0 || d.errorUpdateCount > 0,
            isFetchedAfterMount:
              d.dataUpdateCount > u.dataUpdateCount || d.errorUpdateCount > u.errorUpdateCount,
            isFetching: y,
            isRefetching: y && !b,
            isLoadingError: v && !x,
            isPaused: 'paused' === d.fetchStatus,
            isPlaceholderData: f,
            isRefetchError: v && x,
            isStale: sx(e, t),
            refetch: this.refetch,
            promise: this.#C,
            isEnabled: !1 !== r6(t.enabled, e),
          };
        if (this.options.experimental_prefetchInRender) {
          let t = (e) => {
              'error' === E.status ? e.reject(E.error) : void 0 !== E.data && e.resolve(E.data);
            },
            n = () => {
              t((this.#C = E.promise = ny()));
            },
            a = this.#C;
          switch (a.status) {
            case 'pending':
              e.queryHash === i.queryHash && t(a);
              break;
            case 'fulfilled':
              ('error' === E.status || E.data !== a.value) && n();
              break;
            case 'rejected':
              ('error' !== E.status || E.error !== a.reason) && n();
          }
        }
        return E;
      }
      updateResult() {
        let e = this.#f,
          t = this.createResult(this.#k, this.options);
        if (
          ((this.#A = this.#k.state),
          (this.#I = this.options),
          void 0 !== this.#A.data && (this.#R = this.#k),
          nr(t, e))
        )
          return;
        this.#f = t;
        let n = () => {
          if (!e) return !0;
          let { notifyOnChangeProps: t } = this.options,
            n = 'function' == typeof t ? t() : t;
          if ('all' === n || (!n && !this.#_.size)) return !0;
          let i = new Set(n ?? this.#_);
          return (
            this.options.throwOnError && i.add('error'),
            Object.keys(this.#f).some((t) => this.#f[t] !== e[t] && i.has(t))
          );
        };
        this.#g({ listeners: n() });
      }
      #L() {
        let e = this.#s.getQueryCache().build(this.#s, this.options);
        if (e === this.#k) return;
        let t = this.#k;
        (this.#k = e),
          (this.#O = e.state),
          this.hasListeners() && (t?.removeObserver(this), e.addObserver(this));
      }
      onQueryUpdate() {
        this.updateResult(), this.hasListeners() && this.#B();
      }
      #g(e) {
        rQ.batch(() => {
          e.listeners &&
            this.listeners.forEach((e) => {
              e(this.#f);
            }),
            this.#s.getQueryCache().notify({ query: this.#k, type: 'observerResultsUpdated' });
        });
      }
    };
    function sb(e, t) {
      return (
        (!1 !== r6(t.enabled, e) &&
          void 0 === e.state.data &&
          ('error' !== e.state.status || !1 !== t.retryOnMount)) ||
        (void 0 !== e.state.data && sv(e, t, t.refetchOnMount))
      );
    }
    function sv(e, t, n) {
      if (!1 !== r6(t.enabled, e) && 'static' !== r2(t.staleTime, e)) {
        let i = 'function' == typeof n ? n(e) : n;
        return 'always' === i || (!1 !== i && sx(e, t));
      }
      return !1;
    }
    function sw(e, t, n, i) {
      return (
        (e !== t || !1 === r6(i.enabled, e)) &&
        (!n.suspense || 'error' !== e.state.status) &&
        sx(e, n)
      );
    }
    function sx(e, t) {
      return !1 !== r6(t.enabled, e) && e.isStaleByTime(r2(t.staleTime, e));
    }
    var sE = eX.createContext(
        ((g = !1),
        {
          clearReset: () => {
            g = !1;
          },
          reset: () => {
            g = !0;
          },
          isReset: () => g,
        })
      ),
      sS = eX.createContext(!1);
    sS.Provider;
    var sC = (e, t, n) =>
      t.fetchOptimistic(e).catch(() => {
        n.clearReset();
      });
    function sk(e, t) {
      return (function (e, t, n) {
        let i = eX.useContext(sS),
          a = eX.useContext(sE),
          o = nO(n),
          s = o.defaultQueryOptions(e);
        if (
          (o.getDefaultOptions().queries?._experimental_beforeQuery?.(s),
          (s._optimisticResults = i ? 'isRestoring' : 'optimistic'),
          s.suspense)
        ) {
          let e = (e) => ('static' === e ? e : Math.max(e ?? 1e3, 1e3)),
            t = s.staleTime;
          (s.staleTime = 'function' == typeof t ? (...n) => e(t(...n)) : e(t)),
            'number' == typeof s.gcTime && (s.gcTime = Math.max(s.gcTime, 1e3));
        }
        (s.suspense || s.throwOnError || s.experimental_prefetchInRender) &&
          !a.isReset() &&
          (s.retryOnMount = !1),
          eX.useEffect(() => {
            a.clearReset();
          }, [a]);
        let l = !o.getQueryCache().get(s.queryHash),
          [u] = eX.useState(() => new t(o, s)),
          c = u.getOptimisticResult(s),
          d = !i && !1 !== e.subscribed;
        if (
          (eX.useSyncExternalStore(
            eX.useCallback(
              (e) => {
                let t = d ? u.subscribe(rQ.batchCalls(e)) : rJ;
                return u.updateResult(), t;
              },
              [u, d]
            ),
            () => u.getCurrentResult(),
            () => u.getCurrentResult()
          ),
          eX.useEffect(() => {
            u.setOptions(s);
          }, [s, u]),
          s?.suspense && c.isPending)
        )
          throw sC(s, u, a);
        if (
          (({ result: e, errorResetBoundary: t, throwOnError: n, query: i, suspense: a }) =>
            e.isError &&
            !t.isReset() &&
            !e.isFetching &&
            i &&
            ((a && void 0 === e.data) || nf(n, [e.error, i])))({
            result: c,
            errorResetBoundary: a,
            throwOnError: s.throwOnError,
            query: o.getQueryCache().get(s.queryHash),
            suspense: s.suspense,
          })
        )
          throw c.error;
        if (
          (o.getDefaultOptions().queries?._experimental_afterQuery?.(s, c),
          s.experimental_prefetchInRender && !rX && c.isLoading && c.isFetching && !i)
        ) {
          let e = l ? sC(s, u, a) : o.getQueryCache().get(s.queryHash)?.promise;
          e?.catch(rJ).finally(() => {
            u.updateResult();
          });
        }
        return s.notifyOnChangeProps ? c : u.trackResult(c);
      })(e, sy, t);
    }
    let sO = (e) => n2.encode(e),
      sA = (e) => n2.decode(e);
    function sI(e) {
      return Uint8Array.from(atob(e), (e) => e.charCodeAt(0));
    }
    function sj(e) {
      if (e.length < 8192) return btoa(String.fromCharCode(...e));
      let t = '';
      for (let n = 0; n < e.length; n += 8192) t += String.fromCharCode(...e.slice(n, n + 8192));
      return btoa(t);
    }
    function sT(e) {
      let t = e.startsWith('0x') ? e.slice(2) : e,
        n = t.length % 2 == 0 ? t : `0${t}}`,
        i = n.match(/.{2}/g)?.map((e) => parseInt(e, 16)) ?? [];
      return Uint8Array.from(i);
    }
    function sR(e) {
      return e.reduce((e, t) => e + t.toString(16).padStart(2, '0'), '');
    }
    function sM(e) {
      let t = [],
        n = 0;
      if (0 === e) return [0];
      for (; e > 0; ) (t[n] = 127 & e), (e >>= 7) && (t[n] |= 128), (n += 1);
      return t;
    }
    e.s(['fromB58', () => sA, 'fromBase58', () => sA, 'toBase58', () => sO], 17423),
      e.s(
        ['fromB64', () => sI, 'fromBase64', () => sI, 'toB64', () => sj, 'toBase64', () => sj],
        36416
      );
    class sP {
      constructor(e) {
        (this.bytePosition = 0),
          (this.dataView = new DataView(e.buffer, e.byteOffset, e.byteLength));
      }
      shift(e) {
        return (this.bytePosition += e), this;
      }
      read8() {
        let e = this.dataView.getUint8(this.bytePosition);
        return this.shift(1), e;
      }
      read16() {
        let e = this.dataView.getUint16(this.bytePosition, !0);
        return this.shift(2), e;
      }
      read32() {
        let e = this.dataView.getUint32(this.bytePosition, !0);
        return this.shift(4), e;
      }
      read64() {
        let e = this.read32();
        return BigInt(
          '0x' + (this.read32().toString(16) + e.toString(16).padStart(8, '0'))
        ).toString(10);
      }
      read128() {
        let e = BigInt(this.read64());
        return BigInt(
          '0x' + (BigInt(this.read64()).toString(16) + e.toString(16).padStart(16, '0'))
        ).toString(10);
      }
      read256() {
        let e = BigInt(this.read128());
        return BigInt(
          '0x' + (BigInt(this.read128()).toString(16) + e.toString(16).padStart(32, '0'))
        ).toString(10);
      }
      readBytes(e) {
        let t = this.bytePosition + this.dataView.byteOffset,
          n = new Uint8Array(this.dataView.buffer, t, e);
        return this.shift(e), n;
      }
      readULEB() {
        let e = this.bytePosition + this.dataView.byteOffset,
          { value: t, length: n } = (function (e) {
            let t = 0,
              n = 0,
              i = 0;
            for (;;) {
              let a = e[i];
              if (((i += 1), (t |= (127 & a) << n), (128 & a) == 0)) break;
              n += 7;
            }
            return { value: t, length: i };
          })(new Uint8Array(this.dataView.buffer, e));
        return this.shift(n), t;
      }
      readVec(e) {
        let t = this.readULEB(),
          n = [];
        for (let i = 0; i < t; i++) n.push(e(this, i, t));
        return n;
      }
    }
    class sN {
      constructor({ initialSize: e = 1024, maxSize: t = 1 / 0, allocateSize: n = 1024 } = {}) {
        (this.bytePosition = 0),
          (this.size = e),
          (this.maxSize = t),
          (this.allocateSize = n),
          (this.dataView = new DataView(new ArrayBuffer(e)));
      }
      ensureSizeOrGrow(e) {
        let t = this.bytePosition + e;
        if (t > this.size) {
          let e = Math.min(this.maxSize, this.size + this.allocateSize);
          if (t > e)
            throw Error(
              `SizeLimitExceeded: Attempting to serialize to BCS, but buffer does not have enough size. Allocated size: ${this.size}, Max size: ${this.maxSize}, Required size: ${t}`
            );
          this.size = e;
          let n = new ArrayBuffer(this.size);
          new Uint8Array(n).set(new Uint8Array(this.dataView.buffer)),
            (this.dataView = new DataView(n));
        }
      }
      shift(e) {
        return (this.bytePosition += e), this;
      }
      write8(e) {
        return (
          this.ensureSizeOrGrow(1),
          this.dataView.setUint8(this.bytePosition, Number(e)),
          this.shift(1)
        );
      }
      write16(e) {
        return (
          this.ensureSizeOrGrow(2),
          this.dataView.setUint16(this.bytePosition, Number(e), !0),
          this.shift(2)
        );
      }
      write32(e) {
        return (
          this.ensureSizeOrGrow(4),
          this.dataView.setUint32(this.bytePosition, Number(e), !0),
          this.shift(4)
        );
      }
      write64(e) {
        return s_(BigInt(e), 8).forEach((e) => this.write8(e)), this;
      }
      write128(e) {
        return s_(BigInt(e), 16).forEach((e) => this.write8(e)), this;
      }
      write256(e) {
        return s_(BigInt(e), 32).forEach((e) => this.write8(e)), this;
      }
      writeULEB(e) {
        return sM(e).forEach((e) => this.write8(e)), this;
      }
      writeVec(e, t) {
        return (
          this.writeULEB(e.length), Array.from(e).forEach((n, i) => t(this, n, i, e.length)), this
        );
      }
      *[Symbol.iterator]() {
        for (let e = 0; e < this.bytePosition; e++) yield this.dataView.getUint8(e);
        return this.toBytes();
      }
      toBytes() {
        return new Uint8Array(this.dataView.buffer.slice(0, this.bytePosition));
      }
      toString(e) {
        var t = this.toBytes();
        switch (e) {
          case 'base58':
            return sO(t);
          case 'base64':
            return sj(t);
          case 'hex':
            return sR(t);
          default:
            throw Error('Unsupported encoding, supported values are: base64, hex');
        }
      }
    }
    function s_(e, t) {
      let n = new Uint8Array(t),
        i = 0;
      for (; e > 0; ) (n[i] = Number(e % BigInt(256))), (e /= BigInt(256)), (i += 1);
      return n;
    }
    var sD = (e) => {
        throw TypeError(e);
      },
      sB = (e, t, n) => t.has(e) || sD('Cannot ' + n),
      sU = (e, t, n) => (sB(e, t, 'read from private field'), n ? n.call(e) : t.get(e)),
      sF = (e, t, n) =>
        t.has(e)
          ? sD('Cannot add the same private member more than once')
          : t instanceof WeakSet
          ? t.add(e)
          : t.set(e, n),
      sL = (e, t, n, i) => (sB(e, t, 'write to private field'), i ? i.call(e, n) : t.set(e, n), n);
    let sz = class e {
      constructor(e) {
        sF(this, J),
          sF(this, ee),
          (this.name = e.name),
          (this.read = e.read),
          (this.serializedSize = e.serializedSize ?? (() => null)),
          sL(this, J, e.write),
          sL(
            this,
            ee,
            e.serialize ??
              ((e, t) => {
                let n = new sN({ initialSize: this.serializedSize(e) ?? void 0, ...t });
                return sU(this, J).call(this, e, n), n.toBytes();
              })
          ),
          (this.validate = e.validate ?? (() => {}));
      }
      write(e, t) {
        this.validate(e), sU(this, J).call(this, e, t);
      }
      serialize(e, t) {
        return this.validate(e), new sW(this, sU(this, ee).call(this, e, t));
      }
      parse(e) {
        let t = new sP(e);
        return this.read(t);
      }
      fromHex(e) {
        return this.parse(sT(e));
      }
      fromBase58(e) {
        return this.parse(sA(e));
      }
      fromBase64(e) {
        return this.parse(sI(e));
      }
      transform({ name: t, input: n, output: i, validate: a }) {
        return new e({
          name: t ?? this.name,
          read: (e) => (i ? i(this.read(e)) : this.read(e)),
          write: (e, t) => sU(this, J).call(this, n ? n(e) : e, t),
          serializedSize: (e) => this.serializedSize(n ? n(e) : e),
          serialize: (e, t) => sU(this, ee).call(this, n ? n(e) : e, t),
          validate: (e) => {
            a?.(e), this.validate(n ? n(e) : e);
          },
        });
      }
    };
    (J = new WeakMap()), (ee = new WeakMap());
    let sV = Symbol.for('@iota/serialized-bcs');
    function s$(e) {
      return !!e && 'object' == typeof e && !0 === e[sV];
    }
    class sW {
      constructor(e, t) {
        sF(this, et), sF(this, er), sL(this, et, e), sL(this, er, t);
      }
      get [sV]() {
        return !0;
      }
      toBytes() {
        return sU(this, er);
      }
      toHex() {
        return sR(sU(this, er));
      }
      toBase64() {
        return sj(sU(this, er));
      }
      toBase58() {
        return sO(sU(this, er));
      }
      parse() {
        return sU(this, et).parse(sU(this, er));
      }
    }
    function sq({ size: e, ...t }) {
      return new sz({ ...t, serializedSize: () => e });
    }
    function sK({ readMethod: e, writeMethod: t, ...n }) {
      return sq({
        ...n,
        read: (t) => t[e](),
        write: (e, n) => n[t](e),
        validate: (e) => {
          if (e < 0 || e > n.maxValue)
            throw TypeError(
              `Invalid ${n.name} value: ${e}. Expected value in range 0-${n.maxValue}`
            );
          n.validate?.(e);
        },
      });
    }
    function sG({ readMethod: e, writeMethod: t, ...n }) {
      return sq({
        ...n,
        read: (t) => t[e](),
        write: (e, n) => n[t](BigInt(e)),
        validate: (e) => {
          let t = BigInt(e);
          if (t < 0 || t > n.maxValue)
            throw TypeError(
              `Invalid ${n.name} value: ${t}. Expected value in range 0-${n.maxValue}`
            );
          n.validate?.(t);
        },
      });
    }
    function sH({ serialize: e, ...t }) {
      let n = new sz({
        ...t,
        serialize: e,
        write: (e, t) => {
          for (let i of n.serialize(e).toBytes()) t.write8(i);
        },
      });
      return n;
    }
    function sZ({ toBytes: e, fromBytes: t, ...n }) {
      return new sz({
        ...n,
        read: (e) => {
          let n = e.readULEB();
          return t(e.readBytes(n));
        },
        write: (t, n) => {
          let i = e(t);
          n.writeULEB(i.length);
          for (let e = 0; e < i.length; e++) n.write8(i[e]);
        },
        serialize: (t) => {
          let n = e(t),
            i = sM(n.length),
            a = new Uint8Array(i.length + n.length);
          return a.set(i, 0), a.set(n, i.length), a;
        },
        validate: (e) => {
          if ('string' != typeof e)
            throw TypeError(`Invalid ${n.name} value: ${e}. Expected string`);
          n.validate?.(e);
        },
      });
    }
    function sY(e) {
      let t = null;
      function n() {
        return t || (t = e()), t;
      }
      return new sz({
        name: 'lazy',
        read: (e) => n().read(e),
        serializedSize: (e) => n().serializedSize(e),
        write: (e, t) => n().write(e, t),
        serialize: (e, t) => n().serialize(e, t).toBytes(),
      });
    }
    (et = new WeakMap()),
      (er = new WeakMap()),
      e.s(
        [
          'BcsType',
          () => sz,
          'bigUIntBcsType',
          () => sG,
          'dynamicSizeBcsType',
          () => sH,
          'fixedSizeBcsType',
          () => sq,
          'isSerializedBcs',
          () => s$,
          'lazyBcsType',
          () => sY,
          'stringLikeBcsType',
          () => sZ,
          'uIntBcsType',
          () => sK,
        ],
        69010
      );
    let sQ = {
      u8: (e) =>
        sK({
          name: 'u8',
          readMethod: 'read8',
          writeMethod: 'write8',
          size: 1,
          maxValue: 255,
          ...e,
        }),
      u16: (e) =>
        sK({
          name: 'u16',
          readMethod: 'read16',
          writeMethod: 'write16',
          size: 2,
          maxValue: 65535,
          ...e,
        }),
      u32: (e) =>
        sK({
          name: 'u32',
          readMethod: 'read32',
          writeMethod: 'write32',
          size: 4,
          maxValue: 0x100000000 - 1,
          ...e,
        }),
      u64: (e) =>
        sG({
          name: 'u64',
          readMethod: 'read64',
          writeMethod: 'write64',
          size: 8,
          maxValue: 2n ** 64n - 1n,
          ...e,
        }),
      u128: (e) =>
        sG({
          name: 'u128',
          readMethod: 'read128',
          writeMethod: 'write128',
          size: 16,
          maxValue: 2n ** 128n - 1n,
          ...e,
        }),
      u256: (e) =>
        sG({
          name: 'u256',
          readMethod: 'read256',
          writeMethod: 'write256',
          size: 32,
          maxValue: 2n ** 256n - 1n,
          ...e,
        }),
      bool: (e) =>
        sq({
          name: 'bool',
          size: 1,
          read: (e) => 1 === e.read8(),
          write: (e, t) => t.write8(+!!e),
          ...e,
          validate: (t) => {
            if ((e?.validate?.(t), 'boolean' != typeof t))
              throw TypeError(`Expected boolean, found ${typeof t}`);
          },
        }),
      uleb128: (e) =>
        sH({
          name: 'uleb128',
          read: (e) => e.readULEB(),
          serialize: (e) => Uint8Array.from(sM(e)),
          ...e,
        }),
      bytes: (e, t) =>
        sq({
          name: `bytes[${e}]`,
          size: e,
          read: (t) => t.readBytes(e),
          write: (t, n) => {
            for (let i = 0; i < e; i++) n.write8(t[i] ?? 0);
          },
          ...t,
          validate: (n) => {
            if ((t?.validate?.(n), !n || 'object' != typeof n || !('length' in n)))
              throw TypeError(`Expected array, found ${typeof n}`);
            if (n.length !== e) throw TypeError(`Expected array of length ${e}, found ${n.length}`);
          },
        }),
      byteVector: (e) =>
        new sz({
          name: 'bytesVector',
          read: (e) => {
            let t = e.readULEB();
            return e.readBytes(t);
          },
          write: (e, t) => {
            let n = new Uint8Array(e);
            t.writeULEB(n.length);
            for (let e = 0; e < n.length; e++) t.write8(n[e] ?? 0);
          },
          ...e,
          serializedSize: (e) => {
            let t = 'length' in e ? e.length : null;
            return null == t ? null : sM(t).length + t;
          },
          validate: (t) => {
            if ((e?.validate?.(t), !t || 'object' != typeof t || !('length' in t)))
              throw TypeError(`Expected array, found ${typeof t}`);
          },
        }),
      string: (e) =>
        sZ({
          name: 'string',
          toBytes: (e) => new TextEncoder().encode(e),
          fromBytes: (e) => new TextDecoder().decode(e),
          ...e,
        }),
      fixedArray: (e, t, n) =>
        new sz({
          name: `${t.name}[${e}]`,
          read: (n) => {
            let i = Array(e);
            for (let a = 0; a < e; a++) i[a] = t.read(n);
            return i;
          },
          write: (e, n) => {
            for (let i of e) t.write(i, n);
          },
          ...n,
          validate: (t) => {
            if ((n?.validate?.(t), !t || 'object' != typeof t || !('length' in t)))
              throw TypeError(`Expected array, found ${typeof t}`);
            if (t.length !== e) throw TypeError(`Expected array of length ${e}, found ${t.length}`);
          },
        }),
      option: (e) =>
        sQ
          .enum(`Option<${e.name}>`, { None: null, Some: e })
          .transform({
            input: (e) => (null == e ? { None: !0 } : { Some: e }),
            output: (e) => ('Some' === e.$kind ? e.Some : null),
          }),
      vector: (e, t) =>
        new sz({
          name: `vector<${e.name}>`,
          read: (t) => {
            let n = t.readULEB(),
              i = Array(n);
            for (let a = 0; a < n; a++) i[a] = e.read(t);
            return i;
          },
          write: (t, n) => {
            for (let i of (n.writeULEB(t.length), t)) e.write(i, n);
          },
          ...t,
          validate: (e) => {
            if ((t?.validate?.(e), !e || 'object' != typeof e || !('length' in e)))
              throw TypeError(`Expected array, found ${typeof e}`);
          },
        }),
      tuple: (e, t) =>
        new sz({
          name: `(${e.map((e) => e.name).join(', ')})`,
          serializedSize: (t) => {
            let n = 0;
            for (let i = 0; i < e.length; i++) {
              let a = e[i].serializedSize(t[i]);
              if (null == a) return null;
              n += a;
            }
            return n;
          },
          read: (t) => {
            let n = [];
            for (let i of e) n.push(i.read(t));
            return n;
          },
          write: (t, n) => {
            for (let i = 0; i < e.length; i++) e[i].write(t[i], n);
          },
          ...t,
          validate: (n) => {
            if ((t?.validate?.(n), !Array.isArray(n)))
              throw TypeError(`Expected array, found ${typeof n}`);
            if (n.length !== e.length)
              throw TypeError(`Expected array of length ${e.length}, found ${n.length}`);
          },
        }),
      struct(e, t, n) {
        let i = Object.entries(t);
        return new sz({
          name: e,
          serializedSize: (e) => {
            let t = 0;
            for (let [n, a] of i) {
              let i = a.serializedSize(e[n]);
              if (null == i) return null;
              t += i;
            }
            return t;
          },
          read: (e) => {
            let t = {};
            for (let [n, a] of i) t[n] = a.read(e);
            return t;
          },
          write: (e, t) => {
            for (let [n, a] of i) a.write(e[n], t);
          },
          ...n,
          validate: (e) => {
            if ((n?.validate?.(e), 'object' != typeof e || null == e))
              throw TypeError(`Expected object, found ${typeof e}`);
          },
        });
      },
      enum(e, t, n) {
        let i = Object.entries(t);
        return new sz({
          name: e,
          read: (t) => {
            let n = t.readULEB(),
              a = i[n];
            if (!a) throw TypeError(`Unknown value ${n} for enum ${e}`);
            let [o, s] = a;
            return { [o]: s?.read(t) ?? !0, $kind: o };
          },
          write: (e, n) => {
            let [a, o] = Object.entries(e).filter(([e]) => Object.hasOwn(t, e))[0];
            for (let e = 0; e < i.length; e++) {
              let [t, s] = i[e];
              if (t === a) {
                n.writeULEB(e), s?.write(o, n);
                return;
              }
            }
          },
          ...n,
          validate: (i) => {
            if ((n?.validate?.(i), 'object' != typeof i || null == i))
              throw TypeError(`Expected object, found ${typeof i}`);
            let a = Object.keys(i).filter((e) => void 0 !== i[e] && Object.hasOwn(t, e));
            if (1 !== a.length)
              throw TypeError(`Expected object with one key, but found ${a.length} for type ${e}}`);
            let [o] = a;
            if (!Object.hasOwn(t, o)) throw TypeError(`Invalid enum variant ${o}`);
          },
        });
      },
      map: (e, t) =>
        sQ.vector(sQ.tuple([e, t])).transform({
          name: `Map<${e.name}, ${t.name}>`,
          input: (e) => [...e.entries()],
          output: (e) => {
            let t = new Map();
            for (let [n, i] of e) t.set(n, i);
            return t;
          },
        }),
      lazy: (e) => sY(e),
    };
    function sX(e) {
      var t, n;
      return (
        (t = e),
        /^(0x|0X)?[a-fA-F0-9]+$/.test(t) &&
          t.length % 2 == 0 &&
          32 == ((n = e), /^(0x|0X)/.test(n) ? (n.length - 2) / 2 : n.length / 2)
      );
    }
    function sJ(e, t = !1, n = !1) {
      let i = e.toLowerCase().replace(/ /g, '');
      if (
        (!t && i.startsWith('0x') && (i = i.slice(2)),
        (i = `0x${i.padStart(64, '0')}`),
        !n || sX(i))
      )
        return i;
      throw Error(`Invalid IOTA address: ${e}`);
    }
    function s0(e, t = !1, n = !1) {
      return sJ(e, t, n);
    }
    e.s(
      [
        'IOTA_ADDRESS_LENGTH',
        () => 32,
        'isValidIotaAddress',
        () => sX,
        'normalizeIotaAddress',
        () => sJ,
        'normalizeIotaObjectId',
        () => s0,
      ],
      10297
    );
    let s1 = /^vector<(.+)>$/,
      s5 = /^([^:]+)::([^:]+)::([^<]+)(<(.+)>)?/;
    class s2 {
      static parseFromStr(e, t = !1) {
        if ('address' === e) return { address: null };
        if ('bool' === e) return { bool: null };
        if ('u8' === e) return { u8: null };
        if ('u16' === e) return { u16: null };
        if ('u32' === e) return { u32: null };
        else if ('u64' === e) return { u64: null };
        else if ('u128' === e) return { u128: null };
        else if ('u256' === e) return { u256: null };
        else if ('signer' === e) return { signer: null };
        let n = e.match(s1);
        if (n) return { vector: s2.parseFromStr(n[1], t) };
        let i = e.match(s5);
        if (i)
          return {
            struct: {
              address: t ? sJ(i[1]) : i[1],
              module: i[2],
              name: i[3],
              typeParams: void 0 === i[5] ? [] : s2.parseStructTypeArgs(i[5], t),
            },
          };
        throw Error(`Encountered unexpected token when parsing type args for ${e}`);
      }
      static parseStructTypeArgs(e, t = !1) {
        return (function (e, t = ['<', '>']) {
          let [n, i] = t,
            a = [],
            o = '',
            s = 0;
          for (let t = 0; t < e.length; t++) {
            let l = e[t];
            if ((l === n && s++, l === i && s--, 0 === s && ',' === l)) {
              a.push(o.trim()), (o = '');
              continue;
            }
            o += l;
          }
          return a.push(o.trim()), a;
        })(e).map((e) => s2.parseFromStr(e, t));
      }
      static tagToString(e) {
        if ('bool' in e) return 'bool';
        if ('u8' in e) return 'u8';
        if ('u16' in e) return 'u16';
        if ('u32' in e) return 'u32';
        if ('u64' in e) return 'u64';
        if ('u128' in e) return 'u128';
        if ('u256' in e) return 'u256';
        if ('address' in e) return 'address';
        if ('signer' in e) return 'signer';
        if ('vector' in e) return `vector<${s2.tagToString(e.vector)}>`;
        if ('struct' in e) {
          let t = e.struct,
            n = t.typeParams.map(s2.tagToString).join(', ');
          return `${t.address}::${t.module}::${t.name}${n ? `<${n}>` : ''}`;
        }
        throw Error('Invalid TypeTag');
      }
    }
    e.s(['TypeTagSerializer', () => s2], 58112);
    let s6 = sQ.bytes(32).transform({
        validate: (e) => {
          let t = 'string' == typeof e ? e : sR(e);
          if (!t || !sX(sJ(t))) throw Error(`Invalid IOTA address ${t}`);
        },
        input: (e) => ('string' == typeof e ? sT(sJ(e)) : e),
        output: (e) => sJ(sR(e)),
      }),
      s3 = sQ.vector(sQ.u8()).transform({
        name: 'ObjectDigest',
        input: (e) => sA(e),
        output: (e) => sO(new Uint8Array(e)),
        validate: (e) => {
          if (32 !== sA(e).length) throw Error('ObjectDigest must be 32 bytes');
        },
      }),
      s4 = sQ.struct('IotaObjectRef', { objectId: s6, version: sQ.u64(), digest: s3 }),
      s8 = sQ.struct('SharedObjectRef', {
        objectId: s6,
        initialSharedVersion: sQ.u64(),
        mutable: sQ.bool(),
      }),
      s9 = sQ.enum('ObjectArg', { ImmOrOwnedObject: s4, SharedObject: s8, Receiving: s4 }),
      s7 = sQ.enum('Owner', {
        AddressOwner: s6,
        ObjectOwner: s6,
        Shared: sQ.struct('Shared', { initialSharedVersion: sQ.u64() }),
        Immutable: null,
      }),
      le = sQ.enum('CallArg', {
        Pure: sQ.struct('Pure', {
          bytes: sQ
            .vector(sQ.u8())
            .transform({
              input: (e) => ('string' == typeof e ? sI(e) : e),
              output: (e) => sj(new Uint8Array(e)),
            }),
        }),
        Object: s9,
      }),
      lt = sQ.enum('TypeTag', {
        bool: null,
        u8: null,
        u64: null,
        u128: null,
        address: null,
        signer: null,
        vector: sQ.lazy(() => lt),
        struct: sQ.lazy(() => lu),
        u16: null,
        u32: null,
        u256: null,
      }),
      lr = lt.transform({
        input: (e) => ('string' == typeof e ? s2.parseFromStr(e, !0) : e),
        output: (e) => s2.tagToString(e),
      }),
      ln = sQ.enum('Argument', {
        GasCoin: null,
        Input: sQ.u16(),
        Result: sQ.u16(),
        NestedResult: sQ.tuple([sQ.u16(), sQ.u16()]),
      }),
      li = sQ.struct('ProgrammableMoveCall', {
        package: s6,
        module: sQ.string(),
        function: sQ.string(),
        typeArguments: sQ.vector(lr),
        arguments: sQ.vector(ln),
      }),
      la = sQ.enum('Command', {
        MoveCall: li,
        TransferObjects: sQ.struct('TransferObjects', { objects: sQ.vector(ln), address: ln }),
        SplitCoins: sQ.struct('SplitCoins', { coin: ln, amounts: sQ.vector(ln) }),
        MergeCoins: sQ.struct('MergeCoins', { destination: ln, sources: sQ.vector(ln) }),
        Publish: sQ.struct('Publish', {
          modules: sQ.vector(
            sQ
              .vector(sQ.u8())
              .transform({
                input: (e) => ('string' == typeof e ? sI(e) : e),
                output: (e) => sj(new Uint8Array(e)),
              })
          ),
          dependencies: sQ.vector(s6),
        }),
        MakeMoveVec: sQ.struct('MakeMoveVec', {
          type: sQ
            .enum('Option', { None: null, Some: lr })
            .transform({
              input: (e) => (null === e ? { None: !0 } : { Some: e }),
              output: (e) => e.Some ?? null,
            }),
          elements: sQ.vector(ln),
        }),
        Upgrade: sQ.struct('Upgrade', {
          modules: sQ.vector(
            sQ
              .vector(sQ.u8())
              .transform({
                input: (e) => ('string' == typeof e ? sI(e) : e),
                output: (e) => sj(new Uint8Array(e)),
              })
          ),
          dependencies: sQ.vector(s6),
          package: s6,
          ticket: ln,
        }),
      }),
      lo = sQ.struct('ProgrammableTransaction', { inputs: sQ.vector(le), commands: sQ.vector(la) }),
      ls = sQ.enum('TransactionKind', {
        ProgrammableTransaction: lo,
        ChangeEpoch: null,
        Genesis: null,
        ConsensusCommitPrologue: null,
      }),
      ll = sQ.enum('TransactionExpiration', {
        None: null,
        Epoch: sQ
          .u64({ name: 'unsafe_u64', ...void 0 })
          .transform({ input: (e) => e, output: (e) => Number(e) }),
      }),
      lu = sQ.struct('StructTag', {
        address: s6,
        module: sQ.string(),
        name: sQ.string(),
        typeParams: sQ.vector(lt),
      }),
      lc = sQ.struct('GasData', {
        payment: sQ.vector(s4),
        owner: s6,
        price: sQ.u64(),
        budget: sQ.u64(),
      }),
      ld = sQ.struct('TransactionDataV1', { kind: ls, sender: s6, gasData: lc, expiration: ll }),
      lf = sQ.enum('TransactionData', { V1: ld }),
      lh = sQ.enum('IntentScope', {
        TransactionData: null,
        TransactionEffects: null,
        CheckpointSummary: null,
        PersonalMessage: null,
      }),
      lp = sQ.enum('IntentVersion', { V0: null }),
      lm = sQ.enum('AppId', { Iota: null }),
      lg = sQ.struct('Intent', { scope: lh, version: lp, appId: lm });
    function ly(e) {
      return sQ.struct(`IntentMessage<${e.name}>`, { intent: lg, value: e });
    }
    let lb = sQ.enum('CompressedSignature', {
        ED25519: sQ.fixedArray(64, sQ.u8()),
        Secp256k1: sQ.fixedArray(64, sQ.u8()),
        Secp256r1: sQ.fixedArray(64, sQ.u8()),
      }),
      lv = sQ.enum('PublicKey', {
        ED25519: sQ.fixedArray(32, sQ.u8()),
        Secp256k1: sQ.fixedArray(33, sQ.u8()),
        Secp256r1: sQ.fixedArray(33, sQ.u8()),
      }),
      lw = sQ.struct('MultiSigPkMap', { pubKey: lv, weight: sQ.u8() }),
      lx = sQ.struct('MultiSigPublicKey', { pk_map: sQ.vector(lw), threshold: sQ.u16() }),
      lE = sQ.struct('MultiSig', { sigs: sQ.vector(lb), bitmap: sQ.u16(), multisig_pk: lx }),
      lS = sQ
        .vector(sQ.u8())
        .transform({
          input: (e) => ('string' == typeof e ? sI(e) : e),
          output: (e) => sj(new Uint8Array(e)),
        }),
      lC = sQ.struct('SenderSignedTransaction', {
        intentMessage: ly(lf),
        txSignatures: sQ.vector(lS),
      }),
      lk = sQ.vector(lC, { name: 'SenderSignedData' }),
      lO = sQ.struct('PasskeyAuthenticator', {
        authenticatorData: sQ.vector(sQ.u8()),
        clientDataJson: sQ.string(),
        userSignature: sQ.vector(sQ.u8()),
      }),
      lA = sQ.enum('PackageUpgradeError', {
        UnableToFetchPackage: sQ.struct('UnableToFetchPackage', { packageId: s6 }),
        NotAPackage: sQ.struct('NotAPackage', { objectId: s6 }),
        IncompatibleUpgrade: null,
        DigestDoesNotMatch: sQ.struct('DigestDoesNotMatch', { digest: sQ.vector(sQ.u8()) }),
        UnknownUpgradePolicy: sQ.struct('UnknownUpgradePolicy', { policy: sQ.u8() }),
        PackageIDDoesNotMatch: sQ.struct('PackageIDDoesNotMatch', { packageId: s6, ticketId: s6 }),
      }),
      lI = sQ.struct('ModuleId', { address: s6, name: sQ.string() }),
      lj = sQ.struct('MoveLocation', {
        module: lI,
        function: sQ.u16(),
        instruction: sQ.u16(),
        functionName: sQ.option(sQ.string()),
      }),
      lT = sQ.enum('CommandArgumentError', {
        TypeMismatch: null,
        InvalidBCSBytes: null,
        InvalidUsageOfPureArg: null,
        InvalidArgumentToPrivateEntryFunction: null,
        IndexOutOfBounds: sQ.struct('IndexOutOfBounds', { idx: sQ.u16() }),
        SecondaryIndexOutOfBounds: sQ.struct('SecondaryIndexOutOfBounds', {
          resultIdx: sQ.u16(),
          secondaryIdx: sQ.u16(),
        }),
        InvalidResultArity: sQ.struct('InvalidResultArity', { resultIdx: sQ.u16() }),
        InvalidGasCoinUsage: null,
        InvalidValueUsage: null,
        InvalidObjectByValue: null,
        InvalidObjectByMutRef: null,
        SharedObjectOperationNotAllowed: null,
      }),
      lR = sQ.enum('TypeArgumentError', { TypeNotFound: null, ConstraintNotSatisfied: null }),
      lM = sQ.enum('ExecutionFailureStatus', {
        InsufficientGas: null,
        InvalidGasObject: null,
        InvariantViolation: null,
        FeatureNotYetSupported: null,
        MoveObjectTooBig: sQ.struct('MoveObjectTooBig', {
          objectSize: sQ.u64(),
          maxObjectSize: sQ.u64(),
        }),
        MovePackageTooBig: sQ.struct('MovePackageTooBig', {
          objectSize: sQ.u64(),
          maxObjectSize: sQ.u64(),
        }),
        CircularObjectOwnership: sQ.struct('CircularObjectOwnership', { object: s6 }),
        InsufficientCoinBalance: null,
        CoinBalanceOverflow: null,
        PublishErrorNonZeroAddress: null,
        IotaMoveVerificationError: null,
        MovePrimitiveRuntimeError: sQ.option(lj),
        MoveAbort: sQ.tuple([lj, sQ.u64()]),
        VMVerificationOrDeserializationError: null,
        VMInvariantViolation: null,
        FunctionNotFound: null,
        ArityMismatch: null,
        TypeArityMismatch: null,
        NonEntryFunctionInvoked: null,
        CommandArgumentError: sQ.struct('CommandArgumentError', { argIdx: sQ.u16(), kind: lT }),
        TypeArgumentError: sQ.struct('TypeArgumentError', { argumentIdx: sQ.u16(), kind: lR }),
        UnusedValueWithoutDrop: sQ.struct('UnusedValueWithoutDrop', {
          resultIdx: sQ.u16(),
          secondaryIdx: sQ.u16(),
        }),
        InvalidPublicFunctionReturnType: sQ.struct('InvalidPublicFunctionReturnType', {
          idx: sQ.u16(),
        }),
        InvalidTransferObject: null,
        EffectsTooLarge: sQ.struct('EffectsTooLarge', { currentSize: sQ.u64(), maxSize: sQ.u64() }),
        PublishUpgradeMissingDependency: null,
        PublishUpgradeDependencyDowngrade: null,
        PackageUpgradeError: sQ.struct('PackageUpgradeError', { upgradeError: lA }),
        WrittenObjectsTooLarge: sQ.struct('WrittenObjectsTooLarge', {
          currentSize: sQ.u64(),
          maxSize: sQ.u64(),
        }),
        CertificateDenied: null,
        IotaMoveVerificationTimedout: null,
        SharedObjectOperationNotAllowed: null,
        InputObjectDeleted: null,
        ExecutionCancelledDueToSharedObjectCongestion: sQ.struct(
          'ExecutionCancelledDueToSharedObjectCongestion',
          { congestedObjects: sQ.vector(s6) }
        ),
        AddressDeniedForCoin: sQ.struct('AddressDeniedForCoin', {
          address: s6,
          coinType: sQ.string(),
        }),
        CoinTypeGlobalPause: sQ.struct('CoinTypeGlobalPause', { coinType: sQ.string() }),
        ExecutionCancelledDueToRandomnessUnavailable: null,
      }),
      lP = sQ.enum('ExecutionStatus', {
        Success: null,
        Failed: sQ.struct('ExecutionFailed', { error: lM, command: sQ.option(sQ.u64()) }),
      }),
      lN = sQ.struct('GasCostSummary', {
        computationCost: sQ.u64(),
        computationCostBurned: sQ.u64(),
        storageCost: sQ.u64(),
        storageRebate: sQ.u64(),
        nonRefundableStorageFee: sQ.u64(),
      }),
      l_ = sQ.tuple([sQ.u64(), s3]),
      lD = sQ.enum('ObjectIn', { NotExist: null, Exist: sQ.tuple([l_, s7]) }),
      lB = sQ.enum('ObjectOut', {
        NotExist: null,
        ObjectWrite: sQ.tuple([s3, s7]),
        PackageWrite: l_,
      }),
      lU = sQ.enum('IDOperation', { None: null, Created: null, Deleted: null }),
      lF = sQ.struct('EffectsObjectChange', { inputState: lD, outputState: lB, idOperation: lU }),
      lL = sQ.enum('UnchangedSharedKind', {
        ReadOnlyRoot: l_,
        MutateDeleted: sQ.u64(),
        ReadDeleted: sQ.u64(),
        Cancelled: sQ.u64(),
        PerEpochConfig: null,
      }),
      lz = sQ.struct('TransactionEffectsV1', {
        status: lP,
        executedEpoch: sQ.u64(),
        gasUsed: lN,
        transactionDigest: s3,
        gasObjectIndex: sQ.option(sQ.u32()),
        eventsDigest: sQ.option(s3),
        dependencies: sQ.vector(s3),
        lamportVersion: sQ.u64(),
        changedObjects: sQ.vector(sQ.tuple([s6, lF])),
        unchangedSharedObjects: sQ.vector(sQ.tuple([s6, lL])),
        auxDataDigest: sQ.option(s3),
      }),
      lV = sQ.enum('TransactionEffects', { V1: lz }),
      l$ = {
        ...sQ,
        U8: sQ.u8(),
        U16: sQ.u16(),
        U32: sQ.u32(),
        U64: sQ.u64(),
        U128: sQ.u128(),
        U256: sQ.u256(),
        ULEB128: sQ.uleb128(),
        Bool: sQ.bool(),
        String: sQ.string(),
        Address: s6,
        AppId: lm,
        Argument: ln,
        CallArg: le,
        CompressedSignature: lb,
        GasData: lc,
        Intent: lg,
        IntentMessage: ly,
        IntentScope: lh,
        IntentVersion: lp,
        MultiSig: lE,
        MultiSigPkMap: lw,
        MultiSigPublicKey: lx,
        ObjectArg: s9,
        ObjectDigest: s3,
        Owner: s7,
        ProgrammableMoveCall: li,
        ProgrammableTransaction: lo,
        PublicKey: lv,
        SenderSignedData: lk,
        SenderSignedTransaction: lC,
        SharedObjectRef: s8,
        StructTag: lu,
        IotaObjectRef: s4,
        Command: la,
        TransactionData: lf,
        TransactionDataV1: ld,
        TransactionExpiration: ll,
        TransactionKind: ls,
        TypeTag: lr,
        TransactionEffects: lV,
        PasskeyAuthenticator: lO,
      };
    e.s(['bcs', () => l$], 35566);
    var lW = 'Document',
      lq = 'FragmentDefinition';
    class lK extends Error {
      constructor(e, t, n, i, a, o, s) {
        super(e),
          (this.name = 'GraphQLError'),
          (this.message = e),
          a && (this.path = a),
          t && (this.nodes = Array.isArray(t) ? t : [t]),
          n && (this.source = n),
          i && (this.positions = i),
          o && (this.originalError = o);
        var l = s;
        if (!l && o) {
          var u = o.extensions;
          u && 'object' == typeof u && (l = u);
        }
        this.extensions = l || {};
      }
      toJSON() {
        return { ...this, message: this.message };
      }
      toString() {
        return this.message;
      }
      get [Symbol.toStringTag]() {
        return 'GraphQLError';
      }
    }
    function lG(e) {
      return new lK(`Syntax Error: Unexpected token at ${ei} in ${e}`);
    }
    function lH(e) {
      if (((e.lastIndex = ei), e.test(en))) return en.slice(ei, (ei = e.lastIndex));
    }
    var lZ = / +(?=[^\s])/y;
    function lY() {
      for (
        var e = 0 | en.charCodeAt(ei++);
        9 === e || 10 === e || 13 === e || 32 === e || 35 === e || 44 === e || 65279 === e;
        e = 0 | en.charCodeAt(ei++)
      )
        if (35 === e) for (; (e = 0 | en.charCodeAt(ei++)) && 10 !== e && 13 !== e; );
      ei--;
    }
    function lQ() {
      for (
        var e = ei, t = 0 | en.charCodeAt(ei++);
        (t >= 48 && t <= 57) || (t >= 65 && t <= 90) || 95 === t || (t >= 97 && t <= 122);
        t = 0 | en.charCodeAt(ei++)
      );
      if (e === ei - 1) throw lG('Name');
      var n = en.slice(e, --ei);
      return lY(), n;
    }
    function lX() {
      return { kind: 'Name', value: lQ() };
    }
    var lJ = /(?:"""|(?:[\s\S]*?[^\\])""")/y,
      l0 = /(?:(?:\.\d+)?[eE][+-]?\d+|\.\d+)/y;
    function l1(e) {
      var t;
      switch (en.charCodeAt(ei)) {
        case 91:
          ei++, lY();
          for (var n = []; 93 !== en.charCodeAt(ei); ) n.push(l1(e));
          return ei++, lY(), { kind: 'ListValue', values: n };
        case 123:
          ei++, lY();
          for (var i = []; 125 !== en.charCodeAt(ei); ) {
            var a = lX();
            if (58 !== en.charCodeAt(ei++)) throw lG('ObjectField');
            lY(), i.push({ kind: 'ObjectField', name: a, value: l1(e) });
          }
          return ei++, lY(), { kind: 'ObjectValue', fields: i };
        case 36:
          if (e) throw lG('Variable');
          return ei++, { kind: 'Variable', name: lX() };
        case 34:
          if (34 === en.charCodeAt(ei + 1) && 34 === en.charCodeAt(ei + 2)) {
            if (((ei += 3), null == (t = lH(lJ)))) throw lG('StringValue');
            return (
              lY(),
              {
                kind: 'StringValue',
                value: (function (e) {
                  for (
                    var t = e.split('\n'), n = '', i = 0, a = 0, o = t.length - 1, s = 0;
                    s < t.length;
                    s++
                  )
                    (lZ.lastIndex = 0),
                      lZ.test(t[s]) &&
                        (s && (!i || lZ.lastIndex < i) && (i = lZ.lastIndex),
                        (a = a || s),
                        (o = s));
                  for (var l = a; l <= o; l++)
                    l !== a && (n += '\n'), (n += t[l].slice(i).replace(/\\"""/g, '"""'));
                  return n;
                })(t.slice(0, -3)),
                block: !0,
              }
            );
          }
          var o,
            s = ei;
          ei++;
          var l = !1;
          for (
            o = 0 | en.charCodeAt(ei++);
            (92 === o && (ei++, (l = !0))) || (10 !== o && 13 !== o && 34 !== o && o);
            o = 0 | en.charCodeAt(ei++)
          );
          if (34 !== o) throw lG('StringValue');
          return (
            (t = en.slice(s, ei)),
            lY(),
            { kind: 'StringValue', value: l ? JSON.parse(t) : t.slice(1, -1), block: !1 }
          );
        case 45:
        case 48:
        case 49:
        case 50:
        case 51:
        case 52:
        case 53:
        case 54:
        case 55:
        case 56:
        case 57:
          for (var u, c = ei++; (u = 0 | en.charCodeAt(ei++)) >= 48 && u <= 57; );
          var d = en.slice(c, --ei);
          if (46 !== (u = en.charCodeAt(ei)) && 69 !== u && 101 !== u)
            return lY(), { kind: 'IntValue', value: d };
          if (null == (t = lH(l0))) throw lG('FloatValue');
          return lY(), { kind: 'FloatValue', value: d + t };
        case 110:
          if (
            117 === en.charCodeAt(ei + 1) &&
            108 === en.charCodeAt(ei + 2) &&
            108 === en.charCodeAt(ei + 3)
          )
            return (ei += 4), lY(), { kind: 'NullValue' };
          break;
        case 116:
          if (
            114 === en.charCodeAt(ei + 1) &&
            117 === en.charCodeAt(ei + 2) &&
            101 === en.charCodeAt(ei + 3)
          )
            return (ei += 4), lY(), { kind: 'BooleanValue', value: !0 };
          break;
        case 102:
          if (
            97 === en.charCodeAt(ei + 1) &&
            108 === en.charCodeAt(ei + 2) &&
            115 === en.charCodeAt(ei + 3) &&
            101 === en.charCodeAt(ei + 4)
          )
            return (ei += 5), lY(), { kind: 'BooleanValue', value: !1 };
      }
      return { kind: 'EnumValue', value: lQ() };
    }
    function l5(e) {
      if (40 === en.charCodeAt(ei)) {
        var t = [];
        ei++, lY();
        do {
          var n = lX();
          if (58 !== en.charCodeAt(ei++)) throw lG('Argument');
          lY(), t.push({ kind: 'Argument', name: n, value: l1(e) });
        } while (41 !== en.charCodeAt(ei));
        return ei++, lY(), t;
      }
    }
    function l2(e) {
      if (64 === en.charCodeAt(ei)) {
        var t = [];
        do ei++, t.push({ kind: 'Directive', name: lX(), arguments: l5(e) });
        while (64 === en.charCodeAt(ei));
        return t;
      }
    }
    function l6() {
      if (123 !== en.charCodeAt(ei++)) throw lG('SelectionSet');
      return lY(), l3();
    }
    function l3() {
      var e = [];
      do
        if (46 === en.charCodeAt(ei)) {
          if (46 !== en.charCodeAt(++ei) || 46 !== en.charCodeAt(++ei)) throw lG('SelectionSet');
          switch ((ei++, lY(), en.charCodeAt(ei))) {
            case 64:
              e.push({
                kind: 'InlineFragment',
                typeCondition: void 0,
                directives: l2(!1),
                selectionSet: l6(),
              });
              break;
            case 111:
              110 === en.charCodeAt(ei + 1)
                ? ((ei += 2),
                  lY(),
                  e.push({
                    kind: 'InlineFragment',
                    typeCondition: { kind: 'NamedType', name: lX() },
                    directives: l2(!1),
                    selectionSet: l6(),
                  }))
                : e.push({ kind: 'FragmentSpread', name: lX(), directives: l2(!1) });
              break;
            case 123:
              ei++,
                lY(),
                e.push({
                  kind: 'InlineFragment',
                  typeCondition: void 0,
                  directives: void 0,
                  selectionSet: l3(),
                });
              break;
            default:
              e.push({ kind: 'FragmentSpread', name: lX(), directives: l2(!1) });
          }
        } else {
          var t = lX(),
            n = void 0;
          58 === en.charCodeAt(ei) && (ei++, lY(), (n = t), (t = lX()));
          var i = l5(!1),
            a = l2(!1),
            o = void 0;
          123 === en.charCodeAt(ei) && (ei++, lY(), (o = l3())),
            e.push({
              kind: 'Field',
              alias: n,
              name: t,
              arguments: i,
              directives: a,
              selectionSet: o,
            });
        }
      while (125 !== en.charCodeAt(ei));
      return ei++, lY(), { kind: 'SelectionSet', selections: e };
    }
    function l4(e, t, n) {
      for (var i = '', a = 0; a < e.length; a++) a && (i += t), (i += n(e[a]));
      return i;
    }
    var l8 = '\n',
      l9 = {
        OperationDefinition(e) {
          var t = '';
          e.description && (t += l9.StringValue(e.description) + '\n'),
            (t += e.operation),
            e.name && (t += ' ' + e.name.value),
            e.variableDefinitions &&
              e.variableDefinitions.length &&
              (e.name || (t += ' '),
              (t += '(' + l4(e.variableDefinitions, ', ', l9.VariableDefinition) + ')')),
            e.directives && e.directives.length && (t += ' ' + l4(e.directives, ' ', l9.Directive));
          var n = l9.SelectionSet(e.selectionSet);
          return 'query' !== t ? t + ' ' + n : n;
        },
        VariableDefinition(e) {
          var t = '';
          return (
            e.description && (t += l9.StringValue(e.description) + ' '),
            (t += l9.Variable(e.variable) + ': ' + l7(e.type)),
            e.defaultValue && (t += ' = ' + l7(e.defaultValue)),
            e.directives && e.directives.length && (t += ' ' + l4(e.directives, ' ', l9.Directive)),
            t
          );
        },
        Field(e) {
          var t = e.alias ? e.alias.value + ': ' + e.name.value : e.name.value;
          if (e.arguments && e.arguments.length) {
            var n = l4(e.arguments, ', ', l9.Argument);
            t.length + n.length + 2 > 80
              ? (t +=
                  '(' +
                  (l8 += '  ') +
                  l4(e.arguments, l8, l9.Argument) +
                  (l8 = l8.slice(0, -2)) +
                  ')')
              : (t += '(' + n + ')');
          }
          return (
            e.directives && e.directives.length && (t += ' ' + l4(e.directives, ' ', l9.Directive)),
            e.selectionSet &&
              e.selectionSet.selections.length &&
              (t += ' ' + l9.SelectionSet(e.selectionSet)),
            t
          );
        },
        StringValue: (e) =>
          e.block
            ? ('"""\n' + e.value.replace(/"""/g, '\\"""') + '\n"""').replace(/\n/g, l8)
            : JSON.stringify(e.value),
        BooleanValue: (e) => '' + e.value,
        NullValue: (e) => 'null',
        IntValue: (e) => e.value,
        FloatValue: (e) => e.value,
        EnumValue: (e) => e.value,
        Name: (e) => e.value,
        Variable: (e) => '$' + e.name.value,
        ListValue: (e) => '[' + l4(e.values, ', ', l7) + ']',
        ObjectValue: (e) => '{' + l4(e.fields, ', ', l9.ObjectField) + '}',
        ObjectField: (e) => e.name.value + ': ' + l7(e.value),
        Document: (e) =>
          e.definitions && e.definitions.length ? l4(e.definitions, '\n\n', l7) : '',
        SelectionSet: (e) =>
          '{' + (l8 += '  ') + l4(e.selections, l8, l7) + (l8 = l8.slice(0, -2)) + '}',
        Argument: (e) => e.name.value + ': ' + l7(e.value),
        FragmentSpread(e) {
          var t = '...' + e.name.value;
          return (
            e.directives && e.directives.length && (t += ' ' + l4(e.directives, ' ', l9.Directive)),
            t
          );
        },
        InlineFragment(e) {
          var t = '...';
          return (
            e.typeCondition && (t += ' on ' + e.typeCondition.name.value),
            e.directives && e.directives.length && (t += ' ' + l4(e.directives, ' ', l9.Directive)),
            t + ' ' + l9.SelectionSet(e.selectionSet)
          );
        },
        FragmentDefinition(e) {
          var t = '';
          return (
            e.description && (t += l9.StringValue(e.description) + '\n'),
            (t += 'fragment ' + e.name.value + ' on ' + e.typeCondition.name.value),
            e.directives && e.directives.length && (t += ' ' + l4(e.directives, ' ', l9.Directive)),
            t + ' ' + l9.SelectionSet(e.selectionSet)
          );
        },
        Directive(e) {
          var t = '@' + e.name.value;
          return (
            e.arguments &&
              e.arguments.length &&
              (t += '(' + l4(e.arguments, ', ', l9.Argument) + ')'),
            t
          );
        },
        NamedType: (e) => e.name.value,
        ListType: (e) => '[' + l7(e.type) + ']',
        NonNullType: (e) => l7(e.type) + '!',
      },
      l7 = (e) => l9[e.kind](e),
      ue = 0,
      ut = new Set();
    function ur() {
      function e(e, t) {
        var n,
          i,
          a = ((en = e.body ? e.body : e),
          (ei = 0),
          lY(),
          {
            kind: 'Document',
            definitions: (function () {
              var e = [];
              do {
                var t = void 0;
                if ((34 === en.charCodeAt(ei) && (t = l1(!0)), 123 === en.charCodeAt(ei))) {
                  if (t) throw lG('Document');
                  ei++,
                    lY(),
                    e.push({
                      kind: 'OperationDefinition',
                      operation: 'query',
                      name: void 0,
                      variableDefinitions: void 0,
                      directives: void 0,
                      selectionSet: l3(),
                    });
                } else {
                  var n = lQ();
                  switch (n) {
                    case 'fragment':
                      e.push(
                        (function (e) {
                          var t = lX();
                          if (111 !== en.charCodeAt(ei++) || 110 !== en.charCodeAt(ei++))
                            throw lG('FragmentDefinition');
                          lY();
                          var n = {
                            kind: 'FragmentDefinition',
                            name: t,
                            typeCondition: { kind: 'NamedType', name: lX() },
                            directives: l2(!1),
                            selectionSet: l6(),
                          };
                          return e && (n.description = e), n;
                        })(t)
                      );
                      break;
                    case 'query':
                    case 'mutation':
                    case 'subscription':
                      var i,
                        a = void 0;
                      40 !== (i = en.charCodeAt(ei)) && 64 !== i && 123 !== i && (a = lX());
                      var o = {
                        kind: 'OperationDefinition',
                        operation: n,
                        name: a,
                        variableDefinitions: (function () {
                          if ((lY(), 40 === en.charCodeAt(ei))) {
                            var e = [];
                            ei++, lY();
                            do {
                              var t = void 0;
                              if (
                                (34 === en.charCodeAt(ei) && (t = l1(!0)),
                                36 !== en.charCodeAt(ei++))
                              )
                                throw lG('Variable');
                              var n = lX();
                              if (58 !== en.charCodeAt(ei++)) throw lG('VariableDefinition');
                              lY();
                              var i = (function () {
                                  for (var e = 0; 91 === en.charCodeAt(ei); ) e++, ei++, lY();
                                  var t = { kind: 'NamedType', name: lX() };
                                  do
                                    if (
                                      (33 === en.charCodeAt(ei) &&
                                        (ei++, lY(), (t = { kind: 'NonNullType', type: t })),
                                      e)
                                    ) {
                                      if (93 !== en.charCodeAt(ei++)) throw lG('NamedType');
                                      lY(), (t = { kind: 'ListType', type: t });
                                    }
                                  while (e--);
                                  return t;
                                })(),
                                a = void 0;
                              61 === en.charCodeAt(ei) && (ei++, lY(), (a = l1(!0))), lY();
                              var o = {
                                kind: 'VariableDefinition',
                                variable: { kind: 'Variable', name: n },
                                type: i,
                                defaultValue: a,
                                directives: l2(!0),
                              };
                              t && (o.description = t), e.push(o);
                            } while (41 !== en.charCodeAt(ei));
                            return ei++, lY(), e;
                          }
                        })(),
                        directives: l2(!1),
                        selectionSet: l6(),
                      };
                      t && (o.description = t), e.push(o);
                      break;
                    default:
                      throw lG('Document');
                  }
                }
              } while (ei < en.length);
              return e;
            })(),
            loc: {
              start: 0,
              end: en.length,
              startToken: void 0,
              endToken: void 0,
              source: { body: en, name: 'graphql.web', locationOffset: { line: 1, column: 1 } },
            },
          }).definitions,
          o = new Set();
        for (var s of t || [])
          for (var l of s.definitions) l.kind !== lq || o.has(l) || (a.push(l), o.add(l));
        return (
          (n = a[0].kind === lq) &&
            a[0].directives &&
            (a[0].directives = a[0].directives.filter((e) => '_unmask' !== e.name.value)),
          {
            kind: lW,
            definitions: a,
            get loc() {
              if (!i && n) {
                var u =
                  e +
                  (function (e) {
                    try {
                      ue++;
                      var t = '';
                      for (var n of e)
                        if (!ut.has(n)) {
                          ut.add(n);
                          var { loc: i } = n;
                          i && (t += i.source.body);
                        }
                      return t;
                    } finally {
                      0 == --ue && ut.clear();
                    }
                  })(t || []);
                return {
                  start: 0,
                  end: u.length,
                  source: { body: u, name: 'GraphQLTada', locationOffset: { line: 1, column: 1 } },
                };
              }
              return i;
            },
            set loc(r) {
              i = r;
            },
          }
        );
      }
      return (
        (e.scalar = function (e, t) {
          return t;
        }),
        (e.persisted = function (e, t) {
          return { kind: lW, definitions: t ? t.definitions : [], documentId: e };
        }),
        e
      );
    }
    ur();
    let un = ur(),
      ui = 'object' == typeof globalThis && 'crypto' in globalThis ? globalThis.crypto : void 0;
    function ua(e) {
      return (
        e instanceof Uint8Array || (ArrayBuffer.isView(e) && 'Uint8Array' === e.constructor.name)
      );
    }
    function uo(e) {
      if (!Number.isSafeInteger(e) || e < 0) throw Error('positive integer expected, got ' + e);
    }
    function us(e, ...t) {
      if (!ua(e)) throw Error('Uint8Array expected');
      if (t.length > 0 && !t.includes(e.length))
        throw Error('Uint8Array expected of length ' + t + ', got length=' + e.length);
    }
    function ul(e) {
      if ('function' != typeof e || 'function' != typeof e.create)
        throw Error('Hash should be wrapped by utils.createHasher');
      uo(e.outputLen), uo(e.blockLen);
    }
    function uu(e, t = !0) {
      if (e.destroyed) throw Error('Hash instance has been destroyed');
      if (t && e.finished) throw Error('Hash#digest() has already been called');
    }
    function uc(e, t) {
      us(e);
      let n = t.outputLen;
      if (e.length < n) throw Error('digestInto() expects output buffer of length at least ' + n);
    }
    function ud(e) {
      return new Uint32Array(e.buffer, e.byteOffset, Math.floor(e.byteLength / 4));
    }
    function uf(...e) {
      for (let t = 0; t < e.length; t++) e[t].fill(0);
    }
    function uh(e) {
      return new DataView(e.buffer, e.byteOffset, e.byteLength);
    }
    function up(e, t) {
      return (e << (32 - t)) | (e >>> t);
    }
    let um = 68 === new Uint8Array(new Uint32Array([0x11223344]).buffer)[0];
    function ug(e) {
      return (
        ((e << 24) & 0xff000000) | ((e << 8) & 0xff0000) | ((e >>> 8) & 65280) | ((e >>> 24) & 255)
      );
    }
    let uy = um ? (e) => e : (e) => ug(e),
      ub = um
        ? (e) => e
        : function (e) {
            for (let t = 0; t < e.length; t++) e[t] = ug(e[t]);
            return e;
          },
      uv =
        'function' == typeof Uint8Array.from([]).toHex && 'function' == typeof Uint8Array.fromHex,
      uw = Array.from({ length: 256 }, (e, t) => t.toString(16).padStart(2, '0'));
    function ux(e) {
      if ((us(e), uv)) return e.toHex();
      let t = '';
      for (let n = 0; n < e.length; n++) t += uw[e[n]];
      return t;
    }
    function uE(e) {
      return e >= 48 && e <= 57
        ? e - 48
        : e >= 65 && e <= 70
        ? e - 55
        : e >= 97 && e <= 102
        ? e - 87
        : void 0;
    }
    function uS(e) {
      if ('string' != typeof e) throw Error('hex string expected, got ' + typeof e);
      if (uv) return Uint8Array.fromHex(e);
      let t = e.length,
        n = t / 2;
      if (t % 2) throw Error('hex string expected, got unpadded hex of length ' + t);
      let i = new Uint8Array(n);
      for (let t = 0, a = 0; t < n; t++, a += 2) {
        let n = uE(e.charCodeAt(a)),
          o = uE(e.charCodeAt(a + 1));
        if (void 0 === n || void 0 === o)
          throw Error(
            'hex string expected, got non-hex character "' + (e[a] + e[a + 1]) + '" at index ' + a
          );
        i[t] = 16 * n + o;
      }
      return i;
    }
    function uC(e) {
      if ('string' != typeof e) throw Error('string expected');
      return new Uint8Array(new TextEncoder().encode(e));
    }
    function uk(e) {
      return 'string' == typeof e && (e = uC(e)), us(e), e;
    }
    function uO(e) {
      return 'string' == typeof e && (e = uC(e)), us(e), e;
    }
    function uA(...e) {
      let t = 0;
      for (let n = 0; n < e.length; n++) {
        let i = e[n];
        us(i), (t += i.length);
      }
      let n = new Uint8Array(t);
      for (let t = 0, i = 0; t < e.length; t++) {
        let a = e[t];
        n.set(a, i), (i += a.length);
      }
      return n;
    }
    class uI {}
    function uj(e) {
      let t = (t) => e().update(uk(t)).digest(),
        n = e();
      return (t.outputLen = n.outputLen), (t.blockLen = n.blockLen), (t.create = () => e()), t;
    }
    function uT(e = 32) {
      if (ui && 'function' == typeof ui.getRandomValues)
        return ui.getRandomValues(new Uint8Array(e));
      if (ui && 'function' == typeof ui.randomBytes) return Uint8Array.from(ui.randomBytes(e));
      throw Error('crypto.getRandomValues must be defined');
    }
    let uR = Uint8Array.from([
      0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2,
      11, 7, 5, 3, 11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4, 7, 9, 3, 1, 13, 12, 11, 14,
      2, 6, 5, 10, 4, 0, 15, 8, 9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13, 2, 12, 6, 10,
      0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9, 12, 5, 1, 15, 14, 13, 4, 10, 0, 7, 6, 3, 9, 2, 8, 11,
      13, 11, 7, 14, 12, 1, 3, 9, 5, 0, 15, 4, 8, 6, 2, 10, 6, 15, 14, 9, 11, 3, 0, 8, 12, 2, 13, 7,
      1, 4, 10, 5, 10, 2, 8, 4, 7, 6, 1, 5, 15, 11, 9, 14, 3, 12, 13, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8,
      9, 10, 11, 12, 13, 14, 15, 14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3, 11, 8, 12, 0,
      5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4, 7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8,
      9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13, 2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5,
      15, 14, 1, 9,
    ]);
    class uM extends uI {
      constructor(e, t, n, i) {
        super(),
          (this.finished = !1),
          (this.length = 0),
          (this.pos = 0),
          (this.destroyed = !1),
          (this.blockLen = e),
          (this.outputLen = t),
          (this.padOffset = n),
          (this.isLE = i),
          (this.buffer = new Uint8Array(e)),
          (this.view = uh(this.buffer));
      }
      update(e) {
        uu(this), us((e = uk(e)));
        let { view: t, buffer: n, blockLen: i } = this,
          a = e.length;
        for (let o = 0; o < a; ) {
          let s = Math.min(i - this.pos, a - o);
          if (s === i) {
            let t = uh(e);
            for (; i <= a - o; o += i) this.process(t, o);
            continue;
          }
          n.set(e.subarray(o, o + s), this.pos),
            (this.pos += s),
            (o += s),
            this.pos === i && (this.process(t, 0), (this.pos = 0));
        }
        return (this.length += e.length), this.roundClean(), this;
      }
      digestInto(e) {
        uu(this), uc(e, this), (this.finished = !0);
        let { buffer: t, view: n, blockLen: i, isLE: a } = this,
          { pos: o } = this;
        (t[o++] = 128),
          uf(this.buffer.subarray(o)),
          this.padOffset > i - o && (this.process(n, 0), (o = 0));
        for (let e = o; e < i; e++) t[e] = 0;
        !(function (e, t, n, i) {
          if ('function' == typeof e.setBigUint64) return e.setBigUint64(t, n, i);
          let a = BigInt(32),
            o = BigInt(0xffffffff),
            s = Number((n >> a) & o),
            l = Number(n & o),
            u = 4 * !!i,
            c = 4 * !i;
          e.setUint32(t + u, s, i), e.setUint32(t + c, l, i);
        })(n, i - 8, BigInt(8 * this.length), a),
          this.process(n, 0);
        let s = uh(e),
          l = this.outputLen;
        if (l % 4) throw Error('_sha2: outputLen should be aligned to 32bit');
        let u = l / 4,
          c = this.get();
        if (u > c.length) throw Error('_sha2: outputLen bigger than state');
        for (let e = 0; e < u; e++) s.setUint32(4 * e, c[e], a);
      }
      digest() {
        let { buffer: e, outputLen: t } = this;
        this.digestInto(e);
        let n = e.slice(0, t);
        return this.destroy(), n;
      }
      _cloneInto(e) {
        e || (e = new this.constructor()), e.set(...this.get());
        let { blockLen: t, buffer: n, length: i, finished: a, destroyed: o, pos: s } = this;
        return (
          (e.destroyed = o),
          (e.finished = a),
          (e.length = i),
          (e.pos = s),
          i % t && e.buffer.set(n),
          e
        );
      }
      clone() {
        return this._cloneInto();
      }
    }
    let uP = Uint32Array.from([
        0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab,
        0x5be0cd19,
      ]),
      uN = Uint32Array.from([
        0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939, 0xffc00b31, 0x68581511, 0x64f98fa7,
        0xbefa4fa4,
      ]),
      u_ = Uint32Array.from([
        0xcbbb9d5d, 0xc1059ed8, 0x629a292a, 0x367cd507, 0x9159015a, 0x3070dd17, 0x152fecd8,
        0xf70e5939, 0x67332667, 0xffc00b31, 0x8eb44a87, 0x68581511, 0xdb0c2e0d, 0x64f98fa7,
        0x47b5481d, 0xbefa4fa4,
      ]),
      uD = Uint32Array.from([
        0x6a09e667, 0xf3bcc908, 0xbb67ae85, 0x84caa73b, 0x3c6ef372, 0xfe94f82b, 0xa54ff53a,
        0x5f1d36f1, 0x510e527f, 0xade682d1, 0x9b05688c, 0x2b3e6c1f, 0x1f83d9ab, 0xfb41bd6b,
        0x5be0cd19, 0x137e2179,
      ]),
      uB = BigInt(0x100000000 - 1),
      uU = BigInt(32);
    function uF(e, t = !1) {
      return t
        ? { h: Number(e & uB), l: Number((e >> uU) & uB) }
        : { h: 0 | Number((e >> uU) & uB), l: 0 | Number(e & uB) };
    }
    let uL = (e, t, n) => e >>> n,
      uz = (e, t, n) => (e << (32 - n)) | (t >>> n),
      uV = (e, t, n) => (e >>> n) | (t << (32 - n)),
      u$ = (e, t, n) => (e << (32 - n)) | (t >>> n),
      uW = (e, t, n) => (e << (64 - n)) | (t >>> (n - 32)),
      uq = (e, t, n) => (e >>> (n - 32)) | (t << (64 - n));
    function uK(e, t, n, i) {
      let a = (t >>> 0) + (i >>> 0);
      return { h: (e + n + ((a / 0x100000000) | 0)) | 0, l: 0 | a };
    }
    let uG = (e, t, n) => (e >>> 0) + (t >>> 0) + (n >>> 0),
      uH = (e, t, n, i) => (t + n + i + ((e / 0x100000000) | 0)) | 0,
      uZ = (e, t, n, i) => (e >>> 0) + (t >>> 0) + (n >>> 0) + (i >>> 0),
      uY = (e, t, n, i, a) => (t + n + i + a + ((e / 0x100000000) | 0)) | 0,
      uQ = (e, t, n, i, a) => (e >>> 0) + (t >>> 0) + (n >>> 0) + (i >>> 0) + (a >>> 0),
      uX = (e, t, n, i, a, o) => (t + n + i + a + o + ((e / 0x100000000) | 0)) | 0,
      uJ = Uint32Array.from([
        0xf3bcc908, 0x6a09e667, 0x84caa73b, 0xbb67ae85, 0xfe94f82b, 0x3c6ef372, 0x5f1d36f1,
        0xa54ff53a, 0xade682d1, 0x510e527f, 0x2b3e6c1f, 0x9b05688c, 0xfb41bd6b, 0x1f83d9ab,
        0x137e2179, 0x5be0cd19,
      ]),
      u0 = new Uint32Array(32);
    function u1(e, t, n, i, a, o) {
      let s = a[o],
        l = a[o + 1],
        u = u0[2 * e],
        c = u0[2 * e + 1],
        d = u0[2 * t],
        f = u0[2 * t + 1],
        h = u0[2 * n],
        p = u0[2 * n + 1],
        m = u0[2 * i],
        g = u0[2 * i + 1],
        y = uG(u, d, s);
      (c = uH(y, c, f, l)),
        (u = 0 | y),
        ({ Dh: g, Dl: m } = { Dh: g ^ c, Dl: m ^ u }),
        ({ Dh: g, Dl: m } = { Dh: m, Dl: g }),
        ({ h: p, l: h } = uK(p, h, g, m)),
        ({ Bh: f, Bl: d } = { Bh: f ^ p, Bl: d ^ h }),
        ({ Bh: f, Bl: d } = { Bh: uV(f, d, 24), Bl: u$(f, d, 24) }),
        (u0[2 * e] = u),
        (u0[2 * e + 1] = c),
        (u0[2 * t] = d),
        (u0[2 * t + 1] = f),
        (u0[2 * n] = h),
        (u0[2 * n + 1] = p),
        (u0[2 * i] = m),
        (u0[2 * i + 1] = g);
    }
    function u5(e, t, n, i, a, o) {
      let s = a[o],
        l = a[o + 1],
        u = u0[2 * e],
        c = u0[2 * e + 1],
        d = u0[2 * t],
        f = u0[2 * t + 1],
        h = u0[2 * n],
        p = u0[2 * n + 1],
        m = u0[2 * i],
        g = u0[2 * i + 1],
        y = uG(u, d, s);
      (c = uH(y, c, f, l)),
        (u = 0 | y),
        ({ Dh: g, Dl: m } = { Dh: g ^ c, Dl: m ^ u }),
        ({ Dh: g, Dl: m } = { Dh: uV(g, m, 16), Dl: u$(g, m, 16) }),
        ({ h: p, l: h } = uK(p, h, g, m)),
        ({ Bh: f, Bl: d } = { Bh: f ^ p, Bl: d ^ h }),
        ({ Bh: f, Bl: d } = { Bh: uW(f, d, 63), Bl: uq(f, d, 63) }),
        (u0[2 * e] = u),
        (u0[2 * e + 1] = c),
        (u0[2 * t] = d),
        (u0[2 * t + 1] = f),
        (u0[2 * n] = h),
        (u0[2 * n + 1] = p),
        (u0[2 * i] = m),
        (u0[2 * i + 1] = g);
    }
    function u2(e, t = {}, n, i, a) {
      if ((uo(n), e < 0 || e > n)) throw Error('outputLen bigger than keyLen');
      let { key: o, salt: s, personalization: l } = t;
      if (void 0 !== o && (o.length < 1 || o.length > n))
        throw Error('key length must be undefined or 1..' + n);
      if (void 0 !== s && s.length !== i) throw Error('salt must be undefined or ' + i);
      if (void 0 !== l && l.length !== a) throw Error('personalization must be undefined or ' + a);
    }
    class u6 extends uI {
      constructor(e, t) {
        super(),
          (this.finished = !1),
          (this.destroyed = !1),
          (this.length = 0),
          (this.pos = 0),
          uo(e),
          uo(t),
          (this.blockLen = e),
          (this.outputLen = t),
          (this.buffer = new Uint8Array(e)),
          (this.buffer32 = ud(this.buffer));
      }
      update(e) {
        uu(this), us((e = uk(e)));
        let { blockLen: t, buffer: n, buffer32: i } = this,
          a = e.length,
          o = e.byteOffset,
          s = e.buffer;
        for (let l = 0; l < a; ) {
          this.pos === t && (ub(i), this.compress(i, 0, !1), ub(i), (this.pos = 0));
          let u = Math.min(t - this.pos, a - l),
            c = o + l;
          if (u === t && !(c % 4) && l + u < a) {
            let e = new Uint32Array(s, c, Math.floor((a - l) / 4));
            ub(e);
            for (let n = 0; l + t < a; n += i.length, l += t)
              (this.length += t), this.compress(e, n, !1);
            ub(e);
            continue;
          }
          n.set(e.subarray(l, l + u), this.pos), (this.pos += u), (this.length += u), (l += u);
        }
        return this;
      }
      digestInto(e) {
        uu(this), uc(e, this);
        let { pos: t, buffer32: n } = this;
        (this.finished = !0), uf(this.buffer.subarray(t)), ub(n), this.compress(n, 0, !0), ub(n);
        let i = ud(e);
        this.get().forEach((e, t) => (i[t] = uy(e)));
      }
      digest() {
        let { buffer: e, outputLen: t } = this;
        this.digestInto(e);
        let n = e.slice(0, t);
        return this.destroy(), n;
      }
      _cloneInto(e) {
        let { buffer: t, length: n, finished: i, destroyed: a, outputLen: o, pos: s } = this;
        return (
          e || (e = new this.constructor({ dkLen: o })),
          e.set(...this.get()),
          e.buffer.set(t),
          (e.destroyed = a),
          (e.finished = i),
          (e.length = n),
          (e.pos = s),
          (e.outputLen = o),
          e
        );
      }
      clone() {
        return this._cloneInto();
      }
    }
    class u3 extends u6 {
      constructor(e = {}) {
        const t = void 0 === e.dkLen ? 64 : e.dkLen;
        super(128, t),
          (this.v0l = 0 | uJ[0]),
          (this.v0h = 0 | uJ[1]),
          (this.v1l = 0 | uJ[2]),
          (this.v1h = 0 | uJ[3]),
          (this.v2l = 0 | uJ[4]),
          (this.v2h = 0 | uJ[5]),
          (this.v3l = 0 | uJ[6]),
          (this.v3h = 0 | uJ[7]),
          (this.v4l = 0 | uJ[8]),
          (this.v4h = 0 | uJ[9]),
          (this.v5l = 0 | uJ[10]),
          (this.v5h = 0 | uJ[11]),
          (this.v6l = 0 | uJ[12]),
          (this.v6h = 0 | uJ[13]),
          (this.v7l = 0 | uJ[14]),
          (this.v7h = 0 | uJ[15]),
          u2(t, e, 64, 16, 16);
        let { key: n, personalization: i, salt: a } = e,
          o = 0;
        if (
          (void 0 !== n && (o = (n = uk(n)).length),
          (this.v0l ^= this.outputLen | (o << 8) | 0x1010000),
          void 0 !== a)
        ) {
          const e = ud((a = uk(a)));
          (this.v4l ^= uy(e[0])),
            (this.v4h ^= uy(e[1])),
            (this.v5l ^= uy(e[2])),
            (this.v5h ^= uy(e[3]));
        }
        if (void 0 !== i) {
          const e = ud((i = uk(i)));
          (this.v6l ^= uy(e[0])),
            (this.v6h ^= uy(e[1])),
            (this.v7l ^= uy(e[2])),
            (this.v7h ^= uy(e[3]));
        }
        if (void 0 !== n) {
          const e = new Uint8Array(this.blockLen);
          e.set(n), this.update(e);
        }
      }
      get() {
        let {
          v0l: e,
          v0h: t,
          v1l: n,
          v1h: i,
          v2l: a,
          v2h: o,
          v3l: s,
          v3h: l,
          v4l: u,
          v4h: c,
          v5l: d,
          v5h: f,
          v6l: h,
          v6h: p,
          v7l: m,
          v7h: g,
        } = this;
        return [e, t, n, i, a, o, s, l, u, c, d, f, h, p, m, g];
      }
      set(e, t, n, i, a, o, s, l, u, c, d, f, h, p, m, g) {
        (this.v0l = 0 | e),
          (this.v0h = 0 | t),
          (this.v1l = 0 | n),
          (this.v1h = 0 | i),
          (this.v2l = 0 | a),
          (this.v2h = 0 | o),
          (this.v3l = 0 | s),
          (this.v3h = 0 | l),
          (this.v4l = 0 | u),
          (this.v4h = 0 | c),
          (this.v5l = 0 | d),
          (this.v5h = 0 | f),
          (this.v6l = 0 | h),
          (this.v6h = 0 | p),
          (this.v7l = 0 | m),
          (this.v7h = 0 | g);
      }
      compress(e, t, n) {
        this.get().forEach((e, t) => (u0[t] = e)), u0.set(uJ, 16);
        let { h: i, l: a } = uF(BigInt(this.length));
        (u0[24] = uJ[8] ^ a), (u0[25] = uJ[9] ^ i), n && ((u0[28] = ~u0[28]), (u0[29] = ~u0[29]));
        let o = 0;
        for (let n = 0; n < 12; n++)
          u1(0, 4, 8, 12, e, t + 2 * uR[o++]),
            u5(0, 4, 8, 12, e, t + 2 * uR[o++]),
            u1(1, 5, 9, 13, e, t + 2 * uR[o++]),
            u5(1, 5, 9, 13, e, t + 2 * uR[o++]),
            u1(2, 6, 10, 14, e, t + 2 * uR[o++]),
            u5(2, 6, 10, 14, e, t + 2 * uR[o++]),
            u1(3, 7, 11, 15, e, t + 2 * uR[o++]),
            u5(3, 7, 11, 15, e, t + 2 * uR[o++]),
            u1(0, 5, 10, 15, e, t + 2 * uR[o++]),
            u5(0, 5, 10, 15, e, t + 2 * uR[o++]),
            u1(1, 6, 11, 12, e, t + 2 * uR[o++]),
            u5(1, 6, 11, 12, e, t + 2 * uR[o++]),
            u1(2, 7, 8, 13, e, t + 2 * uR[o++]),
            u5(2, 7, 8, 13, e, t + 2 * uR[o++]),
            u1(3, 4, 9, 14, e, t + 2 * uR[o++]),
            u5(3, 4, 9, 14, e, t + 2 * uR[o++]);
        (this.v0l ^= u0[0] ^ u0[16]),
          (this.v0h ^= u0[1] ^ u0[17]),
          (this.v1l ^= u0[2] ^ u0[18]),
          (this.v1h ^= u0[3] ^ u0[19]),
          (this.v2l ^= u0[4] ^ u0[20]),
          (this.v2h ^= u0[5] ^ u0[21]),
          (this.v3l ^= u0[6] ^ u0[22]),
          (this.v3h ^= u0[7] ^ u0[23]),
          (this.v4l ^= u0[8] ^ u0[24]),
          (this.v4h ^= u0[9] ^ u0[25]),
          (this.v5l ^= u0[10] ^ u0[26]),
          (this.v5h ^= u0[11] ^ u0[27]),
          (this.v6l ^= u0[12] ^ u0[28]),
          (this.v6h ^= u0[13] ^ u0[29]),
          (this.v7l ^= u0[14] ^ u0[30]),
          (this.v7h ^= u0[15] ^ u0[31]),
          uf(u0);
      }
      destroy() {
        (this.destroyed = !0),
          uf(this.buffer32),
          this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
      }
    }
    let u4 =
        ((F = (e) => new u3(e)),
        ((y = (e, t) => F(t).update(uk(e)).digest()).outputLen = (b = F({})).outputLen),
        (y.blockLen = b.blockLen),
        (y.create = (e) => F(e)),
        y),
      u8 = l$.struct('DummyFieldObj', { dummy_field: l$.bool() }),
      u9 = l$.struct('Name', { labels: l$.vector(l$.string()) }),
      u7 = l$.struct('Range', { from: l$.u8(), to: l$.u8() }),
      ce = l$.struct('CouponRules', {
        length: l$.option(u7),
        available_claims: l$.option(l$.u64()),
        user: l$.option(l$.Address),
        expiration: l$.option(l$.u64()),
        years: l$.option(u7),
        can_stack: l$.bool(),
      }),
      ct = l$.struct('CouponHouse', {
        coupons: l$.struct('Coupons', {
          coupons: l$.struct('Table', {
            id: l$.struct('UID', { id: l$.struct('ID', { bytes: l$.Address }) }),
            size: l$.u64(),
          }),
        }),
        version: l$.u8(),
        id: l$.struct('UID', { id: l$.struct('ID', { bytes: l$.Address }) }),
      }),
      cr = l$.struct('Coupon', { kind: l$.u8(), amount: l$.u64(), rules: ce });
    BigInt('18446744073709551615');
    let cn = {
        devnet: {
          adminAddress: '0x1ca3c38e888493f869ac35346a2041d6cf87b0b935ebba14b35a08811d8a76e4',
          adminCap: '0x5a45ba086c2a873b5d6d34e8503e8ca8850588bf7f301285e279c8dab94eeb73',
          auctionPackageId: '0x79c8714ea294a92da04875c77ccabf8d1a06107e80d41c23d6777d5b1e6724a5',
          auctionHouseObjectId:
            '0xc922c77a1d4f4e699aa912a7c24aee4668f8975d2a5f01ba780f656289bf2c2c',
          coins: {
            IOTA: {
              type: '0x0000000000000000000000000000000000000000000000000000000000000002::iota::IOTA',
              metadataId: '0xf7ceb0424ca93f77858c74aebda8bcd5ffe0f32b82ebcc38afb3ba643d03a5f8',
            },
          },
          iotaNamesObjectId: '0x07c59b37bd7d036bf78fa30561a2ab9f7a970837487656ec29466e817f879342',
          packageId: '0xb9d617f24c84826bf660a2f4031951678cc80c264aebc4413459fb2a95ada9ba',
          paymentsPackageId: '0x98b9b33b7c2347a8f4e8b8716fb4c7e6e1af846ec2ea063a47bba81ffe03b440',
          publisherId: '0xb9435d6c5f3a7bd85fa362b4b89262cf738d48774695e8e9955704ce0fd3526f',
          registryTableId: '0xe00b2f2400c33b4dbd3081c4dcf2e289d0544caba23a3d130b264bd756403c07',
          reverseRegistryTableId:
            '0x1c1da17843cc453ad4079b05ce55e103b7a8cdd4db6ab42dc367b47ed6d8994d',
          couponsPackageId: '0xf2d61106ef44216f03709276c4e79c78485080c6d8fbad8464b7a570b9f36470',
          subnamesPackageId: '0x1efbf928710d0d92635dacff4c502516169d37fa006cabd2f3cdd0123221e09e',
          tempSubnameProxyPackageId:
            '0x4a16b7b2a9c194989519c87ee3f1d1007ece8aecb62b9a50a4c10075db0591a3',
          upgradeCap: '0xd64205c4b10eff4b4adb00ab6f754cda8d8e7525985a31307f7e232481dfaf6e',
        },
        testnet: {
          adminAddress: '0x548474360f9769077ccf07ff6e65060eb448470eabc1ae42b9ed371ddbfc23d2',
          adminCap: '0x541b117cac18fb1c07a293db300acd12b05c01fa81232b37151b005ca7d4f755',
          auctionPackageId: '0x6f727ea576a00036657fff0ae3a6d7c8171b178bf35112d6b83b2a6272cc5f0d',
          auctionHouseObjectId:
            '0x2292ea885039babe8c320f19e0b7546ebdef2b2f6cf2be600bf994cdb51e0050',
          coins: {
            IOTA: {
              type: '0x0000000000000000000000000000000000000000000000000000000000000002::iota::IOTA',
              metadataId: '0x6dcda050874e2f160a008afc9e3ca6304a667cc85045e35f25b3c7967282b153',
            },
          },
          iotaNamesObjectId: '0x7cab491740d51e0d75b26bf9984e49ba2e32a2d0694cabcee605543ed13c7dec',
          packageId: '0x7fff6e95f385349bec98d17121ab2bfa3e134f2f0b1ccefc270313415f7835ea',
          paymentsPackageId: '0x6b1b01f4c72786a893191d5c6e73d3012f7529f86fdee3bc8c163323cee08441',
          publisherId: '0x42faed18f40323158fb9b0f38630800addc2e9eea696265756769fc1f0e08ceb',
          registryTableId: '0x2dfc6f6d46ba55217425643a59dc85fe4d8ed273a9f74077bd0ee280dbb4f590',
          reverseRegistryTableId:
            '0x3550bcacb793ef8b776264665e7c99fa3d897695ed664656aac693cf9cf9b76b',
          couponsPackageId: '0xa7e4e483d79c245470d5eb3c285a4503a78d90a69d36e35e0993012f5c6137ca',
          subnamesPackageId: '0xd06a5607cc762f2352eeeb8c86c7f962558a06c6023c1eec031a41651d898c87',
          tempSubnameProxyPackageId:
            '0x7f34c135e55e5b436b3feaad369eabfe5b6d14c0c57544fefb6921db047e8cbc',
          upgradeCap: '0x03ac547ee58c268a69b5663a1fdee0e8202206922968d2a387104730627d188e',
        },
      },
      ci = /(?!-)[a-z0-9-]{0,62}[a-z0-9]/,
      ca = RegExp(`(?:${ci.source}(?:\\.${ci.source})*)`),
      co = RegExp(`^(${ca.source})?@${ci.source}$`),
      cs = RegExp(`^(?:${ci.source}\\.)+(iota)$`);
    function cl(e) {
      return !(e.length > 235) && (co.test(e) || cs.test(e));
    }
    function cu(
      e,
      t = 'at',
      { onlyFirstSubname: n, truncateLongParts: i, ellipsisForDeepSubnames: a = !0 === n } = {}
    ) {
      let o,
        s = e.toLowerCase();
      if (co.test(s)) {
        let [e, t] = s.split('@');
        o = [...(e ? e.split('.') : []), t];
      } else if (cs.test(s)) o = s.split('.').slice(0, -1);
      else throw Error(`Invalid IOTA name "${e}"`);
      let l =
          n && o.length >= 2
            ? [o[0], a && o.length > 2 ? ('dot' === t ? '.' : '..') : ''].filter(Boolean)
            : o.slice(0, -1),
        u = o[o.length - 1];
      return (i &&
        ((l = l.map((e) => (e.length > 11 ? `${e.slice(0, 6)}...${e.slice(-6)}` : e))),
        (u = u.length > 11 ? `${u.slice(0, 6)}...${u.slice(-6)}` : u)),
      'dot' === t)
        ? `${[...l, u].join('.')}.iota`
        : `${l.join('.')}@${u}`;
    }
    function cc(e, t) {
      return `${e}::iota_names::ConfigKey<${t}>`;
    }
    class cd {
      constructor(e) {
        (this.graphQlClient = e.graphQlClient),
          'network' in e ? (this.config = cn[e.network]) : (this.config = e.packageInfo);
      }
      async getCoreConfig() {
        var e;
        if (!this.config.iotaNamesObjectId) throw Error('IotaNames object ID is not set');
        if (!this.config.packageId) throw Error('IotaNames package ID is not set');
        let t = sj(u8.serialize({ dummy_field: !1 }).toBytes()),
          n = await this.graphQlClient.query({
            query: un(`
                query getCoreConfig($parentId: IotaAddress!, $name: DynamicFieldName!) {
                    owner(address: $parentId) {
                        address
                        dynamicField(name: $name) {
                            value {
                                ... on MoveValue {
                                    json
                                }
                            }
                        }
                    }
                }
            `),
            variables: {
              parentId: this.config.iotaNamesObjectId,
              name: {
                type: cc(
                  this.config.packageId,
                  ((e = this.config.packageId), `${e}::core_config::CoreConfig`)
                ),
                bcs: t,
              },
            },
          }),
          i = n?.data?.owner?.dynamicField?.value?.json;
        if (!i) throw Error('Core config not found or is invalid');
        return i;
      }
      async getPriceList() {
        var e;
        if (!this.config.iotaNamesObjectId) throw Error('IotaNames object ID is not set');
        if (!this.config.packageId) throw Error('IotaNames package ID is not set');
        let t = sj(u8.serialize({ dummy_field: !1 }).toBytes()),
          n = await this.graphQlClient.query({
            query: un(`
                query getPriceList($parentId: IotaAddress!, $name: DynamicFieldName!) {
                    owner(address: $parentId) {
                        address
                        dynamicField(name: $name) {
                            value {
                                ... on MoveValue {
                                    json
                                }
                            }
                        }
                    }
                }
            `),
            variables: {
              parentId: this.config.iotaNamesObjectId,
              name: {
                type: cc(
                  this.config.packageId,
                  ((e = this.config.packageId), `${e}::pricing_config::PricingConfig`)
                ),
                bcs: t,
              },
            },
          }),
          i = n?.data?.owner?.dynamicField?.value?.json?.pricing,
          a = i?.contents;
        if (!a) throw Error('Price list not found or content is invalid');
        let o = new Map();
        for (let e of a) {
          let { pos0: t, pos1: n } = e.key,
            i = [Number(t), Number(n)],
            a = Number(e.value);
          o.set(i, a);
        }
        return o;
      }
      async getRenewalPriceList() {
        var e;
        if (!this.config.iotaNamesObjectId) throw Error('IotaNames object ID is not set');
        if (!this.config.packageId) throw Error('IotaNames package ID is not set');
        let t = sj(u8.serialize({ dummy_field: !1 }).toBytes()),
          n = await this.graphQlClient.query({
            query: un(`
                query getRenewalPriceList($parentId: IotaAddress!, $name: DynamicFieldName!) {
                    owner(address: $parentId) {
                        address
                        dynamicField(name: $name) {
                            value {
                                ... on MoveValue {
                                    json
                                }
                            }
                        }
                    }
                }
            `),
            variables: {
              parentId: this.config.iotaNamesObjectId,
              name: {
                type: cc(
                  this.config.packageId,
                  ((e = this.config.packageId), `${e}::pricing_config::RenewalConfig`)
                ),
                bcs: t,
              },
            },
          }),
          i = n?.data?.owner?.dynamicField?.value?.json?.config?.pricing,
          a = i?.contents;
        if (!a) throw Error('Price list not found or content is invalid');
        let o = new Map();
        for (let e of a) {
          let { pos0: t, pos1: n } = e.key,
            i = [Number(t), Number(n)],
            a = Number(e.value);
          o.set(i, a);
        }
        return o;
      }
      async getDefaultName(e) {
        let t = await this.graphQlClient.query({
          query: un(`
                query resolveNameServiceName($address: IotaAddress!, $nameFormat: NameFormat) {
                    address(address: $address) {
                        iotaNamesDefaultName(format: $nameFormat)
                    }
                }
            `),
          variables: { address: e },
        });
        return t?.data?.address?.iotaNamesDefaultName ?? null;
      }
      async getNameRecord(e) {
        var t;
        if (!cl(e)) throw Error('Invalid IOTA name');
        if (!this.config.registryTableId) throw Error('IotaNames package ID is not set');
        let n = sj(u9.serialize({ labels: cu(e, 'dot').split('.').reverse() }).toBytes()),
          i = await this.graphQlClient.query({
            query: un(`
                query getNameRecord($parentId: IotaAddress!, $name: DynamicFieldName!) {
                    owner(address: $parentId) {
                        address
                        dynamicField(name: $name) {
                            value {
                                ... on MoveValue {
                                    json
                                }
                            }
                        }
                    }
                }
            `),
            variables: {
              parentId: this.config.registryTableId,
              name: { type: ((t = this.config.packageId), `${t}::name::Name`), bcs: n },
            },
          }),
          a = i.data?.owner?.dynamicField?.value?.json;
        if (!a) return null;
        let o = a.data?.contents;
        if (a.error || !o) throw Error('Name record not found. This name is not registered.');
        let s = {};
        return (
          o &&
            o.forEach((e) => {
              e.key && (s[e.key] = e.value);
            }),
          {
            name: e,
            nftId: a?.nft_id,
            targetAddress: a?.target_address,
            expirationTimestampMs: Number(a?.expiration_timestamp_ms),
            data: s,
            avatar: s.avatar,
          }
        );
      }
      async getCouponHouse() {
        if (!this.config.iotaNamesObjectId) throw Error('IotaNames object ID is not set');
        if (!this.config.packageId) throw Error('IotaNames package ID is not set');
        if (!this.config.couponsPackageId) throw Error('Coupon package ID is not set');
        let e = this.config.iotaNamesObjectId,
          t = this.config.packageId,
          n = this.config.couponsPackageId,
          i = u8.serialize({ dummy_field: !1 }).toBase64(),
          a = await this.graphQlClient.query({
            query: un(`
                query getIotaNamesCouponHouseRegistryKey(
                    $parentId: IotaAddress!
                    $name: DynamicFieldName!
                ) {
                    owner(address: $parentId) {
                        dynamicField(name: $name) {
                            value {
                                ... on MoveValue {
                                    bcs
                                }
                            }
                        }
                    }
                }
            `),
            variables: {
              parentId: e,
              name: {
                type: `${t}::iota_names::RegistryKey<${n}::coupon_house::CouponHouse>`,
                bcs: i,
              },
            },
          }),
          o = a?.data?.owner?.dynamicField?.value?.bcs;
        if (!o) throw Error('Coupon house not found or is invalid');
        return ct.parse(sI(o));
      }
      async resolveCoupon(e) {
        let t = await this.getCouponHouse(),
          n = t?.coupons?.coupons?.id.id.bytes;
        if (!n) throw Error('Coupons table ID not found in the coupon house');
        let i = uS(ux(u4(e, { dkLen: 32 }))),
          a = l$.vector(l$.u8()).serialize(i).toBase64(),
          o = await this.graphQlClient.query({
            query: un(`
                query getCouponBcs($parentId: IotaAddress!, $name: DynamicFieldName!) {
                    owner(address: $parentId) {
                        dynamicField(name: $name) {
                            value {
                                ... on MoveValue {
                                    bcs
                                }
                            }
                        }
                    }
                }
            `),
            variables: { parentId: n, name: { type: 'vector<u8>', bcs: a } },
          }),
          s = o?.data?.owner?.dynamicField?.value?.bcs;
        return s ? { ...cr.parse(sI(s)), couponCode: e } : null;
      }
      async calculatePrice({ name: e, years: t, isRegistration: n = !0 }) {
        if (!cl(e)) throw Error('Invalid IOTA names');
        if (!(t > 0 && t < 6)) throw Error('Years must be between 1 and 5');
        if (cu(e, 'dot').split('.').length > 2)
          throw Error('Subnames do not have a registration fee');
        let i = cu(e, 'dot').split('.')[0].length,
          a = await this.getPriceList(),
          o = await this.getRenewalPriceList(),
          s = t,
          l = 0;
        if (n) {
          for (let [[e, t], n] of a.entries())
            if (i >= e && i <= t) {
              (l += n), (s -= 1);
              break;
            }
        }
        for (let [[e, t], n] of o.entries())
          if (i >= e && i <= t) {
            l += s * n;
            break;
          }
        return l;
      }
      async calculateDiscountedPrice({
        coupons: e,
        name: t,
        years: n,
        isRegistration: i = !0,
        address: a,
      }) {
        if (e.every((e) => 'string' == typeof e)) {
          let t = e.map(async (e) => {
            let t = await this.resolveCoupon(e);
            if (!t) throw Error(`Coupon not found: ${e}`);
            return t;
          });
          e = await Promise.all(t);
        }
        let o = cu(t, 'dot');
        !(function (e, t = 3, n = 64, i = !0) {
          if (!e) return;
          let a = e.toLowerCase().split('.');
          if (i || !(a.length > 2)) {
            for (let e of a.slice(0, -1))
              if (e.length < t || e.length > n) return `Name must be ${t}-${n} characters long`;
            cs.test(e);
          }
        })(o);
        let s = o.split('.')[0];
        var l = e,
          u = n,
          c = s.length,
          d = a;
        for (let e of l) {
          if (!e.rules.can_stack && l.length > 1)
            throw Error(
              `Coupon '${e.couponCode}' validation failed: Coupon cannot be used with other coupons.`
            );
          try {
            (function (e) {
              if (
                e?.available_claims !== null &&
                e?.available_claims !== void 0 &&
                0 >= parseInt(e?.available_claims)
              )
                throw Error('Number of claims cannot be zero.');
            })(e.rules),
              (function (e, t) {
                let { from: n, to: i } = e.years || {};
                if (n && i && (t < n || t > i))
                  throw Error('Coupon is not valid for the given number of years.');
              })(e.rules, u),
              0 === e.kind &&
                (function (e) {
                  if (0 >= parseInt(e) || parseInt(e) > 100)
                    throw Error('Invalid percentage amount for coupon.');
                })(e.amount),
              (function (e, t) {
                let { from: n, to: i } = e.length || {};
                if (n && i && (t < n || t > i))
                  throw Error('Coupon is not valid for the given name length.');
              })(e.rules, c),
              (function (e, t) {
                if (e.user && e.user !== t) throw Error('Coupon address does not match.');
              })(e.rules, d),
              (function (e, t = Date.now().toString()) {
                if (e.expiration && Number(t) > Number(e.expiration))
                  throw Error('Coupon has expired.');
              })(e.rules);
          } catch (t) {
            throw Error(`Coupon '${e.couponCode}' validation failed: ${t?.message}`);
          }
        }
        let f = await this.calculatePrice({ name: t, years: n, isRegistration: i });
        var h = e;
        if (!h || 0 === h.length) return f;
        let p = f;
        for (let e of h) {
          if (!e.rules.can_stack && h.length > 1) throw Error('Coupons provided cannot be stacked');
          p = (function (e, t) {
            if (!t) return e;
            let n = Number(t.amount);
            if (0 === t.kind) return e - (e * n) / 100;
            if (1 === t.kind) {
              let t = e - n;
              return t < 0 ? 0 : t;
            }
            throw Error(`Unknown coupon kind: ${t.kind}`);
          })(p, e);
        }
        return p;
      }
    }
    function cf(e) {
      let t = [],
        n = 0;
      if (0 === e) return [0];
      for (; e > 0; ) (t[n] = 127 & e), (e >>= 7) && (t[n] |= 128), (n += 1);
      return t;
    }
    class ch {
      constructor(e) {
        (this.bytePosition = 0),
          (this.dataView = new DataView(e.buffer, e.byteOffset, e.byteLength));
      }
      shift(e) {
        return (this.bytePosition += e), this;
      }
      read8() {
        let e = this.dataView.getUint8(this.bytePosition);
        return this.shift(1), e;
      }
      read16() {
        let e = this.dataView.getUint16(this.bytePosition, !0);
        return this.shift(2), e;
      }
      read32() {
        let e = this.dataView.getUint32(this.bytePosition, !0);
        return this.shift(4), e;
      }
      read64() {
        let e = this.read32();
        return BigInt(
          '0x' + (this.read32().toString(16) + e.toString(16).padStart(8, '0'))
        ).toString(10);
      }
      read128() {
        let e = BigInt(this.read64());
        return BigInt(
          '0x' + (BigInt(this.read64()).toString(16) + e.toString(16).padStart(16, '0'))
        ).toString(10);
      }
      read256() {
        let e = BigInt(this.read128());
        return BigInt(
          '0x' + (BigInt(this.read128()).toString(16) + e.toString(16).padStart(32, '0'))
        ).toString(10);
      }
      readBytes(e) {
        let t = this.bytePosition + this.dataView.byteOffset,
          n = new Uint8Array(this.dataView.buffer, t, e);
        return this.shift(e), n;
      }
      readULEB() {
        let e = this.bytePosition + this.dataView.byteOffset,
          { value: t, length: n } = (function (e) {
            let t = 0,
              n = 0,
              i = 0;
            for (;;) {
              let a = e[i];
              if (((i += 1), (t |= (127 & a) << n), (128 & a) == 0)) break;
              n += 7;
            }
            return { value: t, length: i };
          })(new Uint8Array(this.dataView.buffer, e));
        return this.shift(n), t;
      }
      readVec(e) {
        let t = this.readULEB(),
          n = [];
        for (let i = 0; i < t; i++) n.push(e(this, i, t));
        return n;
      }
    }
    class cp {
      constructor({ initialSize: e = 1024, maxSize: t = 1 / 0, allocateSize: n = 1024 } = {}) {
        (this.bytePosition = 0),
          (this.size = e),
          (this.maxSize = t),
          (this.allocateSize = n),
          (this.dataView = new DataView(new ArrayBuffer(e)));
      }
      ensureSizeOrGrow(e) {
        let t = this.bytePosition + e;
        if (t > this.size) {
          let e = Math.min(this.maxSize, this.size + this.allocateSize);
          if (t > e)
            throw Error(
              `SizeLimitExceeded: Attempting to serialize to BCS, but buffer does not have enough size. Allocated size: ${this.size}, Max size: ${this.maxSize}, Required size: ${t}`
            );
          this.size = e;
          let n = new ArrayBuffer(this.size);
          new Uint8Array(n).set(new Uint8Array(this.dataView.buffer)),
            (this.dataView = new DataView(n));
        }
      }
      shift(e) {
        return (this.bytePosition += e), this;
      }
      write8(e) {
        return (
          this.ensureSizeOrGrow(1),
          this.dataView.setUint8(this.bytePosition, Number(e)),
          this.shift(1)
        );
      }
      write16(e) {
        return (
          this.ensureSizeOrGrow(2),
          this.dataView.setUint16(this.bytePosition, Number(e), !0),
          this.shift(2)
        );
      }
      write32(e) {
        return (
          this.ensureSizeOrGrow(4),
          this.dataView.setUint32(this.bytePosition, Number(e), !0),
          this.shift(4)
        );
      }
      write64(e) {
        return cm(BigInt(e), 8).forEach((e) => this.write8(e)), this;
      }
      write128(e) {
        return cm(BigInt(e), 16).forEach((e) => this.write8(e)), this;
      }
      write256(e) {
        return cm(BigInt(e), 32).forEach((e) => this.write8(e)), this;
      }
      writeULEB(e) {
        return cf(e).forEach((e) => this.write8(e)), this;
      }
      writeVec(e, t) {
        return (
          this.writeULEB(e.length), Array.from(e).forEach((n, i) => t(this, n, i, e.length)), this
        );
      }
      *[Symbol.iterator]() {
        for (let e = 0; e < this.bytePosition; e++) yield this.dataView.getUint8(e);
        return this.toBytes();
      }
      toBytes() {
        return new Uint8Array(this.dataView.buffer.slice(0, this.bytePosition));
      }
      toString(e) {
        var t = this.toBytes();
        switch (e) {
          case 'base58':
            return n2.encode(t);
          case 'base64':
            return n3(t);
          case 'hex':
            return n8(t);
          default:
            throw Error('Unsupported encoding, supported values are: base64, hex');
        }
      }
    }
    function cm(e, t) {
      let n = new Uint8Array(t),
        i = 0;
      for (; e > 0; ) (n[i] = Number(e % BigInt(256))), (e /= BigInt(256)), (i += 1);
      return n;
    }
    var cg = (e) => {
        throw TypeError(e);
      },
      cy = (e, t, n) => t.has(e) || cg('Cannot ' + n),
      cb = (e, t, n) => (cy(e, t, 'read from private field'), n ? n.call(e) : t.get(e)),
      cv = (e, t, n) =>
        t.has(e)
          ? cg('Cannot add the same private member more than once')
          : t instanceof WeakSet
          ? t.add(e)
          : t.set(e, n),
      cw = (e, t, n, i) => (cy(e, t, 'write to private field'), i ? i.call(e, n) : t.set(e, n), n);
    let cx = class e {
      constructor(e) {
        cv(this, ea),
          cv(this, eo),
          (this.name = e.name),
          (this.read = e.read),
          (this.serializedSize = e.serializedSize ?? (() => null)),
          cw(this, ea, e.write),
          cw(
            this,
            eo,
            e.serialize ??
              ((e, t) => {
                let n = new cp({ initialSize: this.serializedSize(e) ?? void 0, ...t });
                return cb(this, ea).call(this, e, n), n.toBytes();
              })
          ),
          (this.validate = e.validate ?? (() => {}));
      }
      write(e, t) {
        this.validate(e), cb(this, ea).call(this, e, t);
      }
      serialize(e, t) {
        return this.validate(e), new cC(this, cb(this, eo).call(this, e, t));
      }
      parse(e) {
        let t = new ch(e);
        return this.read(t);
      }
      fromHex(e) {
        return this.parse(n4(e));
      }
      fromBase58(e) {
        let t;
        return this.parse(((t = e), n2.decode(t)));
      }
      fromBase64(e) {
        return this.parse(n6(e));
      }
      transform({ name: t, input: n, output: i, validate: a }) {
        return new e({
          name: t ?? this.name,
          read: (e) => (i ? i(this.read(e)) : this.read(e)),
          write: (e, t) => cb(this, ea).call(this, n ? n(e) : e, t),
          serializedSize: (e) => this.serializedSize(n ? n(e) : e),
          serialize: (e, t) => cb(this, eo).call(this, n ? n(e) : e, t),
          validate: (e) => {
            a?.(e), this.validate(n ? n(e) : e);
          },
        });
      }
    };
    (ea = new WeakMap()), (eo = new WeakMap());
    let cE = Symbol.for('@iota/serialized-bcs');
    function cS(e) {
      return !!e && 'object' == typeof e && !0 === e[cE];
    }
    class cC {
      constructor(e, t) {
        cv(this, es), cv(this, el), cw(this, es, e), cw(this, el, t);
      }
      get [cE]() {
        return !0;
      }
      toBytes() {
        return cb(this, el);
      }
      toHex() {
        return n8(cb(this, el));
      }
      toBase64() {
        return n3(cb(this, el));
      }
      toBase58() {
        let e;
        return (e = cb(this, el)), n2.encode(e);
      }
      parse() {
        return cb(this, es).parse(cb(this, el));
      }
    }
    function ck({ size: e, ...t }) {
      return new cx({ ...t, serializedSize: () => e });
    }
    function cO({ readMethod: e, writeMethod: t, ...n }) {
      return ck({
        ...n,
        read: (t) => t[e](),
        write: (e, n) => n[t](e),
        validate: (e) => {
          if (e < 0 || e > n.maxValue)
            throw TypeError(
              `Invalid ${n.name} value: ${e}. Expected value in range 0-${n.maxValue}`
            );
          n.validate?.(e);
        },
      });
    }
    function cA({ readMethod: e, writeMethod: t, ...n }) {
      return ck({
        ...n,
        read: (t) => t[e](),
        write: (e, n) => n[t](BigInt(e)),
        validate: (e) => {
          let t = BigInt(e);
          if (t < 0 || t > n.maxValue)
            throw TypeError(
              `Invalid ${n.name} value: ${t}. Expected value in range 0-${n.maxValue}`
            );
          n.validate?.(t);
        },
      });
    }
    function cI(e) {
      let t = typeof e;
      return 'string' === t
        ? `"${e}"`
        : 'number' === t || 'bigint' === t || 'boolean' === t
        ? `${e}`
        : 'object' === t || 'function' === t
        ? (e && Object.getPrototypeOf(e)?.constructor?.name) ?? 'null'
        : t;
    }
    function cj(e, t, n, i, a) {
      var o, s, l, u;
      let c = a && 'input' in a ? a.input : n.value,
        d = a?.expected ?? e.expects ?? null,
        f = a?.received ?? cI(c),
        h = {
          kind: e.kind,
          type: e.type,
          input: c,
          expected: d,
          received: f,
          message: `Invalid ${t}: ${d ? `Expected ${d} but r` : 'R'}eceived ${f}`,
          requirement: e.requirement,
          path: a?.path,
          issues: a?.issues,
          lang: i.lang,
          abortEarly: i.abortEarly,
          abortPipeEarly: i.abortPipeEarly,
        },
        p = 'schema' === e.kind,
        m =
          a?.message ??
          e.message ??
          ((o = e.reference), (s = h.lang), ef?.get(o)?.get(s)) ??
          (p ? ((l = h.lang), ed?.get(l)) : null) ??
          i.message ??
          ((u = h.lang), ec?.get(u));
      m && (h.message = 'function' == typeof m ? m(h) : m),
        p && (n.typed = !1),
        n.issues ? n.issues.push(h) : (n.issues = [h]);
    }
    (es = new WeakMap()), (el = new WeakMap());
    var cT = class extends Error {
      issues;
      constructor(e) {
        super(e[0].message), (this.name = 'ValiError'), (this.issues = e);
      }
    };
    function cR(e, t) {
      return {
        kind: 'validation',
        type: 'check',
        reference: cR,
        async: !1,
        expects: null,
        requirement: e,
        message: t,
        _run(e, t) {
          return e.typed && !this.requirement(e.value) && cj(this, 'input', e, t), e;
        },
      };
    }
    function cM(e) {
      return {
        kind: 'validation',
        type: 'integer',
        reference: cM,
        async: !1,
        expects: null,
        requirement: Number.isInteger,
        message: e,
        _run(e, t) {
          return e.typed && !this.requirement(e.value) && cj(this, 'integer', e, t), e;
        },
      };
    }
    function cP(e) {
      return {
        kind: 'transformation',
        type: 'transform',
        reference: cP,
        async: !1,
        operation: e,
        _run(e) {
          return (e.value = this.operation(e.value)), e;
        },
      };
    }
    function cN(e, t, n) {
      return 'function' == typeof e.default ? e.default(t, n) : e.default;
    }
    function c_(e, t) {
      return !e._run({ typed: !1, value: t }, { abortEarly: !0 }).issues;
    }
    function cD(e, t) {
      return {
        kind: 'schema',
        type: 'array',
        reference: cD,
        expects: 'Array',
        async: !1,
        item: e,
        message: t,
        _run(e, t) {
          let n = e.value;
          if (Array.isArray(n)) {
            (e.typed = !0), (e.value = []);
            for (let i = 0; i < n.length; i++) {
              let a = n[i],
                o = this.item._run({ typed: !1, value: a }, t);
              if (o.issues) {
                let s = { type: 'array', origin: 'value', input: n, key: i, value: a };
                for (let t of o.issues)
                  t.path ? t.path.unshift(s) : (t.path = [s]), e.issues?.push(t);
                if ((e.issues || (e.issues = o.issues), t.abortEarly)) {
                  e.typed = !1;
                  break;
                }
              }
              o.typed || (e.typed = !1), e.value.push(o.value);
            }
          } else cj(this, 'type', e, t);
          return e;
        },
      };
    }
    function cB(e) {
      return {
        kind: 'schema',
        type: 'bigint',
        reference: cB,
        expects: 'bigint',
        async: !1,
        message: e,
        _run(e, t) {
          return 'bigint' == typeof e.value ? (e.typed = !0) : cj(this, 'type', e, t), e;
        },
      };
    }
    function cU(e) {
      return {
        kind: 'schema',
        type: 'boolean',
        reference: cU,
        expects: 'boolean',
        async: !1,
        message: e,
        _run(e, t) {
          return 'boolean' == typeof e.value ? (e.typed = !0) : cj(this, 'type', e, t), e;
        },
      };
    }
    function cF(e) {
      return {
        kind: 'schema',
        type: 'lazy',
        reference: cF,
        expects: 'unknown',
        async: !1,
        getter: e,
        _run(e, t) {
          return this.getter(e.value)._run(e, t);
        },
      };
    }
    function cL(e, t) {
      return {
        kind: 'schema',
        type: 'literal',
        reference: cL,
        expects: cI(e),
        async: !1,
        literal: e,
        message: t,
        _run(e, t) {
          return e.value === this.literal ? (e.typed = !0) : cj(this, 'type', e, t), e;
        },
      };
    }
    function cz(e, ...t) {
      let n = {
        kind: 'schema',
        type: 'nullable',
        reference: cz,
        expects: `${e.expects} | null`,
        async: !1,
        wrapped: e,
        _run(e, t) {
          return null === e.value &&
            ('default' in this && (e.value = cN(this, e, t)), null === e.value)
            ? ((e.typed = !0), e)
            : this.wrapped._run(e, t);
        },
      };
      return 0 in t && (n.default = t[0]), n;
    }
    function cV(e, ...t) {
      let n = {
        kind: 'schema',
        type: 'nullish',
        reference: cV,
        expects: `${e.expects} | null | undefined`,
        async: !1,
        wrapped: e,
        _run(e, t) {
          return (null === e.value || void 0 === e.value) &&
            ('default' in this && (e.value = cN(this, e, t)),
            null === e.value || void 0 === e.value)
            ? ((e.typed = !0), e)
            : this.wrapped._run(e, t);
        },
      };
      return 0 in t && (n.default = t[0]), n;
    }
    function c$(e) {
      return {
        kind: 'schema',
        type: 'number',
        reference: c$,
        expects: 'number',
        async: !1,
        message: e,
        _run(e, t) {
          return (
            'number' != typeof e.value || isNaN(e.value) ? cj(this, 'type', e, t) : (e.typed = !0),
            e
          );
        },
      };
    }
    function cW(e, t) {
      return {
        kind: 'schema',
        type: 'object',
        reference: cW,
        expects: 'Object',
        async: !1,
        entries: e,
        message: t,
        _run(e, t) {
          let n = e.value;
          if (n && 'object' == typeof n)
            for (let i in ((e.typed = !0), (e.value = {}), this.entries)) {
              let a = n[i],
                o = this.entries[i]._run({ typed: !1, value: a }, t);
              if (o.issues) {
                let s = { type: 'object', origin: 'value', input: n, key: i, value: a };
                for (let t of o.issues)
                  t.path ? t.path.unshift(s) : (t.path = [s]), e.issues?.push(t);
                if ((e.issues || (e.issues = o.issues), t.abortEarly)) {
                  e.typed = !1;
                  break;
                }
              }
              o.typed || (e.typed = !1), (void 0 !== o.value || i in n) && (e.value[i] = o.value);
            }
          else cj(this, 'type', e, t);
          return e;
        },
      };
    }
    function cq(e, ...t) {
      let n = {
        kind: 'schema',
        type: 'optional',
        reference: cq,
        expects: `${e.expects} | undefined`,
        async: !1,
        wrapped: e,
        _run(e, t) {
          return void 0 === e.value &&
            ('default' in this && (e.value = cN(this, e, t)), void 0 === e.value)
            ? ((e.typed = !0), e)
            : this.wrapped._run(e, t);
        },
      };
      return 0 in t && (n.default = t[0]), n;
    }
    function cK(e, t, n) {
      return {
        kind: 'schema',
        type: 'record',
        reference: cK,
        expects: 'Object',
        async: !1,
        key: e,
        value: t,
        message: n,
        _run(e, t) {
          let n = e.value;
          if (n && 'object' == typeof n) {
            for (let i in ((e.typed = !0), (e.value = {}), n))
              if (
                Object.hasOwn(n, i) &&
                '__proto__' !== i &&
                'prototype' !== i &&
                'constructor' !== i
              ) {
                let a = n[i],
                  o = this.key._run({ typed: !1, value: i }, t);
                if (o.issues) {
                  let s = { type: 'object', origin: 'key', input: n, key: i, value: a };
                  for (let t of o.issues) (t.path = [s]), e.issues?.push(t);
                  if ((e.issues || (e.issues = o.issues), t.abortEarly)) {
                    e.typed = !1;
                    break;
                  }
                }
                let s = this.value._run({ typed: !1, value: a }, t);
                if (s.issues) {
                  let o = { type: 'object', origin: 'value', input: n, key: i, value: a };
                  for (let t of s.issues)
                    t.path ? t.path.unshift(o) : (t.path = [o]), e.issues?.push(t);
                  if ((e.issues || (e.issues = s.issues), t.abortEarly)) {
                    e.typed = !1;
                    break;
                  }
                }
                (o.typed && s.typed) || (e.typed = !1), o.typed && (e.value[o.value] = s.value);
              }
          } else cj(this, 'type', e, t);
          return e;
        },
      };
    }
    function cG(e) {
      return {
        kind: 'schema',
        type: 'string',
        reference: cG,
        expects: 'string',
        async: !1,
        message: e,
        _run(e, t) {
          return 'string' == typeof e.value ? (e.typed = !0) : cj(this, 'type', e, t), e;
        },
      };
    }
    function cH(e, t) {
      return {
        kind: 'schema',
        type: 'tuple',
        reference: cH,
        expects: 'Array',
        async: !1,
        items: e,
        message: t,
        _run(e, t) {
          let n = e.value;
          if (Array.isArray(n)) {
            (e.typed = !0), (e.value = []);
            for (let i = 0; i < this.items.length; i++) {
              let a = n[i],
                o = this.items[i]._run({ typed: !1, value: a }, t);
              if (o.issues) {
                let s = { type: 'array', origin: 'value', input: n, key: i, value: a };
                for (let t of o.issues)
                  t.path ? t.path.unshift(s) : (t.path = [s]), e.issues?.push(t);
                if ((e.issues || (e.issues = o.issues), t.abortEarly)) {
                  e.typed = !1;
                  break;
                }
              }
              o.typed || (e.typed = !1), e.value.push(o.value);
            }
          } else cj(this, 'type', e, t);
          return e;
        },
      };
    }
    function cZ(e) {
      let t;
      if (e) for (let n of e) t ? t.push(...n.issues) : (t = n.issues);
      return t;
    }
    function cY(e, t) {
      return {
        kind: 'schema',
        type: 'union',
        reference: cY,
        expects: [...new Set(e.map((e) => e.expects))].join(' | ') || 'never',
        async: !1,
        options: e,
        message: t,
        _run(e, t) {
          let n, i, a;
          for (let o of this.options) {
            let s = o._run({ typed: !1, value: e.value }, t);
            if (s.typed)
              if (s.issues) i ? i.push(s) : (i = [s]);
              else {
                n = s;
                break;
              }
            else a ? a.push(s) : (a = [s]);
          }
          if (n) return n;
          if (i) {
            if (1 === i.length) return i[0];
            cj(this, 'type', e, t, { issues: cZ(i) }), (e.typed = !0);
          } else {
            if (a?.length === 1) return a[0];
            cj(this, 'type', e, t, { issues: cZ(a) });
          }
          return e;
        },
      };
    }
    function cQ() {
      return {
        kind: 'schema',
        type: 'unknown',
        reference: cQ,
        expects: 'unknown',
        async: !1,
        _run: (e) => ((e.typed = !0), e),
      };
    }
    function cX(e, t, n) {
      let i = e._run(
        { typed: !1, value: t },
        {
          lang: n?.lang ?? eu?.lang,
          message: n?.message,
          abortEarly: n?.abortEarly ?? eu?.abortEarly,
          abortPipeEarly: n?.abortPipeEarly ?? eu?.abortPipeEarly,
        }
      );
      if (i.issues) throw new cT(i.issues);
      return i.value;
    }
    function cJ(...e) {
      return {
        ...e[0],
        pipe: e,
        _run(t, n) {
          for (let i = 0; i < e.length; i++) {
            if (t.issues && ('schema' === e[i].kind || 'transformation' === e[i].kind)) {
              t.typed = !1;
              break;
            }
            (t.issues && (n.abortEarly || n.abortPipeEarly)) || (t = e[i]._run(t, n));
          }
          return t;
        },
      };
    }
    function c0(e) {
      return cJ(
        cY(Object.entries(e).map(([e, t]) => cW({ [e]: t }))),
        cP((e) => ({ ...e, $kind: Object.keys(e)[0] }))
      );
    }
    e.s(
      [
        'array',
        () => cD,
        'bigint',
        () => cB,
        'boolean',
        () => cU,
        'check',
        () => cR,
        'integer',
        () => cM,
        'is',
        () => c_,
        'lazy',
        () => cF,
        'literal',
        () => cL,
        'nullable',
        () => cz,
        'nullish',
        () => cV,
        'number',
        () => c$,
        'object',
        () => cW,
        'optional',
        () => cq,
        'parse',
        () => cX,
        'pipe',
        () => cJ,
        'record',
        () => cK,
        'string',
        () => cG,
        'transform',
        () => cP,
        'tuple',
        () => cH,
        'union',
        () => cY,
        'unknown',
        () => cQ,
      ],
      43240
    );
    let c1 = cJ(
        cG(),
        cP((e) => ie(e)),
        cR(n7)
      ),
      c5 = cG(),
      c2 = cJ(
        cY([cG(), cJ(c$(), cM())]),
        cR((e) => {
          try {
            return BigInt(e), BigInt(e) >= 0 && 0xffffffffffffffffn >= BigInt(e);
          } catch {
            return !1;
          }
        }, 'Invalid u64')
      ),
      c6 = cW({ objectId: c1, version: c2, digest: cG() }),
      c3 = cJ(
        cY([
          cW({ GasCoin: cL(!0) }),
          cW({ Input: cJ(c$(), cM()), type: cq(cL('pure')) }),
          cW({ Input: cJ(c$(), cM()), type: cq(cL('object')) }),
          cW({ Result: cJ(c$(), cM()) }),
          cW({ NestedResult: cH([cJ(c$(), cM()), cJ(c$(), cM())]) }),
        ]),
        cP((e) => ({ ...e, $kind: Object.keys(e)[0] }))
      ),
      c4 = cW({ budget: cz(c2), price: cz(c2), owner: cz(c1), payment: cz(cD(c6)) });
    cW({ address: cG(), module: cG(), name: cG(), typeParams: cD(cG()) });
    let c8 = cY([
        cL('address'),
        cL('bool'),
        cL('u8'),
        cL('u16'),
        cL('u32'),
        cL('u64'),
        cL('u128'),
        cL('u256'),
        cW({ vector: cF(() => c8) }),
        cW({
          datatype: cW({
            package: cG(),
            module: cG(),
            type: cG(),
            typeParameters: cD(cF(() => c8)),
          }),
        }),
        cW({ typeParameter: cJ(c$(), cM()) }),
      ]),
      c9 = cW({ ref: cz(cY([cL('&'), cL('&mut')])), body: c8 }),
      c7 = cW({
        package: c1,
        module: cG(),
        function: cG(),
        typeArguments: cD(cG()),
        arguments: cD(c3),
        _argumentTypes: cq(cz(cD(c9))),
      }),
      de = cW({ name: cG(), inputs: cK(cG(), cY([c3, cD(c3)])), data: cK(cG(), cQ()) }),
      dt = c0({
        MoveCall: c7,
        TransferObjects: cW({ objects: cD(c3), address: c3 }),
        SplitCoins: cW({ coin: c3, amounts: cD(c3) }),
        MergeCoins: cW({ destination: c3, sources: cD(c3) }),
        Publish: cW({ modules: cD(c5), dependencies: cD(c1) }),
        MakeMoveVec: cW({ type: cz(cG()), elements: cD(c3) }),
        Upgrade: cW({ modules: cD(c5), dependencies: cD(c1), package: c1, ticket: c3 }),
        $Intent: de,
      }),
      dr = c0({
        ImmOrOwnedObject: c6,
        SharedObject: cW({ objectId: c1, initialSharedVersion: c2, mutable: cU() }),
        Receiving: c6,
      }),
      dn = c0({
        Object: dr,
        Pure: cW({ bytes: c5 }),
        UnresolvedPure: cW({ value: cQ() }),
        UnresolvedObject: cW({
          objectId: c1,
          version: cq(cz(c2)),
          digest: cq(cz(cG())),
          initialSharedVersion: cq(cz(c2)),
        }),
      }),
      di = c0({ Object: dr, Pure: cW({ bytes: c5 }) }),
      da = c0({ None: cL(!0), Epoch: c2 }),
      ds = cW({
        version: cL(2),
        sender: cV(c1),
        expiration: cV(da),
        gasData: c4,
        inputs: cD(dn),
        commands: cD(dt),
      });
    var dl =
      (((L = dl || {})[(L.COMPATIBLE = 0)] = 'COMPATIBLE'),
      (L[(L.ADDITIVE = 128)] = 'ADDITIVE'),
      (L[(L.DEP_ONLY = 192)] = 'DEP_ONLY'),
      L);
    let du = {
        MoveCall(e) {
          let [t, n = '', i = ''] =
            'target' in e ? e.target.split('::') : [e.package, e.module, e.function];
          return {
            $kind: 'MoveCall',
            MoveCall: {
              package: t,
              module: n,
              function: i,
              typeArguments: e.typeArguments ?? [],
              arguments: e.arguments ?? [],
            },
          };
        },
        TransferObjects: (e, t) => ({
          $kind: 'TransferObjects',
          TransferObjects: { objects: e.map((e) => cX(c3, e)), address: cX(c3, t) },
        }),
        SplitCoins: (e, t) => ({
          $kind: 'SplitCoins',
          SplitCoins: { coin: cX(c3, e), amounts: t.map((e) => cX(c3, e)) },
        }),
        MergeCoins: (e, t) => ({
          $kind: 'MergeCoins',
          MergeCoins: { destination: cX(c3, e), sources: t.map((e) => cX(c3, e)) },
        }),
        Publish: ({ modules: e, dependencies: t }) => ({
          $kind: 'Publish',
          Publish: {
            modules: e.map((e) => ('string' == typeof e ? e : n3(new Uint8Array(e)))),
            dependencies: t.map((e) => it(e)),
          },
        }),
        Upgrade: ({ modules: e, dependencies: t, package: n, ticket: i }) => ({
          $kind: 'Upgrade',
          Upgrade: {
            modules: e.map((e) => ('string' == typeof e ? e : n3(new Uint8Array(e)))),
            dependencies: t.map((e) => it(e)),
            package: n,
            ticket: cX(c3, i),
          },
        }),
        MakeMoveVec: ({ type: e, elements: t }) => ({
          $kind: 'MakeMoveVec',
          MakeMoveVec: { type: e ?? null, elements: t.map((e) => cX(c3, e)) },
        }),
        Intent: ({ name: e, inputs: t = {}, data: n = {} }) => ({
          $kind: '$Intent',
          $Intent: {
            name: e,
            inputs: Object.fromEntries(
              Object.entries(t).map(([e, t]) => [
                e,
                Array.isArray(t) ? t.map((e) => cX(c3, e)) : cX(c3, t),
              ])
            ),
            data: n,
          },
        }),
      },
      dc = /^vector<(.+)>$/,
      dd = /^([^:]+)::([^:]+)::([^<]+)(<(.+)>)?/;
    class df {
      static parseFromStr(e, t = !1) {
        if ('address' === e) return { address: null };
        if ('bool' === e) return { bool: null };
        if ('u8' === e) return { u8: null };
        if ('u16' === e) return { u16: null };
        if ('u32' === e) return { u32: null };
        else if ('u64' === e) return { u64: null };
        else if ('u128' === e) return { u128: null };
        else if ('u256' === e) return { u256: null };
        else if ('signer' === e) return { signer: null };
        let n = e.match(dc);
        if (n) return { vector: df.parseFromStr(n[1], t) };
        let i = e.match(dd);
        if (i)
          return {
            struct: {
              address: t ? ie(i[1]) : i[1],
              module: i[2],
              name: i[3],
              typeParams: void 0 === i[5] ? [] : df.parseStructTypeArgs(i[5], t),
            },
          };
        throw Error(`Encountered unexpected token when parsing type args for ${e}`);
      }
      static parseStructTypeArgs(e, t = !1) {
        return (function (e, t = ['<', '>']) {
          let [n, i] = t,
            a = [],
            o = '',
            s = 0;
          for (let t = 0; t < e.length; t++) {
            let l = e[t];
            if ((l === n && s++, l === i && s--, 0 === s && ',' === l)) {
              a.push(o.trim()), (o = '');
              continue;
            }
            o += l;
          }
          return a.push(o.trim()), a;
        })(e).map((e) => df.parseFromStr(e, t));
      }
      static tagToString(e) {
        if ('bool' in e) return 'bool';
        if ('u8' in e) return 'u8';
        if ('u16' in e) return 'u16';
        if ('u32' in e) return 'u32';
        if ('u64' in e) return 'u64';
        if ('u128' in e) return 'u128';
        if ('u256' in e) return 'u256';
        if ('address' in e) return 'address';
        if ('signer' in e) return 'signer';
        if ('vector' in e) return `vector<${df.tagToString(e.vector)}>`;
        if ('struct' in e) {
          let t = e.struct,
            n = t.typeParams.map(df.tagToString).join(', ');
          return `${t.address}::${t.module}::${t.name}${n ? `<${n}>` : ''}`;
        }
        throw Error('Invalid TypeTag');
      }
    }
    let dh = cW({ digest: cG(), objectId: cG(), version: cY([cJ(c$(), cM()), cG(), cB()]) }),
      dp = c0({
        ImmOrOwned: dh,
        Shared: cW({ objectId: c1, initialSharedVersion: c2, mutable: cU() }),
        Receiving: dh,
      }),
      dm = c0({ Object: dp, Pure: cD(cJ(c$(), cM())) }),
      dg = cY([
        cW({ kind: cL('Input'), index: cJ(c$(), cM()), value: cQ(), type: cq(cL('object')) }),
        cW({ kind: cL('Input'), index: cJ(c$(), cM()), value: cQ(), type: cL('pure') }),
      ]),
      dy = cY([cW({ Epoch: cJ(c$(), cM()) }), cW({ None: cz(cL(!0)) })]),
      db = cJ(
        cY([c$(), cG(), cB()]),
        cR((e) => {
          if (!['string', 'number', 'bigint'].includes(typeof e)) return !1;
          try {
            return BigInt(e), !0;
          } catch {
            return !1;
          }
        })
      ),
      dv = cY([
        cW({ bool: cz(cL(!0)) }),
        cW({ u8: cz(cL(!0)) }),
        cW({ u64: cz(cL(!0)) }),
        cW({ u128: cz(cL(!0)) }),
        cW({ address: cz(cL(!0)) }),
        cW({ signer: cz(cL(!0)) }),
        cW({ vector: cF(() => dv) }),
        cW({ struct: cF(() => dw) }),
        cW({ u16: cz(cL(!0)) }),
        cW({ u32: cz(cL(!0)) }),
        cW({ u256: cz(cL(!0)) }),
      ]),
      dw = cW({ address: cG(), module: cG(), name: cG(), typeParams: cD(dv) }),
      dx = cW({ budget: cq(db), price: cq(db), payment: cq(cD(dh)), owner: cq(cG()) }),
      dE = cY([
        dg,
        cW({ kind: cL('GasCoin') }),
        cW({ kind: cL('Result'), index: cJ(c$(), cM()) }),
        cW({ kind: cL('NestedResult'), index: cJ(c$(), cM()), resultIndex: cJ(c$(), cM()) }),
      ]),
      dS = cW({
        kind: cL('MoveCall'),
        target: cJ(
          cG(),
          cR((e) => 3 === e.split('::').length)
        ),
        typeArguments: cD(cG()),
        arguments: cD(dE),
      }),
      dC = cW({ kind: cL('TransferObjects'), objects: cD(dE), address: dE }),
      dk = cW({ kind: cL('SplitCoins'), coin: dE, amounts: cD(dE) }),
      dO = cW({ kind: cL('MergeCoins'), destination: dE, sources: cD(dE) }),
      dA = cW({
        kind: cL('MakeMoveVec'),
        type: cY([cW({ Some: dv }), cW({ None: cz(cL(!0)) })]),
        objects: cD(dE),
      }),
      dI = cY([
        dS,
        dC,
        dk,
        dO,
        cW({ kind: cL('Publish'), modules: cD(cD(cJ(c$(), cM()))), dependencies: cD(cG()) }),
        cW({
          kind: cL('Upgrade'),
          modules: cD(cD(cJ(c$(), cM()))),
          dependencies: cD(cG()),
          packageId: cG(),
          ticket: dE,
        }),
        dA,
      ]);
    function dj(e) {
      let t = e.inputs.map((e, t) => {
        if (e.Object)
          return {
            kind: 'Input',
            index: t,
            value: {
              Object: e.Object.ImmOrOwnedObject
                ? { ImmOrOwned: e.Object.ImmOrOwnedObject }
                : e.Object.Receiving
                ? {
                    Receiving: {
                      digest: e.Object.Receiving.digest,
                      version: e.Object.Receiving.version,
                      objectId: e.Object.Receiving.objectId,
                    },
                  }
                : {
                    Shared: {
                      mutable: e.Object.SharedObject.mutable,
                      initialSharedVersion: e.Object.SharedObject.initialSharedVersion,
                      objectId: e.Object.SharedObject.objectId,
                    },
                  },
            },
            type: 'object',
          };
        if (e.Pure)
          return {
            kind: 'Input',
            index: t,
            value: { Pure: Array.from(n6(e.Pure.bytes)) },
            type: 'pure',
          };
        if (e.UnresolvedPure)
          return { kind: 'Input', type: 'pure', index: t, value: e.UnresolvedPure.value };
        if (e.UnresolvedObject)
          return { kind: 'Input', type: 'object', index: t, value: e.UnresolvedObject.objectId };
        throw Error('Invalid input');
      });
      return {
        version: 1,
        sender: e.sender ?? void 0,
        expiration:
          e.expiration?.$kind === 'Epoch'
            ? { Epoch: Number(e.expiration.Epoch) }
            : e.expiration
            ? { None: !0 }
            : null,
        gasConfig: {
          owner: e.gasData.owner ?? void 0,
          budget: e.gasData.budget ?? void 0,
          price: e.gasData.price ?? void 0,
          payment: e.gasData.payment ?? void 0,
        },
        inputs: t,
        transactions: e.commands.map((e) => {
          if (e.MakeMoveVec)
            return {
              kind: 'MakeMoveVec',
              type:
                null === e.MakeMoveVec.type
                  ? { None: !0 }
                  : { Some: df.parseFromStr(e.MakeMoveVec.type) },
              objects: e.MakeMoveVec.elements.map((e) => dT(e, t)),
            };
          if (e.MergeCoins)
            return {
              kind: 'MergeCoins',
              destination: dT(e.MergeCoins.destination, t),
              sources: e.MergeCoins.sources.map((e) => dT(e, t)),
            };
          if (e.MoveCall)
            return {
              kind: 'MoveCall',
              target: `${e.MoveCall.package}::${e.MoveCall.module}::${e.MoveCall.function}`,
              typeArguments: e.MoveCall.typeArguments,
              arguments: e.MoveCall.arguments.map((e) => dT(e, t)),
            };
          if (e.Publish)
            return {
              kind: 'Publish',
              modules: e.Publish.modules.map((e) => Array.from(n6(e))),
              dependencies: e.Publish.dependencies,
            };
          if (e.SplitCoins)
            return {
              kind: 'SplitCoins',
              coin: dT(e.SplitCoins.coin, t),
              amounts: e.SplitCoins.amounts.map((e) => dT(e, t)),
            };
          if (e.TransferObjects)
            return {
              kind: 'TransferObjects',
              objects: e.TransferObjects.objects.map((e) => dT(e, t)),
              address: dT(e.TransferObjects.address, t),
            };
          if (e.Upgrade)
            return {
              kind: 'Upgrade',
              modules: e.Upgrade.modules.map((e) => Array.from(n6(e))),
              dependencies: e.Upgrade.dependencies,
              packageId: e.Upgrade.package,
              ticket: dT(e.Upgrade.ticket, t),
            };
          throw Error(`Unknown transaction ${Object.keys(e)}`);
        }),
      };
    }
    function dT(e, t) {
      if ('GasCoin' === e.$kind) return { kind: 'GasCoin' };
      if ('Result' === e.$kind) return { kind: 'Result', index: e.Result };
      if ('NestedResult' === e.$kind)
        return { kind: 'NestedResult', index: e.NestedResult[0], resultIndex: e.NestedResult[1] };
      if ('Input' === e.$kind) return t[e.Input];
      throw Error(`Invalid argument ${Object.keys(e)}`);
    }
    function dR(e) {
      switch (e.kind) {
        case 'GasCoin':
          return { GasCoin: !0 };
        case 'Result':
          return { Result: e.index };
        case 'NestedResult':
          return { NestedResult: [e.index, e.resultIndex] };
        case 'Input':
          return { Input: e.index };
      }
    }
    function dM(e) {
      return cY(Object.entries(e).map(([e, t]) => cW({ [e]: t })));
    }
    cW({
      version: cL(1),
      sender: cq(cG()),
      expiration: cV(dy),
      gasConfig: dx,
      inputs: cD(dg),
      transactions: cD(dI),
    });
    let dP = dM({
        GasCoin: cL(!0),
        Input: cJ(c$(), cM()),
        Result: cJ(c$(), cM()),
        NestedResult: cH([cJ(c$(), cM()), cJ(c$(), cM())]),
      }),
      dN = cW({ budget: cz(c2), price: cz(c2), owner: cz(c1), payment: cz(cD(c6)) }),
      d_ = cW({
        package: c1,
        module: cG(),
        function: cG(),
        typeArguments: cD(cG()),
        arguments: cD(dP),
      }),
      dD = cW({ name: cG(), inputs: cK(cG(), cY([dP, cD(dP)])), data: cK(cG(), cQ()) }),
      dB = dM({
        MoveCall: d_,
        TransferObjects: cW({ objects: cD(dP), address: dP }),
        SplitCoins: cW({ coin: dP, amounts: cD(dP) }),
        MergeCoins: cW({ destination: dP, sources: cD(dP) }),
        Publish: cW({ modules: cD(c5), dependencies: cD(c1) }),
        MakeMoveVec: cW({ type: cz(cG()), elements: cD(dP) }),
        Upgrade: cW({ modules: cD(c5), dependencies: cD(c1), package: c1, ticket: dP }),
        $Intent: dD,
      }),
      dU = dM({
        ImmOrOwnedObject: c6,
        SharedObject: cW({ objectId: c1, initialSharedVersion: c2, mutable: cU() }),
        Receiving: c6,
      }),
      dF = dM({
        Object: dU,
        Pure: cW({ bytes: c5 }),
        UnresolvedPure: cW({ value: cQ() }),
        UnresolvedObject: cW({
          objectId: c1,
          version: cq(cz(c2)),
          digest: cq(cz(cG())),
          initialSharedVersion: cq(cz(c2)),
        }),
      }),
      dL = dM({ None: cL(!0), Epoch: c2 }),
      dz = cW({
        version: cL(2),
        sender: cV(c1),
        expiration: cV(dL),
        gasData: dN,
        inputs: cD(dF),
        commands: cD(dB),
      }),
      dV = function (e) {
        return { $kind: 'Pure', Pure: { bytes: e instanceof Uint8Array ? n3(e) : e.toBase64() } };
      },
      d$ = ({ objectId: e, digest: t, version: n }) => ({
        $kind: 'Object',
        Object: {
          $kind: 'ImmOrOwnedObject',
          ImmOrOwnedObject: { digest: t, version: n, objectId: ie(e) },
        },
      }),
      dW = ({ objectId: e, mutable: t, initialSharedVersion: n }) => ({
        $kind: 'Object',
        Object: {
          $kind: 'SharedObject',
          SharedObject: { mutable: t, initialSharedVersion: n, objectId: ie(e) },
        },
      }),
      dq = ({ objectId: e, digest: t, version: n }) => ({
        $kind: 'Object',
        Object: { $kind: 'Receiving', Receiving: { digest: t, version: n, objectId: ie(e) } },
      }),
      dK = {
        u8: (e) =>
          cO({
            name: 'u8',
            readMethod: 'read8',
            writeMethod: 'write8',
            size: 1,
            maxValue: 255,
            ...e,
          }),
        u16: (e) =>
          cO({
            name: 'u16',
            readMethod: 'read16',
            writeMethod: 'write16',
            size: 2,
            maxValue: 65535,
            ...e,
          }),
        u32: (e) =>
          cO({
            name: 'u32',
            readMethod: 'read32',
            writeMethod: 'write32',
            size: 4,
            maxValue: 0x100000000 - 1,
            ...e,
          }),
        u64: (e) =>
          cA({
            name: 'u64',
            readMethod: 'read64',
            writeMethod: 'write64',
            size: 8,
            maxValue: 2n ** 64n - 1n,
            ...e,
          }),
        u128: (e) =>
          cA({
            name: 'u128',
            readMethod: 'read128',
            writeMethod: 'write128',
            size: 16,
            maxValue: 2n ** 128n - 1n,
            ...e,
          }),
        u256: (e) =>
          cA({
            name: 'u256',
            readMethod: 'read256',
            writeMethod: 'write256',
            size: 32,
            maxValue: 2n ** 256n - 1n,
            ...e,
          }),
        bool: (e) =>
          ck({
            name: 'bool',
            size: 1,
            read: (e) => 1 === e.read8(),
            write: (e, t) => t.write8(+!!e),
            ...e,
            validate: (t) => {
              if ((e?.validate?.(t), 'boolean' != typeof t))
                throw TypeError(`Expected boolean, found ${typeof t}`);
            },
          }),
        uleb128: (e) =>
          (function ({ serialize: e, ...t }) {
            let n = new cx({
              ...t,
              serialize: e,
              write: (e, t) => {
                for (let i of n.serialize(e).toBytes()) t.write8(i);
              },
            });
            return n;
          })({
            name: 'uleb128',
            read: (e) => e.readULEB(),
            serialize: (e) => Uint8Array.from(cf(e)),
            ...e,
          }),
        bytes: (e, t) =>
          ck({
            name: `bytes[${e}]`,
            size: e,
            read: (t) => t.readBytes(e),
            write: (t, n) => {
              for (let i = 0; i < e; i++) n.write8(t[i] ?? 0);
            },
            ...t,
            validate: (n) => {
              if ((t?.validate?.(n), !n || 'object' != typeof n || !('length' in n)))
                throw TypeError(`Expected array, found ${typeof n}`);
              if (n.length !== e)
                throw TypeError(`Expected array of length ${e}, found ${n.length}`);
            },
          }),
        byteVector: (e) =>
          new cx({
            name: 'bytesVector',
            read: (e) => {
              let t = e.readULEB();
              return e.readBytes(t);
            },
            write: (e, t) => {
              let n = new Uint8Array(e);
              t.writeULEB(n.length);
              for (let e = 0; e < n.length; e++) t.write8(n[e] ?? 0);
            },
            ...e,
            serializedSize: (e) => {
              let t = 'length' in e ? e.length : null;
              return null == t ? null : cf(t).length + t;
            },
            validate: (t) => {
              if ((e?.validate?.(t), !t || 'object' != typeof t || !('length' in t)))
                throw TypeError(`Expected array, found ${typeof t}`);
            },
          }),
        string: (e) =>
          (function ({ toBytes: e, fromBytes: t, ...n }) {
            return new cx({
              ...n,
              read: (e) => {
                let n = e.readULEB();
                return t(e.readBytes(n));
              },
              write: (t, n) => {
                let i = e(t);
                n.writeULEB(i.length);
                for (let e = 0; e < i.length; e++) n.write8(i[e]);
              },
              serialize: (t) => {
                let n = e(t),
                  i = cf(n.length),
                  a = new Uint8Array(i.length + n.length);
                return a.set(i, 0), a.set(n, i.length), a;
              },
              validate: (e) => {
                if ('string' != typeof e)
                  throw TypeError(`Invalid ${n.name} value: ${e}. Expected string`);
                n.validate?.(e);
              },
            });
          })({
            name: 'string',
            toBytes: (e) => new TextEncoder().encode(e),
            fromBytes: (e) => new TextDecoder().decode(e),
            ...e,
          }),
        fixedArray: (e, t, n) =>
          new cx({
            name: `${t.name}[${e}]`,
            read: (n) => {
              let i = Array(e);
              for (let a = 0; a < e; a++) i[a] = t.read(n);
              return i;
            },
            write: (e, n) => {
              for (let i of e) t.write(i, n);
            },
            ...n,
            validate: (t) => {
              if ((n?.validate?.(t), !t || 'object' != typeof t || !('length' in t)))
                throw TypeError(`Expected array, found ${typeof t}`);
              if (t.length !== e)
                throw TypeError(`Expected array of length ${e}, found ${t.length}`);
            },
          }),
        option: (e) =>
          dK
            .enum(`Option<${e.name}>`, { None: null, Some: e })
            .transform({
              input: (e) => (null == e ? { None: !0 } : { Some: e }),
              output: (e) => ('Some' === e.$kind ? e.Some : null),
            }),
        vector: (e, t) =>
          new cx({
            name: `vector<${e.name}>`,
            read: (t) => {
              let n = t.readULEB(),
                i = Array(n);
              for (let a = 0; a < n; a++) i[a] = e.read(t);
              return i;
            },
            write: (t, n) => {
              for (let i of (n.writeULEB(t.length), t)) e.write(i, n);
            },
            ...t,
            validate: (e) => {
              if ((t?.validate?.(e), !e || 'object' != typeof e || !('length' in e)))
                throw TypeError(`Expected array, found ${typeof e}`);
            },
          }),
        tuple: (e, t) =>
          new cx({
            name: `(${e.map((e) => e.name).join(', ')})`,
            serializedSize: (t) => {
              let n = 0;
              for (let i = 0; i < e.length; i++) {
                let a = e[i].serializedSize(t[i]);
                if (null == a) return null;
                n += a;
              }
              return n;
            },
            read: (t) => {
              let n = [];
              for (let i of e) n.push(i.read(t));
              return n;
            },
            write: (t, n) => {
              for (let i = 0; i < e.length; i++) e[i].write(t[i], n);
            },
            ...t,
            validate: (n) => {
              if ((t?.validate?.(n), !Array.isArray(n)))
                throw TypeError(`Expected array, found ${typeof n}`);
              if (n.length !== e.length)
                throw TypeError(`Expected array of length ${e.length}, found ${n.length}`);
            },
          }),
        struct(e, t, n) {
          let i = Object.entries(t);
          return new cx({
            name: e,
            serializedSize: (e) => {
              let t = 0;
              for (let [n, a] of i) {
                let i = a.serializedSize(e[n]);
                if (null == i) return null;
                t += i;
              }
              return t;
            },
            read: (e) => {
              let t = {};
              for (let [n, a] of i) t[n] = a.read(e);
              return t;
            },
            write: (e, t) => {
              for (let [n, a] of i) a.write(e[n], t);
            },
            ...n,
            validate: (e) => {
              if ((n?.validate?.(e), 'object' != typeof e || null == e))
                throw TypeError(`Expected object, found ${typeof e}`);
            },
          });
        },
        enum(e, t, n) {
          let i = Object.entries(t);
          return new cx({
            name: e,
            read: (t) => {
              let n = t.readULEB(),
                a = i[n];
              if (!a) throw TypeError(`Unknown value ${n} for enum ${e}`);
              let [o, s] = a;
              return { [o]: s?.read(t) ?? !0, $kind: o };
            },
            write: (e, n) => {
              let [a, o] = Object.entries(e).filter(([e]) => Object.hasOwn(t, e))[0];
              for (let e = 0; e < i.length; e++) {
                let [t, s] = i[e];
                if (t === a) {
                  n.writeULEB(e), s?.write(o, n);
                  return;
                }
              }
            },
            ...n,
            validate: (i) => {
              if ((n?.validate?.(i), 'object' != typeof i || null == i))
                throw TypeError(`Expected object, found ${typeof i}`);
              let a = Object.keys(i).filter((e) => void 0 !== i[e] && Object.hasOwn(t, e));
              if (1 !== a.length)
                throw TypeError(
                  `Expected object with one key, but found ${a.length} for type ${e}}`
                );
              let [o] = a;
              if (!Object.hasOwn(t, o)) throw TypeError(`Invalid enum variant ${o}`);
            },
          });
        },
        map: (e, t) =>
          dK.vector(dK.tuple([e, t])).transform({
            name: `Map<${e.name}, ${t.name}>`,
            input: (e) => [...e.entries()],
            output: (e) => {
              let t = new Map();
              for (let [n, i] of e) t.set(n, i);
              return t;
            },
          }),
        lazy: (e) =>
          (function (e) {
            let t = null;
            function n() {
              return t || (t = e()), t;
            }
            return new cx({
              name: 'lazy',
              read: (e) => n().read(e),
              serializedSize: (e) => n().serializedSize(e),
              write: (e, t) => n().write(e, t),
              serialize: (e, t) => n().serialize(e, t).toBytes(),
            });
          })(e),
      },
      dG = dK.bytes(32).transform({
        validate: (e) => {
          let t = 'string' == typeof e ? e : n8(e);
          if (!t || !n7(ie(t))) throw Error(`Invalid IOTA address ${t}`);
        },
        input: (e) => ('string' == typeof e ? n4(ie(e)) : e),
        output: (e) => ie(n8(e)),
      }),
      dH = dK.vector(dK.u8()).transform({
        name: 'ObjectDigest',
        input: (e) => {
          let t;
          return (t = e), n2.decode(t);
        },
        output: (e) => {
          let t;
          return (t = new Uint8Array(e)), n2.encode(t);
        },
        validate: (e) => {
          let t;
          if (32 !== ((t = e), n2.decode(t)).length) throw Error('ObjectDigest must be 32 bytes');
        },
      }),
      dZ = dK.struct('IotaObjectRef', { objectId: dG, version: dK.u64(), digest: dH }),
      dY = dK.struct('SharedObjectRef', {
        objectId: dG,
        initialSharedVersion: dK.u64(),
        mutable: dK.bool(),
      }),
      dQ = dK.enum('ObjectArg', { ImmOrOwnedObject: dZ, SharedObject: dY, Receiving: dZ }),
      dX = dK.enum('Owner', {
        AddressOwner: dG,
        ObjectOwner: dG,
        Shared: dK.struct('Shared', { initialSharedVersion: dK.u64() }),
        Immutable: null,
      }),
      dJ = dK.enum('CallArg', {
        Pure: dK.struct('Pure', {
          bytes: dK
            .vector(dK.u8())
            .transform({
              input: (e) => ('string' == typeof e ? n6(e) : e),
              output: (e) => n3(new Uint8Array(e)),
            }),
        }),
        Object: dQ,
      }),
      d0 = dK.enum('TypeTag', {
        bool: null,
        u8: null,
        u64: null,
        u128: null,
        address: null,
        signer: null,
        vector: dK.lazy(() => d0),
        struct: dK.lazy(() => d9),
        u16: null,
        u32: null,
        u256: null,
      }),
      d1 = d0.transform({
        input: (e) => ('string' == typeof e ? df.parseFromStr(e, !0) : e),
        output: (e) => df.tagToString(e),
      }),
      d5 = dK.enum('Argument', {
        GasCoin: null,
        Input: dK.u16(),
        Result: dK.u16(),
        NestedResult: dK.tuple([dK.u16(), dK.u16()]),
      }),
      d2 = dK.struct('ProgrammableMoveCall', {
        package: dG,
        module: dK.string(),
        function: dK.string(),
        typeArguments: dK.vector(d1),
        arguments: dK.vector(d5),
      }),
      d6 = dK.enum('Command', {
        MoveCall: d2,
        TransferObjects: dK.struct('TransferObjects', { objects: dK.vector(d5), address: d5 }),
        SplitCoins: dK.struct('SplitCoins', { coin: d5, amounts: dK.vector(d5) }),
        MergeCoins: dK.struct('MergeCoins', { destination: d5, sources: dK.vector(d5) }),
        Publish: dK.struct('Publish', {
          modules: dK.vector(
            dK
              .vector(dK.u8())
              .transform({
                input: (e) => ('string' == typeof e ? n6(e) : e),
                output: (e) => n3(new Uint8Array(e)),
              })
          ),
          dependencies: dK.vector(dG),
        }),
        MakeMoveVec: dK.struct('MakeMoveVec', {
          type: dK
            .enum('Option', { None: null, Some: d1 })
            .transform({
              input: (e) => (null === e ? { None: !0 } : { Some: e }),
              output: (e) => e.Some ?? null,
            }),
          elements: dK.vector(d5),
        }),
        Upgrade: dK.struct('Upgrade', {
          modules: dK.vector(
            dK
              .vector(dK.u8())
              .transform({
                input: (e) => ('string' == typeof e ? n6(e) : e),
                output: (e) => n3(new Uint8Array(e)),
              })
          ),
          dependencies: dK.vector(dG),
          package: dG,
          ticket: d5,
        }),
      }),
      d3 = dK.struct('ProgrammableTransaction', { inputs: dK.vector(dJ), commands: dK.vector(d6) }),
      d4 = dK.enum('TransactionKind', {
        ProgrammableTransaction: d3,
        ChangeEpoch: null,
        Genesis: null,
        ConsensusCommitPrologue: null,
      }),
      d8 = dK.enum('TransactionExpiration', {
        None: null,
        Epoch: dK
          .u64({ name: 'unsafe_u64', ...void 0 })
          .transform({ input: (e) => e, output: (e) => Number(e) }),
      }),
      d9 = dK.struct('StructTag', {
        address: dG,
        module: dK.string(),
        name: dK.string(),
        typeParams: dK.vector(d0),
      }),
      d7 = dK.struct('GasData', {
        payment: dK.vector(dZ),
        owner: dG,
        price: dK.u64(),
        budget: dK.u64(),
      }),
      fe = dK.struct('TransactionDataV1', { kind: d4, sender: dG, gasData: d7, expiration: d8 }),
      ft = dK.enum('TransactionData', { V1: fe }),
      fr = dK.enum('IntentScope', {
        TransactionData: null,
        TransactionEffects: null,
        CheckpointSummary: null,
        PersonalMessage: null,
      }),
      fn = dK.enum('IntentVersion', { V0: null }),
      fi = dK.enum('AppId', { Iota: null }),
      fa = dK.struct('Intent', { scope: fr, version: fn, appId: fi });
    function fo(e) {
      return dK.struct(`IntentMessage<${e.name}>`, { intent: fa, value: e });
    }
    let fs = dK.enum('CompressedSignature', {
        ED25519: dK.fixedArray(64, dK.u8()),
        Secp256k1: dK.fixedArray(64, dK.u8()),
        Secp256r1: dK.fixedArray(64, dK.u8()),
      }),
      fl = dK.enum('PublicKey', {
        ED25519: dK.fixedArray(32, dK.u8()),
        Secp256k1: dK.fixedArray(33, dK.u8()),
        Secp256r1: dK.fixedArray(33, dK.u8()),
      }),
      fu = dK.struct('MultiSigPkMap', { pubKey: fl, weight: dK.u8() }),
      fc = dK.struct('MultiSigPublicKey', { pk_map: dK.vector(fu), threshold: dK.u16() }),
      fd = dK.struct('MultiSig', { sigs: dK.vector(fs), bitmap: dK.u16(), multisig_pk: fc }),
      ff = dK
        .vector(dK.u8())
        .transform({
          input: (e) => ('string' == typeof e ? n6(e) : e),
          output: (e) => n3(new Uint8Array(e)),
        }),
      fh = dK.struct('SenderSignedTransaction', {
        intentMessage: fo(ft),
        txSignatures: dK.vector(ff),
      }),
      fp = dK.vector(fh, { name: 'SenderSignedData' }),
      fm = dK.struct('PasskeyAuthenticator', {
        authenticatorData: dK.vector(dK.u8()),
        clientDataJson: dK.string(),
        userSignature: dK.vector(dK.u8()),
      }),
      fg = dK.enum('PackageUpgradeError', {
        UnableToFetchPackage: dK.struct('UnableToFetchPackage', { packageId: dG }),
        NotAPackage: dK.struct('NotAPackage', { objectId: dG }),
        IncompatibleUpgrade: null,
        DigestDoesNotMatch: dK.struct('DigestDoesNotMatch', { digest: dK.vector(dK.u8()) }),
        UnknownUpgradePolicy: dK.struct('UnknownUpgradePolicy', { policy: dK.u8() }),
        PackageIDDoesNotMatch: dK.struct('PackageIDDoesNotMatch', { packageId: dG, ticketId: dG }),
      }),
      fy = dK.struct('ModuleId', { address: dG, name: dK.string() }),
      fb = dK.struct('MoveLocation', {
        module: fy,
        function: dK.u16(),
        instruction: dK.u16(),
        functionName: dK.option(dK.string()),
      }),
      fv = dK.enum('CommandArgumentError', {
        TypeMismatch: null,
        InvalidBCSBytes: null,
        InvalidUsageOfPureArg: null,
        InvalidArgumentToPrivateEntryFunction: null,
        IndexOutOfBounds: dK.struct('IndexOutOfBounds', { idx: dK.u16() }),
        SecondaryIndexOutOfBounds: dK.struct('SecondaryIndexOutOfBounds', {
          resultIdx: dK.u16(),
          secondaryIdx: dK.u16(),
        }),
        InvalidResultArity: dK.struct('InvalidResultArity', { resultIdx: dK.u16() }),
        InvalidGasCoinUsage: null,
        InvalidValueUsage: null,
        InvalidObjectByValue: null,
        InvalidObjectByMutRef: null,
        SharedObjectOperationNotAllowed: null,
      }),
      fw = dK.enum('TypeArgumentError', { TypeNotFound: null, ConstraintNotSatisfied: null }),
      fx = dK.enum('ExecutionFailureStatus', {
        InsufficientGas: null,
        InvalidGasObject: null,
        InvariantViolation: null,
        FeatureNotYetSupported: null,
        MoveObjectTooBig: dK.struct('MoveObjectTooBig', {
          objectSize: dK.u64(),
          maxObjectSize: dK.u64(),
        }),
        MovePackageTooBig: dK.struct('MovePackageTooBig', {
          objectSize: dK.u64(),
          maxObjectSize: dK.u64(),
        }),
        CircularObjectOwnership: dK.struct('CircularObjectOwnership', { object: dG }),
        InsufficientCoinBalance: null,
        CoinBalanceOverflow: null,
        PublishErrorNonZeroAddress: null,
        IotaMoveVerificationError: null,
        MovePrimitiveRuntimeError: dK.option(fb),
        MoveAbort: dK.tuple([fb, dK.u64()]),
        VMVerificationOrDeserializationError: null,
        VMInvariantViolation: null,
        FunctionNotFound: null,
        ArityMismatch: null,
        TypeArityMismatch: null,
        NonEntryFunctionInvoked: null,
        CommandArgumentError: dK.struct('CommandArgumentError', { argIdx: dK.u16(), kind: fv }),
        TypeArgumentError: dK.struct('TypeArgumentError', { argumentIdx: dK.u16(), kind: fw }),
        UnusedValueWithoutDrop: dK.struct('UnusedValueWithoutDrop', {
          resultIdx: dK.u16(),
          secondaryIdx: dK.u16(),
        }),
        InvalidPublicFunctionReturnType: dK.struct('InvalidPublicFunctionReturnType', {
          idx: dK.u16(),
        }),
        InvalidTransferObject: null,
        EffectsTooLarge: dK.struct('EffectsTooLarge', { currentSize: dK.u64(), maxSize: dK.u64() }),
        PublishUpgradeMissingDependency: null,
        PublishUpgradeDependencyDowngrade: null,
        PackageUpgradeError: dK.struct('PackageUpgradeError', { upgradeError: fg }),
        WrittenObjectsTooLarge: dK.struct('WrittenObjectsTooLarge', {
          currentSize: dK.u64(),
          maxSize: dK.u64(),
        }),
        CertificateDenied: null,
        IotaMoveVerificationTimedout: null,
        SharedObjectOperationNotAllowed: null,
        InputObjectDeleted: null,
        ExecutionCancelledDueToSharedObjectCongestion: dK.struct(
          'ExecutionCancelledDueToSharedObjectCongestion',
          { congestedObjects: dK.vector(dG) }
        ),
        AddressDeniedForCoin: dK.struct('AddressDeniedForCoin', {
          address: dG,
          coinType: dK.string(),
        }),
        CoinTypeGlobalPause: dK.struct('CoinTypeGlobalPause', { coinType: dK.string() }),
        ExecutionCancelledDueToRandomnessUnavailable: null,
      }),
      fE = dK.enum('ExecutionStatus', {
        Success: null,
        Failed: dK.struct('ExecutionFailed', { error: fx, command: dK.option(dK.u64()) }),
      }),
      fS = dK.struct('GasCostSummary', {
        computationCost: dK.u64(),
        computationCostBurned: dK.u64(),
        storageCost: dK.u64(),
        storageRebate: dK.u64(),
        nonRefundableStorageFee: dK.u64(),
      }),
      fC = dK.tuple([dK.u64(), dH]),
      fk = dK.enum('ObjectIn', { NotExist: null, Exist: dK.tuple([fC, dX]) }),
      fO = dK.enum('ObjectOut', {
        NotExist: null,
        ObjectWrite: dK.tuple([dH, dX]),
        PackageWrite: fC,
      }),
      fA = dK.enum('IDOperation', { None: null, Created: null, Deleted: null }),
      fI = dK.struct('EffectsObjectChange', { inputState: fk, outputState: fO, idOperation: fA }),
      fj = dK.enum('UnchangedSharedKind', {
        ReadOnlyRoot: fC,
        MutateDeleted: dK.u64(),
        ReadDeleted: dK.u64(),
        Cancelled: dK.u64(),
        PerEpochConfig: null,
      }),
      fT = dK.struct('TransactionEffectsV1', {
        status: fE,
        executedEpoch: dK.u64(),
        gasUsed: fS,
        transactionDigest: dH,
        gasObjectIndex: dK.option(dK.u32()),
        eventsDigest: dK.option(dH),
        dependencies: dK.vector(dH),
        lamportVersion: dK.u64(),
        changedObjects: dK.vector(dK.tuple([dG, fI])),
        unchangedSharedObjects: dK.vector(dK.tuple([dG, fj])),
        auxDataDigest: dK.option(dH),
      }),
      fR = dK.enum('TransactionEffects', { V1: fT }),
      fM = {
        ...dK,
        U8: dK.u8(),
        U16: dK.u16(),
        U32: dK.u32(),
        U64: dK.u64(),
        U128: dK.u128(),
        U256: dK.u256(),
        ULEB128: dK.uleb128(),
        Bool: dK.bool(),
        String: dK.string(),
        Address: dG,
        AppId: fi,
        Argument: d5,
        CallArg: dJ,
        CompressedSignature: fs,
        GasData: d7,
        Intent: fa,
        IntentMessage: fo,
        IntentScope: fr,
        IntentVersion: fn,
        MultiSig: fd,
        MultiSigPkMap: fu,
        MultiSigPublicKey: fc,
        ObjectArg: dQ,
        ObjectDigest: dH,
        Owner: dX,
        ProgrammableMoveCall: d2,
        ProgrammableTransaction: d3,
        PublicKey: fl,
        SenderSignedData: fp,
        SenderSignedTransaction: fh,
        SharedObjectRef: dY,
        StructTag: d9,
        IotaObjectRef: dZ,
        Command: d6,
        TransactionData: ft,
        TransactionDataV1: fe,
        TransactionExpiration: d8,
        TransactionKind: d4,
        TypeTag: d1,
        TransactionEffects: fR,
        PasskeyAuthenticator: fm,
      };
    BigInt(1e9), it('0x6');
    function fP(e) {
      if ('string' == typeof e)
        switch (e) {
          case 'Address':
            return 'address';
          case 'Bool':
            return 'bool';
          case 'U8':
            return 'u8';
          case 'U16':
            return 'u16';
          case 'U32':
            return 'u32';
          case 'U64':
            return 'u64';
          case 'U128':
            return 'u128';
          case 'U256':
            return 'u256';
          default:
            throw Error(`Unexpected type ${e}`);
        }
      if ('Vector' in e) return { vector: fP(e.Vector) };
      if ('Struct' in e)
        return {
          datatype: {
            package: e.Struct.address,
            module: e.Struct.module,
            type: e.Struct.name,
            typeParameters: e.Struct.typeArguments.map(fP),
          },
        };
      if ('TypeParameter' in e) return { typeParameter: e.TypeParameter };
      throw Error(`Unexpected type ${JSON.stringify(e)}`);
    }
    async function fN(e, t, n) {
      return (
        await fF(e, t),
        await fU(e, t),
        t.onlyTransactionKind || (await f_(e, t), await fD(e, t), await fB(e, t)),
        await void e.inputs.forEach((e, t) => {
          if ('Object' !== e.$kind && 'Pure' !== e.$kind)
            throw Error(
              `Input at index ${t} has not been resolved.  Expected a Pure or Object input, but found ${JSON.stringify(
                e
              )}`
            );
        }),
        await n()
      );
    }
    async function f_(e, t) {
      e.gasConfig.price || (e.gasConfig.price = String(await fz(t).getReferenceGasPrice()));
    }
    async function fD(e, t) {
      if (e.gasConfig.budget) return;
      let n = await fz(t).dryRunTransactionBlock({
        transactionBlock: e.build({
          overrides: { gasData: { budget: String(5e10), payment: [] } },
        }),
      });
      if ('success' !== n.effects.status.status)
        throw Error(
          `Dry run failed, could not automatically determine a budget: ${n.effects.status.error}`,
          { cause: n }
        );
      let i = 1000n * BigInt(e.gasConfig.price || 1n),
        a = BigInt(n.effects.gasUsed.computationCost) + i,
        o = a + BigInt(n.effects.gasUsed.storageCost) - BigInt(n.effects.gasUsed.storageRebate);
      e.gasConfig.budget = String(o > a ? o : a);
    }
    async function fB(e, t) {
      if (!e.gasConfig.payment) {
        let n = (
          await fz(t).getCoins({
            owner: e.gasConfig.owner || e.sender,
            coinType: '0x2::iota::IOTA',
          })
        ).data
          .filter(
            (t) =>
              !e.inputs.find(
                (e) =>
                  !!e.Object?.ImmOrOwnedObject &&
                  t.coinObjectId === e.Object.ImmOrOwnedObject.objectId
              )
          )
          .map((e) => ({ objectId: e.coinObjectId, digest: e.digest, version: e.version }));
        if (!n.length) throw Error('No valid gas coins found for the transaction.');
        e.gasConfig.payment = n.map((e) => cX(c6, e));
      }
    }
    async function fU(e, t) {
      var n;
      let i = [
          ...new Set(
            e.inputs
              .filter(
                (e) =>
                  e.UnresolvedObject &&
                  !(e.UnresolvedObject.version || e.UnresolvedObject?.initialSharedVersion)
              )
              .map((e) => it(e.UnresolvedObject.objectId))
          ),
        ],
        a = i.length
          ? Array.from({ length: Math.ceil((n = i).length / 50) }, (e, t) =>
              n.slice(50 * t, 50 * t + 50)
            )
          : [],
        o = new Map(),
        s = new Map();
      if (
        (await Promise.all(
          a.map(async (e) => {
            for (let n of await fz(t).multiGetObjects({ ids: e, options: { showOwner: !0 } })) {
              let e = n.data?.objectId;
              if (e) {
                if (n.error || !n.data) return void s.set(e, n.error);
                let t = n.data.owner,
                  i =
                    t && 'object' == typeof t && 'Shared' in t
                      ? t.Shared.initial_shared_version
                      : null;
                o.set(e, {
                  objectId: e,
                  digest: n.data.digest,
                  version: n.data.version,
                  initialSharedVersion: i,
                });
              }
            }
          })
        ),
        s.size > 0)
      )
        throw Error(`The following input objects are invalid: ${Array.from(s).join(', ')}`);
      for (let [t, n] of e.inputs.entries()) {
        let i;
        if (!n.UnresolvedObject) continue;
        let a = ie(n.UnresolvedObject.objectId),
          s = o.get(a);
        n.UnresolvedObject.initialSharedVersion ?? s?.initialSharedVersion
          ? (i = dW({
              objectId: a,
              initialSharedVersion:
                n.UnresolvedObject.initialSharedVersion || s?.initialSharedVersion,
              mutable: (function (e, t) {
                let n = !1;
                return (
                  e.getInputUses(t, (e, t) => {
                    if (t.MoveCall && t.MoveCall._argumentTypes) {
                      let i = t.MoveCall.arguments.indexOf(e);
                      n = '&' !== t.MoveCall._argumentTypes[i].ref || n;
                    }
                    ('MakeMoveVec' === t.$kind ||
                      'MergeCoins' === t.$kind ||
                      'SplitCoins' === t.$kind) &&
                      (n = !0);
                  }),
                  n
                );
              })(e, t),
            }))
          : (function (e, t) {
              let n = !1;
              return (
                e.getInputUses(t, (e, t) => {
                  if (t.MoveCall && t.MoveCall._argumentTypes) {
                    var i;
                    let a = t.MoveCall.arguments.indexOf(e);
                    n =
                      ('object' == typeof (i = t.MoveCall._argumentTypes[a]).body &&
                        'datatype' in i.body &&
                        '0x2' === i.body.datatype.package &&
                        'transfer' === i.body.datatype.module &&
                        'Receiving' === i.body.datatype.type) ||
                      n;
                  }
                }),
                n
              );
            })(e, t) &&
            (i = dq({
              objectId: a,
              digest: n.UnresolvedObject.digest ?? s?.digest,
              version: n.UnresolvedObject.version ?? s?.version,
            })),
          (e.inputs[e.inputs.indexOf(n)] =
            i ??
            d$({
              objectId: a,
              digest: n.UnresolvedObject.digest ?? s?.digest,
              version: n.UnresolvedObject.version ?? s?.version,
            }));
      }
    }
    async function fF(e, t) {
      let { inputs: n, commands: i } = e,
        a = [],
        o = new Set();
      i.forEach((t) => {
        if (t.MoveCall) {
          if (t.MoveCall._argumentTypes) return;
          if (
            t.MoveCall.arguments
              .map((t) => ('Input' === t.$kind ? e.inputs[t.Input] : null))
              .some((e) => e?.UnresolvedPure || e?.UnresolvedObject)
          ) {
            let e = `${t.MoveCall.package}::${t.MoveCall.module}::${t.MoveCall.function}`;
            o.add(e), a.push(t.MoveCall);
          }
        }
        switch (t.$kind) {
          case 'SplitCoins':
            t.SplitCoins.amounts.forEach((t) => {
              fL(t, fM.U64, e);
            });
            break;
          case 'TransferObjects':
            fL(t.TransferObjects.address, fM.Address, e);
        }
      });
      let s = new Map();
      if (o.size > 0) {
        let e = fz(t);
        await Promise.all(
          [...o].map(async (t) => {
            let [n, i, a] = t.split('::'),
              o = await e.getNormalizedMoveFunction({ package: n, module: i, function: a });
            s.set(
              t,
              o.parameters.map((e) =>
                'object' == typeof e && 'Reference' in e
                  ? { ref: '&', body: fP(e.Reference) }
                  : 'object' == typeof e && 'MutableReference' in e
                  ? { ref: '&mut', body: fP(e.MutableReference) }
                  : { ref: null, body: fP(e) }
              )
            );
          })
        );
      }
      a.length &&
        (await Promise.all(
          a.map(async (e) => {
            var t;
            let n,
              i = s.get(`${e.package}::${e.module}::${e.function}`);
            i &&
              (e._argumentTypes =
                i.length > 0 &&
                (n =
                  'object' == typeof (t = i.at(-1)).body && 'datatype' in t.body
                    ? t.body.datatype
                    : null) &&
                ie(n.package) === ie('0x2') &&
                'tx_context' === n.module &&
                'TxContext' === n.type
                  ? i.slice(0, i.length - 1)
                  : i);
          })
        )),
        i.forEach((e) => {
          if (!e.MoveCall) return;
          let t = e.MoveCall,
            i = `${t.package}::${t.module}::${t.function}`,
            a = t._argumentTypes;
          if (a) {
            if (a.length !== e.MoveCall.arguments.length)
              throw Error(`Incorrect number of arguments for ${i}`);
            a.forEach((e, i) => {
              let a = t.arguments[i];
              if ('Input' !== a.$kind) return;
              let o = n[a.Input];
              if (!o.UnresolvedPure && !o.UnresolvedObject) return;
              let s = o.UnresolvedPure?.value ?? o.UnresolvedObject?.objectId,
                l = n.indexOf(o),
                u = (function e(t) {
                  if ('string' == typeof t)
                    switch (t) {
                      case 'address':
                        return fM.Address;
                      case 'bool':
                        return fM.Bool;
                      case 'u8':
                        return fM.U8;
                      case 'u16':
                        return fM.U16;
                      case 'u32':
                        return fM.U32;
                      case 'u64':
                        return fM.U64;
                      case 'u128':
                        return fM.U128;
                      case 'u256':
                        return fM.U256;
                      default:
                        throw Error(`Unknown type signature ${t}`);
                    }
                  if ('vector' in t) {
                    if ('u8' === t.vector)
                      return fM
                        .vector(fM.U8)
                        .transform({
                          input: (e) => ('string' == typeof e ? new TextEncoder().encode(e) : e),
                          output: (e) => e,
                        });
                    let n = e(t.vector);
                    return n ? fM.vector(n) : null;
                  }
                  if ('datatype' in t) {
                    let n = ie(t.datatype.package);
                    if (n === ie('0x1')) {
                      if (
                        ('ascii' === t.datatype.module && 'String' === t.datatype.type) ||
                        ('string' === t.datatype.module && 'String' === t.datatype.type)
                      )
                        return fM.String;
                      if ('option' === t.datatype.module && 'Option' === t.datatype.type) {
                        let n = e(t.datatype.typeParameters[0]);
                        return n ? fM.vector(n) : null;
                      }
                    }
                    if (
                      n === ie('0x2') &&
                      'object' === t.datatype.module &&
                      'ID' === t.datatype.type
                    )
                      return fM.Address;
                  }
                  return null;
                })(e.body);
              if (u) {
                (a.type = 'pure'), (n[l] = dV(u.serialize(s)));
                return;
              }
              if ('string' != typeof s)
                throw Error(
                  `Expect the argument to be an object id string, got ${JSON.stringify(s, null, 2)}`
                );
              a.type = 'object';
              let c = o.UnresolvedPure
                ? { $kind: 'UnresolvedObject', UnresolvedObject: { objectId: s } }
                : o;
              n[l] = c;
            });
          }
        });
    }
    function fL(e, t, n) {
      if ('Input' !== e.$kind) return;
      let i = n.inputs[e.Input];
      'UnresolvedPure' === i.$kind && (n.inputs[e.Input] = dV(t.serialize(i.UnresolvedPure.value)));
    }
    function fz(e) {
      if (!e.client)
        throw Error(
          'No iota client passed to Transaction#build, but transaction data was not sufficient to build offline.'
        );
      return e.client;
    }
    function fV(e) {
      switch (e) {
        case 'u8':
          return fM.u8();
        case 'u16':
          return fM.u16();
        case 'u32':
          return fM.u32();
        case 'u64':
          return fM.u64();
        case 'u128':
          return fM.u128();
        case 'u256':
          return fM.u256();
        case 'bool':
          return fM.bool();
        case 'string':
          return fM.string();
        case 'id':
        case 'address':
          return fM.Address;
      }
      let t = e.match(/^(vector|option)<(.+)>$/);
      if (t) {
        let [e, n] = t.slice(1);
        return 'vector' === e ? fM.vector(fV(n)) : fM.option(fV(n));
      }
      throw Error(`Invalid Pure type name: ${e}`);
    }
    function f$(e) {
      return ie(e).replace('0x', '');
    }
    it('0x5'), e.s(['blake2b', 0, u4], 51001);
    class fW {
      constructor(e) {
        (this.version = 2),
          (this.sender = e?.sender ?? null),
          (this.expiration = e?.expiration ?? null),
          (this.inputs = e?.inputs ?? []),
          (this.commands = e?.commands ?? []),
          (this.gasData = e?.gasData ?? { budget: null, price: null, owner: null, payment: null });
      }
      static fromKindBytes(e) {
        let t = fM.TransactionKind.parse(e).ProgrammableTransaction;
        if (!t) throw Error('Unable to deserialize from bytes.');
        return fW.restore({
          version: 2,
          sender: null,
          expiration: null,
          gasData: { budget: null, owner: null, payment: null, price: null },
          inputs: t.inputs,
          commands: t.commands,
        });
      }
      static fromBytes(e) {
        let t = fM.TransactionData.parse(e),
          n = t?.V1,
          i = n.kind.ProgrammableTransaction;
        if (!n || !i) throw Error('Unable to deserialize from bytes.');
        return fW.restore({
          version: 2,
          sender: n.sender,
          expiration: n.expiration,
          gasData: n.gasData,
          inputs: i.inputs,
          commands: i.commands,
        });
      }
      static restore(e) {
        return 2 === e.version
          ? new fW(cX(ds, e))
          : new fW(
              cX(
                ds,
                cX(ds, {
                  version: 2,
                  sender: e.sender ?? null,
                  expiration: e.expiration
                    ? 'Epoch' in e.expiration
                      ? { Epoch: e.expiration.Epoch }
                      : { None: !0 }
                    : null,
                  gasData: {
                    owner: e.gasConfig.owner ?? null,
                    budget: e.gasConfig.budget?.toString() ?? null,
                    price: e.gasConfig.price?.toString() ?? null,
                    payment:
                      e.gasConfig.payment?.map((e) => ({
                        digest: e.digest,
                        objectId: e.objectId,
                        version: e.version.toString(),
                      })) ?? null,
                  },
                  inputs: e.inputs.map((e) => {
                    if ('Input' === e.kind) {
                      if (c_(dm, e.value)) {
                        let t = cX(dm, e.value);
                        if (t.Object) {
                          if (t.Object.ImmOrOwned)
                            return {
                              Object: {
                                ImmOrOwnedObject: {
                                  objectId: t.Object.ImmOrOwned.objectId,
                                  version: String(t.Object.ImmOrOwned.version),
                                  digest: t.Object.ImmOrOwned.digest,
                                },
                              },
                            };
                          if (t.Object.Shared)
                            return {
                              Object: {
                                SharedObject: {
                                  mutable: t.Object.Shared.mutable ?? null,
                                  initialSharedVersion: t.Object.Shared.initialSharedVersion,
                                  objectId: t.Object.Shared.objectId,
                                },
                              },
                            };
                          if (t.Object.Receiving)
                            return {
                              Object: {
                                Receiving: {
                                  digest: t.Object.Receiving.digest,
                                  version: String(t.Object.Receiving.version),
                                  objectId: t.Object.Receiving.objectId,
                                },
                              },
                            };
                          throw Error('Invalid object input');
                        }
                        return { Pure: { bytes: n3(new Uint8Array(t.Pure)) } };
                      }
                      return 'object' === e.type
                        ? { UnresolvedObject: { objectId: e.value } }
                        : { UnresolvedPure: { value: e.value } };
                    }
                    throw Error('Invalid input');
                  }),
                  commands: e.transactions.map((e) => {
                    switch (e.kind) {
                      case 'MakeMoveVec':
                        return {
                          MakeMoveVec: {
                            type: 'Some' in e.type ? df.tagToString(e.type.Some) : null,
                            elements: e.objects.map((e) => dR(e)),
                          },
                        };
                      case 'MergeCoins':
                        return {
                          MergeCoins: {
                            destination: dR(e.destination),
                            sources: e.sources.map((e) => dR(e)),
                          },
                        };
                      case 'MoveCall': {
                        let [t, n, i] = e.target.split('::');
                        return {
                          MoveCall: {
                            package: t,
                            module: n,
                            function: i,
                            typeArguments: e.typeArguments,
                            arguments: e.arguments.map((e) => dR(e)),
                          },
                        };
                      }
                      case 'Publish':
                        return {
                          Publish: {
                            modules: e.modules.map((e) => n3(Uint8Array.from(e))),
                            dependencies: e.dependencies,
                          },
                        };
                      case 'SplitCoins':
                        return {
                          SplitCoins: { coin: dR(e.coin), amounts: e.amounts.map((e) => dR(e)) },
                        };
                      case 'TransferObjects':
                        return {
                          TransferObjects: {
                            objects: e.objects.map((e) => dR(e)),
                            address: dR(e.address),
                          },
                        };
                      case 'Upgrade':
                        return {
                          Upgrade: {
                            modules: e.modules.map((e) => n3(Uint8Array.from(e))),
                            dependencies: e.dependencies,
                            package: e.packageId,
                            ticket: dR(e.ticket),
                          },
                        };
                    }
                    throw Error(`Unknown transaction ${Object.keys(e)}`);
                  }),
                })
              )
            );
      }
      static getDigestFromBytes(e) {
        let t, n, i;
        return (
          (n = new Uint8Array(
            (t = Array.from('TransactionData::').map((e) => e.charCodeAt(0))).length + e.length
          )).set(t),
          n.set(e, t.length),
          (i = u4(n, { dkLen: 32 })),
          n2.encode(i)
        );
      }
      get gasConfig() {
        return this.gasData;
      }
      set gasConfig(e) {
        this.gasData = e;
      }
      build({ maxSizeBytes: e = 1 / 0, overrides: t, onlyTransactionKind: n } = {}) {
        let i = this.inputs,
          a = this.commands;
        if (n)
          return fM.TransactionKind.serialize(
            { ProgrammableTransaction: { inputs: i, commands: a } },
            { maxSize: e }
          ).toBytes();
        let o = t?.expiration ?? this.expiration,
          s = t?.sender ?? this.sender,
          l = { ...this.gasData, ...t?.gasConfig, ...t?.gasData };
        if (!s) throw Error('Missing transaction sender');
        if (!l.budget) throw Error('Missing gas budget');
        if (!l.payment) throw Error('Missing gas payment');
        if (!l.price) throw Error('Missing gas price');
        let u = {
          sender: f$(s),
          expiration: o || { None: !0 },
          gasData: {
            payment: l.payment,
            owner: f$(this.gasData.owner ?? s),
            price: BigInt(l.price),
            budget: BigInt(l.budget),
          },
          kind: { ProgrammableTransaction: { inputs: i, commands: a } },
        };
        return fM.TransactionData.serialize({ V1: u }, { maxSize: e }).toBytes();
      }
      addInput(e, t) {
        let n = this.inputs.length;
        return this.inputs.push(t), { Input: n, type: e, $kind: 'Input' };
      }
      getInputUses(e, t) {
        this.mapArguments((n, i) => ('Input' === n.$kind && n.Input === e && t(n, i), n));
      }
      mapArguments(e) {
        for (let t of this.commands)
          switch (t.$kind) {
            case 'MoveCall':
              t.MoveCall.arguments = t.MoveCall.arguments.map((n) => e(n, t));
              break;
            case 'TransferObjects':
              (t.TransferObjects.objects = t.TransferObjects.objects.map((n) => e(n, t))),
                (t.TransferObjects.address = e(t.TransferObjects.address, t));
              break;
            case 'SplitCoins':
              (t.SplitCoins.coin = e(t.SplitCoins.coin, t)),
                (t.SplitCoins.amounts = t.SplitCoins.amounts.map((n) => e(n, t)));
              break;
            case 'MergeCoins':
              (t.MergeCoins.destination = e(t.MergeCoins.destination, t)),
                (t.MergeCoins.sources = t.MergeCoins.sources.map((n) => e(n, t)));
              break;
            case 'MakeMoveVec':
              t.MakeMoveVec.elements = t.MakeMoveVec.elements.map((n) => e(n, t));
              break;
            case 'Upgrade':
              t.Upgrade.ticket = e(t.Upgrade.ticket, t);
              break;
            case '$Intent':
              let n = t.$Intent.inputs;
              for (let [i, a] of ((t.$Intent.inputs = {}), Object.entries(n)))
                t.$Intent.inputs[i] = Array.isArray(a) ? a.map((n) => e(n, t)) : e(a, t);
              break;
            case 'Publish':
              break;
            default:
              throw Error(`Unexpected transaction kind: ${t.$kind}`);
          }
      }
      replaceCommand(e, t) {
        if (!Array.isArray(t)) {
          this.commands[e] = t;
          return;
        }
        let n = t.length - 1;
        this.commands.splice(e, 1, ...t),
          0 !== n &&
            this.mapArguments((t) => {
              switch (t.$kind) {
                case 'Result':
                  t.Result > e && (t.Result += n);
                  break;
                case 'NestedResult':
                  t.NestedResult[0] > e && (t.NestedResult[0] += n);
              }
              return t;
            });
      }
      getDigest() {
        let e = this.build({ onlyTransactionKind: !1 });
        return fW.getDigestFromBytes(e);
      }
      snapshot() {
        return cX(ds, this);
      }
    }
    function fq(e) {
      return 'string' == typeof e
        ? ie(e)
        : e.Object
        ? e.Object.ImmOrOwnedObject
          ? ie(e.Object.ImmOrOwnedObject.objectId)
          : e.Object.Receiving
          ? ie(e.Object.Receiving.objectId)
          : ie(e.Object.SharedObject.objectId)
        : e.UnresolvedObject
        ? ie(e.UnresolvedObject.objectId)
        : void 0;
    }
    var fK = (e) => {
        throw TypeError(e);
      },
      fG = (e, t, n) => t.has(e) || fK('Cannot ' + n),
      fH = (e, t, n) => (fG(e, t, 'read from private field'), n ? n.call(e) : t.get(e)),
      fZ = (e, t, n) =>
        t.has(e)
          ? fK('Cannot add the same private member more than once')
          : t instanceof WeakSet
          ? t.add(e)
          : t.set(e, n),
      fY = (e, t, n, i) => (fG(e, t, 'write to private field'), i ? i.call(e, n) : t.set(e, n), n),
      fQ = (e, t, n) => (fG(e, t, 'access private method'), n);
    let fX = Symbol.for('@iota/transaction');
    function fJ(e) {
      return !!e && 'object' == typeof e && !0 === e[fX];
    }
    let f0 = { buildPlugins: new Map(), serializationPlugins: new Map() },
      f1 = Symbol.for('@iota/transaction/registry');
    function f5() {
      try {
        let e = globalThis;
        return e[f1] || (e[f1] = f0), e[f1];
      } catch (e) {
        return f0;
      }
    }
    let f2 = class e {
      constructor() {
        fZ(this, ey),
          fZ(this, eh),
          fZ(this, ep),
          fZ(this, em, new Map()),
          fZ(this, eg),
          (this.object = (function (e) {
            function t(t) {
              return e(t);
            }
            return (
              (t.system = () => e('0x5')),
              (t.clock = () => e('0x6')),
              (t.random = () => e('0x8')),
              (t.denyList = () => e('0x403')),
              (t.option =
                ({ type: e, value: t }) =>
                (n) =>
                  n.moveCall({
                    typeArguments: [e],
                    target: `0x1::option::${null === t ? 'none' : 'some'}`,
                    arguments: null === t ? [] : [n.object(t)],
                  })),
              t
            );
          })((e) => {
            if ('function' == typeof e) return this.object(e(this));
            if ('object' == typeof e && c_(c3, e)) return e;
            let t = fq(e),
              n = fH(this, eg).inputs.find((e) => t === fq(e));
            return (
              n?.Object?.SharedObject &&
                'object' == typeof e &&
                e.Object?.SharedObject &&
                (n.Object.SharedObject.mutable =
                  n.Object.SharedObject.mutable || e.Object.SharedObject.mutable),
              n
                ? { $kind: 'Input', Input: fH(this, eg).inputs.indexOf(n), type: 'object' }
                : fH(this, eg).addInput(
                    'object',
                    'string' == typeof e
                      ? { $kind: 'UnresolvedObject', UnresolvedObject: { objectId: ie(e) } }
                      : e
                  )
            );
          }));
        const e = f5();
        fY(this, eg, new fW()),
          fY(this, ep, [...e.buildPlugins.values()]),
          fY(this, eh, [...e.serializationPlugins.values()]);
      }
      static fromKind(t) {
        let n = new e();
        return fY(n, eg, fW.fromKindBytes('string' == typeof t ? n6(t) : t)), n;
      }
      static from(t) {
        let n = new e();
        return (
          fJ(t)
            ? fY(n, eg, new fW(t.getData()))
            : 'string' == typeof t && t.startsWith('{')
            ? fY(n, eg, fW.restore(JSON.parse(t)))
            : fY(n, eg, fW.fromBytes('string' == typeof t ? n6(t) : t)),
          n
        );
      }
      static registerGlobalSerializationPlugin(e, t) {
        f5().serializationPlugins.set(e, t ?? e);
      }
      static unregisterGlobalSerializationPlugin(e) {
        f5().serializationPlugins.delete(e);
      }
      static registerGlobalBuildPlugin(e, t) {
        f5().buildPlugins.set(e, t ?? e);
      }
      static unregisterGlobalBuildPlugin(e) {
        f5().buildPlugins.delete(e);
      }
      addSerializationPlugin(e) {
        fH(this, eh).push(e);
      }
      addBuildPlugin(e) {
        fH(this, ep).push(e);
      }
      addIntentResolver(e, t) {
        if (fH(this, em).has(e) && fH(this, em).get(e) !== t)
          throw Error(`Intent resolver for ${e} already exists`);
        fH(this, em).set(e, t);
      }
      setSender(e) {
        fH(this, eg).sender = e;
      }
      setSenderIfNotSet(e) {
        fH(this, eg).sender || (fH(this, eg).sender = e);
      }
      setExpiration(e) {
        fH(this, eg).expiration = e ? cX(da, e) : null;
      }
      setGasPrice(e) {
        fH(this, eg).gasConfig.price = String(e);
      }
      setGasBudget(e) {
        fH(this, eg).gasConfig.budget = String(e);
      }
      setGasBudgetIfNotSet(e) {
        null == fH(this, eg).gasData.budget && (fH(this, eg).gasConfig.budget = String(e));
      }
      setGasOwner(e) {
        fH(this, eg).gasConfig.owner = e;
      }
      setGasPayment(e) {
        fH(this, eg).gasConfig.payment = e.map((e) => cX(c6, e));
      }
      get blockData() {
        return dj(fH(this, eg).snapshot());
      }
      getData() {
        return fH(this, eg).snapshot();
      }
      get [fX]() {
        return !0;
      }
      get pure() {
        return (
          Object.defineProperty(this, 'pure', {
            enumerable: !1,
            value: (function (e) {
              function t(t, n) {
                if ('string' == typeof t) return e(fV(t).serialize(n));
                if (t instanceof Uint8Array || cS(t)) return e(t);
                throw Error(
                  'tx.pure must be called either a bcs type name, or a serialized bcs value'
                );
              }
              return (
                (t.u8 = (t) => e(fM.U8.serialize(t))),
                (t.u16 = (t) => e(fM.U16.serialize(t))),
                (t.u32 = (t) => e(fM.U32.serialize(t))),
                (t.u64 = (t) => e(fM.U64.serialize(t))),
                (t.u128 = (t) => e(fM.U128.serialize(t))),
                (t.u256 = (t) => e(fM.U256.serialize(t))),
                (t.bool = (t) => e(fM.Bool.serialize(t))),
                (t.string = (t) => e(fM.String.serialize(t))),
                (t.address = (t) => e(fM.Address.serialize(t))),
                (t.id = t.address),
                (t.vector = (t, n) => e(fM.vector(fV(t)).serialize(n))),
                (t.option = (t, n) => e(fM.option(fV(t)).serialize(n))),
                t
              );
            })((e) =>
              cS(e)
                ? fH(this, eg).addInput('pure', { $kind: 'Pure', Pure: { bytes: e.toBase64() } })
                : fH(this, eg).addInput(
                    'pure',
                    c_(di, e)
                      ? cX(di, e)
                      : e instanceof Uint8Array
                      ? dV(e)
                      : { $kind: 'UnresolvedPure', UnresolvedPure: { value: e } }
                  )
            ),
          }),
          this.pure
        );
      }
      get gas() {
        return { $kind: 'GasCoin', GasCoin: !0 };
      }
      objectRef(...e) {
        return this.object(d$(...e));
      }
      receivingRef(...e) {
        return this.object(dq(...e));
      }
      sharedObjectRef(...e) {
        return this.object(dW(...e));
      }
      add(e) {
        var t;
        let n, i;
        return 'function' == typeof e
          ? e(this)
          : ((t = fH(this, eg).commands.push(e) - 1),
            (n = []),
            (i = (e) => n[e] ?? (n[e] = { $kind: 'NestedResult', NestedResult: [t, e] })),
            new Proxy(
              { $kind: 'Result', Result: t },
              {
                set() {
                  throw Error(
                    'The transaction result is a proxy, and does not support setting properties directly'
                  );
                },
                get(e, t) {
                  if (t in e) return Reflect.get(e, t);
                  if (t === Symbol.iterator)
                    return function* () {
                      let e = 0;
                      for (;;) yield i(e), e++;
                    };
                  if ('symbol' == typeof t) return;
                  let n = parseInt(t, 10);
                  if (!Number.isNaN(n) && !(n < 0)) return i(n);
                },
              }
            ));
      }
      splitCoins(e, t) {
        return this.add(
          du.SplitCoins(
            'string' == typeof e ? this.object(e) : fQ(this, ey, ev).call(this, e),
            t.map((e) =>
              'number' == typeof e || 'bigint' == typeof e || 'string' == typeof e
                ? this.pure.u64(e)
                : fQ(this, ey, eb).call(this, e)
            )
          )
        );
      }
      mergeCoins(e, t) {
        return this.add(
          du.MergeCoins(
            this.object(e),
            t.map((e) => this.object(e))
          )
        );
      }
      publish({ modules: e, dependencies: t }) {
        return this.add(du.Publish({ modules: e, dependencies: t }));
      }
      upgrade({ modules: e, dependencies: t, package: n, ticket: i }) {
        return this.add(
          du.Upgrade({ modules: e, dependencies: t, package: n, ticket: this.object(i) })
        );
      }
      moveCall({ arguments: e, ...t }) {
        return this.add(
          du.MoveCall({ ...t, arguments: e?.map((e) => fQ(this, ey, eb).call(this, e)) })
        );
      }
      transferObjects(e, t) {
        return this.add(
          du.TransferObjects(
            e.map((e) => this.object(e)),
            'string' == typeof t ? this.pure.address(t) : fQ(this, ey, eb).call(this, t)
          )
        );
      }
      makeMoveVec({ type: e, elements: t }) {
        return this.add(du.MakeMoveVec({ type: e, elements: t.map((e) => this.object(e)) }));
      }
      serialize() {
        return JSON.stringify(dj(fH(this, eg).snapshot()));
      }
      async toJSON(e = {}) {
        return (
          await this.prepareForSerialization(e),
          JSON.stringify(
            cX(dz, fH(this, eg).snapshot()),
            (e, t) => ('bigint' == typeof t ? t.toString() : t),
            2
          )
        );
      }
      async sign(e) {
        let { signer: t, ...n } = e,
          i = await this.build(n);
        return t.signTransaction(i);
      }
      async build(e = {}) {
        return (
          await this.prepareForSerialization(e),
          await fQ(this, ey, ew).call(this, e),
          fH(this, eg).build({
            maxSizeBytes: e.maxSizeBytes,
            onlyTransactionKind: e.onlyTransactionKind,
          })
        );
      }
      async getDigest(e = {}) {
        return await fQ(this, ey, ew).call(this, e), fH(this, eg).getDigest();
      }
      async prepareForSerialization(e) {
        let t = new Set();
        for (let e of fH(this, eg).commands) e.$Intent && t.add(e.$Intent.name);
        let n = [...fH(this, eh)];
        for (let i of t)
          if (!e.supportedIntents?.includes(i)) {
            if (!fH(this, em).has(i)) throw Error(`Missing intent resolver for ${i}`);
            n.push(fH(this, em).get(i));
          }
        await fQ(this, ey, ex).call(this, n, e);
      }
    };
    (eh = new WeakMap()),
      (ep = new WeakMap()),
      (em = new WeakMap()),
      (eg = new WeakMap()),
      (ey = new WeakSet()),
      (eb = function (e) {
        return cS(e) ? this.pure(e) : fQ(this, ey, ev).call(this, e);
      }),
      (ev = function (e) {
        return 'function' == typeof e ? cX(c3, e(this)) : cX(c3, e);
      }),
      (ew = async function (e) {
        if (!e.onlyTransactionKind && !fH(this, eg).sender)
          throw Error('Missing transaction sender');
        await fQ(this, ey, ex).call(this, [...fH(this, ep), fN], e);
      }),
      (ex = async function (e, t) {
        let n = (i) => {
          if (i >= e.length) return () => {};
          let a = e[i];
          return async () => {
            let e = n(i + 1),
              o = !1,
              s = !1;
            if (
              (await a(fH(this, eg), t, async () => {
                if (o) throw Error(`next() was call multiple times in TransactionPlugin ${i}`);
                (o = !0), await e(), (s = !0);
              }),
              !o)
            )
              throw Error(`next() was not called in TransactionPlugin ${i}`);
            if (!s) throw Error(`next() was not awaited in TransactionPlugin ${i}`);
          };
        };
        await n(0)();
      });
    let f6 = {
      '-32700': 'ParseError',
      '-32701': 'OversizedRequest',
      '-32702': 'OversizedResponse',
      '-32600': 'InvalidRequest',
      '-32601': 'MethodNotFound',
      '-32602': 'InvalidParams',
      '-32603': 'InternalError',
      '-32604': 'ServerBusy',
      '-32000': 'CallExecutionFailed',
      '-32001': 'UnknownError',
      '-32003': 'SubscriptionClosed',
      '-32004': 'SubscriptionClosedWithError',
      '-32005': 'BatchesNotSupported',
      '-32006': 'TooManySubscriptions',
      '-32050': 'TransientError',
      '-32002': 'TransactionExecutionClientError',
    };
    class f3 extends Error {}
    class f4 extends f3 {
      constructor(e, t) {
        super(e), (this.code = t), (this.type = f6[t] ?? 'ServerError');
      }
    }
    class f8 extends f3 {
      constructor(e, t, n) {
        super(e), (this.status = t), (this.statusText = n);
      }
    }
    var f9 = (e) => {
        throw TypeError(e);
      },
      f7 = (e, t, n) => t.has(e) || f9('Cannot ' + n),
      he = (e, t, n) => (f7(e, t, 'read from private field'), n ? n.call(e) : t.get(e)),
      ht = (e, t, n) =>
        t.has(e)
          ? f9('Cannot add the same private member more than once')
          : t instanceof WeakSet
          ? t.add(e)
          : t.set(e, n),
      hr = (e, t, n, i) => (f7(e, t, 'write to private field'), i ? i.call(e, n) : t.set(e, n), n),
      hn = (e, t, n) => (f7(e, t, 'access private method'), n);
    let hi = {
      WebSocketConstructor: 'undefined' != typeof WebSocket ? WebSocket : void 0,
      callTimeout: 3e4,
      reconnectTimeout: 3e3,
      maxReconnects: 5,
    };
    class ha {
      constructor(e, t = {}) {
        if (
          (ht(this, eI),
          ht(this, eE, 0),
          ht(this, eS, 0),
          ht(this, eC, null),
          ht(this, ek, null),
          ht(this, eO, new Set()),
          ht(this, eA, new Map()),
          (this.endpoint = e),
          (this.options = { ...hi, ...t }),
          !this.options.WebSocketConstructor)
        )
          throw Error('Missing WebSocket constructor');
        this.endpoint.startsWith('http') &&
          (this.endpoint = (function (e) {
            let t = new URL(e);
            return (t.protocol = t.protocol.replace('http', 'ws')), t.toString();
          })(this.endpoint));
      }
      async makeRequest(e, t) {
        let n = await hn(this, eI, ej).call(this);
        return new Promise((i, a) => {
          hr(this, eE, he(this, eE) + 1),
            he(this, eA).set(he(this, eE), {
              resolve: i,
              reject: a,
              timeout: setTimeout(() => {
                he(this, eA).delete(he(this, eE)), a(Error(`Request timeout: ${e}`));
              }, this.options.callTimeout),
            }),
            n.send(JSON.stringify({ jsonrpc: '2.0', id: he(this, eE), method: e, params: t }));
        }).then(({ error: e, result: t }) => {
          if (e) throw new f4(e.message, e.code);
          return t;
        });
      }
      async subscribe(e) {
        let t = new ho(e);
        return he(this, eO).add(t), await t.subscribe(this), () => t.unsubscribe(this);
      }
    }
    (eE = new WeakMap()),
      (eS = new WeakMap()),
      (eC = new WeakMap()),
      (ek = new WeakMap()),
      (eO = new WeakMap()),
      (eA = new WeakMap()),
      (eI = new WeakSet()),
      (ej = function () {
        return (
          he(this, ek) ||
            hr(
              this,
              ek,
              new Promise((e) => {
                he(this, eC)?.close(),
                  hr(this, eC, new this.options.WebSocketConstructor(this.endpoint)),
                  he(this, eC).addEventListener('open', () => {
                    hr(this, eS, 0), e(he(this, eC));
                  }),
                  he(this, eC).addEventListener('close', () => {
                    let e, t, n, i;
                    ((e = this),
                    (t = eS),
                    {
                      set _(value) {
                        hr(e, t, value, n);
                      },
                      get _() {
                        return he(e, t, i);
                      },
                    })._++,
                      he(this, eS) <= this.options.maxReconnects &&
                        setTimeout(() => {
                          hn(this, eI, eT).call(this);
                        }, this.options.reconnectTimeout);
                  }),
                  he(this, eC).addEventListener('message', ({ data: e }) => {
                    let t;
                    try {
                      t = JSON.parse(e);
                    } catch (t) {
                      console.error(Error(`Failed to parse RPC message: ${e}`, { cause: t }));
                      return;
                    }
                    if ('id' in t && null != t.id && he(this, eA).has(t.id)) {
                      let { resolve: e, timeout: n } = he(this, eA).get(t.id);
                      clearTimeout(n), e(t);
                    } else if ('params' in t) {
                      let { params: e } = t;
                      he(this, eO).forEach((t) => {
                        t.subscriptionId === e.subscription &&
                          e.subscription === t.subscriptionId &&
                          t.onMessage(e.result);
                      });
                    }
                  });
              })
            ),
          he(this, ek)
        );
      }),
      (eT = async function () {
        return (
          he(this, eC)?.close(),
          hr(this, ek, null),
          Promise.allSettled([...he(this, eO)].map((e) => e.subscribe(this)))
        );
      });
    class ho {
      constructor(e) {
        (this.subscriptionId = null), (this.subscribed = !1), (this.input = e);
      }
      onMessage(e) {
        this.subscribed && this.input.onMessage(e);
      }
      async unsubscribe(e) {
        let { subscriptionId: t } = this;
        return (
          (this.subscribed = !1),
          null != t && ((this.subscriptionId = null), e.makeRequest(this.input.unsubscribe, [t]))
        );
      }
      async subscribe(e) {
        (this.subscriptionId = null), (this.subscribed = !0);
        let t = await e.makeRequest(this.input.method, this.input.params);
        this.subscribed && (this.subscriptionId = t);
      }
    }
    var hs = (e) => {
        throw TypeError(e);
      },
      hl = (e, t, n) => t.has(e) || hs('Cannot ' + n),
      hu = (e, t, n) => (hl(e, t, 'read from private field'), n ? n.call(e) : t.get(e)),
      hc = (e, t, n) =>
        t.has(e)
          ? hs('Cannot add the same private member more than once')
          : t instanceof WeakSet
          ? t.add(e)
          : t.set(e, n),
      hd = (e, t, n, i) => (hl(e, t, 'write to private field'), i ? i.call(e, n) : t.set(e, n), n);
    class hf {
      constructor(e) {
        hc(this, eN), hc(this, eR, 0), hc(this, eM), hc(this, eP), hd(this, eM, e);
      }
      fetch(e, t) {
        let n = hu(this, eM).fetch ?? fetch;
        if (!n)
          throw Error(
            'The current environment does not support fetch, you can provide a fetch implementation in the options for IotaHTTPTransport.'
          );
        return n(e, t);
      }
      async request(e) {
        hd(this, eR, hu(this, eR) + 1);
        let t = await this.fetch(hu(this, eM).rpc?.url ?? hu(this, eM).url, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Client-Sdk-Type': 'typescript',
            'Client-Sdk-Version': '1.7.0',
            'Client-Target-Api-Version': '1.12.0-alpha',
            ...hu(this, eM).rpc?.headers,
          },
          body: JSON.stringify({
            jsonrpc: '2.0',
            id: hu(this, eR),
            method: e.method,
            params: e.params,
          }),
        });
        if (!t.ok) throw new f8(`Unexpected status code: ${t.status}`, t.status, t.statusText);
        let n = await t.json();
        if ('error' in n && null != n.error) throw new f4(n.error.message, n.error.code);
        return n.result;
      }
      async subscribe(e) {
        let t,
          n,
          i = await ((t = eN), (n = e_), hl(this, t, 'access private method'), n)
            .call(this)
            .subscribe(e);
        return async () => !!(await i());
      }
    }
    (eR = new WeakMap()),
      (eM = new WeakMap()),
      (eP = new WeakMap()),
      (eN = new WeakSet()),
      (e_ = function () {
        if (!hu(this, eP)) {
          let e = hu(this, eM).WebSocketConstructor ?? WebSocket;
          if (!e)
            throw Error(
              'The current environment does not support WebSocket, you can provide a WebSocketConstructor in the options for IotaHTTPTransport.'
            );
          hd(
            this,
            eP,
            new ha(hu(this, eM).websocket?.url ?? hu(this, eM).url, {
              WebSocketConstructor: e,
              ...hu(this, eM).websocket,
            })
          );
        }
        return hu(this, eP);
      });
    let hh = Symbol.for('@iota/IotaClient');
    class hp {
      get [hh]() {
        return !0;
      }
      constructor(e) {
        this.transport = e.transport ?? new hf({ url: e.url });
      }
      async getRpcApiVersion() {
        return (await this.transport.request({ method: 'rpc.discover', params: [] })).info.version;
      }
      async getCoins(e) {
        if (!e.owner || !n7(ie(e.owner))) throw Error('Invalid IOTA address');
        return await this.transport.request({
          method: 'iotax_getCoins',
          params: [e.owner, e.coinType, e.cursor, e.limit],
        });
      }
      async getAllCoins(e) {
        if (!e.owner || !n7(ie(e.owner))) throw Error('Invalid IOTA address');
        return await this.transport.request({
          method: 'iotax_getAllCoins',
          params: [e.owner, e.cursor, e.limit],
        });
      }
      async getBalance(e) {
        if (!e.owner || !n7(ie(e.owner))) throw Error('Invalid IOTA address');
        return await this.transport.request({
          method: 'iotax_getBalance',
          params: [e.owner, e.coinType],
        });
      }
      async getAllBalances(e) {
        if (!e.owner || !n7(ie(e.owner))) throw Error('Invalid IOTA address');
        return await this.transport.request({ method: 'iotax_getAllBalances', params: [e.owner] });
      }
      async getCoinMetadata(e) {
        return await this.transport.request({
          method: 'iotax_getCoinMetadata',
          params: [e.coinType],
        });
      }
      async getTotalSupply(e) {
        return await this.transport.request({
          method: 'iotax_getTotalSupply',
          params: [e.coinType],
        });
      }
      async getCirculatingSupply() {
        return await this.transport.request({ method: 'iotax_getCirculatingSupply', params: [] });
      }
      async call(e, t) {
        return await this.transport.request({ method: e, params: t });
      }
      async getMoveFunctionArgTypes(e) {
        return await this.transport.request({
          method: 'iota_getMoveFunctionArgTypes',
          params: [e.package, e.module, e.function],
        });
      }
      async getNormalizedMoveModulesByPackage(e) {
        return await this.transport.request({
          method: 'iota_getNormalizedMoveModulesByPackage',
          params: [e.package],
        });
      }
      async getNormalizedMoveModule(e) {
        return await this.transport.request({
          method: 'iota_getNormalizedMoveModule',
          params: [e.package, e.module],
        });
      }
      async getNormalizedMoveFunction(e) {
        return await this.transport.request({
          method: 'iota_getNormalizedMoveFunction',
          params: [e.package, e.module, e.function],
        });
      }
      async getNormalizedMoveStruct(e) {
        return await this.transport.request({
          method: 'iota_getNormalizedMoveStruct',
          params: [e.package, e.module, e.struct],
        });
      }
      async getOwnedObjects(e) {
        if (!e.owner || !n7(ie(e.owner))) throw Error('Invalid IOTA address');
        return await this.transport.request({
          method: 'iotax_getOwnedObjects',
          params: [e.owner, { filter: e.filter, options: e.options }, e.cursor, e.limit],
        });
      }
      async getObject(e) {
        if (!e.id || !n7(it(e.id))) throw Error('Invalid IOTA Object id');
        return await this.transport.request({
          method: 'iota_getObject',
          params: [e.id, e.options],
        });
      }
      async tryGetPastObject(e) {
        return await this.transport.request({
          method: 'iota_tryGetPastObject',
          params: [e.id, e.version, e.options],
        });
      }
      async multiGetObjects(e) {
        if (
          (e.ids.forEach((e) => {
            if (!e || !n7(it(e))) throw Error(`Invalid IOTA Object id ${e}`);
          }),
          e.ids.length !== new Set(e.ids).size)
        )
          throw Error(`Duplicate object ids in batch call ${e.ids}`);
        return await this.transport.request({
          method: 'iota_multiGetObjects',
          params: [e.ids, e.options],
        });
      }
      async queryTransactionBlocks(e) {
        return await this.transport.request({
          method: 'iotax_queryTransactionBlocks',
          params: [
            { filter: e.filter, options: e.options },
            e.cursor,
            e.limit,
            'descending' === (e.order || 'descending'),
          ],
        });
      }
      async getTransactionBlock(e) {
        if (!n9(e.digest)) throw Error('Invalid Transaction digest');
        return await this.transport.request({
          method: 'iota_getTransactionBlock',
          params: [e.digest, e.options],
        });
      }
      async multiGetTransactionBlocks(e) {
        if (
          (e.digests.forEach((e) => {
            if (!n9(e)) throw Error(`Invalid Transaction digest ${e}`);
          }),
          e.digests.length !== new Set(e.digests).size)
        )
          throw Error(`Duplicate digests in batch call ${e.digests}`);
        return await this.transport.request({
          method: 'iota_multiGetTransactionBlocks',
          params: [e.digests, e.options],
        });
      }
      async executeTransactionBlock({ transactionBlock: e, signature: t, options: n }) {
        return await this.transport.request({
          method: 'iota_executeTransactionBlock',
          params: ['string' == typeof e ? e : n3(e), Array.isArray(t) ? t : [t], n],
        });
      }
      async signAndExecuteTransaction({ transaction: e, signer: t, ...n }) {
        let i;
        e instanceof Uint8Array
          ? (i = e)
          : (e.setSenderIfNotSet(t.toIotaAddress()), (i = await e.build({ client: this })));
        let { signature: a, bytes: o } = await t.signTransaction(i);
        return this.executeTransactionBlock({ transactionBlock: o, signature: a, ...n });
      }
      async getTotalTransactionBlocks() {
        return BigInt(
          await this.transport.request({ method: 'iota_getTotalTransactionBlocks', params: [] })
        );
      }
      async getReferenceGasPrice() {
        return BigInt(
          await this.transport.request({ method: 'iotax_getReferenceGasPrice', params: [] })
        );
      }
      async getStakes(e) {
        if (!e.owner || !n7(ie(e.owner))) throw Error('Invalid IOTA address');
        return await this.transport.request({ method: 'iotax_getStakes', params: [e.owner] });
      }
      async getTimelockedStakes(e) {
        if (!e.owner || !n7(ie(e.owner))) throw Error('Invalid IOTA address');
        return await this.transport.request({
          method: 'iotax_getTimelockedStakes',
          params: [e.owner],
        });
      }
      async getStakesByIds(e) {
        return (
          e.stakedIotaIds.forEach((e) => {
            if (!e || !n7(it(e))) throw Error(`Invalid IOTA Stake id ${e}`);
          }),
          await this.transport.request({
            method: 'iotax_getStakesByIds',
            params: [e.stakedIotaIds],
          })
        );
      }
      async getTimelockedStakesByIds(e) {
        return (
          e.timelockedStakedIotaIds.forEach((e) => {
            if (!e || !n7(it(e))) throw Error(`Invalid IOTA Timelocked Stake id ${e}`);
          }),
          await this.transport.request({
            method: 'iotax_getTimelockedStakesByIds',
            params: [e.timelockedStakedIotaIds],
          })
        );
      }
      async getLatestIotaSystemStateV1() {
        return await this.transport.request({
          method: 'iotax_getLatestIotaSystemState',
          params: [],
        });
      }
      async getLatestIotaSystemStateV2() {
        return await this.transport.request({
          method: 'iotax_getLatestIotaSystemStateV2',
          params: [],
        });
      }
      async getLatestIotaSystemState() {
        let e =
          Number((await this.getProtocolConfig()).maxSupportedProtocolVersion) >= 5
            ? await this.getLatestIotaSystemStateV2()
            : { V1: await this.getLatestIotaSystemStateV1() };
        return 'V2' in e
          ? {
              ...e.V2,
              committeeMembers: e.V2.committeeMembers.map((t) => e.V2.activeValidators[Number(t)]),
            }
          : {
              ...e.V1,
              committeeMembers: e.V1.activeValidators,
              safeModeComputationCharges: e.V1.safeModeComputationRewards,
              safeModeComputationChargesBurned: e.V1.safeModeComputationRewards,
            };
      }
      async queryEvents(e) {
        return await this.transport.request({
          method: 'iotax_queryEvents',
          params: [e.query, e.cursor, e.limit, 'descending' === (e.order || 'descending')],
        });
      }
      async subscribeEvent(e) {
        return this.transport.subscribe({
          method: 'iotax_subscribeEvent',
          unsubscribe: 'iotax_unsubscribeEvent',
          params: [e.filter],
          onMessage: e.onMessage,
        });
      }
      async subscribeTransaction(e) {
        return this.transport.subscribe({
          method: 'iotax_subscribeTransaction',
          unsubscribe: 'iotax_unsubscribeTransaction',
          params: [e.filter],
          onMessage: e.onMessage,
        });
      }
      async devInspectTransactionBlock(e) {
        let t;
        if (fJ(e.transactionBlock))
          e.transactionBlock.setSenderIfNotSet(e.sender),
            (t = n3(await e.transactionBlock.build({ client: this, onlyTransactionKind: !0 })));
        else if ('string' == typeof e.transactionBlock) t = e.transactionBlock;
        else if (e.transactionBlock instanceof Uint8Array) t = n3(e.transactionBlock);
        else throw Error('Unknown transaction block format.');
        return await this.transport.request({
          method: 'iota_devInspectTransactionBlock',
          params: [e.sender, t, e.gasPrice?.toString(), e.epoch],
        });
      }
      async dryRunTransactionBlock(e) {
        return await this.transport.request({
          method: 'iota_dryRunTransactionBlock',
          params: [
            'string' == typeof e.transactionBlock ? e.transactionBlock : n3(e.transactionBlock),
          ],
        });
      }
      async getDynamicFields(e) {
        if (!e.parentId || !n7(it(e.parentId))) throw Error('Invalid IOTA Object id');
        return await this.transport.request({
          method: 'iotax_getDynamicFields',
          params: [e.parentId, e.cursor, e.limit],
        });
      }
      async getDynamicFieldObject(e) {
        return await this.transport.request({
          method: 'iotax_getDynamicFieldObjectV2',
          params: [e.parentObjectId, e.name, e.options],
        });
      }
      async getDynamicFieldObjectV1(e) {
        return await this.transport.request({
          method: 'iotax_getDynamicFieldObject',
          params: [e.parentId, e.name],
        });
      }
      async getDynamicFieldObjectV2(e) {
        return await this.transport.request({
          method: 'iotax_getDynamicFieldObjectV2',
          params: [e.parentObjectId, e.name, e.options],
        });
      }
      async getLatestCheckpointSequenceNumber() {
        return String(
          await this.transport.request({
            method: 'iota_getLatestCheckpointSequenceNumber',
            params: [],
          })
        );
      }
      async getCheckpoint(e) {
        return await this.transport.request({ method: 'iota_getCheckpoint', params: [e.id] });
      }
      async getCheckpoints(e) {
        return await this.transport.request({
          method: 'iota_getCheckpoints',
          params: [e.cursor, e?.limit, e.descendingOrder],
        });
      }
      async getCommitteeInfo(e) {
        return await this.transport.request({
          method: 'iotax_getCommitteeInfo',
          params: [e?.epoch],
        });
      }
      async getNetworkMetrics() {
        return await this.transport.request({ method: 'iotax_getNetworkMetrics', params: [] });
      }
      async getAddressMetrics() {
        return await this.transport.request({
          method: 'iotax_getLatestAddressMetrics',
          params: [],
        });
      }
      async getEpochMetrics(e) {
        return await this.transport.request({
          method: 'iotax_getEpochMetrics',
          params: [e?.cursor, e?.limit, e?.descendingOrder],
        });
      }
      async getAllEpochAddressMetrics(e) {
        return await this.transport.request({
          method: 'iotax_getAllEpochAddressMetrics',
          params: [e?.descendingOrder],
        });
      }
      async getCheckpointAddressMetrics(e) {
        return await this.transport.request({
          method: 'iotax_getCheckpointAddressMetrics',
          params: [e?.checkpoint],
        });
      }
      async getEpochs(e) {
        return await this.transport.request({
          method: 'iotax_getEpochs',
          params: [e?.cursor, e?.limit, e?.descendingOrder],
        });
      }
      async getMoveCallMetrics() {
        return await this.transport.request({ method: 'iotax_getMoveCallMetrics', params: [] });
      }
      async getCurrentEpoch() {
        return await this.transport.request({ method: 'iotax_getCurrentEpoch', params: [] });
      }
      async getTotalTransactions() {
        return String(
          await this.transport.request({ method: 'iotax_getTotalTransactions', params: [] })
        );
      }
      async getValidatorsApy() {
        return await this.transport.request({ method: 'iotax_getValidatorsApy', params: [] });
      }
      async getChainIdentifier() {
        return await this.transport.request({ method: 'iota_getChainIdentifier', params: [] });
      }
      async getProtocolConfig(e) {
        return await this.transport.request({
          method: 'iota_getProtocolConfig',
          params: [e?.version],
        });
      }
      async getParticipationMetrics() {
        return await this.transport.request({
          method: 'iotax_getParticipationMetrics',
          params: [],
        });
      }
      async waitForTransaction({
        signal: e,
        timeout: t = 6e4,
        pollInterval: n = 2e3,
        waitMode: i,
        ...a
      }) {
        let o = AbortSignal.timeout(t),
          s = new Promise((e, t) => {
            o.addEventListener('abort', () => t(o.reason));
          });
        for (s.catch(() => {}); !o.aborted; ) {
          e?.throwIfAborted();
          let t = async () => {
            await Promise.race([new Promise((e) => setTimeout(e, n)), s]);
          };
          try {
            if ('indexed-on-node' === i) {
              if (await this.isTransactionIndexedOnNode({ digest: a.digest }))
                return await this.getTransactionBlock(a);
            } else {
              if ('checkpoint' !== i) return await this.getTransactionBlock(a);
              let e = await this.getTransactionBlock(a);
              if (e.checkpoint) return e;
            }
            await t();
          } catch (e) {
            await t();
          }
        }
        throw (o.throwIfAborted(), Error('Unexpected error while waiting for transaction block.'));
      }
      async iotaNamesLookup(e) {
        return await this.transport.request({ method: 'iotax_iotaNamesLookup', params: [e.name] });
      }
      async iotaNamesReverseLookup(e) {
        return await this.transport.request({
          method: 'iotax_iotaNamesReverseLookup',
          params: [e.address],
        });
      }
      async iotaNamesFindAllRegistrationNFTs(e) {
        return await this.transport.request({
          method: 'iotax_iotaNamesFindAllRegistrationNFTs',
          params: [e.address, e.cursor, e.limit, e.options],
        });
      }
      async isTransactionIndexedOnNode(e) {
        return await this.transport.request({
          method: 'iota_isTransactionIndexedOnNode',
          params: [e.digest],
        });
      }
      async view(e) {
        return await this.transport.request({
          method: 'iota_view',
          params: [e.functionName, e.typeArgs, e.callArgs],
        });
      }
    }
    function hm(e) {
      return 9 === e || 32 === e;
    }
    let hg = /[\x00-\x1f\x22\x5c\x7f-\x9f]/g;
    function hy(e) {
      return hb[e.charCodeAt(0)];
    }
    let hb = [
        '\\u0000',
        '\\u0001',
        '\\u0002',
        '\\u0003',
        '\\u0004',
        '\\u0005',
        '\\u0006',
        '\\u0007',
        '\\b',
        '\\t',
        '\\n',
        '\\u000B',
        '\\f',
        '\\r',
        '\\u000E',
        '\\u000F',
        '\\u0010',
        '\\u0011',
        '\\u0012',
        '\\u0013',
        '\\u0014',
        '\\u0015',
        '\\u0016',
        '\\u0017',
        '\\u0018',
        '\\u0019',
        '\\u001A',
        '\\u001B',
        '\\u001C',
        '\\u001D',
        '\\u001E',
        '\\u001F',
        '',
        '',
        '\\"',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '\\\\',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '\\u007F',
        '\\u0080',
        '\\u0081',
        '\\u0082',
        '\\u0083',
        '\\u0084',
        '\\u0085',
        '\\u0086',
        '\\u0087',
        '\\u0088',
        '\\u0089',
        '\\u008A',
        '\\u008B',
        '\\u008C',
        '\\u008D',
        '\\u008E',
        '\\u008F',
        '\\u0090',
        '\\u0091',
        '\\u0092',
        '\\u0093',
        '\\u0094',
        '\\u0095',
        '\\u0096',
        '\\u0097',
        '\\u0098',
        '\\u0099',
        '\\u009A',
        '\\u009B',
        '\\u009C',
        '\\u009D',
        '\\u009E',
        '\\u009F',
      ],
      hv = {
        Name: [],
        Document: ['definitions'],
        OperationDefinition: [
          'description',
          'name',
          'variableDefinitions',
          'directives',
          'selectionSet',
        ],
        VariableDefinition: ['description', 'variable', 'type', 'defaultValue', 'directives'],
        Variable: ['name'],
        SelectionSet: ['selections'],
        Field: ['alias', 'name', 'arguments', 'directives', 'selectionSet'],
        Argument: ['name', 'value'],
        FragmentSpread: ['name', 'directives'],
        InlineFragment: ['typeCondition', 'directives', 'selectionSet'],
        FragmentDefinition: [
          'description',
          'name',
          'variableDefinitions',
          'typeCondition',
          'directives',
          'selectionSet',
        ],
        IntValue: [],
        FloatValue: [],
        StringValue: [],
        BooleanValue: [],
        NullValue: [],
        EnumValue: [],
        ListValue: ['values'],
        ObjectValue: ['fields'],
        ObjectField: ['name', 'value'],
        Directive: ['name', 'arguments'],
        NamedType: ['name'],
        ListType: ['type'],
        NonNullType: ['type'],
        SchemaDefinition: ['description', 'directives', 'operationTypes'],
        OperationTypeDefinition: ['type'],
        ScalarTypeDefinition: ['description', 'name', 'directives'],
        ObjectTypeDefinition: ['description', 'name', 'interfaces', 'directives', 'fields'],
        FieldDefinition: ['description', 'name', 'arguments', 'type', 'directives'],
        InputValueDefinition: ['description', 'name', 'type', 'defaultValue', 'directives'],
        InterfaceTypeDefinition: ['description', 'name', 'interfaces', 'directives', 'fields'],
        UnionTypeDefinition: ['description', 'name', 'directives', 'types'],
        EnumTypeDefinition: ['description', 'name', 'directives', 'values'],
        EnumValueDefinition: ['description', 'name', 'directives'],
        InputObjectTypeDefinition: ['description', 'name', 'directives', 'fields'],
        DirectiveDefinition: ['description', 'name', 'arguments', 'locations'],
        SchemaExtension: ['directives', 'operationTypes'],
        ScalarTypeExtension: ['name', 'directives'],
        ObjectTypeExtension: ['name', 'interfaces', 'directives', 'fields'],
        InterfaceTypeExtension: ['name', 'interfaces', 'directives', 'fields'],
        UnionTypeExtension: ['name', 'directives', 'types'],
        EnumTypeExtension: ['name', 'directives', 'values'],
        InputObjectTypeExtension: ['name', 'directives', 'fields'],
        TypeCoordinate: ['name'],
        MemberCoordinate: ['name', 'memberName'],
        ArgumentCoordinate: ['name', 'fieldName', 'argumentName'],
        DirectiveCoordinate: ['name'],
        DirectiveArgumentCoordinate: ['name', 'argumentName'],
      },
      hw = new Set(Object.keys(hv));
    function hx(e) {
      let t = null == e ? void 0 : e.kind;
      return 'string' == typeof t && hw.has(t);
    }
    ((z = eD || (eD = {})).QUERY = 'query'),
      (z.MUTATION = 'mutation'),
      (z.SUBSCRIPTION = 'subscription'),
      ((V = eB || (eB = {})).NAME = 'Name'),
      (V.DOCUMENT = 'Document'),
      (V.OPERATION_DEFINITION = 'OperationDefinition'),
      (V.VARIABLE_DEFINITION = 'VariableDefinition'),
      (V.SELECTION_SET = 'SelectionSet'),
      (V.FIELD = 'Field'),
      (V.ARGUMENT = 'Argument'),
      (V.FRAGMENT_SPREAD = 'FragmentSpread'),
      (V.INLINE_FRAGMENT = 'InlineFragment'),
      (V.FRAGMENT_DEFINITION = 'FragmentDefinition'),
      (V.VARIABLE = 'Variable'),
      (V.INT = 'IntValue'),
      (V.FLOAT = 'FloatValue'),
      (V.STRING = 'StringValue'),
      (V.BOOLEAN = 'BooleanValue'),
      (V.NULL = 'NullValue'),
      (V.ENUM = 'EnumValue'),
      (V.LIST = 'ListValue'),
      (V.OBJECT = 'ObjectValue'),
      (V.OBJECT_FIELD = 'ObjectField'),
      (V.DIRECTIVE = 'Directive'),
      (V.NAMED_TYPE = 'NamedType'),
      (V.LIST_TYPE = 'ListType'),
      (V.NON_NULL_TYPE = 'NonNullType'),
      (V.SCHEMA_DEFINITION = 'SchemaDefinition'),
      (V.OPERATION_TYPE_DEFINITION = 'OperationTypeDefinition'),
      (V.SCALAR_TYPE_DEFINITION = 'ScalarTypeDefinition'),
      (V.OBJECT_TYPE_DEFINITION = 'ObjectTypeDefinition'),
      (V.FIELD_DEFINITION = 'FieldDefinition'),
      (V.INPUT_VALUE_DEFINITION = 'InputValueDefinition'),
      (V.INTERFACE_TYPE_DEFINITION = 'InterfaceTypeDefinition'),
      (V.UNION_TYPE_DEFINITION = 'UnionTypeDefinition'),
      (V.ENUM_TYPE_DEFINITION = 'EnumTypeDefinition'),
      (V.ENUM_VALUE_DEFINITION = 'EnumValueDefinition'),
      (V.INPUT_OBJECT_TYPE_DEFINITION = 'InputObjectTypeDefinition'),
      (V.DIRECTIVE_DEFINITION = 'DirectiveDefinition'),
      (V.SCHEMA_EXTENSION = 'SchemaExtension'),
      (V.SCALAR_TYPE_EXTENSION = 'ScalarTypeExtension'),
      (V.OBJECT_TYPE_EXTENSION = 'ObjectTypeExtension'),
      (V.INTERFACE_TYPE_EXTENSION = 'InterfaceTypeExtension'),
      (V.UNION_TYPE_EXTENSION = 'UnionTypeExtension'),
      (V.ENUM_TYPE_EXTENSION = 'EnumTypeExtension'),
      (V.INPUT_OBJECT_TYPE_EXTENSION = 'InputObjectTypeExtension'),
      (V.TYPE_COORDINATE = 'TypeCoordinate'),
      (V.MEMBER_COORDINATE = 'MemberCoordinate'),
      (V.ARGUMENT_COORDINATE = 'ArgumentCoordinate'),
      (V.DIRECTIVE_COORDINATE = 'DirectiveCoordinate'),
      (V.DIRECTIVE_ARGUMENT_COORDINATE = 'DirectiveArgumentCoordinate');
    let hE = Object.freeze({}),
      hS = {
        Name: { leave: (e) => e.value },
        Variable: { leave: (e) => '$' + e.name },
        Document: { leave: (e) => hC(e.definitions, '\n\n') },
        OperationDefinition: {
          leave(e) {
            let t = hI(e.variableDefinitions)
                ? hO('(\n', hC(e.variableDefinitions, '\n'), '\n)')
                : hO('(', hC(e.variableDefinitions, ', '), ')'),
              n =
                hO('', e.description, '\n') +
                hC([e.operation, hC([e.name, t]), hC(e.directives, ' ')], ' ');
            return ('query' === n ? '' : n + ' ') + e.selectionSet;
          },
        },
        VariableDefinition: {
          leave: ({ variable: e, type: t, defaultValue: n, directives: i, description: a }) =>
            hO('', a, '\n') + e + ': ' + t + hO(' = ', n) + hO(' ', hC(i, ' ')),
        },
        SelectionSet: { leave: ({ selections: e }) => hk(e) },
        Field: {
          leave({ alias: e, name: t, arguments: n, directives: i, selectionSet: a }) {
            let o = hO('', e, ': ') + t,
              s = o + hO('(', hC(n, ', '), ')');
            return (
              s.length > 80 && (s = o + hO('(\n', hA(hC(n, '\n')), '\n)')),
              hC([s, hC(i, ' '), a], ' ')
            );
          },
        },
        Argument: { leave: ({ name: e, value: t }) => e + ': ' + t },
        FragmentSpread: { leave: ({ name: e, directives: t }) => '...' + e + hO(' ', hC(t, ' ')) },
        InlineFragment: {
          leave: ({ typeCondition: e, directives: t, selectionSet: n }) =>
            hC(['...', hO('on ', e), hC(t, ' '), n], ' '),
        },
        FragmentDefinition: {
          leave: ({
            name: e,
            typeCondition: t,
            variableDefinitions: n,
            directives: i,
            selectionSet: a,
            description: o,
          }) =>
            hO('', o, '\n') +
            `fragment ${e}${hO('(', hC(n, ', '), ')')} ` +
            `on ${t} ${hO('', hC(i, ' '), ' ')}` +
            a,
        },
        IntValue: { leave: ({ value: e }) => e },
        FloatValue: { leave: ({ value: e }) => e },
        StringValue: {
          leave: ({ value: e, block: t }) => {
            let n, i, a, o, s, l, u, c, d, f, h;
            return t
              ? ((a = 1 === (i = (n = e.replace(/"""/g, '\\"""')).split(/\r\n|[\n\r]/g)).length),
                (o =
                  i.length > 1 && i.slice(1).every((e) => 0 === e.length || hm(e.charCodeAt(0)))),
                (s = n.endsWith('\\"""')),
                (l = e.endsWith('"') && !s),
                (u = e.endsWith('\\')),
                (c = l || u),
                (d = !a || e.length > 70 || c || o || s),
                (f = ''),
                (h = a && hm(e.charCodeAt(0))),
                ((d && !h) || o) && (f += '\n'),
                (f += n),
                (d || c) && (f += '\n'),
                '"""' + f + '"""')
              : `"${e.replace(hg, hy)}"`;
          },
        },
        BooleanValue: { leave: ({ value: e }) => (e ? 'true' : 'false') },
        NullValue: { leave: () => 'null' },
        EnumValue: { leave: ({ value: e }) => e },
        ListValue: { leave: ({ values: e }) => '[' + hC(e, ', ') + ']' },
        ObjectValue: { leave: ({ fields: e }) => '{' + hC(e, ', ') + '}' },
        ObjectField: { leave: ({ name: e, value: t }) => e + ': ' + t },
        Directive: { leave: ({ name: e, arguments: t }) => '@' + e + hO('(', hC(t, ', '), ')') },
        NamedType: { leave: ({ name: e }) => e },
        ListType: { leave: ({ type: e }) => '[' + e + ']' },
        NonNullType: { leave: ({ type: e }) => e + '!' },
        SchemaDefinition: {
          leave: ({ description: e, directives: t, operationTypes: n }) =>
            hO('', e, '\n') + hC(['schema', hC(t, ' '), hk(n)], ' '),
        },
        OperationTypeDefinition: { leave: ({ operation: e, type: t }) => e + ': ' + t },
        ScalarTypeDefinition: {
          leave: ({ description: e, name: t, directives: n }) =>
            hO('', e, '\n') + hC(['scalar', t, hC(n, ' ')], ' '),
        },
        ObjectTypeDefinition: {
          leave: ({ description: e, name: t, interfaces: n, directives: i, fields: a }) =>
            hO('', e, '\n') +
            hC(['type', t, hO('implements ', hC(n, ' & ')), hC(i, ' '), hk(a)], ' '),
        },
        FieldDefinition: {
          leave: ({ description: e, name: t, arguments: n, type: i, directives: a }) =>
            hO('', e, '\n') +
            t +
            (hI(n) ? hO('(\n', hA(hC(n, '\n')), '\n)') : hO('(', hC(n, ', '), ')')) +
            ': ' +
            i +
            hO(' ', hC(a, ' ')),
        },
        InputValueDefinition: {
          leave: ({ description: e, name: t, type: n, defaultValue: i, directives: a }) =>
            hO('', e, '\n') + hC([t + ': ' + n, hO('= ', i), hC(a, ' ')], ' '),
        },
        InterfaceTypeDefinition: {
          leave: ({ description: e, name: t, interfaces: n, directives: i, fields: a }) =>
            hO('', e, '\n') +
            hC(['interface', t, hO('implements ', hC(n, ' & ')), hC(i, ' '), hk(a)], ' '),
        },
        UnionTypeDefinition: {
          leave: ({ description: e, name: t, directives: n, types: i }) =>
            hO('', e, '\n') + hC(['union', t, hC(n, ' '), hO('= ', hC(i, ' | '))], ' '),
        },
        EnumTypeDefinition: {
          leave: ({ description: e, name: t, directives: n, values: i }) =>
            hO('', e, '\n') + hC(['enum', t, hC(n, ' '), hk(i)], ' '),
        },
        EnumValueDefinition: {
          leave: ({ description: e, name: t, directives: n }) =>
            hO('', e, '\n') + hC([t, hC(n, ' ')], ' '),
        },
        InputObjectTypeDefinition: {
          leave: ({ description: e, name: t, directives: n, fields: i }) =>
            hO('', e, '\n') + hC(['input', t, hC(n, ' '), hk(i)], ' '),
        },
        DirectiveDefinition: {
          leave: ({ description: e, name: t, arguments: n, repeatable: i, locations: a }) =>
            hO('', e, '\n') +
            'directive @' +
            t +
            (hI(n) ? hO('(\n', hA(hC(n, '\n')), '\n)') : hO('(', hC(n, ', '), ')')) +
            (i ? ' repeatable' : '') +
            ' on ' +
            hC(a, ' | '),
        },
        SchemaExtension: {
          leave: ({ directives: e, operationTypes: t }) =>
            hC(['extend schema', hC(e, ' '), hk(t)], ' '),
        },
        ScalarTypeExtension: {
          leave: ({ name: e, directives: t }) => hC(['extend scalar', e, hC(t, ' ')], ' '),
        },
        ObjectTypeExtension: {
          leave: ({ name: e, interfaces: t, directives: n, fields: i }) =>
            hC(['extend type', e, hO('implements ', hC(t, ' & ')), hC(n, ' '), hk(i)], ' '),
        },
        InterfaceTypeExtension: {
          leave: ({ name: e, interfaces: t, directives: n, fields: i }) =>
            hC(['extend interface', e, hO('implements ', hC(t, ' & ')), hC(n, ' '), hk(i)], ' '),
        },
        UnionTypeExtension: {
          leave: ({ name: e, directives: t, types: n }) =>
            hC(['extend union', e, hC(t, ' '), hO('= ', hC(n, ' | '))], ' '),
        },
        EnumTypeExtension: {
          leave: ({ name: e, directives: t, values: n }) =>
            hC(['extend enum', e, hC(t, ' '), hk(n)], ' '),
        },
        InputObjectTypeExtension: {
          leave: ({ name: e, directives: t, fields: n }) =>
            hC(['extend input', e, hC(t, ' '), hk(n)], ' '),
        },
        TypeCoordinate: { leave: ({ name: e }) => e },
        MemberCoordinate: { leave: ({ name: e, memberName: t }) => hC([e, hO('.', t)]) },
        ArgumentCoordinate: {
          leave: ({ name: e, fieldName: t, argumentName: n }) =>
            hC([e, hO('.', t), hO('(', n, ':)')]),
        },
        DirectiveCoordinate: { leave: ({ name: e }) => hC(['@', e]) },
        DirectiveArgumentCoordinate: {
          leave: ({ name: e, argumentName: t }) => hC(['@', e, hO('(', t, ':)')]),
        },
      };
    function hC(e, t = '') {
      var n;
      return null != (n = null == e ? void 0 : e.filter((e) => e).join(t)) ? n : '';
    }
    function hk(e) {
      return hO('{\n', hA(hC(e, '\n')), '\n}');
    }
    function hO(e, t, n = '') {
      return null != t && '' !== t ? e + t + n : '';
    }
    function hA(e) {
      return hO('  ', e.replace(/\n/g, '\n  '));
    }
    function hI(e) {
      var t;
      return null != (t = null == e ? void 0 : e.some((e) => e.includes('\n'))) && t;
    }
    var hj = (e) => {
        throw TypeError(e);
      },
      hT = (e, t, n) => t.has(e) || hj('Cannot ' + n),
      hR = (e, t, n) => (hT(e, t, 'read from private field'), n ? n.call(e) : t.get(e)),
      hM = (e, t, n) =>
        t.has(e)
          ? hj('Cannot add the same private member more than once')
          : t instanceof WeakSet
          ? t.add(e)
          : t.set(e, n),
      hP = (e, t, n, i) => (hT(e, t, 'write to private field'), i ? i.call(e, n) : t.set(e, n), n);
    class hN extends Error {}
    class h_ {
      constructor({ url: e, fetch: t = fetch, headers: n = {}, queries: i = {} }) {
        hM(this, eU),
          hM(this, eF),
          hM(this, eL),
          hM(this, ez),
          hP(this, eU, e),
          hP(this, eF, i),
          hP(this, eL, n),
          hP(this, ez, (...e) => t(...e));
      }
      async query(e) {
        let t = await hR(this, ez).call(this, hR(this, eU), {
          method: 'POST',
          headers: { 'Content-Type': 'application/json', ...hR(this, eL) },
          body: JSON.stringify({
            query:
              'string' == typeof e.query
                ? String(e.query)
                : (function (e, t, n = hv) {
                    let i,
                      a,
                      o,
                      s = new Map();
                    for (let e of Object.values(eB))
                      s.set(
                        e,
                        (function (e, t) {
                          let n = e[t];
                          return 'object' == typeof n
                            ? n
                            : 'function' == typeof n
                            ? { enter: n, leave: void 0 }
                            : { enter: e.enter, leave: e.leave };
                        })(t, e)
                      );
                    let l = Array.isArray(e),
                      u = [e],
                      c = -1,
                      d = [],
                      f = e,
                      h = [],
                      p = [];
                    do {
                      var m, g, y;
                      let e,
                        b = ++c === u.length,
                        v = b && 0 !== d.length;
                      if (b) {
                        if (
                          ((a = 0 === p.length ? void 0 : h[h.length - 1]),
                          (f = o),
                          (o = p.pop()),
                          v)
                        )
                          if (l) {
                            f = f.slice();
                            let e = 0;
                            for (let [t, n] of d) {
                              let i = t - e;
                              null === n ? (f.splice(i, 1), e++) : (f[i] = n);
                            }
                          } else for (let [e, t] of ((f = { ...f }), d)) f[e] = t;
                        (c = i.index), (u = i.keys), (d = i.edits), (l = i.inArray), (i = i.prev);
                      } else if (o) {
                        if (null == (f = o[(a = l ? c : u[c])])) continue;
                        h.push(a);
                      }
                      if (!Array.isArray(f)) {
                        hx(f) ||
                          (function (e, t) {
                            if (!e) throw Error(t);
                          })(
                            !1,
                            `Invalid AST Node: ${(function e(t, n) {
                              switch (typeof t) {
                                case 'string':
                                  return JSON.stringify(t);
                                case 'function':
                                  return t.name ? `[function ${t.name}]` : '[function]';
                                case 'object':
                                  return (function (t, n) {
                                    let i;
                                    if (null === t) return 'null';
                                    if (n.includes(t)) return '[Circular]';
                                    let a = [...n, t];
                                    if ('function' == typeof t.toJSON) {
                                      let n = t.toJSON();
                                      if (n !== t) return 'string' == typeof n ? n : e(n, a);
                                    } else if (Array.isArray(t)) {
                                      var o,
                                        s,
                                        l = t,
                                        u = a;
                                      if (0 === l.length) return '[]';
                                      if (u.length > 2) return '[Array]';
                                      let n = Math.min(10, l.length),
                                        i = l.length - n,
                                        c = [];
                                      for (let t = 0; t < n; ++t) c.push(e(l[t], u));
                                      return (
                                        1 === i
                                          ? c.push('... 1 more item')
                                          : i > 1 && c.push(`... ${i} more items`),
                                        '[' + c.join(', ') + ']'
                                      );
                                    }
                                    return (
                                      (o = t),
                                      (s = a),
                                      0 === (i = Object.entries(o)).length
                                        ? '{}'
                                        : s.length > 2
                                        ? '[' +
                                          (function (e) {
                                            let t = Object.prototype.toString
                                              .call(e)
                                              .replace(/^\[object /, '')
                                              .replace(/]$/, '');
                                            if (
                                              'Object' === t &&
                                              'function' == typeof e.constructor
                                            ) {
                                              let t = e.constructor.name;
                                              if ('string' == typeof t && '' !== t) return t;
                                            }
                                            return t;
                                          })(o) +
                                          ']'
                                        : '{ ' +
                                          i.map(([t, n]) => t + ': ' + e(n, s)).join(', ') +
                                          ' }'
                                    );
                                  })(t, n);
                                default:
                                  return String(t);
                              }
                            })(f, [])}.`
                          );
                        let n = b
                          ? null == (m = s.get(f.kind))
                            ? void 0
                            : m.leave
                          : null == (g = s.get(f.kind))
                          ? void 0
                          : g.enter;
                        if ((e = null == n ? void 0 : n.call(t, f, a, o, h, p)) === hE) break;
                        if (!1 === e) {
                          if (!b) {
                            h.pop();
                            continue;
                          }
                        } else if (void 0 !== e && (d.push([a, e]), !b))
                          if (hx(e)) f = e;
                          else {
                            h.pop();
                            continue;
                          }
                      }
                      void 0 === e && v && d.push([a, f]),
                        b
                          ? h.pop()
                          : ((i = { inArray: l, index: c, keys: u, edits: d, prev: i }),
                            (u = (l = Array.isArray(f)) ? f : null != (y = n[f.kind]) ? y : []),
                            (c = -1),
                            (d = []),
                            o && p.push(o),
                            (o = f));
                    } while (void 0 !== i);
                    return 0 !== d.length ? d[d.length - 1][1] : e;
                  })(e.query, hS),
            variables: e.variables,
            extensions: e.extensions,
            operationName: e.operationName,
          }),
        });
        if (!t.ok) throw new hN(`GraphQL request failed: ${t.statusText} (${t.status})`);
        return await t.json();
      }
      async execute(e, t) {
        return this.query({ ...t, query: hR(this, eF)[e] });
      }
    }
    (eU = new WeakMap()), (eF = new WeakMap()), (eL = new WeakMap()), (ez = new WeakMap());
    var hD = e.i(96510),
      hB = e.i(93453);
    function hU(e, t) {
      return fM
        .IntentMessage(fM.fixedArray(t.length, fM.u8()))
        .serialize({
          intent: { scope: { [e]: !0 }, version: { V0: !0 }, appId: { Iota: !0 } },
          value: t,
        })
        .toBytes();
    }
    let hF = { ED25519: 0, Secp256k1: 1, Secp256r1: 2, MultiSig: 3, Passkey: 6 },
      hL = { ED25519: 32, Secp256k1: 33, Secp256r1: 33 },
      hz = { 0: 'ED25519', 1: 'Secp256k1', 2: 'Secp256r1', 3: 'MultiSig', 6: 'Passkey' },
      hV = Uint32Array.from([
        0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4,
        0xab1c5ed5, 0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe,
        0x9bdc06a7, 0xc19bf174, 0xe49b69c1, 0xefbe4786, 0xfc19dc6, 0x240ca1cc, 0x2de92c6f,
        0x4a7484aa, 0x5cb0a9dc, 0x76f988da, 0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,
        0xc6e00bf3, 0xd5a79147, 0x6ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc,
        0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85, 0xa2bfe8a1, 0xa81a664b,
        0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070, 0x19a4c116,
        0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7,
        0xc67178f2,
      ]),
      h$ = new Uint32Array(64);
    class hW extends uM {
      constructor(e = 32) {
        super(64, e, 8, !1),
          (this.A = 0 | uP[0]),
          (this.B = 0 | uP[1]),
          (this.C = 0 | uP[2]),
          (this.D = 0 | uP[3]),
          (this.E = 0 | uP[4]),
          (this.F = 0 | uP[5]),
          (this.G = 0 | uP[6]),
          (this.H = 0 | uP[7]);
      }
      get() {
        let { A: e, B: t, C: n, D: i, E: a, F: o, G: s, H: l } = this;
        return [e, t, n, i, a, o, s, l];
      }
      set(e, t, n, i, a, o, s, l) {
        (this.A = 0 | e),
          (this.B = 0 | t),
          (this.C = 0 | n),
          (this.D = 0 | i),
          (this.E = 0 | a),
          (this.F = 0 | o),
          (this.G = 0 | s),
          (this.H = 0 | l);
      }
      process(e, t) {
        for (let n = 0; n < 16; n++, t += 4) h$[n] = e.getUint32(t, !1);
        for (let e = 16; e < 64; e++) {
          let t = h$[e - 15],
            n = h$[e - 2],
            i = up(t, 7) ^ up(t, 18) ^ (t >>> 3),
            a = up(n, 17) ^ up(n, 19) ^ (n >>> 10);
          h$[e] = (a + h$[e - 7] + i + h$[e - 16]) | 0;
        }
        let { A: n, B: i, C: a, D: o, E: s, F: l, G: u, H: c } = this;
        for (let e = 0; e < 64; e++) {
          var d, f, h, p;
          let t =
              (c +
                (up(s, 6) ^ up(s, 11) ^ up(s, 25)) +
                (((d = s) & l) ^ (~d & u)) +
                hV[e] +
                h$[e]) |
              0,
            m =
              ((up(n, 2) ^ up(n, 13) ^ up(n, 22)) +
                (((f = n) & (h = i)) ^ (f & (p = a)) ^ (h & p))) |
              0;
          (c = u),
            (u = l),
            (l = s),
            (s = (o + t) | 0),
            (o = a),
            (a = i),
            (i = n),
            (n = (t + m) | 0);
        }
        (n = (n + this.A) | 0),
          (i = (i + this.B) | 0),
          (a = (a + this.C) | 0),
          (o = (o + this.D) | 0),
          (s = (s + this.E) | 0),
          (l = (l + this.F) | 0),
          (u = (u + this.G) | 0),
          (c = (c + this.H) | 0),
          this.set(n, i, a, o, s, l, u, c);
      }
      roundClean() {
        uf(h$);
      }
      destroy() {
        this.set(0, 0, 0, 0, 0, 0, 0, 0), uf(this.buffer);
      }
    }
    let hq = (function (e, t = !1) {
        let n = e.length,
          i = new Uint32Array(n),
          a = new Uint32Array(n);
        for (let o = 0; o < n; o++) {
          let { h: n, l: s } = uF(e[o], t);
          [i[o], a[o]] = [n, s];
        }
        return [i, a];
      })(
        [
          '0x428a2f98d728ae22',
          '0x7137449123ef65cd',
          '0xb5c0fbcfec4d3b2f',
          '0xe9b5dba58189dbbc',
          '0x3956c25bf348b538',
          '0x59f111f1b605d019',
          '0x923f82a4af194f9b',
          '0xab1c5ed5da6d8118',
          '0xd807aa98a3030242',
          '0x12835b0145706fbe',
          '0x243185be4ee4b28c',
          '0x550c7dc3d5ffb4e2',
          '0x72be5d74f27b896f',
          '0x80deb1fe3b1696b1',
          '0x9bdc06a725c71235',
          '0xc19bf174cf692694',
          '0xe49b69c19ef14ad2',
          '0xefbe4786384f25e3',
          '0x0fc19dc68b8cd5b5',
          '0x240ca1cc77ac9c65',
          '0x2de92c6f592b0275',
          '0x4a7484aa6ea6e483',
          '0x5cb0a9dcbd41fbd4',
          '0x76f988da831153b5',
          '0x983e5152ee66dfab',
          '0xa831c66d2db43210',
          '0xb00327c898fb213f',
          '0xbf597fc7beef0ee4',
          '0xc6e00bf33da88fc2',
          '0xd5a79147930aa725',
          '0x06ca6351e003826f',
          '0x142929670a0e6e70',
          '0x27b70a8546d22ffc',
          '0x2e1b21385c26c926',
          '0x4d2c6dfc5ac42aed',
          '0x53380d139d95b3df',
          '0x650a73548baf63de',
          '0x766a0abb3c77b2a8',
          '0x81c2c92e47edaee6',
          '0x92722c851482353b',
          '0xa2bfe8a14cf10364',
          '0xa81a664bbc423001',
          '0xc24b8b70d0f89791',
          '0xc76c51a30654be30',
          '0xd192e819d6ef5218',
          '0xd69906245565a910',
          '0xf40e35855771202a',
          '0x106aa07032bbd1b8',
          '0x19a4c116b8d2d0c8',
          '0x1e376c085141ab53',
          '0x2748774cdf8eeb99',
          '0x34b0bcb5e19b48a8',
          '0x391c0cb3c5c95a63',
          '0x4ed8aa4ae3418acb',
          '0x5b9cca4f7763e373',
          '0x682e6ff3d6b2b8a3',
          '0x748f82ee5defb2fc',
          '0x78a5636f43172f60',
          '0x84c87814a1f0ab72',
          '0x8cc702081a6439ec',
          '0x90befffa23631e28',
          '0xa4506cebde82bde9',
          '0xbef9a3f7b2c67915',
          '0xc67178f2e372532b',
          '0xca273eceea26619c',
          '0xd186b8c721c0c207',
          '0xeada7dd6cde0eb1e',
          '0xf57d4f7fee6ed178',
          '0x06f067aa72176fba',
          '0x0a637dc5a2c898a6',
          '0x113f9804bef90dae',
          '0x1b710b35131c471b',
          '0x28db77f523047d84',
          '0x32caab7b40c72493',
          '0x3c9ebe0a15c9bebc',
          '0x431d67c49c100d4c',
          '0x4cc5d4becb3e42b6',
          '0x597f299cfc657e2a',
          '0x5fcb6fab3ad6faec',
          '0x6c44198c4a475817',
        ].map((e) => BigInt(e))
      ),
      hK = hq[0],
      hG = hq[1],
      hH = new Uint32Array(80),
      hZ = new Uint32Array(80);
    class hY extends uM {
      constructor(e = 64) {
        super(128, e, 16, !1),
          (this.Ah = 0 | uD[0]),
          (this.Al = 0 | uD[1]),
          (this.Bh = 0 | uD[2]),
          (this.Bl = 0 | uD[3]),
          (this.Ch = 0 | uD[4]),
          (this.Cl = 0 | uD[5]),
          (this.Dh = 0 | uD[6]),
          (this.Dl = 0 | uD[7]),
          (this.Eh = 0 | uD[8]),
          (this.El = 0 | uD[9]),
          (this.Fh = 0 | uD[10]),
          (this.Fl = 0 | uD[11]),
          (this.Gh = 0 | uD[12]),
          (this.Gl = 0 | uD[13]),
          (this.Hh = 0 | uD[14]),
          (this.Hl = 0 | uD[15]);
      }
      get() {
        let {
          Ah: e,
          Al: t,
          Bh: n,
          Bl: i,
          Ch: a,
          Cl: o,
          Dh: s,
          Dl: l,
          Eh: u,
          El: c,
          Fh: d,
          Fl: f,
          Gh: h,
          Gl: p,
          Hh: m,
          Hl: g,
        } = this;
        return [e, t, n, i, a, o, s, l, u, c, d, f, h, p, m, g];
      }
      set(e, t, n, i, a, o, s, l, u, c, d, f, h, p, m, g) {
        (this.Ah = 0 | e),
          (this.Al = 0 | t),
          (this.Bh = 0 | n),
          (this.Bl = 0 | i),
          (this.Ch = 0 | a),
          (this.Cl = 0 | o),
          (this.Dh = 0 | s),
          (this.Dl = 0 | l),
          (this.Eh = 0 | u),
          (this.El = 0 | c),
          (this.Fh = 0 | d),
          (this.Fl = 0 | f),
          (this.Gh = 0 | h),
          (this.Gl = 0 | p),
          (this.Hh = 0 | m),
          (this.Hl = 0 | g);
      }
      process(e, t) {
        for (let n = 0; n < 16; n++, t += 4)
          (hH[n] = e.getUint32(t)), (hZ[n] = e.getUint32((t += 4)));
        for (let e = 16; e < 80; e++) {
          let t = 0 | hH[e - 15],
            n = 0 | hZ[e - 15],
            i = uV(t, n, 1) ^ uV(t, n, 8) ^ uL(t, n, 7),
            a = u$(t, n, 1) ^ u$(t, n, 8) ^ uz(t, n, 7),
            o = 0 | hH[e - 2],
            s = 0 | hZ[e - 2],
            l = uV(o, s, 19) ^ uW(o, s, 61) ^ uL(o, s, 6),
            u = uZ(a, u$(o, s, 19) ^ uq(o, s, 61) ^ uz(o, s, 6), hZ[e - 7], hZ[e - 16]),
            c = uY(u, i, l, hH[e - 7], hH[e - 16]);
          (hH[e] = 0 | c), (hZ[e] = 0 | u);
        }
        let {
          Ah: n,
          Al: i,
          Bh: a,
          Bl: o,
          Ch: s,
          Cl: l,
          Dh: u,
          Dl: c,
          Eh: d,
          El: f,
          Fh: h,
          Fl: p,
          Gh: m,
          Gl: g,
          Hh: y,
          Hl: b,
        } = this;
        for (let e = 0; e < 80; e++) {
          let t = uV(d, f, 14) ^ uV(d, f, 18) ^ uW(d, f, 41),
            v = u$(d, f, 14) ^ u$(d, f, 18) ^ uq(d, f, 41),
            w = (d & h) ^ (~d & m),
            x = uQ(b, v, (f & p) ^ (~f & g), hG[e], hZ[e]),
            E = uX(x, y, t, w, hK[e], hH[e]),
            S = 0 | x,
            C = uV(n, i, 28) ^ uW(n, i, 34) ^ uW(n, i, 39),
            k = u$(n, i, 28) ^ uq(n, i, 34) ^ uq(n, i, 39),
            O = (n & a) ^ (n & s) ^ (a & s),
            A = (i & o) ^ (i & l) ^ (o & l);
          (y = 0 | m),
            (b = 0 | g),
            (m = 0 | h),
            (g = 0 | p),
            (h = 0 | d),
            (p = 0 | f),
            ({ h: d, l: f } = uK(0 | u, 0 | c, 0 | E, 0 | S)),
            (u = 0 | s),
            (c = 0 | l),
            (s = 0 | a),
            (l = 0 | o),
            (a = 0 | n),
            (o = 0 | i);
          let I = uG(S, k, A);
          (n = uH(I, E, C, O)), (i = 0 | I);
        }
        ({ h: n, l: i } = uK(0 | this.Ah, 0 | this.Al, 0 | n, 0 | i)),
          ({ h: a, l: o } = uK(0 | this.Bh, 0 | this.Bl, 0 | a, 0 | o)),
          ({ h: s, l: l } = uK(0 | this.Ch, 0 | this.Cl, 0 | s, 0 | l)),
          ({ h: u, l: c } = uK(0 | this.Dh, 0 | this.Dl, 0 | u, 0 | c)),
          ({ h: d, l: f } = uK(0 | this.Eh, 0 | this.El, 0 | d, 0 | f)),
          ({ h: h, l: p } = uK(0 | this.Fh, 0 | this.Fl, 0 | h, 0 | p)),
          ({ h: m, l: g } = uK(0 | this.Gh, 0 | this.Gl, 0 | m, 0 | g)),
          ({ h: y, l: b } = uK(0 | this.Hh, 0 | this.Hl, 0 | y, 0 | b)),
          this.set(n, i, a, o, s, l, u, c, d, f, h, p, m, g, y, b);
      }
      roundClean() {
        uf(hH, hZ);
      }
      destroy() {
        uf(this.buffer), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
      }
    }
    class hQ extends hY {
      constructor() {
        super(48),
          (this.Ah = 0 | u_[0]),
          (this.Al = 0 | u_[1]),
          (this.Bh = 0 | u_[2]),
          (this.Bl = 0 | u_[3]),
          (this.Ch = 0 | u_[4]),
          (this.Cl = 0 | u_[5]),
          (this.Dh = 0 | u_[6]),
          (this.Dl = 0 | u_[7]),
          (this.Eh = 0 | u_[8]),
          (this.El = 0 | u_[9]),
          (this.Fh = 0 | u_[10]),
          (this.Fl = 0 | u_[11]),
          (this.Gh = 0 | u_[12]),
          (this.Gl = 0 | u_[13]),
          (this.Hh = 0 | u_[14]),
          (this.Hl = 0 | u_[15]);
      }
    }
    let hX = uj(() => new hW()),
      hJ = uj(() => new hY()),
      h0 = uj(() => new hQ());
    class h1 extends uI {
      constructor(e, t) {
        super(), (this.finished = !1), (this.destroyed = !1), ul(e);
        const n = uk(t);
        if (((this.iHash = e.create()), 'function' != typeof this.iHash.update))
          throw Error('Expected instance of class which extends utils.Hash');
        (this.blockLen = this.iHash.blockLen), (this.outputLen = this.iHash.outputLen);
        const i = this.blockLen,
          a = new Uint8Array(i);
        a.set(n.length > i ? e.create().update(n).digest() : n);
        for (let e = 0; e < a.length; e++) a[e] ^= 54;
        this.iHash.update(a), (this.oHash = e.create());
        for (let e = 0; e < a.length; e++) a[e] ^= 106;
        this.oHash.update(a), uf(a);
      }
      update(e) {
        return uu(this), this.iHash.update(e), this;
      }
      digestInto(e) {
        uu(this),
          us(e, this.outputLen),
          (this.finished = !0),
          this.iHash.digestInto(e),
          this.oHash.update(e),
          this.oHash.digestInto(e),
          this.destroy();
      }
      digest() {
        let e = new Uint8Array(this.oHash.outputLen);
        return this.digestInto(e), e;
      }
      _cloneInto(e) {
        e || (e = Object.create(Object.getPrototypeOf(this), {}));
        let { oHash: t, iHash: n, finished: i, destroyed: a, blockLen: o, outputLen: s } = this;
        return (
          (e.finished = i),
          (e.destroyed = a),
          (e.blockLen = o),
          (e.outputLen = s),
          (e.oHash = t._cloneInto(e.oHash)),
          (e.iHash = n._cloneInto(e.iHash)),
          e
        );
      }
      clone() {
        return this._cloneInto();
      }
      destroy() {
        (this.destroyed = !0), this.oHash.destroy(), this.iHash.destroy();
      }
    }
    let h5 = (e, t, n) => new h1(e, t).update(n).digest();
    h5.create = (e, t) => new h1(e, t);
    let h2 = BigInt(0),
      h6 = BigInt(1);
    function h3(e, t = '') {
      if ('boolean' != typeof e)
        throw Error((t && `"${t}"`) + 'expected boolean, got type=' + typeof e);
      return e;
    }
    function h4(e, t, n = '') {
      let i = ua(e),
        a = e?.length,
        o = void 0 !== t;
      if (!i || (o && a !== t))
        throw Error(
          (n && `"${n}" `) +
            'expected Uint8Array' +
            (o ? ` of length ${t}` : '') +
            ', got ' +
            (i ? `length=${a}` : `type=${typeof e}`)
        );
      return e;
    }
    function h8(e) {
      let t = e.toString(16);
      return 1 & t.length ? '0' + t : t;
    }
    function h9(e) {
      if ('string' != typeof e) throw Error('hex string expected, got ' + typeof e);
      return '' === e ? h2 : BigInt('0x' + e);
    }
    function h7(e) {
      return h9(ux(e));
    }
    function pe(e) {
      return us(e), h9(ux(Uint8Array.from(e).reverse()));
    }
    function pt(e, t) {
      return uS(e.toString(16).padStart(2 * t, '0'));
    }
    function pr(e, t) {
      return pt(e, t).reverse();
    }
    function pn(e, t, n) {
      let i;
      if ('string' == typeof t)
        try {
          i = uS(t);
        } catch (t) {
          throw Error(e + ' must be hex string or Uint8Array, cause: ' + t);
        }
      else if (ua(t)) i = Uint8Array.from(t);
      else throw Error(e + ' must be hex string or Uint8Array');
      let a = i.length;
      if ('number' == typeof n && a !== n)
        throw Error(e + ' of length ' + n + ' expected, got ' + a);
      return i;
    }
    let pi = (e) => 'bigint' == typeof e && h2 <= e;
    function pa(e) {
      let t;
      for (t = 0; e > h2; e >>= h6, t += 1);
      return t;
    }
    let po = (e) => (h6 << BigInt(e)) - h6;
    function ps(e, t, n = {}) {
      if (!e || 'object' != typeof e) throw Error('expected valid options object');
      function i(t, n, i) {
        let a = e[t];
        if (i && void 0 === a) return;
        let o = typeof a;
        if (o !== n || null === a) throw Error(`param "${t}" is invalid: expected ${n}, got ${o}`);
      }
      Object.entries(t).forEach(([e, t]) => i(e, t, !1)),
        Object.entries(n).forEach(([e, t]) => i(e, t, !0));
    }
    function pl(e) {
      let t = new WeakMap();
      return (n, ...i) => {
        let a = t.get(n);
        if (void 0 !== a) return a;
        let o = e(n, ...i);
        return t.set(n, o), o;
      };
    }
    let pu = BigInt(0),
      pc = BigInt(1),
      pd = BigInt(2),
      pf = BigInt(3),
      ph = BigInt(4),
      pp = BigInt(5),
      pm = BigInt(7),
      pg = BigInt(8),
      py = BigInt(9),
      pb = BigInt(16);
    function pv(e, t) {
      let n = e % t;
      return n >= pu ? n : t + n;
    }
    function pw(e, t) {
      if (e === pu) throw Error('invert: expected non-zero number');
      if (t <= pu) throw Error('invert: expected positive modulus, got ' + t);
      let n = pv(e, t),
        i = t,
        a = pu,
        o = pc,
        s = pc,
        l = pu;
      for (; n !== pu; ) {
        let e = i / n,
          t = i % n,
          u = a - s * e,
          c = o - l * e;
        (i = n), (n = t), (a = s), (o = l), (s = u), (l = c);
      }
      if (i !== pc) throw Error('invert: does not exist');
      return pv(a, t);
    }
    function px(e, t, n) {
      if (!e.eql(e.sqr(t), n)) throw Error('Cannot find square root');
    }
    function pE(e, t) {
      let n = (e.ORDER + pc) / ph,
        i = e.pow(t, n);
      return px(e, i, t), i;
    }
    function pS(e, t) {
      let n = (e.ORDER - pp) / pg,
        i = e.mul(t, pd),
        a = e.pow(i, n),
        o = e.mul(t, a),
        s = e.mul(e.mul(o, pd), a),
        l = e.mul(o, e.sub(s, e.ONE));
      return px(e, l, t), l;
    }
    function pC(e) {
      if (e < pf) throw Error('sqrt is not defined for small field');
      let t = e - pc,
        n = 0;
      for (; t % pd === pu; ) (t /= pd), n++;
      let i = pd,
        a = pT(e);
      for (; 1 === pI(a, i); )
        if (i++ > 1e3) throw Error('Cannot find square root: probably non-prime P');
      if (1 === n) return pE;
      let o = a.pow(i, t),
        s = (t + pc) / pd;
      return function (e, i) {
        if (e.is0(i)) return i;
        if (1 !== pI(e, i)) throw Error('Cannot find square root');
        let a = n,
          l = e.mul(e.ONE, o),
          u = e.pow(i, t),
          c = e.pow(i, s);
        for (; !e.eql(u, e.ONE); ) {
          if (e.is0(u)) return e.ZERO;
          let t = 1,
            n = e.sqr(u);
          for (; !e.eql(n, e.ONE); )
            if ((t++, (n = e.sqr(n)), t === a)) throw Error('Cannot find square root');
          let i = pc << BigInt(a - t - 1),
            o = e.pow(l, i);
          (a = t), (l = e.sqr(o)), (u = e.mul(u, l)), (c = e.mul(c, o));
        }
        return c;
      };
    }
    let pk = [
      'create',
      'isValid',
      'is0',
      'neg',
      'inv',
      'sqrt',
      'sqr',
      'eql',
      'add',
      'sub',
      'mul',
      'pow',
      'div',
      'addN',
      'subN',
      'mulN',
      'sqrN',
    ];
    function pO(e) {
      return (
        ps(
          e,
          pk.reduce((e, t) => ((e[t] = 'function'), e), {
            ORDER: 'bigint',
            MASK: 'bigint',
            BYTES: 'number',
            BITS: 'number',
          })
        ),
        e
      );
    }
    function pA(e, t, n = !1) {
      let i = Array(t.length).fill(n ? e.ZERO : void 0),
        a = t.reduce((t, n, a) => (e.is0(n) ? t : ((i[a] = t), e.mul(t, n))), e.ONE),
        o = e.inv(a);
      return (
        t.reduceRight((t, n, a) => (e.is0(n) ? t : ((i[a] = e.mul(t, i[a])), e.mul(t, n))), o), i
      );
    }
    function pI(e, t) {
      let n = (e.ORDER - pc) / pd,
        i = e.pow(t, n),
        a = e.eql(i, e.ONE),
        o = e.eql(i, e.ZERO),
        s = e.eql(i, e.neg(e.ONE));
      if (!a && !o && !s) throw Error('invalid Legendre symbol result');
      return a ? 1 : o ? 0 : -1;
    }
    function pj(e, t) {
      void 0 !== t && uo(t);
      let n = void 0 !== t ? t : e.toString(2).length,
        i = Math.ceil(n / 8);
      return { nBitLength: n, nByteLength: i };
    }
    function pT(e, t, n = !1, i = {}) {
      let a, o, s, l;
      if (e <= pu) throw Error('invalid field: expected ORDER > 0, got ' + e);
      let u = !1;
      if ('object' == typeof t && null != t) {
        if (i.sqrt || n) throw Error('cannot specify opts in two arguments');
        t.BITS && (o = t.BITS),
          t.sqrt && (s = t.sqrt),
          'boolean' == typeof t.isLE && (n = t.isLE),
          'boolean' == typeof t.modFromBytes && (u = t.modFromBytes),
          (l = t.allowedLengths);
      } else 'number' == typeof t && (o = t), i.sqrt && (s = i.sqrt);
      let { nBitLength: c, nByteLength: d } = pj(e, o);
      if (d > 2048) throw Error('invalid field: expected ORDER of <= 2048 bytes');
      let f = Object.freeze({
        ORDER: e,
        isLE: n,
        BITS: c,
        BYTES: d,
        MASK: po(c),
        ZERO: pu,
        ONE: pc,
        allowedLengths: l,
        create: (t) => pv(t, e),
        isValid: (t) => {
          if ('bigint' != typeof t)
            throw Error('invalid field element: expected bigint, got ' + typeof t);
          return pu <= t && t < e;
        },
        is0: (e) => e === pu,
        isValidNot0: (e) => !f.is0(e) && f.isValid(e),
        isOdd: (e) => (e & pc) === pc,
        neg: (t) => pv(-t, e),
        eql: (e, t) => e === t,
        sqr: (t) => pv(t * t, e),
        add: (t, n) => pv(t + n, e),
        sub: (t, n) => pv(t - n, e),
        mul: (t, n) => pv(t * n, e),
        pow: (e, t) =>
          (function (e, t, n) {
            if (n < pu) throw Error('invalid exponent, negatives unsupported');
            if (n === pu) return e.ONE;
            if (n === pc) return t;
            let i = e.ONE,
              a = t;
            for (; n > pu; ) n & pc && (i = e.mul(i, a)), (a = e.sqr(a)), (n >>= pc);
            return i;
          })(f, e, t),
        div: (t, n) => pv(t * pw(n, e), e),
        sqrN: (e) => e * e,
        addN: (e, t) => e + t,
        subN: (e, t) => e - t,
        mulN: (e, t) => e * t,
        inv: (t) => pw(t, e),
        sqrt:
          s ||
          ((t) => (
            a ||
              (a = (function (e) {
                if (e % ph === pf) return pE;
                if (e % pg === pp) return pS;
                if (e % pb === py) {
                  let t, n, i, a, o, s;
                  return (
                    (t = pT(e)),
                    (i = (n = pC(e))(t, t.neg(t.ONE))),
                    (a = n(t, i)),
                    (o = n(t, t.neg(i))),
                    (s = (e + pm) / pb),
                    (e, t) => {
                      let n = e.pow(t, s),
                        l = e.mul(n, i),
                        u = e.mul(n, a),
                        c = e.mul(n, o),
                        d = e.eql(e.sqr(l), t),
                        f = e.eql(e.sqr(u), t);
                      (n = e.cmov(n, l, d)), (l = e.cmov(c, u, f));
                      let h = e.eql(e.sqr(l), t),
                        p = e.cmov(n, l, h);
                      return px(e, p, t), p;
                    }
                  );
                }
                return pC(e);
              })(e)),
            a(f, t)
          )),
        toBytes: (e) => (n ? pr(e, d) : pt(e, d)),
        fromBytes: (t, i = !0) => {
          if (l) {
            if (!l.includes(t.length) || t.length > d)
              throw Error('Field.fromBytes: expected ' + l + ' bytes, got ' + t.length);
            let e = new Uint8Array(d);
            e.set(t, n ? 0 : e.length - t.length), (t = e);
          }
          if (t.length !== d)
            throw Error('Field.fromBytes: expected ' + d + ' bytes, got ' + t.length);
          let a = n ? pe(t) : h7(t);
          if ((u && (a = pv(a, e)), !i && !f.isValid(a)))
            throw Error('invalid field element: outside of range 0..ORDER');
          return a;
        },
        invertBatch: (e) => pA(f, e),
        cmov: (e, t, n) => (n ? t : e),
      });
      return Object.freeze(f);
    }
    function pR(e) {
      if ('bigint' != typeof e) throw Error('field order must be bigint');
      return Math.ceil(e.toString(2).length / 8);
    }
    function pM(e) {
      let t = pR(e);
      return t + Math.ceil(t / 2);
    }
    let pP = BigInt(0),
      pN = BigInt(1);
    function p_(e, t) {
      let n = t.negate();
      return e ? n : t;
    }
    function pD(e, t) {
      let n = pA(
        e.Fp,
        t.map((e) => e.Z)
      );
      return t.map((t, i) => e.fromAffine(t.toAffine(n[i])));
    }
    function pB(e, t) {
      if (!Number.isSafeInteger(e) || e <= 0 || e > t)
        throw Error('invalid window size, expected [1..' + t + '], got W=' + e);
    }
    function pU(e, t) {
      pB(e, t);
      let n = Math.ceil(t / e) + 1,
        i = 2 ** (e - 1),
        a = 2 ** e;
      return { windows: n, windowSize: i, mask: po(e), maxNumber: a, shiftBy: BigInt(e) };
    }
    function pF(e, t, n) {
      let { windowSize: i, mask: a, maxNumber: o, shiftBy: s } = n,
        l = Number(e & a),
        u = e >> s;
      l > i && ((l -= o), (u += pN));
      let c = t * i,
        d = c + Math.abs(l) - 1,
        f = 0 === l;
      return { nextN: u, offset: d, isZero: f, isNeg: l < 0, isNegF: t % 2 != 0, offsetF: c };
    }
    let pL = new WeakMap(),
      pz = new WeakMap();
    function pV(e) {
      return pz.get(e) || 1;
    }
    function p$(e) {
      if (e !== pP) throw Error('invalid wNAF');
    }
    class pW {
      constructor(e, t) {
        (this.BASE = e.BASE), (this.ZERO = e.ZERO), (this.Fn = e.Fn), (this.bits = t);
      }
      _unsafeLadder(e, t, n = this.ZERO) {
        let i = e;
        for (; t > pP; ) t & pN && (n = n.add(i)), (i = i.double()), (t >>= pN);
        return n;
      }
      precomputeWindow(e, t) {
        let { windows: n, windowSize: i } = pU(t, this.bits),
          a = [],
          o = e,
          s = o;
        for (let e = 0; e < n; e++) {
          (s = o), a.push(s);
          for (let e = 1; e < i; e++) (s = s.add(o)), a.push(s);
          o = s.double();
        }
        return a;
      }
      wNAF(e, t, n) {
        if (!this.Fn.isValid(n)) throw Error('invalid scalar');
        let i = this.ZERO,
          a = this.BASE,
          o = pU(e, this.bits);
        for (let e = 0; e < o.windows; e++) {
          let { nextN: s, offset: l, isZero: u, isNeg: c, isNegF: d, offsetF: f } = pF(n, e, o);
          (n = s), u ? (a = a.add(p_(d, t[f]))) : (i = i.add(p_(c, t[l])));
        }
        return p$(n), { p: i, f: a };
      }
      wNAFUnsafe(e, t, n, i = this.ZERO) {
        let a = pU(e, this.bits);
        for (let e = 0; e < a.windows && n !== pP; e++) {
          let { nextN: o, offset: s, isZero: l, isNeg: u } = pF(n, e, a);
          if (((n = o), !l)) {
            let e = t[s];
            i = i.add(u ? e.negate() : e);
          }
        }
        return p$(n), i;
      }
      getPrecomputes(e, t, n) {
        let i = pL.get(t);
        return (
          i ||
            ((i = this.precomputeWindow(t, e)),
            1 !== e && ('function' == typeof n && (i = n(i)), pL.set(t, i))),
          i
        );
      }
      cached(e, t, n) {
        let i = pV(e);
        return this.wNAF(i, this.getPrecomputes(i, e, n), t);
      }
      unsafe(e, t, n, i) {
        let a = pV(e);
        return 1 === a
          ? this._unsafeLadder(e, t, i)
          : this.wNAFUnsafe(a, this.getPrecomputes(a, e, n), t, i);
      }
      createCache(e, t) {
        pB(t, this.bits), pz.set(e, t), pL.delete(e);
      }
      hasCache(e) {
        return 1 !== pV(e);
      }
    }
    function pq(e, t, n) {
      if (!t) return pT(e, { isLE: n });
      if (t.ORDER !== e) throw Error('Field.ORDER must match order: Fp == p, Fn == n');
      return pO(t), t;
    }
    let pK = (e, t) => (e + (e >= 0 ? t : -t) / pX) / t;
    function pG(e) {
      if (!['compact', 'recovered', 'der'].includes(e))
        throw Error('Signature format must be "compact", "recovered", or "der"');
      return e;
    }
    function pH(e, t) {
      let n = {};
      for (let i of Object.keys(t)) n[i] = void 0 === e[i] ? t[i] : e[i];
      return h3(n.lowS, 'lowS'), h3(n.prehash, 'prehash'), void 0 !== n.format && pG(n.format), n;
    }
    let pZ = {
        Err: class extends Error {
          constructor(e = '') {
            super(e);
          }
        },
        _tlv: {
          encode: (e, t) => {
            let { Err: n } = pZ;
            if (e < 0 || e > 256) throw new n('tlv.encode: wrong tag');
            if (1 & t.length) throw new n('tlv.encode: unpadded data');
            let i = t.length / 2,
              a = h8(i);
            if ((a.length / 2) & 128) throw new n('tlv.encode: long form length too big');
            let o = i > 127 ? h8((a.length / 2) | 128) : '';
            return h8(e) + o + a + t;
          },
          decode(e, t) {
            let { Err: n } = pZ,
              i = 0;
            if (e < 0 || e > 256) throw new n('tlv.encode: wrong tag');
            if (t.length < 2 || t[i++] !== e) throw new n('tlv.decode: wrong tlv');
            let a = t[i++],
              o = 0;
            if (128 & a) {
              let e = 127 & a;
              if (!e) throw new n('tlv.decode(long): indefinite length not supported');
              if (e > 4) throw new n('tlv.decode(long): byte length is too big');
              let s = t.subarray(i, i + e);
              if (s.length !== e) throw new n('tlv.decode: length bytes not complete');
              if (0 === s[0]) throw new n('tlv.decode(long): zero leftmost byte');
              for (let e of s) o = (o << 8) | e;
              if (((i += e), o < 128)) throw new n('tlv.decode(long): not minimal encoding');
            } else o = a;
            let s = t.subarray(i, i + o);
            if (s.length !== o) throw new n('tlv.decode: wrong value length');
            return { v: s, l: t.subarray(i + o) };
          },
        },
        _int: {
          encode(e) {
            let { Err: t } = pZ;
            if (e < pY) throw new t('integer: negative integers are not allowed');
            let n = h8(e);
            if ((8 & Number.parseInt(n[0], 16) && (n = '00' + n), 1 & n.length))
              throw new t('unexpected DER parsing assertion: unpadded hex');
            return n;
          },
          decode(e) {
            let { Err: t } = pZ;
            if (128 & e[0]) throw new t('invalid signature integer: negative');
            if (0 === e[0] && !(128 & e[1]))
              throw new t('invalid signature integer: unnecessary leading zero');
            return h7(e);
          },
        },
        toSig(e) {
          let { Err: t, _int: n, _tlv: i } = pZ,
            a = pn('signature', e),
            { v: o, l: s } = i.decode(48, a);
          if (s.length) throw new t('invalid signature: left bytes after parsing');
          let { v: l, l: u } = i.decode(2, o),
            { v: c, l: d } = i.decode(2, u);
          if (d.length) throw new t('invalid signature: left bytes after parsing');
          return { r: n.decode(l), s: n.decode(c) };
        },
        hexFromSig(e) {
          let { _tlv: t, _int: n } = pZ,
            i = t.encode(2, n.encode(e.r)),
            a = t.encode(2, n.encode(e.s));
          return t.encode(48, i + a);
        },
      },
      pY = BigInt(0),
      pQ = BigInt(1),
      pX = BigInt(2),
      pJ = BigInt(3),
      p0 = BigInt(4);
    function p1(e, t) {
      let n,
        { BYTES: i } = e;
      if ('bigint' == typeof t) n = t;
      else {
        let a = pn('private key', t);
        try {
          n = e.fromBytes(a);
        } catch (e) {
          throw Error(`invalid private key: expected ui8a of size ${i}, got ${typeof t}`);
        }
      }
      if (!e.isValidNot0(n)) throw Error('invalid private key: out of range [1..N-1]');
      return n;
    }
    function p5(e) {
      return Uint8Array.of(e ? 2 : 3);
    }
    function p2(e, t) {
      return {
        secretKey: t.BYTES,
        publicKey: 1 + e.BYTES,
        publicKeyUncompressed: 1 + 2 * e.BYTES,
        publicKeyHasPrefix: !0,
        signature: 2 * t.BYTES,
      };
    }
    function p6(e, t) {
      let n = (t) =>
        (function (e) {
          let t,
            {
              CURVE: n,
              curveOpts: i,
              hash: a,
              ecdsaOpts: o,
            } = (function (e) {
              let t,
                n,
                i,
                a,
                { CURVE: o, curveOpts: s } =
                  ((t = { a: e.a, b: e.b, p: e.Fp.ORDER, n: e.n, h: e.h, Gx: e.Gx, Gy: e.Gy }),
                  (n = e.Fp),
                  (i = e.allowedPrivateKeyLengths
                    ? Array.from(new Set(e.allowedPrivateKeyLengths.map((e) => Math.ceil(e / 2))))
                    : void 0),
                  (a = {
                    Fp: n,
                    Fn: pT(t.n, {
                      BITS: e.nBitLength,
                      allowedLengths: i,
                      modFromBytes: e.wrapPrivateKey,
                    }),
                    allowInfinityPoint: e.allowInfinityPoint,
                    endo: e.endo,
                    isTorsionFree: e.isTorsionFree,
                    clearCofactor: e.clearCofactor,
                    fromBytes: e.fromBytes,
                    toBytes: e.toBytes,
                  }),
                  { CURVE: t, curveOpts: a }),
                l = {
                  hmac: e.hmac,
                  randomBytes: e.randomBytes,
                  lowS: e.lowS,
                  bits2int: e.bits2int,
                  bits2int_modN: e.bits2int_modN,
                };
              return { CURVE: o, curveOpts: s, hash: e.hash, ecdsaOpts: l };
            })(e),
            s = (function (e, t, n = {}) {
              ul(t),
                ps(
                  n,
                  {},
                  {
                    hmac: 'function',
                    lowS: 'boolean',
                    randomBytes: 'function',
                    bits2int: 'function',
                    bits2int_modN: 'function',
                  }
                );
              let i = n.randomBytes || uT,
                a = n.hmac || ((e, ...n) => h5(t, e, uA(...n))),
                { Fp: o, Fn: s } = e,
                { ORDER: l, BITS: u } = s,
                {
                  keygen: c,
                  getPublicKey: d,
                  getSharedSecret: f,
                  utils: h,
                  lengths: p,
                } = (function (e, t = {}) {
                  let { Fn: n } = e,
                    i = t.randomBytes || uT,
                    a = Object.assign(p2(e.Fp, n), { seed: pM(n.ORDER) });
                  function o(e) {
                    try {
                      return !!p1(n, e);
                    } catch (e) {
                      return !1;
                    }
                  }
                  function s(e = i(a.seed)) {
                    return (function (e, t, n = !1) {
                      let i = e.length,
                        a = pR(t),
                        o = pM(t);
                      if (i < 16 || i < o || i > 1024)
                        throw Error('expected ' + o + '-1024 bytes of input, got ' + i);
                      let s = pv(n ? pe(e) : h7(e), t - pc) + pc;
                      return n ? pr(s, a) : pt(s, a);
                    })(h4(e, a.seed, 'seed'), n.ORDER);
                  }
                  function l(t, i = !0) {
                    return e.BASE.multiply(p1(n, t)).toBytes(i);
                  }
                  function u(t) {
                    if ('bigint' == typeof t) return !1;
                    if (t instanceof e) return !0;
                    let { secretKey: i, publicKey: o, publicKeyUncompressed: s } = a;
                    if (n.allowedLengths || i === o) return;
                    let l = pn('key', t).length;
                    return l === o || l === s;
                  }
                  return Object.freeze({
                    getPublicKey: l,
                    getSharedSecret: function (t, i, a = !0) {
                      if (!0 === u(t)) throw Error('first arg must be private key');
                      if (!1 === u(i)) throw Error('second arg must be public key');
                      let o = p1(n, t);
                      return e.fromHex(i).multiply(o).toBytes(a);
                    },
                    keygen: function (e) {
                      let t = s(e);
                      return { secretKey: t, publicKey: l(t) };
                    },
                    Point: e,
                    utils: {
                      isValidSecretKey: o,
                      isValidPublicKey: function (t, n) {
                        let { publicKey: i, publicKeyUncompressed: o } = a;
                        try {
                          let a = t.length;
                          if ((!0 === n && a !== i) || (!1 === n && a !== o)) return !1;
                          return !!e.fromBytes(t);
                        } catch (e) {
                          return !1;
                        }
                      },
                      randomSecretKey: s,
                      isValidPrivateKey: o,
                      randomPrivateKey: s,
                      normPrivateKeyToScalar: (e) => p1(n, e),
                      precompute: (t = 8, n = e.BASE) => n.precompute(t, !1),
                    },
                    lengths: a,
                  });
                })(e, n),
                m = {
                  prehash: !1,
                  lowS: 'boolean' == typeof n.lowS && n.lowS,
                  format: void 0,
                  extraEntropy: !1,
                },
                g = 'compact';
              function y(e, t) {
                if (!s.isValidNot0(t))
                  throw Error(`invalid signature ${e}: out of range 1..Point.Fn.ORDER`);
                return t;
              }
              class b {
                constructor(e, t, n) {
                  (this.r = y('r', e)),
                    (this.s = y('s', t)),
                    null != n && (this.recovery = n),
                    Object.freeze(this);
                }
                static fromBytes(e, t = g) {
                  var n, i;
                  let a, o;
                  if (
                    ((n = e),
                    pG((i = t)),
                    (o = p.signature),
                    h4(
                      n,
                      'compact' === i ? o : 'recovered' === i ? o + 1 : void 0,
                      `${i} signature`
                    ),
                    'der' === t)
                  ) {
                    let { r: t, s: n } = pZ.toSig(h4(e));
                    return new b(t, n);
                  }
                  'recovered' === t && ((a = e[0]), (t = 'compact'), (e = e.subarray(1)));
                  let l = s.BYTES,
                    u = e.subarray(0, l),
                    c = e.subarray(l, 2 * l);
                  return new b(s.fromBytes(u), s.fromBytes(c), a);
                }
                static fromHex(e, t) {
                  return this.fromBytes(uS(e), t);
                }
                addRecoveryBit(e) {
                  return new b(this.r, this.s, e);
                }
                recoverPublicKey(t) {
                  let n = o.ORDER,
                    { r: i, s: a, recovery: u } = this;
                  if (null == u || ![0, 1, 2, 3].includes(u)) throw Error('recovery id invalid');
                  if (l * pX < n && u > 1) throw Error('recovery id is ambiguous for h>1 curve');
                  let c = 2 === u || 3 === u ? i + l : i;
                  if (!o.isValid(c)) throw Error('recovery id 2 or 3 invalid');
                  let d = o.toBytes(c),
                    f = e.fromBytes(uA(p5((1 & u) == 0), d)),
                    h = s.inv(c),
                    p = w(pn('msgHash', t)),
                    m = s.create(-p * h),
                    g = s.create(a * h),
                    y = e.BASE.multiplyUnsafe(m).add(f.multiplyUnsafe(g));
                  if (y.is0()) throw Error('point at infinify');
                  return y.assertValidity(), y;
                }
                hasHighS() {
                  return this.s > l >> pQ;
                }
                toBytes(e = g) {
                  if ((pG(e), 'der' === e)) return uS(pZ.hexFromSig(this));
                  let t = s.toBytes(this.r),
                    n = s.toBytes(this.s);
                  if ('recovered' === e) {
                    if (null == this.recovery) throw Error('recovery bit must be present');
                    return uA(Uint8Array.of(this.recovery), t, n);
                  }
                  return uA(t, n);
                }
                toHex(e) {
                  return ux(this.toBytes(e));
                }
                assertValidity() {}
                static fromCompact(e) {
                  return b.fromBytes(pn('sig', e), 'compact');
                }
                static fromDER(e) {
                  return b.fromBytes(pn('sig', e), 'der');
                }
                normalizeS() {
                  return this.hasHighS() ? new b(this.r, s.neg(this.s), this.recovery) : this;
                }
                toDERRawBytes() {
                  return this.toBytes('der');
                }
                toDERHex() {
                  return ux(this.toBytes('der'));
                }
                toCompactRawBytes() {
                  return this.toBytes('compact');
                }
                toCompactHex() {
                  return ux(this.toBytes('compact'));
                }
              }
              let v =
                  n.bits2int ||
                  function (e) {
                    if (e.length > 8192) throw Error('input is too large');
                    let t = h7(e),
                      n = 8 * e.length - u;
                    return n > 0 ? t >> BigInt(n) : t;
                  },
                w =
                  n.bits2int_modN ||
                  function (e) {
                    return s.create(v(e));
                  },
                x = po(u);
              function E(e) {
                return (
                  !(function (e, t, n, i) {
                    if (!(pi(t) && pi(n) && pi(i)) || !(n <= t) || !(t < i))
                      throw Error('expected valid ' + e + ': ' + n + ' <= n < ' + i + ', got ' + t);
                  })('num < 2^' + u, e, pY, x),
                  s.toBytes(e)
                );
              }
              function S(e, n) {
                return h4(e, void 0, 'message'), n ? h4(t(e), void 0, 'prehashed message') : e;
              }
              return Object.freeze({
                keygen: c,
                getPublicKey: d,
                getSharedSecret: f,
                utils: h,
                lengths: p,
                Point: e,
                sign: function (n, o, u = {}) {
                  let { seed: c, k2sig: d } = (function (t, n, a) {
                    if (['recovered', 'canonical'].some((e) => e in a))
                      throw Error('sign() legacy options not supported');
                    let { lowS: o, prehash: u, extraEntropy: c } = pH(a, m),
                      d = w((t = S(t, u))),
                      f = p1(s, n),
                      h = [E(f), E(d)];
                    if (null != c && !1 !== c) {
                      let e = !0 === c ? i(p.secretKey) : c;
                      h.push(pn('extraEntropy', e));
                    }
                    return {
                      seed: uA(...h),
                      k2sig: function (t) {
                        let n = v(t);
                        if (!s.isValidNot0(n)) return;
                        let i = s.inv(n),
                          a = e.BASE.multiply(n).toAffine(),
                          u = s.create(a.x);
                        if (u === pY) return;
                        let c = s.create(i * s.create(d + u * f));
                        if (c === pY) return;
                        let h = (2 * (a.x !== u)) | Number(a.y & pQ),
                          p = c;
                        return o && c > l >> pQ && ((p = s.neg(c)), (h ^= 1)), new b(u, p, h);
                      },
                    };
                  })((n = pn('message', n)), o, u);
                  return (function (e, t, n) {
                    if ('number' != typeof e || e < 2) throw Error('hashLen must be a number');
                    if ('number' != typeof t || t < 2) throw Error('qByteLen must be a number');
                    if ('function' != typeof n) throw Error('hmacFn must be a function');
                    let i = (e) => new Uint8Array(e),
                      a = i(e),
                      o = i(e),
                      s = 0,
                      l = () => {
                        a.fill(1), o.fill(0), (s = 0);
                      },
                      u = (...e) => n(o, a, ...e),
                      c = (e = i(0)) => {
                        ((o = u(Uint8Array.of(0), e)), (a = u()), 0 !== e.length) &&
                          ((o = u(Uint8Array.of(1), e)), (a = u()));
                      },
                      d = () => {
                        if (s++ >= 1e3) throw Error('drbg: tried 1000 values');
                        let e = 0,
                          n = [];
                        for (; e < t; ) {
                          let t = (a = u()).slice();
                          n.push(t), (e += a.length);
                        }
                        return uA(...n);
                      };
                    return (e, t) => {
                      let n;
                      for (l(), c(e); !(n = t(d())); ) c();
                      return l(), n;
                    };
                  })(
                    t.outputLen,
                    s.BYTES,
                    a
                  )(c, d);
                },
                verify: function (t, n, i, a = {}) {
                  let { lowS: o, prehash: l, format: u } = pH(a, m);
                  if (((i = pn('publicKey', i)), (n = S(pn('message', n), l)), 'strict' in a))
                    throw Error('options.strict was renamed to lowS');
                  let c =
                    void 0 === u
                      ? (function (e) {
                          let t,
                            n = 'string' == typeof e || ua(e),
                            i =
                              !n &&
                              null !== e &&
                              'object' == typeof e &&
                              'bigint' == typeof e.r &&
                              'bigint' == typeof e.s;
                          if (!n && !i)
                            throw Error(
                              'invalid signature, expected Uint8Array, hex string or Signature instance'
                            );
                          if (i) t = new b(e.r, e.s);
                          else if (n) {
                            try {
                              t = b.fromBytes(pn('sig', e), 'der');
                            } catch (e) {
                              if (!(e instanceof pZ.Err)) throw e;
                            }
                            if (!t)
                              try {
                                t = b.fromBytes(pn('sig', e), 'compact');
                              } catch (e) {
                                return !1;
                              }
                          }
                          return !!t && t;
                        })(t)
                      : b.fromBytes(pn('sig', t), u);
                  if (!1 === c) return !1;
                  try {
                    let t = e.fromBytes(i);
                    if (o && c.hasHighS()) return !1;
                    let { r: a, s: l } = c,
                      u = w(n),
                      d = s.inv(l),
                      f = s.create(u * d),
                      h = s.create(a * d),
                      p = e.BASE.multiplyUnsafe(f).add(t.multiplyUnsafe(h));
                    if (p.is0()) return !1;
                    return s.create(p.x) === a;
                  } catch (e) {
                    return !1;
                  }
                },
                recoverPublicKey: function (e, t, n = {}) {
                  let { prehash: i } = pH(n, m);
                  return (t = S(t, i)), b.fromBytes(e, 'recovered').recoverPublicKey(t).toBytes();
                },
                Signature: b,
                hash: t,
              });
            })(
              (function (e, t = {}) {
                let n = (function (e, t, n = {}, i) {
                    if ((void 0 === i && (i = 'edwards' === e), !t || 'object' != typeof t))
                      throw Error(`expected valid ${e} CURVE object`);
                    for (let e of ['p', 'n', 'h']) {
                      let n = t[e];
                      if (!('bigint' == typeof n && n > pP))
                        throw Error(`CURVE.${e} must be positive bigint`);
                    }
                    let a = pq(t.p, n.Fp, i),
                      o = pq(t.n, n.Fn, i);
                    for (let n of ['Gx', 'Gy', 'a', 'weierstrass' === e ? 'b' : 'd'])
                      if (!a.isValid(t[n]))
                        throw Error(`CURVE.${n} must be valid field element of CURVE.Fp`);
                    return { CURVE: (t = Object.freeze(Object.assign({}, t))), Fp: a, Fn: o };
                  })('weierstrass', e, t),
                  { Fp: i, Fn: a } = n,
                  o = n.CURVE,
                  { h: s, n: l } = o;
                ps(
                  t,
                  {},
                  {
                    allowInfinityPoint: 'boolean',
                    clearCofactor: 'function',
                    isTorsionFree: 'function',
                    fromBytes: 'function',
                    toBytes: 'function',
                    endo: 'object',
                    wrapPrivateKey: 'boolean',
                  }
                );
                let { endo: u } = t;
                if (u && (!i.is0(o.a) || 'bigint' != typeof u.beta || !Array.isArray(u.basises)))
                  throw Error('invalid endo: expected "beta": bigint and "basises": array');
                let c = p2(i, a);
                function d() {
                  if (!i.isOdd)
                    throw Error('compression is not supported: Field does not have .isOdd()');
                }
                let f =
                    t.toBytes ||
                    function (e, t, n) {
                      let { x: a, y: o } = t.toAffine(),
                        s = i.toBytes(a);
                      return (h3(n, 'isCompressed'), n)
                        ? (d(), uA(p5(!i.isOdd(o)), s))
                        : uA(Uint8Array.of(4), s, i.toBytes(o));
                    },
                  h =
                    t.fromBytes ||
                    function (e) {
                      h4(e, void 0, 'Point');
                      let { publicKey: t, publicKeyUncompressed: n } = c,
                        a = e.length,
                        o = e[0],
                        s = e.subarray(1);
                      if (a === t && (2 === o || 3 === o)) {
                        let e,
                          t = i.fromBytes(s);
                        if (!i.isValid(t)) throw Error('bad point: is not on curve, wrong x');
                        let n = p(t);
                        try {
                          e = i.sqrt(n);
                        } catch (e) {
                          throw Error(
                            'bad point: is not on curve, sqrt error' +
                              (e instanceof Error ? ': ' + e.message : '')
                          );
                        }
                        return d(), ((1 & o) == 1) !== i.isOdd(e) && (e = i.neg(e)), { x: t, y: e };
                      }
                      if (a === n && 4 === o) {
                        let e = i.BYTES,
                          t = i.fromBytes(s.subarray(0, e)),
                          n = i.fromBytes(s.subarray(e, 2 * e));
                        if (!m(t, n)) throw Error('bad point: is not on curve');
                        return { x: t, y: n };
                      }
                      throw Error(
                        `bad point: got length ${a}, expected compressed=${t} or uncompressed=${n}`
                      );
                    };
                function p(e) {
                  let t = i.sqr(e),
                    n = i.mul(t, e);
                  return i.add(i.add(n, i.mul(e, o.a)), o.b);
                }
                function m(e, t) {
                  let n = i.sqr(t),
                    a = p(e);
                  return i.eql(n, a);
                }
                if (!m(o.Gx, o.Gy)) throw Error('bad curve params: generator point');
                let g = i.mul(i.pow(o.a, pJ), p0),
                  y = i.mul(i.sqr(o.b), BigInt(27));
                if (i.is0(i.add(g, y))) throw Error('bad curve params: a or b');
                function b(e, t, n = !1) {
                  if (!i.isValid(t) || (n && i.is0(t))) throw Error(`bad point coordinate ${e}`);
                  return t;
                }
                function v(e) {
                  if (!(e instanceof C)) throw Error('ProjectivePoint expected');
                }
                function w(e) {
                  if (!u || !u.basises) throw Error('no endo');
                  return (function (e, t, n) {
                    let [[i, a], [o, s]] = t,
                      l = pK(s * e, n),
                      u = pK(-a * e, n),
                      c = e - l * i - u * o,
                      d = -l * a - u * s,
                      f = c < pY,
                      h = d < pY;
                    f && (c = -c), h && (d = -d);
                    let p = po(Math.ceil(pa(n) / 2)) + pQ;
                    if (c < pY || c >= p || d < pY || d >= p)
                      throw Error('splitScalar (endomorphism): failed, k=' + e);
                    return { k1neg: f, k1: c, k2neg: h, k2: d };
                  })(e, u.basises, a.ORDER);
                }
                let x = pl((e, t) => {
                    let { X: n, Y: a, Z: o } = e;
                    if (i.eql(o, i.ONE)) return { x: n, y: a };
                    let s = e.is0();
                    null == t && (t = s ? i.ONE : i.inv(o));
                    let l = i.mul(n, t),
                      u = i.mul(a, t),
                      c = i.mul(o, t);
                    if (s) return { x: i.ZERO, y: i.ZERO };
                    if (!i.eql(c, i.ONE)) throw Error('invZ was invalid');
                    return { x: l, y: u };
                  }),
                  E = pl((e) => {
                    if (e.is0()) {
                      if (t.allowInfinityPoint && !i.is0(e.Y)) return;
                      throw Error('bad point: ZERO');
                    }
                    let { x: n, y: a } = e.toAffine();
                    if (!i.isValid(n) || !i.isValid(a))
                      throw Error('bad point: x or y not field elements');
                    if (!m(n, a)) throw Error('bad point: equation left != right');
                    if (!e.isTorsionFree()) throw Error('bad point: not in prime-order subgroup');
                    return !0;
                  });
                function S(e, t, n, a, o) {
                  return (
                    (n = new C(i.mul(n.X, e), n.Y, n.Z)), (t = p_(a, t)), (n = p_(o, n)), t.add(n)
                  );
                }
                class C {
                  constructor(e, t, n) {
                    (this.X = b('x', e)),
                      (this.Y = b('y', t, !0)),
                      (this.Z = b('z', n)),
                      Object.freeze(this);
                  }
                  static CURVE() {
                    return o;
                  }
                  static fromAffine(e) {
                    let { x: t, y: n } = e || {};
                    if (!e || !i.isValid(t) || !i.isValid(n)) throw Error('invalid affine point');
                    if (e instanceof C) throw Error('projective point not allowed');
                    return i.is0(t) && i.is0(n) ? C.ZERO : new C(t, n, i.ONE);
                  }
                  static fromBytes(e) {
                    let t = C.fromAffine(h(h4(e, void 0, 'point')));
                    return t.assertValidity(), t;
                  }
                  static fromHex(e) {
                    return C.fromBytes(pn('pointHex', e));
                  }
                  get x() {
                    return this.toAffine().x;
                  }
                  get y() {
                    return this.toAffine().y;
                  }
                  precompute(e = 8, t = !0) {
                    return O.createCache(this, e), t || this.multiply(pJ), this;
                  }
                  assertValidity() {
                    E(this);
                  }
                  hasEvenY() {
                    let { y: e } = this.toAffine();
                    if (!i.isOdd) throw Error("Field doesn't support isOdd");
                    return !i.isOdd(e);
                  }
                  equals(e) {
                    v(e);
                    let { X: t, Y: n, Z: a } = this,
                      { X: o, Y: s, Z: l } = e,
                      u = i.eql(i.mul(t, l), i.mul(o, a)),
                      c = i.eql(i.mul(n, l), i.mul(s, a));
                    return u && c;
                  }
                  negate() {
                    return new C(this.X, i.neg(this.Y), this.Z);
                  }
                  double() {
                    let { a: e, b: t } = o,
                      n = i.mul(t, pJ),
                      { X: a, Y: s, Z: l } = this,
                      u = i.ZERO,
                      c = i.ZERO,
                      d = i.ZERO,
                      f = i.mul(a, a),
                      h = i.mul(s, s),
                      p = i.mul(l, l),
                      m = i.mul(a, s);
                    return (
                      (m = i.add(m, m)),
                      (d = i.mul(a, l)),
                      (d = i.add(d, d)),
                      (u = i.mul(e, d)),
                      (c = i.mul(n, p)),
                      (c = i.add(u, c)),
                      (u = i.sub(h, c)),
                      (c = i.add(h, c)),
                      (c = i.mul(u, c)),
                      (u = i.mul(m, u)),
                      (d = i.mul(n, d)),
                      (p = i.mul(e, p)),
                      (m = i.sub(f, p)),
                      (m = i.mul(e, m)),
                      (m = i.add(m, d)),
                      (d = i.add(f, f)),
                      (f = i.add(d, f)),
                      (f = i.add(f, p)),
                      (f = i.mul(f, m)),
                      (c = i.add(c, f)),
                      (p = i.mul(s, l)),
                      (p = i.add(p, p)),
                      (f = i.mul(p, m)),
                      (u = i.sub(u, f)),
                      (d = i.mul(p, h)),
                      (d = i.add(d, d)),
                      new C(u, c, (d = i.add(d, d)))
                    );
                  }
                  add(e) {
                    v(e);
                    let { X: t, Y: n, Z: a } = this,
                      { X: s, Y: l, Z: u } = e,
                      c = i.ZERO,
                      d = i.ZERO,
                      f = i.ZERO,
                      h = o.a,
                      p = i.mul(o.b, pJ),
                      m = i.mul(t, s),
                      g = i.mul(n, l),
                      y = i.mul(a, u),
                      b = i.add(t, n),
                      w = i.add(s, l);
                    (b = i.mul(b, w)), (w = i.add(m, g)), (b = i.sub(b, w)), (w = i.add(t, a));
                    let x = i.add(s, u);
                    return (
                      (w = i.mul(w, x)),
                      (x = i.add(m, y)),
                      (w = i.sub(w, x)),
                      (x = i.add(n, a)),
                      (c = i.add(l, u)),
                      (x = i.mul(x, c)),
                      (c = i.add(g, y)),
                      (x = i.sub(x, c)),
                      (f = i.mul(h, w)),
                      (c = i.mul(p, y)),
                      (f = i.add(c, f)),
                      (c = i.sub(g, f)),
                      (f = i.add(g, f)),
                      (d = i.mul(c, f)),
                      (g = i.add(m, m)),
                      (g = i.add(g, m)),
                      (y = i.mul(h, y)),
                      (w = i.mul(p, w)),
                      (g = i.add(g, y)),
                      (y = i.sub(m, y)),
                      (y = i.mul(h, y)),
                      (w = i.add(w, y)),
                      (m = i.mul(g, w)),
                      (d = i.add(d, m)),
                      (m = i.mul(x, w)),
                      (c = i.mul(b, c)),
                      (c = i.sub(c, m)),
                      (m = i.mul(b, g)),
                      (f = i.mul(x, f)),
                      new C(c, d, (f = i.add(f, m)))
                    );
                  }
                  subtract(e) {
                    return this.add(e.negate());
                  }
                  is0() {
                    return this.equals(C.ZERO);
                  }
                  multiply(e) {
                    let n,
                      i,
                      { endo: o } = t;
                    if (!a.isValidNot0(e)) throw Error('invalid scalar: out of range');
                    let s = (e) => O.cached(this, e, (e) => pD(C, e));
                    if (o) {
                      let { k1neg: t, k1: a, k2neg: l, k2: u } = w(e),
                        { p: c, f: d } = s(a),
                        { p: f, f: h } = s(u);
                      (i = d.add(h)), (n = S(o.beta, c, f, t, l));
                    } else {
                      let { p: t, f: a } = s(e);
                      (n = t), (i = a);
                    }
                    return pD(C, [n, i])[0];
                  }
                  multiplyUnsafe(e) {
                    let { endo: n } = t;
                    if (!a.isValid(e)) throw Error('invalid scalar: out of range');
                    if (e === pY || this.is0()) return C.ZERO;
                    if (e === pQ) return this;
                    if (O.hasCache(this)) return this.multiply(e);
                    if (!n) return O.unsafe(this, e);
                    {
                      let { k1neg: t, k1: i, k2neg: a, k2: o } = w(e),
                        { p1: s, p2: l } = (function (e, t, n, i) {
                          let a = t,
                            o = e.ZERO,
                            s = e.ZERO;
                          for (; n > pP || i > pP; )
                            n & pN && (o = o.add(a)),
                              i & pN && (s = s.add(a)),
                              (a = a.double()),
                              (n >>= pN),
                              (i >>= pN);
                          return { p1: o, p2: s };
                        })(C, this, i, o);
                      return S(n.beta, s, l, t, a);
                    }
                  }
                  multiplyAndAddUnsafe(e, t, n) {
                    let i = this.multiplyUnsafe(t).add(e.multiplyUnsafe(n));
                    return i.is0() ? void 0 : i;
                  }
                  toAffine(e) {
                    return x(this, e);
                  }
                  isTorsionFree() {
                    let { isTorsionFree: e } = t;
                    return s === pQ || (e ? e(C, this) : O.unsafe(this, l).is0());
                  }
                  clearCofactor() {
                    let { clearCofactor: e } = t;
                    return s === pQ ? this : e ? e(C, this) : this.multiplyUnsafe(s);
                  }
                  isSmallOrder() {
                    return this.multiplyUnsafe(s).is0();
                  }
                  toBytes(e = !0) {
                    return h3(e, 'isCompressed'), this.assertValidity(), f(C, this, e);
                  }
                  toHex(e = !0) {
                    return ux(this.toBytes(e));
                  }
                  toString() {
                    return `<Point ${this.is0() ? 'ZERO' : this.toHex()}>`;
                  }
                  get px() {
                    return this.X;
                  }
                  get py() {
                    return this.X;
                  }
                  get pz() {
                    return this.Z;
                  }
                  toRawBytes(e = !0) {
                    return this.toBytes(e);
                  }
                  _setWindowSize(e) {
                    this.precompute(e);
                  }
                  static normalizeZ(e) {
                    return pD(C, e);
                  }
                  static msm(e, t) {
                    return (function (e, t, n, i) {
                      if (!Array.isArray(n)) throw Error('array expected');
                      n.forEach((t, n) => {
                        if (!(t instanceof e)) throw Error('invalid point at index ' + n);
                      });
                      if (!Array.isArray(i)) throw Error('array of scalars expected');
                      i.forEach((e, n) => {
                        if (!t.isValid(e)) throw Error('invalid scalar at index ' + n);
                      });
                      let a = n.length,
                        o = i.length;
                      if (a !== o)
                        throw Error('arrays of points and scalars must have equal length');
                      let s = e.ZERO,
                        l = pa(BigInt(a)),
                        u = 1;
                      l > 12 ? (u = l - 3) : l > 4 ? (u = l - 2) : l > 0 && (u = 2);
                      let c = po(u),
                        d = Array(Number(c) + 1).fill(s),
                        f = Math.floor((t.BITS - 1) / u) * u,
                        h = s;
                      for (let e = f; e >= 0; e -= u) {
                        d.fill(s);
                        for (let t = 0; t < o; t++) {
                          let a = Number((i[t] >> BigInt(e)) & c);
                          d[a] = d[a].add(n[t]);
                        }
                        let t = s;
                        for (let e = d.length - 1, n = s; e > 0; e--)
                          (n = n.add(d[e])), (t = t.add(n));
                        if (((h = h.add(t)), 0 !== e)) for (let e = 0; e < u; e++) h = h.double();
                      }
                      return h;
                    })(C, a, e, t);
                  }
                  static fromPrivateKey(e) {
                    return C.BASE.multiply(p1(a, e));
                  }
                }
                (C.BASE = new C(o.Gx, o.Gy, i.ONE)),
                  (C.ZERO = new C(i.ZERO, i.ONE, i.ZERO)),
                  (C.Fp = i),
                  (C.Fn = a);
                let k = a.BITS,
                  O = new pW(C, t.endo ? Math.ceil(k / 2) : k);
                return C.BASE.precompute(8), C;
              })(n, i),
              a,
              o
            );
          return (
            (t = s.Point),
            Object.assign({}, s, {
              ProjectivePoint: t,
              CURVE: Object.assign({}, e, pj(t.Fn.ORDER, t.Fn.BITS)),
            })
          );
        })({ ...e, hash: t });
      return { ...n(t), create: n };
    }
    uC('HashToScalar-');
    let p3 = {
        p: BigInt('0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff'),
        n: BigInt('0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551'),
        h: BigInt(1),
        a: BigInt('0xffffffff00000001000000000000000000000000fffffffffffffffffffffffc'),
        b: BigInt('0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b'),
        Gx: BigInt('0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296'),
        Gy: BigInt('0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5'),
      },
      p4 = {
        p: BigInt(
          '0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffeffffffff0000000000000000ffffffff'
        ),
        n: BigInt(
          '0xffffffffffffffffffffffffffffffffffffffffffffffffc7634d81f4372ddf581a0db248b0a77aecec196accc52973'
        ),
        h: BigInt(1),
        a: BigInt(
          '0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffeffffffff0000000000000000fffffffc'
        ),
        b: BigInt(
          '0xb3312fa7e23ee7e4988e056be3f82d19181d9c6efe8141120314088f5013875ac656398d8a2ed19d2a85c8edd3ec2aef'
        ),
        Gx: BigInt(
          '0xaa87ca22be8b05378eb1c71ef320ad746e1d3b628ba79b9859f741e082542a385502f25dbf55296c3a545e3872760ab7'
        ),
        Gy: BigInt(
          '0x3617de4a96262c6f5d9e98bf9292dc29f8f41dbd289a147ce9da3113b5f0b8c00a60b1ce1d7e819d7a431d7c90ea0e5f'
        ),
      },
      p8 = {
        p: BigInt(
          '0x1ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff'
        ),
        n: BigInt(
          '0x01fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa51868783bf2f966b7fcc0148f709a5d03bb5c9b8899c47aebb6fb71e91386409'
        ),
        h: BigInt(1),
        a: BigInt(
          '0x1fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc'
        ),
        b: BigInt(
          '0x0051953eb9618e1c9a1f929a21a0b68540eea2da725b99b315f3b8b489918ef109e156193951ec7e937b1652c0bd3bb1bf073573df883d2c34f1ef451fd46b503f00'
        ),
        Gx: BigInt(
          '0x00c6858e06b70404e9cd9e3ecb662395b4429c648139053fb521f828af606b4d3dbaa14b5e77efe75928fe1dc127a2ffa8de3348b3c1856a429bf97e7e31c2e5bd66'
        ),
        Gy: BigInt(
          '0x011839296a789a3bc0045c8a5fb42c7d1bd998f54449579b446817afbd17273e662c97ee72995ef42640c550b9013fad0761353c7086a272c24088be94769fd16650'
        ),
      },
      p9 = pT(p3.p),
      p7 = pT(p4.p),
      me = pT(p8.p),
      mt = p6({ ...p3, Fp: p9, lowS: !1 }, hX);
    function mr(e, t) {
      if (e === t) return !0;
      if (e.length !== t.length) return !1;
      for (let n = 0; n < e.length; n++) if (e[n] !== t[n]) return !1;
      return !0;
    }
    (function (e, t, n) {
      if ('function' != typeof t) throw Error('mapToCurve() must be defined');
    })(
      mt.Point,
      (($ = mt.Point),
      (W = { A: p3.a, B: p3.b, Z: mt.Point.Fp.create(BigInt('-10')) }),
      (v = (function (e, t) {
        pO(e);
        let { A: n, B: i, Z: a } = t;
        if (!e.isValid(n) || !e.isValid(i) || !e.isValid(a))
          throw Error('mapToCurveSimpleSWU: invalid opts');
        let o = (function (e, t) {
          let n = e.ORDER,
            i = pY;
          for (let e = n - pQ; e % pX === pY; e /= pX) i += pQ;
          let a = i,
            o = pX << (a - pQ - pQ),
            s = o * pX,
            l = (n - pQ) / s,
            u = (l - pQ) / pX,
            c = s - pQ,
            d = e.pow(t, l),
            f = e.pow(t, (l + pQ) / pX),
            h = (t, n) => {
              let i = d,
                s = e.pow(n, c),
                l = e.sqr(s);
              l = e.mul(l, n);
              let h = e.mul(t, l);
              (h = e.pow(h, u)), (h = e.mul(h, s)), (s = e.mul(h, n)), (l = e.mul(h, t));
              let p = e.mul(l, s);
              h = e.pow(p, o);
              let m = e.eql(h, e.ONE);
              (s = e.mul(l, f)), (h = e.mul(p, i)), (l = e.cmov(s, l, m)), (p = e.cmov(h, p, m));
              for (let t = a; t > pQ; t--) {
                let n = t - pX;
                n = pX << (n - pQ);
                let a = e.pow(p, n),
                  o = e.eql(a, e.ONE);
                (s = e.mul(l, i)),
                  (i = e.mul(i, i)),
                  (a = e.mul(p, i)),
                  (l = e.cmov(s, l, o)),
                  (p = e.cmov(a, p, o));
              }
              return { isValid: m, value: l };
            };
          if (e.ORDER % p0 === pJ) {
            let n = (e.ORDER - pJ) / p0,
              i = e.sqrt(e.neg(t));
            h = (t, a) => {
              let o = e.sqr(a),
                s = e.mul(t, a);
              o = e.mul(o, s);
              let l = e.pow(o, n);
              l = e.mul(l, s);
              let u = e.mul(l, i),
                c = e.mul(e.sqr(l), a),
                d = e.eql(c, t),
                f = e.cmov(u, l, d);
              return { isValid: d, value: f };
            };
          }
          return h;
        })(e, a);
        if (!e.isOdd) throw Error('Field does not have .isOdd()');
        return (t) => {
          let s, l, u, c, d, f, h, p;
          (s = e.sqr(t)),
            (s = e.mul(s, a)),
            (l = e.sqr(s)),
            (l = e.add(l, s)),
            (u = e.add(l, e.ONE)),
            (u = e.mul(u, i)),
            (c = e.cmov(a, e.neg(l), !e.eql(l, e.ZERO))),
            (c = e.mul(c, n)),
            (l = e.sqr(u)),
            (f = e.sqr(c)),
            (d = e.mul(f, n)),
            (l = e.add(l, d)),
            (l = e.mul(l, u)),
            (f = e.mul(f, c)),
            (d = e.mul(f, i)),
            (l = e.add(l, d)),
            (h = e.mul(s, u));
          let { isValid: m, value: g } = o(l, f);
          (p = e.mul(s, t)), (p = e.mul(p, g)), (h = e.cmov(h, u, m)), (p = e.cmov(p, g, m));
          let y = e.isOdd(t) === e.isOdd(p);
          p = e.cmov(e.neg(p), p, y);
          let b = pA(e, [c], !0)[0];
          return { x: (h = e.mul(h, b)), y: p };
        };
      })($.Fp, W)),
      (e) => v(e[0])),
      p3.p
    ),
      p6({ ...p4, Fp: p7, lowS: !1 }, h0),
      p6({ ...p8, Fp: me, lowS: !1, allowedPrivateKeyLengths: [130, 131, 132] }, hJ);
    class mn {
      equals(e) {
        return mr(this.toRawBytes(), e.toRawBytes());
      }
      toBase64() {
        return n3(this.toRawBytes());
      }
      toString() {
        throw Error(
          '`toString` is not implemented on public keys. Use `toBase64()` or `toRawBytes()` instead.'
        );
      }
      toIotaPublicKey() {
        return n3(this.toIotaBytes());
      }
      verifyWithIntent(e, t, n) {
        let i = u4(hU(n, e), { dkLen: 32 });
        return this.verify(i, t);
      }
      verifyPersonalMessage(e, t) {
        return this.verifyWithIntent(
          fM.vector(fM.u8()).serialize(e).toBytes(),
          t,
          'PersonalMessage'
        );
      }
      verifyTransaction(e, t) {
        return this.verifyWithIntent(e, t, 'TransactionData');
      }
      toIotaBytes() {
        let e = this.toRawBytes(),
          t = new Uint8Array(e.length + 1);
        return t.set([this.flag()]), t.set(e, 1), t;
      }
      toIotaBytesForAddress() {
        let e = this.toRawBytes();
        if (this.flag() === hF.ED25519) return e;
        {
          let t = new Uint8Array(e.length + 1);
          return t.set([this.flag()]), t.set(e, 1), t;
        }
      }
      toIotaAddress() {
        return ie(ux(u4(this.toIotaBytesForAddress(), { dkLen: 32 })).slice(0, 64));
      }
    }
    new Uint8Array([
      48, 89, 48, 19, 6, 7, 42, 134, 72, 206, 61, 2, 1, 6, 8, 42, 134, 72, 206, 61, 3, 1, 7, 3, 66,
      0,
    ]);
    let mi = 'iotaprivkey';
    class ma {
      async signWithIntent(e, t) {
        let n = u4(hU(t, e), { dkLen: 32 });
        return {
          signature: (function ({ signature: e, signatureScheme: t, publicKey: n }) {
            if (!n) throw Error('`publicKey` is required');
            let i = n.toRawBytes(),
              a = new Uint8Array(1 + e.length + i.length);
            return a.set([hF[t]]), a.set(e, 1), a.set(i, 1 + e.length), n3(a);
          })({
            signature: await this.sign(n),
            signatureScheme: this.getKeyScheme(),
            publicKey: this.getPublicKey(),
          }),
          bytes: n3(e),
        };
      }
      async signTransaction(e) {
        return this.signWithIntent(e, 'TransactionData');
      }
      async signPersonalMessage(e) {
        let { signature: t } = await this.signWithIntent(
          dK.vector(dK.u8()).serialize(e).toBytes(),
          'PersonalMessage'
        );
        return { bytes: n3(e), signature: t };
      }
      toIotaAddress() {
        return this.getPublicKey().toIotaAddress();
      }
    }
    class mo extends ma {}
    function ms(e) {
      return (
        e instanceof Uint8Array || (ArrayBuffer.isView(e) && 'Uint8Array' === e.constructor.name)
      );
    }
    function ml(e, t) {
      return (
        !!Array.isArray(t) &&
        (0 === t.length ||
          (e ? t.every((e) => 'string' == typeof e) : t.every((e) => Number.isSafeInteger(e))))
      );
    }
    function mu(e) {
      if ('function' != typeof e) throw Error('function expected');
      return !0;
    }
    function mc(e, t) {
      if ('string' != typeof t) throw Error(`${e}: string expected`);
      return !0;
    }
    function md(e) {
      if (!Number.isSafeInteger(e)) throw Error(`invalid integer: ${e}`);
    }
    function mf(e) {
      if (!Array.isArray(e)) throw Error('array expected');
    }
    function mh(e, t) {
      if (!ml(!0, t)) throw Error(`${e}: array of strings expected`);
    }
    function mp(e, t) {
      if (!ml(!1, t)) throw Error(`${e}: array of numbers expected`);
    }
    function mm(...e) {
      let t = (e) => e,
        n = (e, t) => (n) => e(t(n));
      return {
        encode: e.map((e) => e.encode).reduceRight(n, t),
        decode: e.map((e) => e.decode).reduce(n, t),
      };
    }
    function mg(e) {
      let t = 'string' == typeof e ? e.split('') : e,
        n = t.length;
      mh('alphabet', t);
      let i = new Map(t.map((e, t) => [e, t]));
      return {
        encode: (i) => (
          mf(i),
          i.map((i) => {
            if (!Number.isSafeInteger(i) || i < 0 || i >= n)
              throw Error(`alphabet.encode: digit index outside alphabet "${i}". Allowed: ${e}`);
            return t[i];
          })
        ),
        decode: (t) => (
          mf(t),
          t.map((t) => {
            mc('alphabet.decode', t);
            let n = i.get(t);
            if (void 0 === n) throw Error(`Unknown letter: "${t}". Allowed: ${e}`);
            return n;
          })
        ),
      };
    }
    function my(e = '') {
      return (
        mc('join', e),
        {
          encode: (t) => (mh('join.decode', t), t.join(e)),
          decode: (t) => (mc('join.decode', t), t.split(e)),
        }
      );
    }
    function mb(e, t, n) {
      if (t < 2) throw Error(`convertRadix: invalid from=${t}, base cannot be less than 2`);
      if (n < 2) throw Error(`convertRadix: invalid to=${n}, base cannot be less than 2`);
      if ((mf(e), !e.length)) return [];
      let i = 0,
        a = [],
        o = Array.from(e, (e) => {
          if ((md(e), e < 0 || e >= t)) throw Error(`invalid integer: ${e}`);
          return e;
        }),
        s = o.length;
      for (;;) {
        let e = 0,
          l = !0;
        for (let a = i; a < s; a++) {
          let s = o[a],
            u = t * e,
            c = u + s;
          if (!Number.isSafeInteger(c) || u / t !== e || c - s !== u)
            throw Error('convertRadix: carry overflow');
          let d = c / n;
          e = c % n;
          let f = Math.floor(d);
          if (((o[a] = f), !Number.isSafeInteger(f) || f * n + e !== c))
            throw Error('convertRadix: carry overflow');
          l && (f ? (l = !1) : (i = a));
        }
        if ((a.push(e), l)) break;
      }
      for (let t = 0; t < e.length - 1 && 0 === e[t]; t++) a.push(0);
      return a.reverse();
    }
    let mv = (e, t) => (0 === t ? e : mv(t, e % t)),
      mw = (() => {
        let e = [];
        for (let t = 0; t < 40; t++) e.push(2 ** t);
        return e;
      })();
    'function' == typeof Uint8Array.from([]).toBase64 && Uint8Array.fromBase64;
    md(58);
    function mx(e) {
      if ('string' != typeof e) throw TypeError('invalid mnemonic type: ' + typeof e);
      return e.normalize('NFKD');
    }
    function mE(e) {
      return !!RegExp("^m\\/44'\\/4218'\\/[0-9]+'\\/[0-9]+'\\/[0-9]+'+$").test(e);
    }
    ('function' == typeof Uint8Array.from([]).toHex && 'function' == typeof Uint8Array.fromHex) ||
      mu((e) => {
        if ('string' != typeof e || e.length % 2 != 0)
          throw TypeError(`hex.decode: expected string, got ${typeof e} with length ${e.length}`);
        return e.toLowerCase();
      });
    let mS = 0x80000000,
      mC = RegExp("^m(\\/[0-9]+')+$"),
      mk = (e) => e.replace("'", ''),
      mO = (e, t, n = mS) => {
        let i;
        if (!mC.test(e) || e.split('/').slice(1).map(mk).some(isNaN))
          throw Error('Invalid derivation path');
        let { key: a, chainCode: o } = {
          key: (i = h5.create(hJ, 'ed25519 seed').update(n4(t)).digest()).slice(0, 32),
          chainCode: i.slice(32),
        };
        return e
          .split('/')
          .slice(1)
          .map(mk)
          .map((e) => parseInt(e, 10))
          .reduce(
            (e, t) =>
              (({ key: e, chainCode: t }, n) => {
                let i = new ArrayBuffer(4);
                new DataView(i).setUint32(0, n);
                let a = new Uint8Array(1 + e.length + i.byteLength);
                a.set(new Uint8Array(1).fill(0)),
                  a.set(e, 1),
                  a.set(new Uint8Array(i, 0, i.byteLength), e.length + 1);
                let o = h5.create(hJ, t).update(a).digest();
                return { key: o.slice(0, 32), chainCode: o.slice(32) };
              })(e, t + n),
            { key: a, chainCode: o }
          );
      };
    class mA extends mn {
      constructor(e) {
        if (
          (super(),
          'string' == typeof e
            ? (this.data = n6(e))
            : e instanceof Uint8Array
            ? (this.data = e)
            : (this.data = Uint8Array.from(e)),
          32 !== this.data.length)
        )
          throw Error(`Invalid public key input. Expected 32 bytes, got ${this.data.length}`);
      }
      equals(e) {
        return super.equals(e);
      }
      toRawBytes() {
        return this.data;
      }
      flag() {
        return hF.ED25519;
      }
      async verify(e, t) {
        let n;
        if ('string' == typeof t) {
          let e = (function (e) {
            let t = n6(e),
              n = hz[t[0]];
            switch (n) {
              case 'Passkey':
                var i = e;
                let a = 'string' == typeof i ? n6(i) : i;
                if (a[0] !== hF.Passkey) throw Error('Invalid signature scheme');
                let o = fm.parse(a.slice(1));
                return {
                  signatureScheme: 'Passkey',
                  serializedSignature: n3(a),
                  signature: a,
                  authenticatorData: o.authenticatorData,
                  clientDataJson: o.clientDataJson,
                  userSignature: new Uint8Array(o.userSignature),
                  publicKey: new Uint8Array(o.userSignature.slice(65)),
                };
              case 'MultiSig':
                return {
                  serializedSignature: e,
                  signatureScheme: n,
                  multisig: fM.MultiSig.parse(t.slice(1)),
                  bytes: t,
                };
              case 'ED25519':
              case 'Secp256k1':
              case 'Secp256r1':
                let s = hL[n],
                  l = t.slice(1, t.length - s),
                  u = t.slice(1 + l.length);
                return {
                  serializedSignature: e,
                  signatureScheme: n,
                  signature: l,
                  publicKey: u,
                  bytes: t,
                };
              default:
                throw Error('Unsupported signature scheme');
            }
          })(t);
          if ('ED25519' !== e.signatureScheme) throw Error('Invalid signature scheme');
          if (!mr(this.toRawBytes(), e.publicKey))
            throw Error('Signature does not match public key');
          n = e.signature;
        } else n = t;
        return hD.default.sign.detached.verify(e, n, this.toRawBytes());
      }
    }
    mA.SIZE = 32;
    let mI = "m/44'/4218'/0'/0'/0'";
    class mj extends mo {
      constructor(e) {
        super(), e ? (this.keypair = e) : (this.keypair = hD.default.sign.keyPair());
      }
      getKeyScheme() {
        return 'ED25519';
      }
      static generate() {
        return new mj(hD.default.sign.keyPair());
      }
      static fromSecretKey(e, t) {
        if ('string' == typeof e) {
          let n = (function (e) {
            let { prefix: t, words: n } = hB.bech32.decode(e);
            if (t !== mi) throw Error('invalid private key prefix');
            let i = new Uint8Array(hB.bech32.fromWords(n)),
              a = i.slice(1);
            return { schema: hz[i[0]], secretKey: a };
          })(e);
          if ('ED25519' !== n.schema) throw Error(`Expected a ED25519 keypair, got ${n.schema}`);
          return this.fromSecretKey(n.secretKey, t);
        }
        let n = e.length;
        if (32 !== n) throw Error(`Wrong secretKey size. Expected 32 bytes, got ${n}.`);
        let i = hD.default.sign.keyPair.fromSeed(e);
        if (!t || !t.skipValidation) {
          let e = new TextEncoder().encode('iota validation'),
            t = hD.default.sign.detached(e, i.secretKey);
          if (!hD.default.sign.detached.verify(e, t, i.publicKey))
            throw Error('provided secretKey is invalid');
        }
        return new mj(i);
      }
      getPublicKey() {
        return new mA(this.keypair.publicKey);
      }
      getSecretKey() {
        return (function (e, t) {
          if (32 !== e.length) throw Error('Invalid bytes length');
          let n = hF[t],
            i = new Uint8Array(e.length + 1);
          return i.set([n]), i.set(e, 1), hB.bech32.encode(mi, hB.bech32.toWords(i));
        })(this.keypair.secretKey.slice(0, 32), this.getKeyScheme());
      }
      async sign(e) {
        return hD.default.sign.detached(e, this.keypair.secretKey);
      }
      static deriveKeypair(e, t) {
        if ((null == t && (t = mI), !mE(t))) throw Error('Invalid derivation path');
        let { key: n } = mO(
          t,
          n8(
            (function (e, t = '') {
              return (function (e, t, n, i) {
                var a;
                let o,
                  {
                    c: s,
                    dkLen: l,
                    DK: u,
                    PRF: c,
                    PRFSalt: d,
                  } = (function (e, t, n, i) {
                    ul(e);
                    let {
                      c: a,
                      dkLen: o,
                      asyncTick: s,
                    } = (function (e, t) {
                      if (void 0 !== t && '[object Object]' !== {}.toString.call(t))
                        throw Error('options should be object or undefined');
                      return Object.assign(e, t);
                    })({ dkLen: 32, asyncTick: 10 }, i);
                    if ((uo(a), uo(o), uo(s), a < 1)) throw Error('iterations (c) should be >= 1');
                    let l = uO(t),
                      u = uO(n),
                      c = new Uint8Array(o),
                      d = h5.create(e, l),
                      f = d._cloneInto().update(u);
                    return { c: a, dkLen: o, asyncTick: s, DK: c, PRF: d, PRFSalt: f };
                  })(e, t, n, i),
                  f = new Uint8Array(4),
                  h = uh(f),
                  p = new Uint8Array(c.outputLen);
                for (let e = 1, t = 0; t < l; e++, t += c.outputLen) {
                  let n = u.subarray(t, t + c.outputLen);
                  h.setInt32(0, e, !1),
                    (o = d._cloneInto(o)).update(f).digestInto(p),
                    n.set(p.subarray(0, n.length));
                  for (let e = 1; e < s; e++) {
                    c._cloneInto(o).update(p).digestInto(p);
                    for (let e = 0; e < n.length; e++) n[e] ^= p[e];
                  }
                }
                return (a = o), c.destroy(), d.destroy(), a && a.destroy(), uf(p), u;
              })(
                hJ,
                (function (e) {
                  let t = mx(e),
                    n = t.split(' ');
                  if (![12, 15, 18, 21, 24].includes(n.length)) throw Error('Invalid mnemonic');
                  return { nfkd: t, words: n };
                })(e).nfkd,
                mx('mnemonic' + t),
                { c: 2048, dkLen: 64 }
              );
            })(e, '')
          )
        );
        return mj.fromSecretKey(n);
      }
      static deriveKeypairFromSeed(e, t) {
        if ((null == t && (t = mI), !mE(t))) throw Error('Invalid derivation path');
        let { key: n } = mO(t, e);
        return mj.fromSecretKey(n);
      }
    }
    var mT = function (e, t, n, i) {
        if ('a' === n && !i) throw TypeError('Private accessor was defined without a getter');
        if ('function' == typeof t ? e !== t || !i : !t.has(e))
          throw TypeError(
            'Cannot read private member from an object whose class did not declare it'
          );
        return 'm' === n ? i : 'a' === n ? i.call(e) : i ? i.value : t.get(e);
      },
      mR = function (e, t, n, i, a) {
        if ('m' === i) throw TypeError('Private method is not writable');
        if ('a' === i && !a) throw TypeError('Private accessor was defined without a setter');
        if ('function' == typeof t ? e !== t || !a : !t.has(e))
          throw TypeError(
            'Cannot write private member to an object whose class did not declare it'
          );
        return 'a' === i ? a.call(e, n) : a ? (a.value = n) : t.set(e, n), n;
      };
    class mM {
      get address() {
        return mT(this, eV, 'f');
      }
      get publicKey() {
        return mT(this, e$, 'f').slice();
      }
      get chains() {
        return mT(this, eW, 'f').slice();
      }
      get features() {
        return mT(this, eq, 'f').slice();
      }
      get label() {
        return mT(this, eK, 'f');
      }
      get icon() {
        return mT(this, eG, 'f');
      }
      constructor(e) {
        eV.set(this, void 0),
          e$.set(this, void 0),
          eW.set(this, void 0),
          eq.set(this, void 0),
          eK.set(this, void 0),
          eG.set(this, void 0),
          new.target === mM && Object.freeze(this),
          mR(this, eV, e.address, 'f'),
          mR(this, e$, e.publicKey.slice(), 'f'),
          mR(this, eW, e.chains.slice(), 'f'),
          mR(this, eq, e.features.slice(), 'f'),
          mR(this, eK, e.label, 'f'),
          mR(this, eG, e.icon, 'f');
      }
    }
    (eV = new WeakMap()),
      (e$ = new WeakMap()),
      (eW = new WeakMap()),
      (eq = new WeakMap()),
      (eK = new WeakMap()),
      (eG = new WeakMap());
    let mP = {
      get url() {
        return `file://${e.P('node_modules/zustand/esm/middleware.mjs')}`;
      },
    };
    function mN(e, t) {
      let n;
      try {
        n = e();
      } catch (e) {
        return;
      }
      return {
        getItem: (e) => {
          var i;
          let a = (e) => (null === e ? null : JSON.parse(e, null == t ? void 0 : t.reviver)),
            o = null != (i = n.getItem(e)) ? i : null;
          return o instanceof Promise ? o.then(a) : a(o);
        },
        setItem: (e, i) => n.setItem(e, JSON.stringify(i, null == t ? void 0 : t.replacer)),
        removeItem: (e) => n.removeItem(e),
      };
    }
    let m_ = (e) => (t) => {
      try {
        let n = e(t);
        if (n instanceof Promise) return n;
        return {
          then: (e) => m_(e)(n),
          catch(e) {
            return this;
          },
        };
      } catch (e) {
        return {
          then(e) {
            return this;
          },
          catch: (t) => m_(t)(e),
        };
      }
    };
    function mD(e) {
      var t = e.match(/^var\((.*)\)$/);
      return t ? t[1] : e;
    }
    function mB(e, t) {
      var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : [],
        i = {};
      for (var a in e) {
        var o = e[a],
          s = [...n, a];
        'string' == typeof o || 'number' == typeof o || null == o
          ? (i[a] = t(o, s))
          : 'object' != typeof o || Array.isArray(o)
          ? console.warn(
              'Skipping invalid key "'
                .concat(s.join('.'), '". Should be a string, number, null or object. Received: "')
                .concat(Array.isArray(o) ? 'Array' : typeof o, '"')
            )
          : (i[a] = mB(o, t, s));
      }
      return i;
    }
    var mU = {},
      mF = e.i(20412),
      mL = class {
        constructor(e) {
          const { failure: t, gotoFn: n, output: i } = this._buildTables(e);
          (this.gotoFn = n), (this.output = i), (this.failure = t);
        }
        _buildTables(e) {
          let t = { 0: {} },
            n = {},
            i = 0;
          for (let a of e) {
            let e = 0;
            for (let o of a)
              t[e] && o in t[e]
                ? (e = t[e][o])
                : (i++, (t[e][o] = i), (t[i] = {}), (e = i), (n[i] = []));
            n[e].push(a);
          }
          let a = {},
            o = [];
          for (let e in t[0]) {
            let n = t[0][e];
            (a[n] = 0), o.push(n);
          }
          for (; o.length > 0; ) {
            let e = o.shift();
            if (void 0 !== e)
              for (let i in t[e]) {
                let s = t[e][i];
                o.push(s);
                let l = a[e];
                for (; l > 0 && !(i in t[l]); ) l = a[l];
                if (i in t[l]) {
                  let e = t[l][i];
                  (a[s] = e), (n[s] = [...n[s], ...n[e]]);
                } else a[s] = 0;
              }
          }
          return { gotoFn: t, output: n, failure: a };
        }
        search(e) {
          let t = 0,
            n = [];
          for (let i = 0; i < e.length; i++) {
            let a = e[i];
            for (; t > 0 && !(a in this.gotoFn[t]); ) t = this.failure[t];
            if (a in this.gotoFn[t] && ((t = this.gotoFn[t][a]), this.output[t].length > 0)) {
              let e = this.output[t];
              n.push([i, e]);
            }
          }
          return n;
        }
        match(e) {
          let t = 0;
          for (let n = 0; n < e.length; n++) {
            let i = e[n];
            for (; t > 0 && !(i in this.gotoFn[t]); ) t = this.failure[t];
            if (i in this.gotoFn[t] && ((t = this.gotoFn[t][i]), this.output[t].length > 0))
              return !0;
          }
          return !1;
        }
      },
      mz = [
        {
          appendCss: () => {},
          registerClassName: () => {},
          onEndFileScope: () => {},
          registerComposition: () => {},
          markCompositionUsed: () => {},
          getIdentOption: () => 'short',
        },
      ],
      mV = !1;
    function m$(e, t) {
      return (
        t || (t = e.slice(0)),
        Object.freeze(Object.defineProperties(e, { raw: { value: Object.freeze(t) } }))
      );
    }
    ((q = eH || (eH = {})).Attribute = 'attribute'),
      (q.Pseudo = 'pseudo'),
      (q.PseudoElement = 'pseudo-element'),
      (q.Tag = 'tag'),
      (q.Universal = 'universal'),
      (q.Adjacent = 'adjacent'),
      (q.Child = 'child'),
      (q.Descendant = 'descendant'),
      (q.Parent = 'parent'),
      (q.Sibling = 'sibling'),
      (q.ColumnCombinator = 'column-combinator'),
      ((K = eZ || (eZ = {})).Any = 'any'),
      (K.Element = 'element'),
      (K.End = 'end'),
      (K.Equals = 'equals'),
      (K.Exists = 'exists'),
      (K.Hyphen = 'hyphen'),
      (K.Not = 'not'),
      (K.Start = 'start');
    let mW = /^[^\\#]?(?:\\(?:[\da-f]{1,6}\s?|.)|[\w\-\u00b0-\uFFFF])+/,
      mq = /\\([\da-f]{1,6}\s?|(\s)|.)/gi,
      mK = new Map([
        [126, eZ.Element],
        [94, eZ.Start],
        [36, eZ.End],
        [42, eZ.Any],
        [33, eZ.Not],
        [124, eZ.Hyphen],
      ]),
      mG = new Set(['has', 'not', 'matches', 'is', 'where', 'host', 'host-context']),
      mH = new Set(['contains', 'icontains']);
    function mZ(e, t, n) {
      let i = parseInt(t, 16) - 65536;
      return i != i || n
        ? t
        : i < 0
        ? String.fromCharCode(i + 65536)
        : String.fromCharCode((i >> 10) | 55296, (1023 & i) | 56320);
    }
    function mY(e) {
      return e.replace(mq, mZ);
    }
    function mQ(e) {
      return 39 === e || 34 === e;
    }
    function mX(e) {
      return 32 === e || 9 === e || 10 === e || 12 === e || 13 === e;
    }
    function mJ(e, t) {
      var n = Object.keys(e);
      if (Object.getOwnPropertySymbols) {
        var i = Object.getOwnPropertySymbols(e);
        t &&
          (i = i.filter(function (t) {
            return Object.getOwnPropertyDescriptor(e, t).enumerable;
          })),
          n.push.apply(n, i);
      }
      return n;
    }
    function m0(e) {
      for (var t = 1; t < arguments.length; t++) {
        var n = null != arguments[t] ? arguments[t] : {};
        t % 2
          ? mJ(Object(n), !0).forEach(function (t) {
              var i, a, o;
              (i = e),
                (a = t),
                (o = n[t]),
                (a = (function (e) {
                  var t = (function (e, t) {
                    if ('object' != typeof e || null === e) return e;
                    var n = e[Symbol.toPrimitive];
                    if (void 0 !== n) {
                      var i = n.call(e, t || 'default');
                      if ('object' != typeof i) return i;
                      throw TypeError('@@toPrimitive must return a primitive value.');
                    }
                    return ('string' === t ? String : Number)(e);
                  })(e, 'string');
                  return 'symbol' == typeof t ? t : String(t);
                })(a)) in i
                  ? Object.defineProperty(i, a, {
                      value: o,
                      enumerable: !0,
                      configurable: !0,
                      writable: !0,
                    })
                  : (i[a] = o);
            })
          : Object.getOwnPropertyDescriptors
          ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n))
          : mJ(Object(n)).forEach(function (t) {
              Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t));
            });
      }
      return e;
    }
    let m1 = (function e(t) {
      return (n.withOptions = (n) => e(m0(m0({}, t), n))), n;
      function n(e, ...i) {
        let a = 'string' == typeof e ? [e] : e.raw,
          {
            alignValues: o = !1,
            escapeSpecialCharacters: s = Array.isArray(e),
            trimWhitespace: l = !0,
          } = t,
          u = '';
        for (let e = 0; e < a.length; e++) {
          let t = a[e];
          if (
            (s &&
              (t = t
                .replace(/\\\n[ \t]*/g, '')
                .replace(/\\`/g, '`')
                .replace(/\\\$/g, '$')
                .replace(/\\\{/g, '{')),
            (u += t),
            e < i.length)
          ) {
            let t = o
              ? (function (e, t) {
                  if ('string' != typeof e || !e.includes('\n')) return e;
                  let n = t.slice(t.lastIndexOf('\n') + 1).match(/^(\s+)/);
                  if (n) {
                    let t = n[1];
                    return e.replace(
                      /\n/g,
                      `
${t}`
                    );
                  }
                  return e;
                })(i[e], u)
              : i[e];
            u += t;
          }
        }
        let c = u.split('\n'),
          d = null;
        for (let e of c) {
          let t = e.match(/^(\s+)\S+/);
          if (t) {
            let e = t[1].length;
            d = d ? Math.min(d, e) : e;
          }
        }
        if (null !== d) {
          let e = d;
          u = c.map((t) => (' ' === t[0] || '	' === t[0] ? t.slice(e) : t)).join('\n');
        }
        return l && (u = u.trim()), s && (u = u.replace(/\\n/g, '\n')), u;
      }
    })({});
    var m5 = function () {
      return (m5 =
        Object.assign ||
        function (e) {
          for (var t, n = 1, i = arguments.length; n < i; n++)
            for (var a in (t = arguments[n]))
              Object.prototype.hasOwnProperty.call(t, a) && (e[a] = t[a]);
          return e;
        }).apply(this, arguments);
    };
    function m2(e, t) {
      var n = {};
      for (var i in e)
        Object.prototype.hasOwnProperty.call(e, i) && 0 > t.indexOf(i) && (n[i] = e[i]);
      if (null != e && 'function' == typeof Object.getOwnPropertySymbols)
        for (var a = 0, i = Object.getOwnPropertySymbols(e); a < i.length; a++)
          0 > t.indexOf(i[a]) &&
            Object.prototype.propertyIsEnumerable.call(e, i[a]) &&
            (n[i[a]] = e[i[a]]);
      return n;
    }
    function m6(e, t) {
      var n = 'function' == typeof Symbol && e[Symbol.iterator];
      if (!n) return e;
      var i,
        a,
        o = n.call(e),
        s = [];
      try {
        for (; (void 0 === t || t-- > 0) && !(i = o.next()).done; ) s.push(i.value);
      } catch (e) {
        a = { error: e };
      } finally {
        try {
          i && !i.done && (n = o.return) && n.call(o);
        } finally {
          if (a) throw a.error;
        }
      }
      return s;
    }
    var m3 = /(\u000D|\u000C|\u000D\u000A)/g,
      m4 = /[\u0000\uD800-\uDFFF]/g,
      m8 = /(\/\*)[\s\S]*?(\*\/)/g,
      m9 = function (e, t) {
        void 0 === t && (t = 0), (e = (e = e.replace(m3, '\n').replace(m4, '')).replace(m8, ''));
        for (var n = []; t < e.length; t += 1) {
          var i = e.charCodeAt(t);
          if (9 === i || 32 === i || 10 === i) {
            for (var a = e.charCodeAt(++t); 9 === a || 32 === a || 10 === a; )
              a = e.charCodeAt(++t);
            (t -= 1), n.push({ type: '<whitespace-token>' });
          } else if (34 === i) {
            var o = m7(e, t);
            if (null === o) return null;
            var s = m6(o, 2),
              l = s[0],
              u = s[1];
            n.push({ type: '<string-token>', value: u }), (t = l);
          } else if (35 === i) {
            if (t + 1 < e.length) {
              var c = e.charCodeAt(t + 1);
              if (
                95 === c ||
                (c >= 65 && c <= 90) ||
                (c >= 97 && c <= 122) ||
                c >= 128 ||
                (c >= 48 && c <= 57) ||
                (92 === c && t + 2 < e.length && 10 !== e.charCodeAt(t + 2))
              ) {
                var d = ge(e, t + 1) ? 'id' : 'unrestricted',
                  o = gi(e, t + 1);
                if (null !== o) {
                  var f = m6(o, 2),
                    l = f[0],
                    u = f[1];
                  n.push({ type: '<hash-token>', value: u.toLowerCase(), flag: d }), (t = l);
                  continue;
                }
              }
            }
            n.push({ type: '<delim-token>', value: i });
          } else if (39 === i) {
            var o = m7(e, t);
            if (null === o) return null;
            var h = m6(o, 2),
              l = h[0],
              u = h[1];
            n.push({ type: '<string-token>', value: u }), (t = l);
          } else if (40 === i) n.push({ type: '<(-token>' });
          else if (41 === i) n.push({ type: '<)-token>' });
          else if (43 === i) {
            var p = gr(e, t);
            if (null === p) n.push({ type: '<delim-token>', value: i });
            else {
              var m = m6(p, 2),
                l = m[0],
                g = m[1];
              '<dimension-token>' === g[0]
                ? n.push({
                    type: '<dimension-token>',
                    value: g[1],
                    unit: g[2].toLowerCase(),
                    flag: 'number',
                  })
                : '<number-token>' === g[0]
                ? n.push({ type: g[0], value: g[1], flag: g[2] })
                : n.push({ type: g[0], value: g[1], flag: 'number' }),
                (t = l);
            }
          } else if (44 === i) n.push({ type: '<comma-token>' });
          else if (45 === i) {
            var y = gr(e, t);
            if (null !== y) {
              var b = m6(y, 2),
                l = b[0],
                g = b[1];
              '<dimension-token>' === g[0]
                ? n.push({
                    type: '<dimension-token>',
                    value: g[1],
                    unit: g[2].toLowerCase(),
                    flag: 'number',
                  })
                : '<number-token>' === g[0]
                ? n.push({ type: g[0], value: g[1], flag: g[2] })
                : n.push({ type: g[0], value: g[1], flag: 'number' }),
                (t = l);
              continue;
            }
            if (t + 2 < e.length) {
              var c = e.charCodeAt(t + 1),
                v = e.charCodeAt(t + 2);
              if (45 === c && 62 === v) {
                n.push({ type: '<CDC-token>' }), (t += 2);
                continue;
              }
            }
            var o = gs(e, t);
            if (null !== o) {
              var w = m6(o, 3),
                l = w[0],
                u = w[1],
                x = w[2];
              n.push({ type: x, value: u }), (t = l);
              continue;
            }
            n.push({ type: '<delim-token>', value: i });
          } else if (46 === i) {
            var y = gr(e, t);
            if (null === y) n.push({ type: '<delim-token>', value: i });
            else {
              var E = m6(y, 2),
                l = E[0],
                g = E[1];
              '<dimension-token>' === g[0]
                ? n.push({
                    type: '<dimension-token>',
                    value: g[1],
                    unit: g[2].toLowerCase(),
                    flag: 'number',
                  })
                : '<number-token>' === g[0]
                ? n.push({ type: g[0], value: g[1], flag: g[2] })
                : n.push({ type: g[0], value: g[1], flag: 'number' }),
                (t = l);
              continue;
            }
          } else if (58 === i) n.push({ type: '<colon-token>' });
          else if (59 === i) n.push({ type: '<semicolon-token>' });
          else if (60 === i) {
            if (t + 3 < e.length) {
              var c = e.charCodeAt(t + 1),
                v = e.charCodeAt(t + 2),
                S = e.charCodeAt(t + 3);
              if (33 === c && 45 === v && 45 === S) {
                n.push({ type: '<CDO-token>' }), (t += 3);
                continue;
              }
            }
            n.push({ type: '<delim-token>', value: i });
          } else if (64 === i) {
            var o = ga(e, t + 1);
            if (null !== o) {
              var C = m6(o, 2),
                l = C[0],
                u = C[1];
              n.push({ type: '<at-keyword-token>', value: u.toLowerCase() }), (t = l);
              continue;
            }
            n.push({ type: '<delim-token>', value: i });
          } else if (91 === i) n.push({ type: '<[-token>' });
          else if (92 === i) {
            var o = gt(e, t);
            if (null === o) return null;
            var k = m6(o, 2),
              l = k[0],
              u = k[1];
            (e = e.slice(0, t) + u + e.slice(l + 1)), (t -= 1);
          } else if (93 === i) n.push({ type: '<]-token>' });
          else if (123 === i) n.push({ type: '<{-token>' });
          else if (125 === i) n.push({ type: '<}-token>' });
          else if (i >= 48 && i <= 57) {
            var o = gr(e, t),
              O = m6(o, 2),
              l = O[0],
              g = O[1];
            '<dimension-token>' === g[0]
              ? n.push({
                  type: '<dimension-token>',
                  value: g[1],
                  unit: g[2].toLowerCase(),
                  flag: 'number',
                })
              : '<number-token>' === g[0]
              ? n.push({ type: g[0], value: g[1], flag: g[2] })
              : n.push({ type: g[0], value: g[1], flag: 'number' }),
              (t = l);
          } else if (95 === i || (i >= 65 && i <= 90) || (i >= 97 && i <= 122) || i >= 128) {
            var o = gs(e, t);
            if (null === o) return null;
            var A = m6(o, 3),
              l = A[0],
              u = A[1],
              x = A[2];
            n.push({ type: x, value: u }), (t = l);
          } else n.push({ type: '<delim-token>', value: i });
        }
        return n.push({ type: '<EOF-token>' }), n;
      },
      m7 = function (e, t) {
        if (e.length <= t + 1) return null;
        for (var n = e.charCodeAt(t), i = [], a = t + 1; a < e.length; a += 1) {
          var o = e.charCodeAt(a);
          if (o === n) return [a, String.fromCharCode.apply(null, i)];
          if (92 === o) {
            var s = gt(e, a);
            if (null === s) return null;
            var l = m6(s, 2),
              u = l[0],
              c = l[1];
            i.push(c), (a = u);
          } else {
            if (10 === o) return null;
            i.push(o);
          }
        }
        return null;
      },
      ge = function (e, t) {
        if (e.length <= t) return !1;
        var n = e.charCodeAt(t);
        if (45 === n) {
          if (e.length <= t + 1) return !1;
          var i = e.charCodeAt(t + 1);
          return (
            45 === i ||
            95 === i ||
            (!!(i >= 65) && !!(i <= 90)) ||
            (!!(i >= 97) && !!(i <= 122)) ||
            !!(i >= 128) ||
            (92 === i && !(e.length <= t + 2) && 10 !== e.charCodeAt(t + 2))
          );
        }
        if (95 === n || (n >= 65 && n <= 90) || (n >= 97 && n <= 122) || n >= 128) return !0;
        if (92 !== n) return !1;
        if (e.length <= t + 1) return !1;
        var i = e.charCodeAt(t + 1);
        return 10 !== i;
      },
      gt = function (e, t) {
        if (e.length <= t + 1 || 92 !== e.charCodeAt(t)) return null;
        var n = e.charCodeAt(t + 1);
        if (10 === n) return null;
        if ((!(n >= 48) || !(n <= 57)) && (!(n >= 65) || !(n <= 70)) && (!(n >= 97) || !(n <= 102)))
          return [t + 1, n];
        for (var i = [n], a = Math.min(t + 7, e.length), o = t + 2; o < a; o += 1) {
          var s = e.charCodeAt(o);
          if ((s >= 48 && s <= 57) || (s >= 65 && s <= 70) || (s >= 97 && s <= 102)) i.push(s);
          else break;
        }
        if (o < e.length) {
          var l = e.charCodeAt(o);
          (9 === l || 32 === l || 10 === l) && (o += 1);
        }
        return [o - 1, parseInt(String.fromCharCode.apply(null, i), 16)];
      },
      gr = function (e, t) {
        var n = gn(e, t);
        if (null === n) return null;
        var i = m6(n, 3),
          a = i[0],
          o = i[1],
          s = i[2],
          l = ga(e, a + 1);
        if (null !== l) {
          var u = m6(l, 2);
          return [u[0], ['<dimension-token>', o, u[1]]];
        }
        return a + 1 < e.length && 37 === e.charCodeAt(a + 1)
          ? [a + 1, ['<percentage-token>', o]]
          : [a, ['<number-token>', o, s]];
      },
      gn = function (e, t) {
        if (e.length <= t) return null;
        var n = 'integer',
          i = [],
          a = e.charCodeAt(t);
        for ((43 === a || 45 === a) && ((t += 1), 45 === a && i.push(45)); t < e.length; ) {
          var o = e.charCodeAt(t);
          if (o >= 48 && o <= 57) i.push(o), (t += 1);
          else break;
        }
        if (t + 1 < e.length) {
          var s = e.charCodeAt(t),
            l = e.charCodeAt(t + 1);
          if (46 === s && l >= 48 && l <= 57)
            for (i.push(s, l), n = 'number', t += 2; t < e.length; ) {
              var o = e.charCodeAt(t);
              if (o >= 48 && o <= 57) i.push(o), (t += 1);
              else break;
            }
        }
        if (t + 1 < e.length) {
          var s = e.charCodeAt(t),
            l = e.charCodeAt(t + 1),
            u = e.charCodeAt(t + 2);
          if (69 === s || 101 === s) {
            var c = l >= 48 && l <= 57;
            if (c || ((43 === l || 45 === l) && u >= 48 && u <= 57))
              for (
                n = 'number',
                  c
                    ? (i.push(69, l), (t += 2))
                    : (45 === l ? i.push(69, 45, u) : i.push(69, u), (t += 3));
                t < e.length;

              ) {
                var o = e.charCodeAt(t);
                if (o >= 48 && o <= 57) i.push(o), (t += 1);
                else break;
              }
          }
        }
        var d = String.fromCharCode.apply(null, i),
          f = 'number' === n ? parseFloat(d) : parseInt(d);
        return -0 === f && (f = 0), Number.isNaN(f) ? null : [t - 1, f, n];
      },
      gi = function (e, t) {
        if (e.length <= t) return null;
        for (var n = [], i = e.charCodeAt(t); t < e.length; i = e.charCodeAt(++t)) {
          if (
            45 === i ||
            95 === i ||
            (i >= 65 && i <= 90) ||
            (i >= 97 && i <= 122) ||
            i >= 128 ||
            (i >= 48 && i <= 57)
          ) {
            n.push(i);
            continue;
          }
          var a = gt(e, t);
          if (null !== a) {
            var o = m6(a, 2),
              s = o[0],
              l = o[1];
            n.push(l), (t = s);
            continue;
          }
          break;
        }
        return 0 === t ? null : [t - 1, String.fromCharCode.apply(null, n)];
      },
      ga = function (e, t) {
        if (e.length <= t || !ge(e, t)) return null;
        for (var n = [], i = e.charCodeAt(t); t < e.length; i = e.charCodeAt(++t)) {
          if (
            45 === i ||
            95 === i ||
            (i >= 65 && i <= 90) ||
            (i >= 97 && i <= 122) ||
            i >= 128 ||
            (i >= 48 && i <= 57)
          ) {
            n.push(i);
            continue;
          }
          var a = gt(e, t);
          if (null !== a) {
            var o = m6(a, 2),
              s = o[0],
              l = o[1];
            n.push(l), (t = s);
            continue;
          }
          break;
        }
        return [t - 1, String.fromCharCode.apply(null, n)];
      },
      go = function (e, t) {
        for (var n = e.charCodeAt(t); 9 === n || 32 === n || 10 === n; ) n = e.charCodeAt(++t);
        for (var i = [], a = !1; t < e.length; ) {
          if (41 === n) return [t, String.fromCharCode.apply(null, i)];
          if (34 === n || 39 === n || 40 === n) break;
          if (9 === n || 32 === n || 10 === n) a || 0 === i.length || (a = !0);
          else if (92 === n) {
            var o = gt(e, t);
            if (null === o || a) return null;
            var s = m6(o, 2),
              l = s[0],
              u = s[1];
            i.push(u), (t = l);
          } else {
            if (a) return null;
            i.push(n);
          }
          n = e.charCodeAt(++t);
        }
        return null;
      },
      gs = function (e, t) {
        var n = ga(e, t);
        if (null === n) return null;
        var i = m6(n, 2),
          a = i[0],
          o = i[1];
        if ('url' === o.toLowerCase()) {
          if (e.length > a + 1) {
            var s = e.charCodeAt(a + 1);
            if (40 === s) {
              for (var l = 2; a + l < e.length; l += 1) {
                var u = e.charCodeAt(a + l);
                if (34 === u || 39 === u) break;
                if (9 !== u && 32 !== u && 10 !== u) {
                  var c = go(e, a + l);
                  if (null === c) return null;
                  var d = m6(c, 2);
                  return [d[0], d[1], '<url-token>'];
                }
              }
              return [a + 1, o.toLowerCase(), '<function-token>'];
            }
          }
        } else if (e.length > a + 1) {
          var s = e.charCodeAt(a + 1);
          if (40 === s) return [a + 1, o.toLowerCase(), '<function-token>'];
        }
        return [a, o.toLowerCase(), '<ident-token>'];
      },
      gl = function (e) {
        for (var t = e.length - 1; t >= 0; t--) e[t] = gu(e[t]);
        return e;
      },
      gu = function (e) {
        if (null === e.mediaCondition) return e;
        var t = gc(e.mediaCondition);
        return (
          null === t.operator &&
            1 === t.children.length &&
            'children' in t.children[0] &&
            (t = t.children[0]),
          { mediaPrefix: e.mediaPrefix, mediaType: e.mediaType, mediaCondition: t }
        );
      },
      gc = function e(t) {
        for (var n = t.children.length - 1; n >= 0; n--) {
          var i = t.children[n];
          if (!('context' in i)) {
            var a = e(i);
            if (null === a.operator && 1 === a.children.length) t.children[n] = a.children[0];
            else if (a.operator === t.operator && ('and' === a.operator || 'or' === a.operator)) {
              for (var o = [n, 1], s = 0; s < a.children.length; s++) o.push(a.children[s]);
              t.children.splice.apply(t.children, o);
            }
          }
        }
        return t;
      },
      gd = function (e, t) {
        return t instanceof Error
          ? Error(''.concat(t.message.trim(), '\n').concat(e.trim()))
          : Error(e.trim());
      },
      gf = function (e) {
        var t = m9(e.trim());
        if (null === t) throw gd('Failed tokenizing');
        var n = 0,
          i = t.length - 1;
        if ('<at-keyword-token>' === t[0].type && 'media' === t[0].value) {
          if ('<whitespace-token>' !== t[1].type) throw gd('Expected whitespace after media');
          n = 2;
          for (var a = 2; a < t.length - 1; a++) {
            var o = t[a];
            if ('<{-token>' === o.type) {
              i = a;
              break;
            }
            if ('<semicolon-token>' === o.type)
              throw gd("Expected '{' in media query but found ';'");
          }
        }
        return gp((t = t.slice(n, i)));
      },
      gh = function (e) {
        for (var t = [], n = !1, i = 0; i < e.length; i++)
          '<whitespace-token>' === e[i].type
            ? ((n = !0), t.length > 0 && (t[t.length - 1].wsAfter = !0))
            : (t.push(m5(m5({}, e[i]), { wsBefore: n, wsAfter: !1 })), (n = !1));
        return t;
      },
      gp = function (e) {
        for (var t, n, i = [[]], a = 0; a < e.length; a++) {
          var o = e[a];
          '<comma-token>' === o.type ? i.push([]) : i[i.length - 1].push(o);
        }
        var s = i.map(gh);
        if (1 === s.length && 0 === s[0].length)
          return [{ mediaCondition: null, mediaPrefix: null, mediaType: 'all' }];
        var l = s.map(function (e) {
            return 0 === e.length ? null : gm(e);
          }),
          u = [];
        try {
          for (
            var c = (function (e) {
                var t = 'function' == typeof Symbol && Symbol.iterator,
                  n = t && e[t],
                  i = 0;
                if (n) return n.call(e);
                if (e && 'number' == typeof e.length)
                  return {
                    next: function () {
                      return e && i >= e.length && (e = void 0), { value: e && e[i++], done: !e };
                    },
                  };
                throw TypeError(t ? 'Object is not iterable.' : 'Symbol.iterator is not defined.');
              })(l),
              d = c.next();
            !d.done;
            d = c.next()
          ) {
            var f = d.value;
            null !== f && u.push(f);
          }
        } catch (e) {
          t = { error: e };
        } finally {
          try {
            d && !d.done && (n = c.return) && n.call(c);
          } finally {
            if (t) throw t.error;
          }
        }
        if (0 === u.length) throw gd('No valid media queries');
        return u;
      },
      gm = function (e) {
        var t = e[0];
        if ('<(-token>' === t.type)
          try {
            return { mediaPrefix: null, mediaType: 'all', mediaCondition: gg(e, !0) };
          } catch (e) {
            throw gd("Expected media condition after '('", e);
          }
        if ('<ident-token>' === t.type) {
          var n = null,
            i = void 0,
            a = t.value;
          ('only' === a || 'not' === a) && (n = a);
          var o = +(null !== n);
          if (e.length <= o) throw gd('Expected extra token in media query');
          var s = e[o];
          if ('<ident-token>' === s.type) {
            var l = s.value;
            if ('all' === l) i = 'all';
            else if ('print' === l || 'screen' === l) i = l;
            else if (
              'tty' === l ||
              'tv' === l ||
              'projection' === l ||
              'handheld' === l ||
              'braille' === l ||
              'embossed' === l ||
              'aural' === l ||
              'speech' === l
            )
              (n = 'not' === n ? null : 'not'), (i = 'all');
            else throw gd("Unknown ident '".concat(l, "' in media query"));
          } else if ('not' === n && '<(-token>' === s.type) {
            var u = [{ type: '<(-token>', wsBefore: !1, wsAfter: !1 }];
            u.push.apply(u, e), u.push({ type: '<)-token>', wsBefore: !1, wsAfter: !1 });
            try {
              return { mediaPrefix: null, mediaType: 'all', mediaCondition: gg(u, !0) };
            } catch (e) {
              throw gd("Expected media condition after '('", e);
            }
          } else throw gd('Invalid media query');
          if (o + 1 === e.length) return { mediaPrefix: n, mediaType: i, mediaCondition: null };
          if (o + 4 < e.length) {
            var c = e[o + 1];
            if ('<ident-token>' === c.type && 'and' === c.value)
              try {
                return { mediaPrefix: n, mediaType: i, mediaCondition: gg(e.slice(o + 2), !1) };
              } catch (e) {
                throw gd("Expected media condition after 'and'", e);
              }
            throw gd("Expected 'and' after media prefix");
          }
          throw gd('Expected media condition after media prefix');
        }
        throw gd('Expected media condition or media prefix');
      },
      gg = function e(t, n, i) {
        if (
          (void 0 === i && (i = null),
          t.length < 3 || '<(-token>' !== t[0].type || '<)-token>' !== t[t.length - 1].type)
        )
          throw Error('Invalid media condition');
        for (var a, o = t.length - 1, s = 0, l = 0, u = 0; u < t.length; u++) {
          var c = t[u];
          if (
            ('<(-token>' === c.type
              ? ((l += 1), (s = Math.max(s, l)))
              : '<)-token>' === c.type && (l -= 1),
            0 === l)
          ) {
            o = u;
            break;
          }
        }
        if (0 !== l) throw Error('Mismatched parens\nInvalid media condition');
        var d = t.slice(0, o + 1);
        if (
          ((a =
            1 === s
              ? gy(d)
              : '<ident-token>' === d[1].type && 'not' === d[1].value
              ? e(d.slice(2, -1), !0, 'not')
              : e(d.slice(1, -1), !0)),
          o === t.length - 1)
        )
          return { operator: i, children: [a] };
        var f = t[o + 1];
        if ('<ident-token>' !== f.type) throw Error('Invalid operator\nInvalid media condition');
        if (null !== i && i !== f.value)
          throw Error(
            "'"
              .concat(f.value, "' and '")
              .concat(i, "' must not be at same level\nInvalid media condition")
          );
        if ('or' !== f.value || n) {
          if ('and' !== f.value && 'or' !== f.value)
            throw Error("Invalid operator: '".concat(f.value, "'\nInvalid media condition"));
        } else
          throw Error("Cannot use 'or' at top level of a media query\nInvalid media condition");
        var h = e(t.slice(o + 2), n, f.value);
        return { operator: f.value, children: [a].concat(h.children) };
      },
      gy = function (e) {
        if (e.length < 3 || '<(-token>' !== e[0].type || '<)-token>' !== e[e.length - 1].type)
          throw Error('Invalid media feature');
        for (var t = [e[0]], n = 1; n < e.length; n++) {
          if (n < e.length - 2) {
            var i = e[n],
              a = e[n + 1],
              o = e[n + 2];
            if (
              '<number-token>' === i.type &&
              i.value > 0 &&
              '<delim-token>' === a.type &&
              47 === a.value &&
              '<number-token>' === o.type &&
              o.value > 0
            ) {
              t.push({
                type: '<ratio-token>',
                numerator: i.value,
                denominator: o.value,
                wsBefore: i.wsBefore,
                wsAfter: o.wsAfter,
              }),
                (n += 2);
              continue;
            }
          }
          t.push(e[n]);
        }
        var s = t[1];
        if ('<ident-token>' === s.type && 3 === t.length)
          return { context: 'boolean', feature: s.value };
        if (5 === t.length && '<ident-token>' === t[1].type && '<colon-token>' === t[2].type) {
          var l = t[3];
          if (
            '<number-token>' === l.type ||
            '<dimension-token>' === l.type ||
            '<ratio-token>' === l.type ||
            '<ident-token>' === l.type
          ) {
            var u = t[1].value,
              c = null,
              d = u.slice(0, 4);
            return (
              'min-' === d
                ? ((c = 'min'), (u = u.slice(4)))
                : 'max-' === d && ((c = 'max'), (u = u.slice(4))),
              l.wsBefore,
              l.wsAfter,
              { context: 'value', prefix: c, feature: u, value: m2(l, ['wsBefore', 'wsAfter']) }
            );
          }
        } else if (t.length >= 5)
          try {
            var f = gb(t);
            return { context: 'range', feature: f.featureName, range: f };
          } catch (e) {
            throw gd('Invalid media feature', e);
          }
        throw Error('Invalid media feature');
      },
      gb = function (e) {
        if (e.length < 5 || '<(-token>' !== e[0].type || '<)-token>' !== e[e.length - 1].type)
          throw Error('Invalid range');
        var t,
          n,
          i,
          a,
          o = { leftToken: null, leftOp: null, featureName: '', rightOp: null, rightToken: null },
          s =
            '<number-token>' === e[1].type ||
            '<dimension-token>' === e[1].type ||
            '<ratio-token>' === e[1].type ||
            ('<ident-token>' === e[1].type && 'infinite' === e[1].value);
        if ('<delim-token>' === e[2].type) {
          if (60 === e[2].value)
            '<delim-token>' !== e[3].type || 61 !== e[3].value || e[3].wsBefore
              ? (o[s ? 'leftOp' : 'rightOp'] = '<')
              : (o[s ? 'leftOp' : 'rightOp'] = '<=');
          else if (62 === e[2].value)
            '<delim-token>' !== e[3].type || 61 !== e[3].value || e[3].wsBefore
              ? (o[s ? 'leftOp' : 'rightOp'] = '>')
              : (o[s ? 'leftOp' : 'rightOp'] = '>=');
          else if (61 === e[2].value) o[s ? 'leftOp' : 'rightOp'] = '=';
          else throw Error('Invalid range');
          if (s) o.leftToken = e[1];
          else if ('<ident-token>' === e[1].type) o.featureName = e[1].value;
          else throw Error('Invalid range');
          var l =
              2 +
              (null != (n = null == (t = o[s ? 'leftOp' : 'rightOp']) ? void 0 : t.length) ? n : 0),
            u = e[l];
          if (s)
            if ('<ident-token>' === u.type) {
              if (((o.featureName = u.value), e.length >= 7)) {
                var c = e[l + 1],
                  d = e[l + 2];
                if ('<delim-token>' === c.type) {
                  var f = c.value;
                  if (60 === f)
                    '<delim-token>' !== d.type || 61 !== d.value || d.wsBefore
                      ? (o.rightOp = '<')
                      : (o.rightOp = '<=');
                  else if (62 === f)
                    '<delim-token>' !== d.type || 61 !== d.value || d.wsBefore
                      ? (o.rightOp = '>')
                      : (o.rightOp = '>=');
                  else throw Error('Invalid range');
                  var h =
                    e[l + 1 + (null != (a = null == (i = o.rightOp) ? void 0 : i.length) ? a : 0)];
                  o.rightToken = h;
                } else throw Error('Invalid range');
              } else if (l + 2 !== e.length) throw Error('Invalid range');
            } else throw Error('Invalid range');
          else o.rightToken = u;
          var p = null,
            m = o.leftToken,
            g = o.leftOp,
            y = o.featureName,
            b = o.rightOp,
            v = o.rightToken,
            w = null;
          if (null !== m)
            if ('<ident-token>' === m.type) {
              var x = m.type,
                E = m.value;
              'infinite' === E && (w = { type: x, value: E });
            } else
              ('<number-token>' === m.type ||
                '<dimension-token>' === m.type ||
                '<ratio-token>' === m.type) &&
                (m.wsBefore, m.wsAfter, (w = m2(m, ['wsBefore', 'wsAfter'])));
          var S = null;
          if (null !== v)
            if ('<ident-token>' === v.type) {
              var x = v.type,
                E = v.value;
              'infinite' === E && (S = { type: x, value: E });
            } else
              ('<number-token>' === v.type ||
                '<dimension-token>' === v.type ||
                '<ratio-token>' === v.type) &&
                (v.wsBefore, v.wsAfter, (S = m2(v, ['wsBefore', 'wsAfter'])));
          if (null !== w && null !== S)
            if (('<' === g || '<=' === g) && ('<' === b || '<=' === b))
              p = { leftToken: w, leftOp: g, featureName: y, rightOp: b, rightToken: S };
            else if (('>' === g || '>=' === g) && ('>' === b || '>=' === b))
              p = { leftToken: w, leftOp: g, featureName: y, rightOp: b, rightToken: S };
            else throw Error('Invalid range');
          else
            null === w && null === g && null !== b && null !== S
              ? (p = { leftToken: w, leftOp: g, featureName: y, rightOp: b, rightToken: S })
              : null !== w &&
                null !== g &&
                null === b &&
                null === S &&
                (p = { leftToken: w, leftOp: g, featureName: y, rightOp: b, rightToken: S });
          return p;
        }
        throw Error('Invalid range');
      };
    function gv(e, t) {
      var n = Object.keys(e);
      if (Object.getOwnPropertySymbols) {
        var i = Object.getOwnPropertySymbols(e);
        t &&
          (i = i.filter(function (t) {
            return Object.getOwnPropertyDescriptor(e, t).enumerable;
          })),
          n.push.apply(n, i);
      }
      return n;
    }
    function gw(e) {
      for (var t = 1; t < arguments.length; t++) {
        var n = null != arguments[t] ? arguments[t] : {};
        t % 2
          ? gv(Object(n), !0).forEach(function (t) {
              !(function (e, t, n) {
                var i;
                (t =
                  'symbol' ==
                  typeof (i = (function (e, t) {
                    if ('object' != typeof e || !e) return e;
                    var n = e[Symbol.toPrimitive];
                    if (void 0 !== n) {
                      var i = n.call(e, t || 'default');
                      if ('object' != typeof i) return i;
                      throw TypeError('@@toPrimitive must return a primitive value.');
                    }
                    return ('string' === t ? String : Number)(e);
                  })(t, 'string'))
                    ? i
                    : String(i)) in e
                  ? Object.defineProperty(e, t, {
                      value: n,
                      enumerable: !0,
                      configurable: !0,
                      writable: !0,
                    })
                  : (e[t] = n);
              })(e, t, n[t]);
            })
          : Object.getOwnPropertyDescriptors
          ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n))
          : gv(Object(n)).forEach(function (t) {
              Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t));
            });
      }
      return e;
    }
    function gx(e, t) {
      if (null == e) return {};
      var n,
        i,
        a = (function (e, t) {
          if (null == e) return {};
          var n,
            i,
            a = {},
            o = Object.keys(e);
          for (i = 0; i < o.length; i++) (n = o[i]), t.indexOf(n) >= 0 || (a[n] = e[n]);
          return a;
        })(e, t);
      if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        for (i = 0; i < o.length; i++)
          (n = o[i]),
            !(t.indexOf(n) >= 0) &&
              Object.prototype.propertyIsEnumerable.call(e, n) &&
              (a[n] = e[n]);
      }
      return a;
    }
    function gE(e, t) {
      for (var n in e) t(e[n], n);
    }
    function gS(e, t) {
      var n = {};
      for (var i in e) -1 === t.indexOf(i) && (n[i] = e[i]);
      return n;
    }
    class gC {
      constructor() {
        (this.ruleset = new Map()), (this.precedenceLookup = new Map());
      }
      findOrCreateCondition(e) {
        var t = this.ruleset.get(e);
        return t || ((t = { query: e, rules: [], children: new gC() }), this.ruleset.set(e, t)), t;
      }
      getConditionalRulesetByPath(e) {
        var t = this;
        for (var n of e) t = t.findOrCreateCondition(n).children;
        return t;
      }
      addRule(e, t, n) {
        var i = this.getConditionalRulesetByPath(n).findOrCreateCondition(t);
        if (!i) throw Error('Failed to add conditional rule');
        i.rules.push(e);
      }
      addConditionPrecedence(e, t) {
        for (var n = this.getConditionalRulesetByPath(e), i = 0; i < t.length; i++) {
          var a,
            o = t[i],
            s = null != (a = n.precedenceLookup.get(o)) ? a : new Set();
          for (var l of t.slice(i + 1)) s.add(l);
          n.precedenceLookup.set(o, s);
        }
      }
      isCompatible(e) {
        for (var [t, n] of this.precedenceLookup.entries())
          for (var i of n) {
            var a;
            if (null != (a = e.precedenceLookup.get(i)) && a.has(t)) return !1;
          }
        for (var { query: o, children: s } of e.ruleset.values()) {
          var l = this.ruleset.get(o);
          if (l && !l.children.isCompatible(s)) return !1;
        }
        return !0;
      }
      merge(e) {
        for (var { query: t, rules: n, children: i } of e.ruleset.values()) {
          var a = this.ruleset.get(t);
          a
            ? (a.rules.push(...n), a.children.merge(i))
            : this.ruleset.set(t, { query: t, rules: n, children: i });
        }
        for (var [o, s] of e.precedenceLookup.entries()) {
          var l,
            u = null != (l = this.precedenceLookup.get(o)) ? l : new Set();
          this.precedenceLookup.set(o, new Set([...u, ...s]));
        }
      }
      mergeIfCompatible(e) {
        return !!this.isCompatible(e) && (this.merge(e), !0);
      }
      getSortedRuleset() {
        var e = this,
          t = [],
          n = function (n) {
            var a = e.ruleset.get(i);
            if (!a) throw Error("Can't find condition for ".concat(i));
            var o = t.findIndex((e) => n.has(e.query));
            o > -1 ? t.splice(o, 0, a) : t.push(a);
          };
        for (var [i, a] of this.precedenceLookup.entries()) n(a);
        return t;
      }
      renderToArray() {
        var e = [];
        for (var { query: t, rules: n, children: i } of this.getSortedRuleset()) {
          var a = {};
          for (var o of n) a[o.selector] = gw(gw({}, a[o.selector]), o.rule);
          Object.assign(a, ...i.renderToArray()), e.push({ [t]: a });
        }
        return e;
      }
    }
    var gk = {
        ':-moz-any-link': !0,
        ':-moz-full-screen': !0,
        ':-moz-placeholder': !0,
        ':-moz-read-only': !0,
        ':-moz-read-write': !0,
        ':-ms-fullscreen': !0,
        ':-ms-input-placeholder': !0,
        ':-webkit-any-link': !0,
        ':-webkit-full-screen': !0,
        '::-moz-color-swatch': !0,
        '::-moz-list-bullet': !0,
        '::-moz-list-number': !0,
        '::-moz-page-sequence': !0,
        '::-moz-page': !0,
        '::-moz-placeholder': !0,
        '::-moz-progress-bar': !0,
        '::-moz-range-progress': !0,
        '::-moz-range-thumb': !0,
        '::-moz-range-track': !0,
        '::-moz-scrolled-page-sequence': !0,
        '::-moz-selection': !0,
        '::-ms-backdrop': !0,
        '::-ms-browse': !0,
        '::-ms-check': !0,
        '::-ms-clear': !0,
        '::-ms-fill-lower': !0,
        '::-ms-fill-upper': !0,
        '::-ms-fill': !0,
        '::-ms-reveal': !0,
        '::-ms-thumb': !0,
        '::-ms-ticks-after': !0,
        '::-ms-ticks-before': !0,
        '::-ms-tooltip': !0,
        '::-ms-track': !0,
        '::-ms-value': !0,
        '::-webkit-backdrop': !0,
        '::-webkit-calendar-picker-indicator': !0,
        '::-webkit-inner-spin-button': !0,
        '::-webkit-input-placeholder': !0,
        '::-webkit-meter-bar': !0,
        '::-webkit-meter-even-less-good-value': !0,
        '::-webkit-meter-inner-element': !0,
        '::-webkit-meter-optimum-value': !0,
        '::-webkit-meter-suboptimum-value': !0,
        '::-webkit-outer-spin-button': !0,
        '::-webkit-progress-bar': !0,
        '::-webkit-progress-inner-element': !0,
        '::-webkit-progress-inner-value': !0,
        '::-webkit-progress-value': !0,
        '::-webkit-resizer': !0,
        '::-webkit-scrollbar-button': !0,
        '::-webkit-scrollbar-corner': !0,
        '::-webkit-scrollbar-thumb': !0,
        '::-webkit-scrollbar-track-piece': !0,
        '::-webkit-scrollbar-track': !0,
        '::-webkit-scrollbar': !0,
        '::-webkit-search-cancel-button': !0,
        '::-webkit-search-results-button': !0,
        '::-webkit-slider-runnable-track': !0,
        '::-webkit-slider-thumb': !0,
        '::after': !0,
        '::backdrop': !0,
        '::before': !0,
        '::cue': !0,
        '::file-selector-button': !0,
        '::first-letter': !0,
        '::first-line': !0,
        '::grammar-error': !0,
        '::marker': !0,
        '::placeholder': !0,
        '::selection': !0,
        '::spelling-error': !0,
        '::target-text': !0,
        '::view-transition-group': !0,
        '::view-transition-image-pair': !0,
        '::view-transition-new': !0,
        '::view-transition-old': !0,
        '::view-transition': !0,
        ':active': !0,
        ':after': !0,
        ':any-link': !0,
        ':before': !0,
        ':blank': !0,
        ':checked': !0,
        ':default': !0,
        ':defined': !0,
        ':disabled': !0,
        ':empty': !0,
        ':enabled': !0,
        ':first-child': !0,
        ':first-letter': !0,
        ':first-line': !0,
        ':first-of-type': !0,
        ':first': !0,
        ':focus-visible': !0,
        ':focus-within': !0,
        ':focus': !0,
        ':fullscreen': !0,
        ':hover': !0,
        ':in-range': !0,
        ':indeterminate': !0,
        ':invalid': !0,
        ':last-child': !0,
        ':last-of-type': !0,
        ':left': !0,
        ':link': !0,
        ':only-child': !0,
        ':only-of-type': !0,
        ':optional': !0,
        ':out-of-range': !0,
        ':placeholder-shown': !0,
        ':read-only': !0,
        ':read-write': !0,
        ':required': !0,
        ':right': !0,
        ':root': !0,
        ':scope': !0,
        ':target': !0,
        ':valid': !0,
        ':visited': !0,
      },
      gO = Object.keys(gk),
      gA = (e, t) =>
        Error(
          m1(
            eQ ||
              (eQ = m$([
                '\n    Invalid media query: "',
                '"\n\n    ',
                '\n\n    Read more on MDN: https://developer.mozilla.org/en-US/docs/Web/CSS/Media_Queries/Using_media_queries\n  ',
              ])),
            e,
            t
          )
        ),
      gI = (e) => {
        if ('@media ' === e) throw gA(e, 'Query is empty');
        try {
          gl(gf(e));
        } catch (t) {
          throw gA(e, t.message);
        }
      },
      gj = ['vars'],
      gT = ['content'],
      gR = '__DECLARATION',
      gM = {
        animationIterationCount: !0,
        borderImage: !0,
        borderImageOutset: !0,
        borderImageSlice: !0,
        borderImageWidth: !0,
        boxFlex: !0,
        boxFlexGroup: !0,
        columnCount: !0,
        columns: !0,
        flex: !0,
        flexGrow: !0,
        flexShrink: !0,
        fontWeight: !0,
        gridArea: !0,
        gridColumn: !0,
        gridColumnEnd: !0,
        gridColumnStart: !0,
        gridRow: !0,
        gridRowEnd: !0,
        gridRowStart: !0,
        initialLetter: !0,
        lineClamp: !0,
        lineHeight: !0,
        maxLines: !0,
        opacity: !0,
        order: !0,
        orphans: !0,
        scale: !0,
        tabSize: !0,
        WebkitLineClamp: !0,
        widows: !0,
        zIndex: !0,
        zoom: !0,
        fillOpacity: !0,
        floodOpacity: !0,
        maskBorder: !0,
        maskBorderOutset: !0,
        maskBorderSlice: !0,
        maskBorderWidth: !0,
        shapeImageThreshold: !0,
        stopOpacity: !0,
        strokeDashoffset: !0,
        strokeMiterlimit: !0,
        strokeOpacity: !0,
        strokeWidth: !0,
      },
      gP = [...gO, '@layer', '@media', '@supports', '@container', 'selectors'];
    class gN {
      constructor(e, t) {
        (this.rules = []),
          (this.conditionalRulesets = [new gC()]),
          (this.fontFaceRules = []),
          (this.keyframesRules = []),
          (this.propertyRules = []),
          (this.localClassNamesMap = new Map(e.map((e) => [e, e]))),
          (this.localClassNamesSearch = new mL(e)),
          (this.layers = new Map()),
          (this.composedClassLists = t
            .map((e) => {
              var { identifier: t, classList: n } = e;
              return { identifier: t, regex: RegExp('('.concat(n, ')'), 'g') };
            })
            .reverse());
      }
      processCssObj(e) {
        if ('fontFace' === e.type) return void this.fontFaceRules.push(e.rule);
        if ('property' === e.type) return void this.propertyRules.push(e);
        if ('keyframes' === e.type) {
          (e.rule = Object.fromEntries(
            Object.entries(e.rule).map((e) => {
              var [t, n] = e;
              return [t, this.transformVars(this.transformProperties(n))];
            })
          )),
            this.keyframesRules.push(e);
          return;
        }
        if (((this.currConditionalRuleset = new gC()), 'layer' === e.type)) {
          var t = '@layer '.concat(e.name);
          this.addLayer([t]);
        } else {
          var n = gS(e.rule, gP);
          this.addRule({ selector: e.selector, rule: n }),
            this.transformLayer(e, e.rule['@layer']),
            this.transformMedia(e, e.rule['@media']),
            this.transformSupports(e, e.rule['@supports']),
            this.transformContainer(e, e.rule['@container']),
            this.transformSimplePseudos(e, e.rule),
            this.transformSelectors(e, e.rule);
        }
        this.conditionalRulesets[this.conditionalRulesets.length - 1].mergeIfCompatible(
          this.currConditionalRuleset
        ) || this.conditionalRulesets.push(this.currConditionalRuleset);
      }
      addConditionalRule(e, t) {
        var n = this.transformVars(this.transformProperties(e.rule)),
          i = this.transformSelector(e.selector);
        if (!this.currConditionalRuleset) throw Error("Couldn't add conditional rule");
        var a = t[t.length - 1],
          o = t.slice(0, t.length - 1);
        this.currConditionalRuleset.addRule({ selector: i, rule: n }, a, o);
      }
      addRule(e) {
        var t = this.transformVars(this.transformProperties(e.rule)),
          n = this.transformSelector(e.selector);
        this.rules.push({ selector: n, rule: t });
      }
      addLayer(e) {
        var t = e.join(' - ');
        this.layers.set(t, e);
      }
      transformProperties(e) {
        return this.transformContent(this.pixelifyProperties(e));
      }
      pixelifyProperties(e) {
        return (
          gE(e, (t, n) => {
            'number' != typeof t || 0 === t || gM[n] || (e[n] = ''.concat(t, 'px'));
          }),
          e
        );
      }
      transformVars(e) {
        var { vars: t } = e,
          n = gx(e, gj);
        return t
          ? gw(
              gw(
                {},
                (function (e, t) {
                  var n = {};
                  for (var i in e) n[t(e[i], i)] = e[i];
                  return n;
                })(t, (e, t) => mD(t))
              ),
              n
            )
          : n;
      }
      transformContent(e) {
        var { content: t } = e,
          n = gx(e, gT);
        return void 0 === t
          ? n
          : gw(
              {
                content: (Array.isArray(t) ? t : [t]).map((e) =>
                  e &&
                  (e.includes('"') ||
                    e.includes("'") ||
                    /^([A-Za-z\-]+\([^]*|[^]*-quote|inherit|initial|none|normal|revert|unset)(\s|$)/.test(
                      e
                    ))
                    ? e
                    : '"'.concat(e, '"')
                ),
              },
              n
            );
      }
      transformClassname(e) {
        return '.'.concat((0, mF.default)(e, { isIdentifier: !0 }));
      }
      transformSelector(e) {
        var t = e,
          n = function (e) {
            t = t.replace(
              a,
              () => (
                !(function () {
                  (() => {
                    if (mz.length < 1) throw Error('No adapter configured');
                    return mz[mz.length - 1];
                  })().markCompositionUsed(...arguments);
                })(e),
                e
              )
            );
          };
        for (var { identifier: i, regex: a } of this.composedClassLists) n(i);
        if (this.localClassNamesMap.has(t)) return this.transformClassname(t);
        for (
          var o = this.localClassNamesSearch.search(t), s = t.length, l = o.length - 1;
          l >= 0;
          l--
        ) {
          var [u, [c]] = o[l],
            d = u - c.length + 1;
          s <= u ||
            ((s = d),
            '.' !== t[d - 1] &&
              (t = (function (e, t, n, i) {
                var a = e.slice(0, t),
                  o = e.slice(n);
                return ''.concat(a).concat(i).concat(o);
              })(t, d, u + 1, this.transformClassname(c))));
        }
        return t;
      }
      transformSelectors(e, t, n) {
        gE(t.selectors, (t, i) => {
          if ('local' !== e.type)
            throw Error(
              'Selectors are not allowed within '.concat(
                'global' === e.type ? '"globalStyle"' : '"selectors"'
              )
            );
          var a,
            o = this.transformSelector(i.replace(RegExp('&', 'g'), e.selector)),
            s = e.selector,
            l = () => {
              var e = RegExp(
                '.'.concat(
                  (0, mF.default)(s, { isIdentifier: !0 }).replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&')
                ),
                'g'
              );
              return o.replace(e, '&');
            };
          try {
            a = (function (e) {
              let t = [],
                n = (function e(t, n, i) {
                  let a = [];
                  function o(e) {
                    let t = n.slice(i + e).match(mW);
                    if (!t) throw Error(`Expected name, found ${n.slice(i)}`);
                    let [a] = t;
                    return (i += e + a.length), mY(a);
                  }
                  function s(e) {
                    for (i += e; i < n.length && mX(n.charCodeAt(i)); ) i++;
                  }
                  function l() {
                    let e = (i += 1),
                      t = 1;
                    for (; t > 0 && i < n.length; i++)
                      40 !== n.charCodeAt(i) || u(i) ? 41 === n.charCodeAt(i) && !u(i) && t-- : t++;
                    if (t) throw Error('Parenthesis not matched');
                    return mY(n.slice(e, i - 1));
                  }
                  function u(e) {
                    let t = 0;
                    for (; 92 === n.charCodeAt(--e); ) t++;
                    return (1 & t) == 1;
                  }
                  function c() {
                    if (
                      a.length > 0 &&
                      (function (e) {
                        switch (e.type) {
                          case eH.Adjacent:
                          case eH.Child:
                          case eH.Descendant:
                          case eH.Parent:
                          case eH.Sibling:
                          case eH.ColumnCombinator:
                            return !0;
                          default:
                            return !1;
                        }
                      })(a[a.length - 1])
                    )
                      throw Error('Did not expect successive traversals.');
                  }
                  function d(e) {
                    if (a.length > 0 && a[a.length - 1].type === eH.Descendant) {
                      a[a.length - 1].type = e;
                      return;
                    }
                    c(), a.push({ type: e });
                  }
                  function f(e, t) {
                    a.push({
                      type: eH.Attribute,
                      name: e,
                      action: t,
                      value: o(1),
                      namespace: null,
                      ignoreCase: 'quirks',
                    });
                  }
                  function h() {
                    if (
                      (a.length && a[a.length - 1].type === eH.Descendant && a.pop(),
                      0 === a.length)
                    )
                      throw Error('Empty sub-selector');
                    t.push(a);
                  }
                  if ((s(0), n.length === i)) return i;
                  e: for (; i < n.length; ) {
                    let t = n.charCodeAt(i);
                    switch (t) {
                      case 32:
                      case 9:
                      case 10:
                      case 12:
                      case 13:
                        (0 === a.length || a[0].type !== eH.Descendant) &&
                          (c(), a.push({ type: eH.Descendant })),
                          s(1);
                        break;
                      case 62:
                        d(eH.Child), s(1);
                        break;
                      case 60:
                        d(eH.Parent), s(1);
                        break;
                      case 126:
                        d(eH.Sibling), s(1);
                        break;
                      case 43:
                        d(eH.Adjacent), s(1);
                        break;
                      case 46:
                        f('class', eZ.Element);
                        break;
                      case 35:
                        f('id', eZ.Equals);
                        break;
                      case 91: {
                        let e;
                        s(1);
                        let t = null;
                        124 === n.charCodeAt(i)
                          ? (e = o(1))
                          : n.startsWith('*|', i)
                          ? ((t = '*'), (e = o(2)))
                          : ((e = o(0)),
                            124 === n.charCodeAt(i) &&
                              61 !== n.charCodeAt(i + 1) &&
                              ((t = e), (e = o(1)))),
                          s(0);
                        let l = eZ.Exists,
                          c = mK.get(n.charCodeAt(i));
                        if (c) {
                          if (((l = c), 61 !== n.charCodeAt(i + 1))) throw Error('Expected `=`');
                          s(2);
                        } else 61 === n.charCodeAt(i) && ((l = eZ.Equals), s(1));
                        let d = '',
                          f = null;
                        if ('exists' !== l) {
                          if (mQ(n.charCodeAt(i))) {
                            let e = n.charCodeAt(i),
                              t = i + 1;
                            for (; t < n.length && (n.charCodeAt(t) !== e || u(t)); ) t += 1;
                            if (n.charCodeAt(t) !== e) throw Error("Attribute value didn't end");
                            (d = mY(n.slice(i + 1, t))), (i = t + 1);
                          } else {
                            let e = i;
                            for (
                              ;
                              i < n.length &&
                              ((!mX(n.charCodeAt(i)) && 93 !== n.charCodeAt(i)) || u(i));

                            )
                              i += 1;
                            d = mY(n.slice(e, i));
                          }
                          s(0);
                          let e = 32 | n.charCodeAt(i);
                          115 === e ? ((f = !1), s(1)) : 105 === e && ((f = !0), s(1));
                        }
                        if (93 !== n.charCodeAt(i))
                          throw Error("Attribute selector didn't terminate");
                        i += 1;
                        let h = {
                          type: eH.Attribute,
                          name: e,
                          action: l,
                          value: d,
                          namespace: t,
                          ignoreCase: f,
                        };
                        a.push(h);
                        break;
                      }
                      case 58: {
                        if (58 === n.charCodeAt(i + 1)) {
                          a.push({
                            type: eH.PseudoElement,
                            name: o(2).toLowerCase(),
                            data: 40 === n.charCodeAt(i) ? l() : null,
                          });
                          continue;
                        }
                        let t = o(1).toLowerCase(),
                          s = null;
                        if (40 === n.charCodeAt(i))
                          if (mG.has(t)) {
                            if (mQ(n.charCodeAt(i + 1)))
                              throw Error(`Pseudo-selector ${t} cannot be quoted`);
                            if (((i = e((s = []), n, i + 1)), 41 !== n.charCodeAt(i)))
                              throw Error(`Missing closing parenthesis in :${t} (${n})`);
                            i += 1;
                          } else {
                            if (((s = l()), mH.has(t))) {
                              let e = s.charCodeAt(0);
                              e === s.charCodeAt(s.length - 1) && mQ(e) && (s = s.slice(1, -1));
                            }
                            s = mY(s);
                          }
                        a.push({ type: eH.Pseudo, name: t, data: s });
                        break;
                      }
                      case 44:
                        h(), (a = []), s(1);
                        break;
                      default: {
                        let e;
                        if (n.startsWith('/*', i)) {
                          let e = n.indexOf('*/', i + 2);
                          if (e < 0) throw Error('Comment was not terminated');
                          (i = e + 2), 0 === a.length && s(0);
                          break;
                        }
                        let l = null;
                        if (42 === t) (i += 1), (e = '*');
                        else if (124 === t) {
                          if (((e = ''), 124 === n.charCodeAt(i + 1))) {
                            d(eH.ColumnCombinator), s(2);
                            break;
                          }
                        } else if (mW.test(n.slice(i))) e = o(0);
                        else break e;
                        124 === n.charCodeAt(i) &&
                          124 !== n.charCodeAt(i + 1) &&
                          ((l = e),
                          42 === n.charCodeAt(i + 1) ? ((e = '*'), (i += 2)) : (e = o(1))),
                          a.push(
                            '*' === e
                              ? { type: eH.Universal, namespace: l }
                              : { type: eH.Tag, name: e, namespace: l }
                          );
                      }
                    }
                  }
                  return h(), i;
                })(t, `${e}`, 0);
              if (n < e.length) throw Error(`Unmatched selector: ${e.slice(n)}`);
              return t;
            })(o);
          } catch (e) {
            throw Error('Invalid selector: '.concat(l()));
          }
          a.forEach((e) => {
            try {
              for (var t = e.length - 1; t >= -1; t--) {
                if (!e[t]) throw Error();
                var n = e[t];
                if (
                  'child' === n.type ||
                  'parent' === n.type ||
                  'sibling' === n.type ||
                  'adjacent' === n.type ||
                  'descendant' === n.type
                )
                  throw Error();
                if ('attribute' === n.type && 'class' === n.name && n.value === s) return;
              }
            } catch (e) {
              throw Error(
                m1(
                  eY ||
                    (eY = m$([
                      '\n        Invalid selector: ',
                      "\n    \n        Style selectors must target the '&' character (along with any modifiers), e.g. ",
                      ' or ',
                      ".\n        \n        This is to ensure that each style block only affects the styling of a single class.\n        \n        If your selector is targeting another class, you should move it to the style definition for that class, e.g. given we have styles for 'parent' and 'child' elements, instead of adding a selector of ",
                      ") to 'parent', you should add ",
                      " to 'child').\n        \n        If your selector is targeting something global, use the 'globalStyle' function instead, e.g. if you wanted to write ",
                      ", you should instead write 'globalStyle(",
                      ", { ... })'\n      ",
                    ])),
                  l(),
                  '`${parent} &`',
                  '`${parent} &:hover`',
                  '`& ${child}`',
                  '`${parent} &`',
                  '`& h1`',
                  '`${parent} h1`'
                )
              );
            }
          });
          var u = { selector: o, rule: gS(t, gP) };
          n ? this.addConditionalRule(u, n) : this.addRule(u);
          var c = { type: 'selector', selector: o, rule: t };
          this.transformLayer(c, t['@layer'], n),
            this.transformSupports(c, t['@supports'], n),
            this.transformMedia(c, t['@media'], n),
            this.transformContainer(c, t['@container'], n);
        });
      }
      transformMedia(e, t) {
        var n,
          i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : [];
        if (t)
          for (var [a, o] of (null == (n = this.currConditionalRuleset) ||
            n.addConditionPrecedence(
              i,
              Object.keys(t).map((e) => '@media '.concat(e))
            ),
          Object.entries(t))) {
            var s = '@media '.concat(a);
            gI(s);
            var l = [...i, s];
            this.addConditionalRule({ selector: e.selector, rule: gS(o, gP) }, l),
              'local' === e.type &&
                (this.transformSimplePseudos(e, o, l), this.transformSelectors(e, o, l)),
              this.transformLayer(e, o['@layer'], l),
              this.transformSupports(e, o['@supports'], l),
              this.transformContainer(e, o['@container'], l);
          }
      }
      transformContainer(e, t) {
        var n,
          i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : [];
        t &&
          (null == (n = this.currConditionalRuleset) ||
            n.addConditionPrecedence(
              i,
              Object.keys(t).map((e) => '@container '.concat(e))
            ),
          gE(t, (t, n) => {
            var a = [...i, '@container '.concat(n)];
            this.addConditionalRule({ selector: e.selector, rule: gS(t, gP) }, a),
              'local' === e.type &&
                (this.transformSimplePseudos(e, t, a), this.transformSelectors(e, t, a)),
              this.transformLayer(e, t['@layer'], a),
              this.transformSupports(e, t['@supports'], a),
              this.transformMedia(e, t['@media'], a);
          }));
      }
      transformLayer(e, t) {
        var n,
          i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : [];
        t &&
          (null == (n = this.currConditionalRuleset) ||
            n.addConditionPrecedence(
              i,
              Object.keys(t).map((e) => '@layer '.concat(e))
            ),
          gE(t, (t, n) => {
            var a = [...i, '@layer '.concat(n)];
            this.addLayer(a),
              this.addConditionalRule({ selector: e.selector, rule: gS(t, gP) }, a),
              'local' === e.type &&
                (this.transformSimplePseudos(e, t, a), this.transformSelectors(e, t, a)),
              this.transformMedia(e, t['@media'], a),
              this.transformSupports(e, t['@supports'], a),
              this.transformContainer(e, t['@container'], a);
          }));
      }
      transformSupports(e, t) {
        var n,
          i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : [];
        t &&
          (null == (n = this.currConditionalRuleset) ||
            n.addConditionPrecedence(
              i,
              Object.keys(t).map((e) => '@supports '.concat(e))
            ),
          gE(t, (t, n) => {
            var a = [...i, '@supports '.concat(n)];
            this.addConditionalRule({ selector: e.selector, rule: gS(t, gP) }, a),
              'local' === e.type &&
                (this.transformSimplePseudos(e, t, a), this.transformSelectors(e, t, a)),
              this.transformLayer(e, t['@layer'], a),
              this.transformMedia(e, t['@media'], a),
              this.transformContainer(e, t['@container'], a);
          }));
      }
      transformSimplePseudos(e, t, n) {
        for (var i of Object.keys(t))
          if (gk[i]) {
            if ('local' !== e.type)
              throw Error(
                'Simple pseudos are not valid in '.concat(
                  'global' === e.type ? '"globalStyle"' : '"selectors"'
                )
              );
            n
              ? this.addConditionalRule(
                  { selector: ''.concat(e.selector).concat(i), rule: t[i] },
                  n
                )
              : this.addRule({
                  conditions: n,
                  selector: ''.concat(e.selector).concat(i),
                  rule: t[i],
                });
          }
      }
      toCss() {
        var e = [];
        for (var t of this.fontFaceRules) e.push(g_({ '@font-face': t }));
        for (var n of this.propertyRules) e.push(g_({ ['@property '.concat(n.name)]: n.rule }));
        for (var i of this.keyframesRules) e.push(g_({ ['@keyframes '.concat(i.name)]: i.rule }));
        for (var a of this.layers.values()) {
          var [o, ...s] = a.reverse(),
            l = { [o]: gR };
          for (var u of s) l = { [u]: l };
          e.push(g_(l));
        }
        for (var c of this.rules) e.push(g_({ [c.selector]: c.rule }));
        for (var d of this.conditionalRulesets) for (var f of d.renderToArray()) e.push(g_(f));
        return e.filter(Boolean);
      }
    }
    function g_(e) {
      var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : '',
        n = [],
        i = function (i) {
          var a = e[i];
          a && Array.isArray(a)
            ? n.push(...a.map((e) => g_({ [i]: e }, t)))
            : a && 'object' == typeof a
            ? 0 !== Object.keys(a).length &&
              n.push(
                ''
                  .concat(t)
                  .concat(i, ' {\n')
                  .concat(g_(a, t + '  '), '\n')
                  .concat(t, '}')
              )
            : a === gR
            ? n.push(''.concat(t).concat(i, ';'))
            : n.push(
                ''
                  .concat(t)
                  .concat(
                    i.startsWith('--')
                      ? i
                      : i
                          .replace(/([A-Z])/g, '-$1')
                          .replace(/^ms-/, '-ms-')
                          .toLowerCase(),
                    ': '
                  )
                  .concat(a, ';')
              );
        };
      for (var a of Object.keys(e)) i(a);
      return n.join('\n');
    }
    let gD =
        'object' == typeof performance && performance && 'function' == typeof performance.now
          ? performance
          : Date,
      gB = new Set(),
      gU = 'object' == typeof rH.default && rH.default ? rH.default : {},
      gF = (e, t, n, i) => {
        'function' == typeof gU.emitWarning
          ? gU.emitWarning(e, t, n, i)
          : console.error(`[${n}] ${t}: ${e}`);
      },
      gL = globalThis.AbortController,
      gz = globalThis.AbortSignal;
    if (void 0 === gL) {
      (gz = class {
        onabort;
        _onabort = [];
        reason;
        aborted = !1;
        addEventListener(e, t) {
          this._onabort.push(t);
        }
      }),
        (gL = class {
          constructor() {
            t();
          }
          signal = new gz();
          abort(e) {
            if (!this.signal.aborted) {
              for (let t of ((this.signal.reason = e),
              (this.signal.aborted = !0),
              this.signal._onabort))
                t(e);
              this.signal.onabort?.(e);
            }
          }
        });
      let e = gU.env?.LRU_CACHE_IGNORE_AC_WARNING !== '1',
        t = () => {
          e &&
            ((e = !1),
            gF(
              'AbortController is not defined. If using lru-cache in node 14, load an AbortController polyfill from the `node-abort-controller` package. A minimal polyfill is provided for use by LRUCache.fetch(), but it should not be relied upon in other contexts (eg, passing it to other APIs that use AbortController/AbortSignal might have undesirable effects). You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.',
              'NO_ABORT_CONTROLLER',
              'ENOTSUP',
              t
            ));
        };
    }
    Symbol('type');
    let gV = (e) => e && e === Math.floor(e) && e > 0 && isFinite(e),
      g$ = (e) =>
        gV(e)
          ? e <= 256
            ? Uint8Array
            : e <= 65536
            ? Uint16Array
            : e <= 0x100000000
            ? Uint32Array
            : e <= Number.MAX_SAFE_INTEGER
            ? gW
            : null
          : null;
    class gW extends Array {
      constructor(e) {
        super(e), this.fill(0);
      }
    }
    class gq {
      heap;
      length;
      static #W = !1;
      static create(e) {
        let t = g$(e);
        if (!t) return [];
        gq.#W = !0;
        let n = new gq(e, t);
        return (gq.#W = !1), n;
      }
      constructor(e, t) {
        if (!gq.#W) throw TypeError('instantiate Stack using Stack.create(n)');
        (this.heap = new t(e)), (this.length = 0);
      }
      push(e) {
        this.heap[this.length++] = e;
      }
      pop() {
        return this.heap[--this.length];
      }
    }
    class gK {
      #q;
      #K;
      #G;
      #H;
      #Z;
      #Y;
      ttl;
      ttlResolution;
      ttlAutopurge;
      updateAgeOnGet;
      updateAgeOnHas;
      allowStale;
      noDisposeOnSet;
      noUpdateTTL;
      maxEntrySize;
      sizeCalculation;
      noDeleteOnFetchRejection;
      noDeleteOnStaleGet;
      allowStaleOnFetchAbort;
      allowStaleOnFetchRejection;
      ignoreFetchAbort;
      #Q;
      #X;
      #J;
      #ee;
      #et;
      #er;
      #en;
      #ei;
      #ea;
      #eo;
      #es;
      #el;
      #eu;
      #ec;
      #ed;
      #ef;
      #eh;
      static unsafeExposeInternals(e) {
        return {
          starts: e.#eu,
          ttls: e.#ec,
          sizes: e.#el,
          keyMap: e.#J,
          keyList: e.#ee,
          valList: e.#et,
          next: e.#er,
          prev: e.#en,
          get head() {
            return e.#ei;
          },
          get tail() {
            return e.#ea;
          },
          free: e.#eo,
          isBackgroundFetch: (t) => e.#ep(t),
          backgroundFetch: (t, n, i, a) => e.#em(t, n, i, a),
          moveToTail: (t) => e.#eg(t),
          indexes: (t) => e.#ey(t),
          rindexes: (t) => e.#eb(t),
          isStale: (t) => e.#ev(t),
        };
      }
      get max() {
        return this.#q;
      }
      get maxSize() {
        return this.#K;
      }
      get calculatedSize() {
        return this.#X;
      }
      get size() {
        return this.#Q;
      }
      get fetchMethod() {
        return this.#Z;
      }
      get memoMethod() {
        return this.#Y;
      }
      get dispose() {
        return this.#G;
      }
      get disposeAfter() {
        return this.#H;
      }
      constructor(e) {
        const {
          max: t = 0,
          ttl: n,
          ttlResolution: i = 1,
          ttlAutopurge: a,
          updateAgeOnGet: o,
          updateAgeOnHas: s,
          allowStale: l,
          dispose: u,
          disposeAfter: c,
          noDisposeOnSet: d,
          noUpdateTTL: f,
          maxSize: h = 0,
          maxEntrySize: p = 0,
          sizeCalculation: m,
          fetchMethod: g,
          memoMethod: y,
          noDeleteOnFetchRejection: b,
          noDeleteOnStaleGet: v,
          allowStaleOnFetchRejection: w,
          allowStaleOnFetchAbort: x,
          ignoreFetchAbort: E,
        } = e;
        if (0 !== t && !gV(t)) throw TypeError('max option must be a nonnegative integer');
        const S = t ? g$(t) : Array;
        if (!S) throw Error('invalid max value: ' + t);
        if (
          ((this.#q = t),
          (this.#K = h),
          (this.maxEntrySize = p || this.#K),
          (this.sizeCalculation = m),
          this.sizeCalculation)
        ) {
          if (!this.#K && !this.maxEntrySize)
            throw TypeError('cannot set sizeCalculation without setting maxSize or maxEntrySize');
          if ('function' != typeof this.sizeCalculation)
            throw TypeError('sizeCalculation set to non-function');
        }
        if (void 0 !== y && 'function' != typeof y)
          throw TypeError('memoMethod must be a function if defined');
        if (((this.#Y = y), void 0 !== g && 'function' != typeof g))
          throw TypeError('fetchMethod must be a function if specified');
        if (
          ((this.#Z = g),
          (this.#ef = !!g),
          (this.#J = new Map()),
          (this.#ee = Array(t).fill(void 0)),
          (this.#et = Array(t).fill(void 0)),
          (this.#er = new S(t)),
          (this.#en = new S(t)),
          (this.#ei = 0),
          (this.#ea = 0),
          (this.#eo = gq.create(t)),
          (this.#Q = 0),
          (this.#X = 0),
          'function' == typeof u && (this.#G = u),
          'function' == typeof c
            ? ((this.#H = c), (this.#es = []))
            : ((this.#H = void 0), (this.#es = void 0)),
          (this.#ed = !!this.#G),
          (this.#eh = !!this.#H),
          (this.noDisposeOnSet = !!d),
          (this.noUpdateTTL = !!f),
          (this.noDeleteOnFetchRejection = !!b),
          (this.allowStaleOnFetchRejection = !!w),
          (this.allowStaleOnFetchAbort = !!x),
          (this.ignoreFetchAbort = !!E),
          0 !== this.maxEntrySize)
        ) {
          if (0 !== this.#K && !gV(this.#K))
            throw TypeError('maxSize must be a positive integer if specified');
          if (!gV(this.maxEntrySize))
            throw TypeError('maxEntrySize must be a positive integer if specified');
          this.#ew();
        }
        if (
          ((this.allowStale = !!l),
          (this.noDeleteOnStaleGet = !!v),
          (this.updateAgeOnGet = !!o),
          (this.updateAgeOnHas = !!s),
          (this.ttlResolution = gV(i) || 0 === i ? i : 1),
          (this.ttlAutopurge = !!a),
          (this.ttl = n || 0),
          this.ttl)
        ) {
          if (!gV(this.ttl)) throw TypeError('ttl must be a positive integer if specified');
          this.#ex();
        }
        if (0 === this.#q && 0 === this.ttl && 0 === this.#K)
          throw TypeError('At least one of max, maxSize, or ttl is required');
        if (!this.ttlAutopurge && !this.#q && !this.#K) {
          const e = 'LRU_CACHE_UNBOUNDED';
          gB.has(e) ||
            (gB.add(e),
            gF(
              'TTL caching without ttlAutopurge, max, or maxSize can result in unbounded memory consumption.',
              'UnboundedCacheWarning',
              e,
              gK
            ));
        }
      }
      getRemainingTTL(e) {
        return this.#J.has(e) ? 1 / 0 : 0;
      }
      #ex() {
        let e = new gW(this.#q),
          t = new gW(this.#q);
        (this.#ec = e),
          (this.#eu = t),
          (this.#eE = (n, i, a = gD.now()) => {
            if (((t[n] = 0 !== i ? a : 0), (e[n] = i), 0 !== i && this.ttlAutopurge)) {
              let e = setTimeout(() => {
                this.#ev(n) && this.#eS(this.#ee[n], 'expire');
              }, i + 1);
              e.unref && e.unref();
            }
          }),
          (this.#eC = (n) => {
            t[n] = 0 !== e[n] ? gD.now() : 0;
          }),
          (this.#ek = (a, o) => {
            if (e[o]) {
              let s = e[o],
                l = t[o];
              if (!s || !l) return;
              (a.ttl = s), (a.start = l), (a.now = n || i());
              let u = a.now - l;
              a.remainingTTL = s - u;
            }
          });
        let n = 0,
          i = () => {
            let e = gD.now();
            if (this.ttlResolution > 0) {
              n = e;
              let t = setTimeout(() => (n = 0), this.ttlResolution);
              t.unref && t.unref();
            }
            return e;
          };
        (this.getRemainingTTL = (a) => {
          let o = this.#J.get(a);
          if (void 0 === o) return 0;
          let s = e[o],
            l = t[o];
          return s && l ? s - ((n || i()) - l) : 1 / 0;
        }),
          (this.#ev = (a) => {
            let o = t[a],
              s = e[a];
            return !!s && !!o && (n || i()) - o > s;
          });
      }
      #eC = () => {};
      #ek = () => {};
      #eE = () => {};
      #ev = () => !1;
      #ew() {
        let e = new gW(this.#q);
        (this.#X = 0),
          (this.#el = e),
          (this.#eO = (t) => {
            (this.#X -= e[t]), (e[t] = 0);
          }),
          (this.#eA = (e, t, n, i) => {
            if (this.#ep(t)) return 0;
            if (!gV(n))
              if (i) {
                if ('function' != typeof i) throw TypeError('sizeCalculation must be a function');
                if (!gV((n = i(t, e))))
                  throw TypeError('sizeCalculation return invalid (expect positive integer)');
              } else
                throw TypeError(
                  'invalid size value (must be positive integer). When maxSize or maxEntrySize is used, sizeCalculation or size must be set.'
                );
            return n;
          }),
          (this.#eI = (t, n, i) => {
            if (((e[t] = n), this.#K)) {
              let n = this.#K - e[t];
              for (; this.#X > n; ) this.#ej(!0);
            }
            (this.#X += e[t]), i && ((i.entrySize = n), (i.totalCalculatedSize = this.#X));
          });
      }
      #eO = (e) => {};
      #eI = (e, t, n) => {};
      #eA = (e, t, n, i) => {
        if (n || i)
          throw TypeError('cannot set size without setting maxSize or maxEntrySize on cache');
        return 0;
      };
      *#ey({ allowStale: e = this.allowStale } = {}) {
        if (this.#Q)
          for (
            let t = this.#ea;
            this.#eT(t) && ((e || !this.#ev(t)) && (yield t), t !== this.#ei);

          )
            t = this.#en[t];
      }
      *#eb({ allowStale: e = this.allowStale } = {}) {
        if (this.#Q)
          for (
            let t = this.#ei;
            this.#eT(t) && ((e || !this.#ev(t)) && (yield t), t !== this.#ea);

          )
            t = this.#er[t];
      }
      #eT(e) {
        return void 0 !== e && this.#J.get(this.#ee[e]) === e;
      }
      *entries() {
        for (let e of this.#ey())
          void 0 === this.#et[e] ||
            void 0 === this.#ee[e] ||
            this.#ep(this.#et[e]) ||
            (yield [this.#ee[e], this.#et[e]]);
      }
      *rentries() {
        for (let e of this.#eb())
          void 0 === this.#et[e] ||
            void 0 === this.#ee[e] ||
            this.#ep(this.#et[e]) ||
            (yield [this.#ee[e], this.#et[e]]);
      }
      *keys() {
        for (let e of this.#ey()) {
          let t = this.#ee[e];
          void 0 === t || this.#ep(this.#et[e]) || (yield t);
        }
      }
      *rkeys() {
        for (let e of this.#eb()) {
          let t = this.#ee[e];
          void 0 === t || this.#ep(this.#et[e]) || (yield t);
        }
      }
      *values() {
        for (let e of this.#ey())
          void 0 === this.#et[e] || this.#ep(this.#et[e]) || (yield this.#et[e]);
      }
      *rvalues() {
        for (let e of this.#eb())
          void 0 === this.#et[e] || this.#ep(this.#et[e]) || (yield this.#et[e]);
      }
      [Symbol.iterator]() {
        return this.entries();
      }
      [Symbol.toStringTag] = 'LRUCache';
      find(e, t = {}) {
        for (let n of this.#ey()) {
          let i = this.#et[n],
            a = this.#ep(i) ? i.__staleWhileFetching : i;
          if (void 0 !== a && e(a, this.#ee[n], this)) return this.get(this.#ee[n], t);
        }
      }
      forEach(e, t = this) {
        for (let n of this.#ey()) {
          let i = this.#et[n],
            a = this.#ep(i) ? i.__staleWhileFetching : i;
          void 0 !== a && e.call(t, a, this.#ee[n], this);
        }
      }
      rforEach(e, t = this) {
        for (let n of this.#eb()) {
          let i = this.#et[n],
            a = this.#ep(i) ? i.__staleWhileFetching : i;
          void 0 !== a && e.call(t, a, this.#ee[n], this);
        }
      }
      purgeStale() {
        let e = !1;
        for (let t of this.#eb({ allowStale: !0 }))
          this.#ev(t) && (this.#eS(this.#ee[t], 'expire'), (e = !0));
        return e;
      }
      info(e) {
        let t = this.#J.get(e);
        if (void 0 === t) return;
        let n = this.#et[t],
          i = this.#ep(n) ? n.__staleWhileFetching : n;
        if (void 0 === i) return;
        let a = { value: i };
        if (this.#ec && this.#eu) {
          let e = this.#ec[t],
            n = this.#eu[t];
          e && n && ((a.ttl = e - (gD.now() - n)), (a.start = Date.now()));
        }
        return this.#el && (a.size = this.#el[t]), a;
      }
      dump() {
        let e = [];
        for (let t of this.#ey({ allowStale: !0 })) {
          let n = this.#ee[t],
            i = this.#et[t],
            a = this.#ep(i) ? i.__staleWhileFetching : i;
          if (void 0 === a || void 0 === n) continue;
          let o = { value: a };
          if (this.#ec && this.#eu) {
            o.ttl = this.#ec[t];
            let e = gD.now() - this.#eu[t];
            o.start = Math.floor(Date.now() - e);
          }
          this.#el && (o.size = this.#el[t]), e.unshift([n, o]);
        }
        return e;
      }
      load(e) {
        for (let [t, n] of (this.clear(), e)) {
          if (n.start) {
            let e = Date.now() - n.start;
            n.start = gD.now() - e;
          }
          this.set(t, n.value, n);
        }
      }
      set(e, t, n = {}) {
        if (void 0 === t) return this.delete(e), this;
        let {
            ttl: i = this.ttl,
            start: a,
            noDisposeOnSet: o = this.noDisposeOnSet,
            sizeCalculation: s = this.sizeCalculation,
            status: l,
          } = n,
          { noUpdateTTL: u = this.noUpdateTTL } = n,
          c = this.#eA(e, t, n.size || 0, s);
        if (this.maxEntrySize && c > this.maxEntrySize)
          return l && ((l.set = 'miss'), (l.maxEntrySizeExceeded = !0)), this.#eS(e, 'set'), this;
        let d = 0 === this.#Q ? void 0 : this.#J.get(e);
        if (void 0 === d)
          (d =
            0 === this.#Q
              ? this.#ea
              : 0 !== this.#eo.length
              ? this.#eo.pop()
              : this.#Q === this.#q
              ? this.#ej(!1)
              : this.#Q),
            (this.#ee[d] = e),
            (this.#et[d] = t),
            this.#J.set(e, d),
            (this.#er[this.#ea] = d),
            (this.#en[d] = this.#ea),
            (this.#ea = d),
            this.#Q++,
            this.#eI(d, c, l),
            l && (l.set = 'add'),
            (u = !1);
        else {
          this.#eg(d);
          let n = this.#et[d];
          if (t !== n) {
            if (this.#ef && this.#ep(n)) {
              n.__abortController.abort(Error('replaced'));
              let { __staleWhileFetching: t } = n;
              void 0 !== t &&
                !o &&
                (this.#ed && this.#G?.(t, e, 'set'), this.#eh && this.#es?.push([t, e, 'set']));
            } else
              !o && (this.#ed && this.#G?.(n, e, 'set'), this.#eh && this.#es?.push([n, e, 'set']));
            if ((this.#eO(d), this.#eI(d, c, l), (this.#et[d] = t), l)) {
              l.set = 'replace';
              let e = n && this.#ep(n) ? n.__staleWhileFetching : n;
              void 0 !== e && (l.oldValue = e);
            }
          } else l && (l.set = 'update');
        }
        if (
          (0 === i || this.#ec || this.#ex(),
          this.#ec && (u || this.#eE(d, i, a), l && this.#ek(l, d)),
          !o && this.#eh && this.#es)
        ) {
          let e,
            t = this.#es;
          for (; (e = t?.shift()); ) this.#H?.(...e);
        }
        return this;
      }
      pop() {
        try {
          for (; this.#Q; ) {
            let e = this.#et[this.#ei];
            if ((this.#ej(!0), this.#ep(e))) {
              if (e.__staleWhileFetching) return e.__staleWhileFetching;
            } else if (void 0 !== e) return e;
          }
        } finally {
          if (this.#eh && this.#es) {
            let e,
              t = this.#es;
            for (; (e = t?.shift()); ) this.#H?.(...e);
          }
        }
      }
      #ej(e) {
        let t = this.#ei,
          n = this.#ee[t],
          i = this.#et[t];
        return (
          this.#ef && this.#ep(i)
            ? i.__abortController.abort(Error('evicted'))
            : (this.#ed || this.#eh) &&
              (this.#ed && this.#G?.(i, n, 'evict'), this.#eh && this.#es?.push([i, n, 'evict'])),
          this.#eO(t),
          e && ((this.#ee[t] = void 0), (this.#et[t] = void 0), this.#eo.push(t)),
          1 === this.#Q
            ? ((this.#ei = this.#ea = 0), (this.#eo.length = 0))
            : (this.#ei = this.#er[t]),
          this.#J.delete(n),
          this.#Q--,
          t
        );
      }
      has(e, t = {}) {
        let { updateAgeOnHas: n = this.updateAgeOnHas, status: i } = t,
          a = this.#J.get(e);
        if (void 0 !== a) {
          let e = this.#et[a];
          if (this.#ep(e) && void 0 === e.__staleWhileFetching) return !1;
          if (!this.#ev(a)) return n && this.#eC(a), i && ((i.has = 'hit'), this.#ek(i, a)), !0;
          i && ((i.has = 'stale'), this.#ek(i, a));
        } else i && (i.has = 'miss');
        return !1;
      }
      peek(e, t = {}) {
        let { allowStale: n = this.allowStale } = t,
          i = this.#J.get(e);
        if (void 0 === i || (!n && this.#ev(i))) return;
        let a = this.#et[i];
        return this.#ep(a) ? a.__staleWhileFetching : a;
      }
      #em(e, t, n, i) {
        let a = void 0 === t ? void 0 : this.#et[t];
        if (this.#ep(a)) return a;
        let o = new gL(),
          { signal: s } = n;
        s?.addEventListener('abort', () => o.abort(s.reason), { signal: o.signal });
        let l = { signal: o.signal, options: n, context: i },
          u = (i, a = !1) => {
            let { aborted: s } = o.signal,
              u = n.ignoreFetchAbort && void 0 !== i;
            return (n.status &&
              (s && !a
                ? ((n.status.fetchAborted = !0),
                  (n.status.fetchError = o.signal.reason),
                  u && (n.status.fetchAbortIgnored = !0))
                : (n.status.fetchResolved = !0)),
            !s || u || a)
              ? (this.#et[t] === f &&
                  (void 0 === i
                    ? f.__staleWhileFetching
                      ? (this.#et[t] = f.__staleWhileFetching)
                      : this.#eS(e, 'fetch')
                    : (n.status && (n.status.fetchUpdated = !0), this.set(e, i, l.options))),
                i)
              : c(o.signal.reason);
          },
          c = (i) => {
            let { aborted: a } = o.signal,
              s = a && n.allowStaleOnFetchAbort,
              l = s || n.allowStaleOnFetchRejection,
              u = l || n.noDeleteOnFetchRejection;
            if (
              (this.#et[t] === f &&
                (u && void 0 !== f.__staleWhileFetching
                  ? s || (this.#et[t] = f.__staleWhileFetching)
                  : this.#eS(e, 'fetch')),
              l)
            )
              return (
                n.status && void 0 !== f.__staleWhileFetching && (n.status.returnedStale = !0),
                f.__staleWhileFetching
              );
            if (f.__returned === f) throw i;
          },
          d = (t, i) => {
            let s = this.#Z?.(e, a, l);
            s && s instanceof Promise && s.then((e) => t(void 0 === e ? void 0 : e), i),
              o.signal.addEventListener('abort', () => {
                (!n.ignoreFetchAbort || n.allowStaleOnFetchAbort) &&
                  (t(void 0), n.allowStaleOnFetchAbort && (t = (e) => u(e, !0)));
              });
          };
        n.status && (n.status.fetchDispatched = !0);
        let f = new Promise(d).then(
            u,
            (e) => (n.status && ((n.status.fetchRejected = !0), (n.status.fetchError = e)), c(e))
          ),
          h = Object.assign(f, {
            __abortController: o,
            __staleWhileFetching: a,
            __returned: void 0,
          });
        return (
          void 0 === t
            ? (this.set(e, h, { ...l.options, status: void 0 }), (t = this.#J.get(e)))
            : (this.#et[t] = h),
          h
        );
      }
      #ep(e) {
        return (
          !!this.#ef &&
          !!e &&
          e instanceof Promise &&
          e.hasOwnProperty('__staleWhileFetching') &&
          e.__abortController instanceof gL
        );
      }
      async fetch(e, t = {}) {
        let {
          allowStale: n = this.allowStale,
          updateAgeOnGet: i = this.updateAgeOnGet,
          noDeleteOnStaleGet: a = this.noDeleteOnStaleGet,
          ttl: o = this.ttl,
          noDisposeOnSet: s = this.noDisposeOnSet,
          size: l = 0,
          sizeCalculation: u = this.sizeCalculation,
          noUpdateTTL: c = this.noUpdateTTL,
          noDeleteOnFetchRejection: d = this.noDeleteOnFetchRejection,
          allowStaleOnFetchRejection: f = this.allowStaleOnFetchRejection,
          ignoreFetchAbort: h = this.ignoreFetchAbort,
          allowStaleOnFetchAbort: p = this.allowStaleOnFetchAbort,
          context: m,
          forceRefresh: g = !1,
          status: y,
          signal: b,
        } = t;
        if (!this.#ef)
          return (
            y && (y.fetch = 'get'),
            this.get(e, { allowStale: n, updateAgeOnGet: i, noDeleteOnStaleGet: a, status: y })
          );
        let v = {
            allowStale: n,
            updateAgeOnGet: i,
            noDeleteOnStaleGet: a,
            ttl: o,
            noDisposeOnSet: s,
            size: l,
            sizeCalculation: u,
            noUpdateTTL: c,
            noDeleteOnFetchRejection: d,
            allowStaleOnFetchRejection: f,
            allowStaleOnFetchAbort: p,
            ignoreFetchAbort: h,
            status: y,
            signal: b,
          },
          w = this.#J.get(e);
        if (void 0 === w) {
          y && (y.fetch = 'miss');
          let t = this.#em(e, w, v, m);
          return (t.__returned = t);
        }
        {
          let t = this.#et[w];
          if (this.#ep(t)) {
            let e = n && void 0 !== t.__staleWhileFetching;
            return (
              y && ((y.fetch = 'inflight'), e && (y.returnedStale = !0)),
              e ? t.__staleWhileFetching : (t.__returned = t)
            );
          }
          let a = this.#ev(w);
          if (!g && !a)
            return y && (y.fetch = 'hit'), this.#eg(w), i && this.#eC(w), y && this.#ek(y, w), t;
          let o = this.#em(e, w, v, m),
            s = void 0 !== o.__staleWhileFetching && n;
          return (
            y && ((y.fetch = a ? 'stale' : 'refresh'), s && a && (y.returnedStale = !0)),
            s ? o.__staleWhileFetching : (o.__returned = o)
          );
        }
      }
      async forceFetch(e, t = {}) {
        let n = await this.fetch(e, t);
        if (void 0 === n) throw Error('fetch() returned undefined');
        return n;
      }
      memo(e, t = {}) {
        let n = this.#Y;
        if (!n) throw Error('no memoMethod provided to constructor');
        let { context: i, forceRefresh: a, ...o } = t,
          s = this.get(e, o);
        if (!a && void 0 !== s) return s;
        let l = n(e, s, { options: o, context: i });
        return this.set(e, l, o), l;
      }
      get(e, t = {}) {
        let {
            allowStale: n = this.allowStale,
            updateAgeOnGet: i = this.updateAgeOnGet,
            noDeleteOnStaleGet: a = this.noDeleteOnStaleGet,
            status: o,
          } = t,
          s = this.#J.get(e);
        if (void 0 !== s) {
          let t = this.#et[s],
            l = this.#ep(t);
          return (o && this.#ek(o, s), this.#ev(s))
            ? (o && (o.get = 'stale'), l)
              ? (o && n && void 0 !== t.__staleWhileFetching && (o.returnedStale = !0),
                n ? t.__staleWhileFetching : void 0)
              : (a || this.#eS(e, 'expire'), o && n && (o.returnedStale = !0), n ? t : void 0)
            : (o && (o.get = 'hit'), l)
            ? t.__staleWhileFetching
            : (this.#eg(s), i && this.#eC(s), t);
        }
        o && (o.get = 'miss');
      }
      #eR(e, t) {
        (this.#en[t] = e), (this.#er[e] = t);
      }
      #eg(e) {
        e !== this.#ea &&
          (e === this.#ei ? (this.#ei = this.#er[e]) : this.#eR(this.#en[e], this.#er[e]),
          this.#eR(this.#ea, e),
          (this.#ea = e));
      }
      delete(e) {
        return this.#eS(e, 'delete');
      }
      #eS(e, t) {
        let n = !1;
        if (0 !== this.#Q) {
          let i = this.#J.get(e);
          if (void 0 !== i)
            if (((n = !0), 1 === this.#Q)) this.#eM(t);
            else {
              this.#eO(i);
              let n = this.#et[i];
              if (
                (this.#ep(n)
                  ? n.__abortController.abort(Error('deleted'))
                  : (this.#ed || this.#eh) &&
                    (this.#ed && this.#G?.(n, e, t), this.#eh && this.#es?.push([n, e, t])),
                this.#J.delete(e),
                (this.#ee[i] = void 0),
                (this.#et[i] = void 0),
                i === this.#ea)
              )
                this.#ea = this.#en[i];
              else if (i === this.#ei) this.#ei = this.#er[i];
              else {
                let e = this.#en[i];
                this.#er[e] = this.#er[i];
                let t = this.#er[i];
                this.#en[t] = this.#en[i];
              }
              this.#Q--, this.#eo.push(i);
            }
        }
        if (this.#eh && this.#es?.length) {
          let e,
            t = this.#es;
          for (; (e = t?.shift()); ) this.#H?.(...e);
        }
        return n;
      }
      clear() {
        return this.#eM('delete');
      }
      #eM(e) {
        for (let t of this.#eb({ allowStale: !0 })) {
          let n = this.#et[t];
          if (this.#ep(n)) n.__abortController.abort(Error('deleted'));
          else {
            let i = this.#ee[t];
            this.#ed && this.#G?.(n, i, e), this.#eh && this.#es?.push([n, i, e]);
          }
        }
        if (
          (this.#J.clear(),
          this.#et.fill(void 0),
          this.#ee.fill(void 0),
          this.#ec && this.#eu && (this.#ec.fill(0), this.#eu.fill(0)),
          this.#el && this.#el.fill(0),
          (this.#ei = 0),
          (this.#ea = 0),
          (this.#eo.length = 0),
          (this.#X = 0),
          (this.#Q = 0),
          this.#eh && this.#es)
        ) {
          let e,
            t = this.#es;
          for (; (e = t?.shift()); ) this.#H?.(...e);
        }
      }
    }
    e.i(2031), e.i(30860);
    var gG = new Set(),
      gH = [],
      gZ = [];
    mV ||
      ((e) => {
        if (!e) throw Error('No adapter provided when calling "setAdapter"');
        (mV = !0), mz.push(e);
      })({
        appendCss: (e) => {
          gZ.push(e);
        },
        registerClassName: (e) => {
          gG.add(e);
        },
        registerComposition: (e) => {
          gH.push(e);
        },
        markCompositionUsed: () => {},
        onEndFileScope: (e) => {
          ((e) => {
            var { fileScope: t, css: n } = e,
              i = t.packageName ? [t.packageName, t.filePath].join('/') : t.filePath,
              a = mU[i];
            if (!a) {
              var o = document.createElement('style');
              t.packageName && o.setAttribute('data-package', t.packageName),
                o.setAttribute('data-file', t.filePath),
                o.setAttribute('type', 'text/css'),
                (a = mU[i] = o),
                document.head.appendChild(o);
            }
            a.innerHTML = n;
          })({
            fileScope: e,
            css: (function (e) {
              var { localClassNames: t, cssObjs: n, composedClassLists: i } = e,
                a = new gN(t, i);
              for (var o of n) a.processCssObj(o);
              return a.toCss();
            })({ localClassNames: Array.from(gG), composedClassLists: gH, cssObjs: gZ }).join('\n'),
          }),
            (gZ = []);
        },
        getIdentOption: () => 'short',
      });
    var gY = (e, t) => {
      for (var n = t - 1; n >= 0; ) {
        if ('/' === e[n]) return n;
        n--;
      }
      return -1;
    };
    function gQ(e) {
      return {
        onFetch: (t, n) => {
          let i = t.options,
            a = t.fetchOptions?.meta?.fetchMore?.direction,
            o = t.state.data?.pages || [],
            s = t.state.data?.pageParams || [],
            l = { pages: [], pageParams: [] },
            u = 0,
            c = async () => {
              let n = !1,
                c = nd(t.options, t.fetchOptions),
                d = async (e, i, a) => {
                  let o;
                  if (n) return Promise.reject();
                  if (null == i && e.pages.length) return Promise.resolve(e);
                  let s =
                      (Object.defineProperty(
                        (o = {
                          client: t.client,
                          queryKey: t.queryKey,
                          pageParam: i,
                          direction: a ? 'backward' : 'forward',
                          meta: t.options.meta,
                        }),
                        'signal',
                        {
                          enumerable: !0,
                          get: () => (
                            t.signal.aborted
                              ? (n = !0)
                              : t.signal.addEventListener('abort', () => {
                                  n = !0;
                                }),
                            t.signal
                          ),
                        }
                      ),
                      o),
                    l = await c(s),
                    { maxPages: u } = t.options,
                    d = a ? nu : nl;
                  return { pages: d(e.pages, l, u), pageParams: d(e.pageParams, i, u) };
                };
              if (a && o.length) {
                let e = 'backward' === a,
                  t = { pages: o, pageParams: s },
                  n = (e ? gJ : gX)(i, t);
                l = await d(t, n, e);
              } else {
                let t = e ?? o.length;
                do {
                  let e = 0 === u ? s[0] ?? i.initialPageParam : gX(i, l);
                  if (u > 0 && null == e) break;
                  (l = await d(l, e)), u++;
                } while (u < t);
              }
              return l;
            };
          t.options.persister
            ? (t.fetchFn = () =>
                t.options.persister?.(
                  c,
                  {
                    client: t.client,
                    queryKey: t.queryKey,
                    meta: t.options.meta,
                    signal: t.signal,
                  },
                  n
                ))
            : (t.fetchFn = c);
        },
      };
    }
    function gX(e, { pages: t, pageParams: n }) {
      let i = t.length - 1;
      return t.length > 0 ? e.getNextPageParam(t[i], t, n[i], n) : void 0;
    }
    function gJ(e, { pages: t, pageParams: n }) {
      return t.length > 0 ? e.getPreviousPageParam?.(t[0], t, n[0], n) : void 0;
    }
    function g0(e, t) {
      return !!t && null != gX(e, t);
    }
    function g1(e, t) {
      return !!t && !!e.getPreviousPageParam && null != gJ(e, t);
    }
    async function g5(e, t) {
      if (!e.features['iota:signTransaction'])
        throw Error(`Provided wallet (${e.name}) does not support the signTransaction feature.`);
      return e.features['iota:signTransaction'].signTransaction(t);
    }
    (G = new gK({ max: 500 })),
      e.s(
        ['hasNextPage', () => g0, 'hasPreviousPage', () => g1, 'infiniteQueryBehavior', () => gQ],
        92571
      );
    var g2 = Object.create,
      g6 = Object.defineProperty,
      g3 = Object.getOwnPropertyDescriptor,
      g4 = Object.getOwnPropertyNames,
      g8 = Object.getPrototypeOf,
      g9 = Object.prototype.hasOwnProperty,
      g7 = (e) => {
        throw TypeError(e);
      },
      ye = (e, t, n) => (
        t.has(e) || g7('Cannot read from private field'), n ? n.call(e) : t.get(e)
      ),
      yt = (e, t, n) =>
        t.has(e)
          ? g7('Cannot add the same private member more than once')
          : t instanceof WeakSet
          ? t.add(e)
          : t.set(e, n),
      yr =
        ((w = {
          'vanilla-extract-css-ns:src/components/styling/StyleMarker.css.ts.vanilla.css?source=OndoZXJlKCopIHsKICBib3gtc2l6aW5nOiBib3JkZXItYm94OwogIGNvbG9yOiB2YXIoLS1kYXBwLWtpdC1jb2xvcnMtYm9keSk7CiAgZm9udC1mYW1pbHk6IHZhcigtLWRhcHAta2l0LXR5cG9ncmFwaHktZm9udEZhbWlseSk7CiAgZm9udC1zaXplOiB2YXIoLS1kYXBwLWtpdC1mb250V2VpZ2h0cy1ub3JtYWwpOwogIGZvbnQtc3R5bGU6IHZhcigtLWRhcHAta2l0LXR5cG9ncmFwaHktZm9udFN0eWxlKTsKICBmb250LXdlaWdodDogdmFyKC0tZGFwcC1raXQtZm9udFdlaWdodHMtbm9ybWFsKTsKICBsaW5lLWhlaWdodDogdmFyKC0tZGFwcC1raXQtdHlwb2dyYXBoeS1saW5lSGVpZ2h0KTsKICBsZXR0ZXItc3BhY2luZzogdmFyKC0tZGFwcC1raXQtdHlwb2dyYXBoeS1sZXR0ZXJTcGFjaW5nKTsKfQo6d2hlcmUoYnV0dG9uKSB7CiAgYXBwZWFyYW5jZTogbm9uZTsKICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDsKICBmb250LXNpemU6IGluaGVyaXQ7CiAgZm9udC1mYW1pbHk6IGluaGVyaXQ7CiAgbGluZS1oZWlnaHQ6IGluaGVyaXQ7CiAgbGV0dGVyLXNwYWNpbmc6IGluaGVyaXQ7CiAgY29sb3I6IGluaGVyaXQ7CiAgYm9yZGVyOiAwOwogIHBhZGRpbmc6IDA7CiAgbWFyZ2luOiAwOwp9Cjp3aGVyZShhKSB7CiAgdGV4dC1kZWNvcmF0aW9uOiBub25lOwogIGNvbG9yOiBpbmhlcml0OwogIG91dGxpbmU6IG5vbmU7Cn0KOndoZXJlKG9sLCB1bCkgewogIGxpc3Qtc3R5bGU6IG5vbmU7CiAgbWFyZ2luOiAwOwogIHBhZGRpbmc6IDA7Cn0KOndoZXJlKGgxLCBoMiwgaDMsIGg0LCBoNSwgaDYpIHsKICBmb250LXNpemU6IGluaGVyaXQ7CiAgZm9udC13ZWlnaHQ6IGluaGVyaXQ7CiAgbWFyZ2luOiAwOwp9'() {},
        }),
        function () {
          return w && (x = (0, w[g4(w)[0]])((w = 0))), x;
        }),
      yn =
        ((E = {
          'src/components/styling/StyleMarker.css.ts'() {
            yr();
          },
        }),
        function () {
          return S || (0, E[g4(E)[0]])((S = { exports: {} }).exports, S), S.exports;
        }),
      yi = {
        all: { baseScope: 'wallet' },
        connectWallet: ya('connect-wallet'),
        autoconnectWallet: ya('autoconnect-wallet'),
        disconnectWallet: ya('disconnect-wallet'),
        signPersonalMessage: ya('sign-personal-message'),
        signTransaction: ya('sign-transaction'),
        signAndExecuteTransaction: ya('sign-and-execute-transaction'),
        switchAccount: ya('switch-account'),
        reportTransactionEffects: ya('report-transaction-effects'),
      };
    function ya(e) {
      return function (t = []) {
        return [{ ...yi.all, baseEntity: e }, ...t];
      };
    }
    var yo = (0, eX.createContext)(null);
    function ys(e) {
      let t = (0, eX.useContext)(yo);
      if (!t)
        throw Error(
          'Could not find WalletContext. Ensure that you have set up the WalletProvider.'
        );
      return (function (e, t = (e) => e, n) {
        nM.env && nM.env.MODE;
        let i = nN(e.subscribe, e.getState, e.getServerState || e.getInitialState, t, void 0);
        return nP(i), i;
      })(t, e);
    }
    function yl({ mutationKey: e, ...t } = {}) {
      let n = ys((e) => e.setWalletConnected),
        i = ys((e) => e.setConnectionStatus);
      return nI({
        mutationKey: yi.connectWallet(e),
        mutationFn: async ({ wallet: e, accountAddress: t, ...a }) => {
          try {
            var o, s;
            i('connecting');
            let l = await e.features['standard:connect'].connect(a),
              u = l.accounts.filter((e) => e.chains.some(rG)),
              c =
                ((o = u),
                (s = t),
                0 === o.length ? null : s ? o.find((e) => e.address === s) ?? o[0] : o[0]);
            return n(e, u, c, l.supportedIntents), { accounts: u };
          } catch (e) {
            throw (i('disconnected'), e);
          }
        },
        ...t,
      });
    }
    function yu(e, t) {
      let n = nF()
        .get()
        .filter(
          (e) =>
            (function (e, t = []) {
              return [...nq, ...t].every((t) => t in e.features);
            })(e) &&
            (!t || t(e))
        );
      return [
        ...e.map((e) => n.find((t) => t.name === e)).filter(Boolean),
        ...n.filter((t) => !e.includes(t.name)),
      ];
    }
    function yc(e) {
      return e?.id ?? e?.name;
    }
    function yd(e) {
      return (0, e2.jsx)('svg', {
        width: 24,
        height: 24,
        fill: 'none',
        xmlns: 'http://www.w3.org/2000/svg',
        ...e,
        children: (0, e2.jsx)('path', {
          d: 'M7.57 12.262c0 .341.13.629.403.895l5.175 5.059c.204.205.45.307.751.307.609 0 1.101-.485 1.101-1.087 0-.293-.123-.574-.349-.8L10.14 12.27l4.511-4.375A1.13 1.13 0 0 0 15 7.087C15 6.485 14.508 6 13.9 6c-.295 0-.54.103-.752.308l-5.175 5.058c-.28.28-.404.56-.404.896Z',
          fill: 'currentColor',
        }),
      });
    }
    function yf(e) {
      return (0, e2.jsx)('svg', {
        width: 10,
        height: 10,
        fill: 'none',
        xmlns: 'http://www.w3.org/2000/svg',
        ...e,
        children: (0, e2.jsx)('path', {
          d: 'M9.708.292a.999.999 0 0 0-1.413 0l-3.289 3.29L1.717.291A.999.999 0 0 0 .305 1.705l3.289 3.289-3.29 3.289a.999.999 0 1 0 1.413 1.412l3.29-3.289 3.288 3.29a.999.999 0 0 0 1.413-1.413l-3.29-3.29 3.29-3.288a.999.999 0 0 0 0-1.413Z',
          fill: 'currentColor',
        }),
      });
    }
    var yh = 'data-dapp-kit',
      yp = `[${yh}]`,
      ym = { [yh]: '' };
    (O = null != (C = yn()) ? g2(g8(C)) : {}),
      ((e, t, n, i) => {
        if ((t && 'object' == typeof t) || 'function' == typeof t)
          for (let a of g4(t))
            g9.call(e, a) ||
              a === n ||
              g6(e, a, { get: () => t[a], enumerable: !(i = g3(t, a)) || i.enumerable });
      })(!k && C && C.__esModule ? O : g6(O, 'default', { value: C, enumerable: !0 }), C);
    var yg = (0, eX.forwardRef)(({ children: e, ...t }, n) =>
      (0, e2.jsx)(nZ, { ref: n, ...t, ...ym, children: e })
    );
    yg.displayName = 'StyleMarker';
    var yy = n5({
        defaultClassName: 'Heading__12b5l8i0',
        variantClassNames: {
          size: {
            sm: 'Heading_headingVariants_size_sm__12b5l8i1',
            md: 'Heading_headingVariants_size_md__12b5l8i2',
            lg: 'Heading_headingVariants_size_lg__12b5l8i3',
            xl: 'Heading_headingVariants_size_xl__12b5l8i4',
          },
          weight: {
            normal: 'Heading_headingVariants_weight_normal__12b5l8i5',
            bold: 'Heading_headingVariants_weight_bold__12b5l8i6',
          },
          truncate: { true: 'Heading_headingVariants_truncate_true__12b5l8i7' },
        },
        defaultVariants: { size: 'lg', weight: 'bold' },
        compoundVariants: [],
      }),
      yb = (0, eX.forwardRef)(
        (
          {
            children: e,
            className: t,
            asChild: n = !1,
            as: i = 'h1',
            size: a,
            weight: o,
            truncate: s,
            ...l
          },
          u
        ) =>
          (0, e2.jsx)(nZ, {
            ...l,
            ref: u,
            className: rW(yy({ size: a, weight: o, truncate: s }), t),
            children: n ? e : (0, e2.jsx)(i, { children: e }),
          })
      );
    yb.displayName = 'Heading';
    var yv = (0, eX.forwardRef)(({ className: e, asChild: t = !1, ...n }, i) => {
      let a = t ? nZ : 'button';
      return (0, e2.jsx)(a, { ...n, className: rW('IconButton_container__ap1qll0', e), ref: i });
    });
    yv.displayName = 'Button';
    var yw = n5({
        defaultClassName: 'Button_buttonVariants__ctbx2n0',
        variantClassNames: {
          variant: {
            primary: 'Button_buttonVariants_variant_primary__ctbx2n1',
            outline: 'Button_buttonVariants_variant_outline__ctbx2n2',
          },
          size: {
            md: 'Button_buttonVariants_size_md__ctbx2n3',
            lg: 'Button_buttonVariants_size_lg__ctbx2n4',
          },
        },
        defaultVariants: { variant: 'primary', size: 'md' },
        compoundVariants: [],
      }),
      yx = (0, eX.forwardRef)(({ className: e, variant: t, size: n, asChild: i = !1, ...a }, o) => {
        let s = i ? nZ : 'button';
        return (0, e2.jsx)(s, { ...a, className: rW(yw({ variant: t, size: n }), e), ref: o });
      });
    yx.displayName = 'Button';
    var yE = n5({
        defaultClassName: 'Text__aprhbd0',
        variantClassNames: {
          size: { sm: 'Text_textVariants_size_sm__aprhbd1' },
          weight: {
            normal: 'Text_textVariants_weight_normal__aprhbd2',
            medium: 'Text_textVariants_weight_medium__aprhbd3',
            bold: 'Text_textVariants_weight_bold__aprhbd4',
          },
          color: {
            muted: 'Text_textVariants_color_muted__aprhbd5',
            danger: 'Text_textVariants_color_danger__aprhbd6',
          },
          mono: { true: 'Text_textVariants_mono_true__aprhbd7' },
        },
        defaultVariants: { size: 'sm', weight: 'normal' },
        compoundVariants: [],
      }),
      yS = (0, eX.forwardRef)(
        (
          {
            children: e,
            className: t,
            asChild: n = !1,
            as: i = 'div',
            size: a,
            weight: o,
            color: s,
            mono: l,
            ...u
          },
          c
        ) =>
          (0, e2.jsx)(nZ, {
            ...u,
            ref: c,
            className: rW(yE({ size: a, weight: o, color: s, mono: l }), t),
            children: n ? e : (0, e2.jsx)(i, { children: e }),
          })
      );
    function yC({ selectedWallet: e, hadConnectionError: t, onRetryConnection: n }) {
      return (0, e2.jsxs)('div', {
        className: 'ConnectionStatus_container__c5q1ll0',
        children: [
          (0, e2.jsx)('img', {
            className: 'ConnectionStatus_walletIcon__c5q1ll1',
            src: e.icon,
            alt: `${e.name} logo`,
          }),
          (0, e2.jsx)('div', {
            className: 'ConnectionStatus_title__c5q1ll2',
            children: (0, e2.jsxs)(yb, { as: 'h2', size: 'xl', children: ['Opening ', e.name] }),
          }),
          (0, e2.jsx)('div', {
            className: 'ConnectionStatus_connectionStatus__c5q1ll3',
            children: t
              ? (0, e2.jsx)(yS, { color: 'danger', children: 'Connection failed' })
              : (0, e2.jsx)(yS, {
                  color: 'muted',
                  children: 'Confirm connection in the wallet...',
                }),
          }),
          t
            ? (0, e2.jsx)('div', {
                className: 'ConnectionStatus_retryButtonContainer__c5q1ll4',
                children: (0, e2.jsx)(yx, {
                  type: 'button',
                  variant: 'primary',
                  onClick: () => n(e),
                  children: 'Retry Connection',
                }),
              })
            : null,
        ],
      });
    }
    function yk({ title: e, children: t }) {
      return (0, e2.jsxs)('section', {
        className: 'InfoSection_container__1d1nrmt0',
        children: [
          (0, e2.jsx)(yb, { as: 'h3', size: 'sm', weight: 'normal', children: e }),
          (0, e2.jsx)(yS, { weight: 'medium', color: 'muted', children: t }),
        ],
      });
    }
    function yO() {
      return (0, e2.jsxs)('div', {
        className: 'GettingStarted_container__qu36t90',
        children: [
          (0, e2.jsx)(yb, { as: 'h2', children: 'Get Started with IOTA' }),
          (0, e2.jsxs)('div', {
            className: 'GettingStarted_content__qu36t91',
            children: [
              (0, e2.jsx)(yk, {
                title: 'Install the IOTA Wallet Extension',
                children: 'We recommend pinning IOTA Wallet to your taskbar for quicker access.',
              }),
              (0, e2.jsx)(yk, {
                title: 'Create or Import a Wallet',
                children:
                  'Be sure to back up your wallet using a secure method. Never share your secret phrase with anyone.',
              }),
              (0, e2.jsx)(yk, {
                title: 'Refresh Your Browser',
                children:
                  'Once you set up your wallet, refresh this window browser to load up the extension.',
              }),
              (0, e2.jsx)('div', {
                className: 'GettingStarted_installButtonContainer__qu36t92',
                children: (0, e2.jsx)(yx, {
                  variant: 'primary',
                  asChild: !0,
                  children: (0, e2.jsx)('a', {
                    href: 'https://chrome.google.com/webstore/detail/iota-wallet/iidjkmdceolghepehaaddojmnjnkkija',
                    target: '_blank',
                    rel: 'noreferrer',
                    children: 'Install Wallet Extension',
                  }),
                }),
              }),
            ],
          }),
        ],
      });
    }
    function yA() {
      return (0, e2.jsxs)('div', {
        className: 'WhatIsAWallet_container__1kdcimq0',
        children: [
          (0, e2.jsx)(yb, { as: 'h2', children: 'What is a Wallet' }),
          (0, e2.jsxs)('div', {
            className: 'WhatIsAWallet_content__1kdcimq1',
            children: [
              (0, e2.jsx)(yk, {
                title: 'Easy Login',
                children:
                  'No need to create new accounts and passwords for every website. Just connect your wallet and get going.',
              }),
              (0, e2.jsx)(yk, {
                title: 'Store your Digital Assets',
                children:
                  'Send, receive, store, and display your digital assets like NFTs & coins.',
              }),
            ],
          }),
        ],
      });
    }
    function yI() {
      return ys((e) => e.wallets);
    }
    function yj(e) {
      return (0, e2.jsx)('svg', {
        xmlns: 'http://www.w3.org/2000/svg',
        width: '28px',
        height: '28px',
        fill: 'none',
        viewBox: '0 0 24 24',
        ...e,
        children: (0, e2.jsx)('path', {
          fill: '#171d26',
          d: 'M18.27 2.259c0 .695-.568 1.259-1.268 1.259s-1.267-.564-1.267-1.259S16.302 1 17.002 1s1.268.564 1.268 1.259m1.425 17.785c0 .695-.568 1.259-1.268 1.259s-1.267-.564-1.267-1.26c0-.695.567-1.258 1.267-1.258s1.268.563 1.268 1.259m-2.33-13.379a1.06 1.06 0 0 0 1.063-1.056 1.06 1.06 0 0 0-1.063-1.057A1.06 1.06 0 0 0 16.3 5.61a1.06 1.06 0 0 0 1.064 1.056Zm3.891-.651a1.06 1.06 0 0 1-1.063 1.056 1.06 1.06 0 0 1-1.064-1.056 1.06 1.06 0 0 1 1.064-1.057 1.06 1.06 0 0 1 1.063 1.057m-4.253 3.329c.5 0 .905-.403.905-.9 0-.496-.405-.9-.905-.9s-.906.404-.906.9c0 .497.406.9.906.9m3.734-.52c0 .497-.405.9-.905.9a.903.903 0 0 1-.906-.9c0-.496.405-.9.906-.9.5 0 .905.404.905.9m1.357 1.777c.5 0 .906-.402.906-.899s-.405-.9-.906-.9c-.5 0-.905.403-.905.9s.405.9.905.9Zm-2.309.495a.79.79 0 0 1-.792.787.79.79 0 0 1-.791-.787c0-.434.354-.786.791-.786s.792.352.792.786m-3.62.404a.79.79 0 0 0 .792-.787.79.79 0 0 0-.792-.786.79.79 0 0 0-.791.786c0 .435.354.787.791.787m5.907.471a.79.79 0 0 1-.791.787.79.79 0 0 1-.792-.786.79.79 0 0 1 .792-.787.79.79 0 0 1 .791.787Zm-4.21 1.554c.375 0 .68-.302.68-.675a.677.677 0 0 0-.68-.675.68.68 0 0 0-.68.675c0 .373.304.675.68.675m2.968.178a.68.68 0 0 1-.68.676.677.677 0 0 1-.68-.676c0-.373.304-.675.68-.675.375 0 .68.302.68.675m-5.774-.582c.375 0 .68-.302.68-.675a.68.68 0 0 0-.68-.675.68.68 0 0 0-.68.675c0 .373.304.675.68.675m2.127.943c0 .31-.254.561-.566.561a.564.564 0 0 1-.566-.562c0-.31.253-.561.566-.561s.566.251.566.562m.407 2.114a.496.496 0 0 0 .498-.494.496.496 0 0 0-.498-.495.496.496 0 0 0-.498.495c0 .273.223.494.498.494m-.791-.09a.407.407 0 0 1-.408.405.407.407 0 0 1-.408-.405c0-.223.182-.405.408-.405s.408.181.408.405m-1.472-.765a.496.496 0 0 0 .498-.494.496.496 0 0 0-.498-.495.496.496 0 0 0-.498.495c0 .273.223.494.498.494m-.973-1.64c0 .31-.254.562-.566.562a.564.564 0 0 1-.566-.562c0-.31.253-.562.566-.562s.566.251.566.562m-.588-3.666a.564.564 0 0 0 .566-.562.564.564 0 0 0-.566-.562.564.564 0 0 0-.565.562c0 .31.253.562.565.562m.745-2.473a.496.496 0 0 1-.497.494.496.496 0 0 1-.498-.494c0-.273.223-.494.498-.494s.498.22.498.494Zm.047-1.123a.406.406 0 0 0 .407-.406.406.406 0 0 0-.407-.405.407.407 0 0 0-.408.405c0 .224.182.406.408.406m-.452-1.26a.496.496 0 0 1-.498.494.496.496 0 0 1-.498-.494c0-.273.223-.494.498-.494s.498.22.498.494m4.776 10.32a.564.564 0 0 0 .566-.561.564.564 0 0 0-.566-.562.564.564 0 0 0-.566.562c0 .31.253.562.566.562ZM12.883 4.439c0 .31-.254.562-.566.562a.564.564 0 0 1-.566-.562c0-.31.254-.562.566-.562s.566.251.566.562m-.18 2.945a.564.564 0 0 0 .566-.562.564.564 0 0 0-.566-.561.564.564 0 0 0-.566.561c0 .31.253.562.566.562m.045 1.597a.677.677 0 0 1-.68.676.68.68 0 0 1-.679-.676c0-.373.304-.675.68-.675.375 0 .68.302.68.675Zm-2.74.676a.79.79 0 0 0 .791-.786.79.79 0 0 0-.791-.787.79.79 0 0 0-.792.787c0 .434.354.786.792.786m-1.494-.36c0 .497-.405.9-.905.9a.903.903 0 0 1-.906-.9c0-.497.406-.9.906-.9s.905.403.905.9m-3.529 2.18a1.06 1.06 0 0 0 1.063-1.056 1.06 1.06 0 0 0-1.063-1.056A1.06 1.06 0 0 0 3.92 10.42a1.06 1.06 0 0 0 1.064 1.056Zm-1.45.9c0 .696-.568 1.26-1.268 1.26S1 13.073 1 12.377c0-.695.567-1.259 1.267-1.259s1.268.564 1.268 1.26Zm.386-3.531A1.06 1.06 0 0 0 4.985 7.79 1.06 1.06 0 0 0 3.92 6.733 1.06 1.06 0 0 0 2.858 7.79 1.06 1.06 0 0 0 3.92 8.846Zm3.53-2.181c0 .497-.405.9-.906.9a.903.903 0 0 1-.905-.9c0-.496.405-.9.905-.9s.906.404.906.9M6.162 5.182c.5 0 .905-.403.905-.9 0-.496-.405-.9-.905-.9s-.906.404-.906.9c0 .497.406.9.906.9m3.19-1.326a.79.79 0 0 1-.791.787.79.79 0 0 1-.792-.787c0-.434.354-.786.792-.786.437 0 .791.352.791.786m1.268.788c.375 0 .68-.303.68-.675a.677.677 0 0 0-.68-.676.68.68 0 0 0-.68.675c0 .373.304.676.68.676m1.063 1.708a.68.68 0 0 1-.68.675.677.677 0 0 1-.68-.675c0-.373.305-.675.68-.675s.68.302.68.675m-2.739.695a.79.79 0 0 0 .792-.786.79.79 0 0 0-.792-.786.79.79 0 0 0-.791.786c0 .434.354.786.791.786m-1.832 5.578a.407.407 0 0 1-.408.405.407.407 0 0 1-.408-.405c0-.223.182-.405.408-.405s.408.181.408.405m1.221.201a.496.496 0 0 0 .497-.494.496.496 0 0 0-.497-.495.496.496 0 0 0-.498.495c0 .273.223.494.498.494m2.354-1.236c0 .31-.253.562-.565.562a.564.564 0 0 1-.566-.562c0-.31.253-.562.566-.562s.565.252.565.562m-.135 2.361c.375 0 .68-.302.68-.675a.677.677 0 0 0-.68-.675.677.677 0 0 0-.68.675c0 .373.304.675.68.675m-1.608-.135c0 .31-.253.562-.566.562a.564.564 0 0 1-.565-.562c0-.31.253-.562.565-.562.313 0 .566.252.566.562m-2.488.538a.496.496 0 0 0 .498-.494.496.496 0 0 0-.498-.495.496.496 0 0 0-.498.495c0 .273.223.494.498.494m.588.991c0 .31-.254.562-.566.562a.564.564 0 0 1-.566-.562c0-.31.253-.562.566-.562s.566.252.566.562m1.742.855c.376 0 .68-.303.68-.675a.677.677 0 0 0-.68-.676.677.677 0 0 0-.68.675c0 .373.305.676.68.676m3.484-1.08a.79.79 0 0 1-.79.786.79.79 0 0 1-.792-.786c0-.435.354-.787.791-.787s.792.352.792.787Zm.794 2.743c.5 0 .906-.402.906-.9 0-.496-.406-.899-.906-.899s-.905.403-.905.9.405.9.905.9Zm-2.536-.518a.79.79 0 0 1-.792.786.79.79 0 0 1-.792-.787.79.79 0 0 1 .792-.786.79.79 0 0 1 .792.787m-2.669 2.316a.79.79 0 0 0 .791-.786.79.79 0 0 0-.792-.786.79.79 0 0 0-.791.786c0 .434.354.786.792.786m2.466 1.079c0 .497-.405.9-.905.9a.903.903 0 0 1-.906-.9c0-.496.405-.9.906-.9.5 0 .905.404.905.9M13.584 22a1.06 1.06 0 0 0 1.064-1.056 1.06 1.06 0 0 0-1.064-1.057 1.06 1.06 0 0 0-1.063 1.057A1.06 1.06 0 0 0 13.584 22m-1.379-2.788c0 .497-.405.9-.905.9a.903.903 0 0 1-.906-.9c0-.497.405-.9.905-.9s.906.403.906.9m3.123.54a1.06 1.06 0 0 0 1.063-1.057 1.06 1.06 0 0 0-1.063-1.056 1.06 1.06 0 0 0-1.064 1.056 1.06 1.06 0 0 0 1.064 1.057m-7.741-2.699a.677.677 0 0 1-.68.676.677.677 0 0 1-.68-.676c0-.373.305-.675.68-.675s.68.302.68.675',
        }),
      });
    }
    function yT({ name: e, icon: t, onClick: n, isSelected: i = !1 }) {
      return (0, e2.jsx)('li', {
        className: 'WalletListItem_container__1vrvezk0',
        children: (0, e2.jsxs)('button', {
          className: rW('WalletListItem_walletItem__1vrvezk1', {
            WalletListItem_selectedWalletItem__1vrvezk2: i,
          }),
          type: 'button',
          onClick: n,
          children: [
            'string' == typeof t
              ? (0, e2.jsx)('img', {
                  className: 'WalletListItem_walletIcon__1vrvezk3',
                  src: t,
                  alt: `${e} logo`,
                })
              : t,
            (0, e2.jsx)(yb, {
              size: 'md',
              truncate: !0,
              asChild: !0,
              children: (0, e2.jsx)('div', { children: e }),
            }),
          ],
        }),
      });
    }
    function yR({ selectedWalletName: e, onPlaceholderClick: t, onSelect: n }) {
      let i = yI();
      return (0, e2.jsx)('ul', {
        className: 'WalletList_container__1tkdegw0',
        children:
          i.length > 0
            ? i.map((t) =>
                (0, e2.jsx)(
                  yT,
                  { name: t.name, icon: t.icon, isSelected: yc(t) === e, onClick: () => n(t) },
                  yc(t)
                )
              )
            : (0, e2.jsx)(yT, {
                name: 'IOTA Wallet',
                icon: (0, e2.jsx)(yj, { className: 'WalletList_icon__1tkdegw1' }),
                onClick: t,
                isSelected: !0,
              }),
      });
    }
    function yM({ trigger: e, open: t, defaultOpen: n, onOpenChange: i }) {
      let a,
        [o, s] = (0, eX.useState)(t ?? n),
        [l, u] = (0, eX.useState)(),
        [c, d] = (0, eX.useState)(),
        { mutate: f, isError: h } = yl(),
        p = () => {
          d(void 0), u(void 0);
        },
        m = (e) => {
          e || p(), s(e), i?.(e);
        },
        g = (e) => {
          u('connection-status'), f({ wallet: e, silent: !1 }, { onSuccess: () => m(!1) });
        };
      switch (l) {
        case 'what-is-a-wallet':
        default:
          a = (0, e2.jsx)(yA, {});
          break;
        case 'getting-started':
          a = (0, e2.jsx)(yO, {});
          break;
        case 'connection-status':
          a = (0, e2.jsx)(yC, { selectedWallet: c, hadConnectionError: h, onRetryConnection: g });
      }
      return (0, e2.jsxs)(ry, {
        open: t ?? o,
        onOpenChange: m,
        children: [
          (0, e2.jsx)(rv, { asChild: !0, children: e }),
          (0, e2.jsx)(rS, {
            children: (0, e2.jsx)(yg, {
              children: (0, e2.jsx)(rk, {
                className: 'ConnectModal_overlay__17mljma0',
                children: (0, e2.jsxs)(rj, {
                  className: 'ConnectModal_content__17mljma2',
                  'aria-describedby': void 0,
                  children: [
                    (0, e2.jsxs)('div', {
                      className: rW('ConnectModal_walletListContainer__17mljma9', {
                        ConnectModal_walletListContainerWithViewSelected__17mljmaa: !!l,
                      }),
                      children: [
                        (0, e2.jsxs)('div', {
                          className: 'ConnectModal_walletListContent__17mljma8',
                          children: [
                            (0, e2.jsx)(rN, {
                              className: 'ConnectModal_title__17mljma1',
                              asChild: !0,
                              children: (0, e2.jsx)(yb, { as: 'h2', children: 'Connect a Wallet' }),
                            }),
                            (0, e2.jsx)(yR, {
                              selectedWalletName: yc(c),
                              onPlaceholderClick: () => u('getting-started'),
                              onSelect: (e) => {
                                yc(c) !== yc(e) && (d(e), g(e));
                              },
                            }),
                          ],
                        }),
                        (0, e2.jsx)('button', {
                          className: 'ConnectModal_whatIsAWalletButton__17mljma3',
                          onClick: () => u('what-is-a-wallet'),
                          type: 'button',
                          children: 'What is a Wallet?',
                        }),
                      ],
                    }),
                    (0, e2.jsxs)('div', {
                      className: rW('ConnectModal_viewContainer__17mljma4', {
                        ConnectModal_selectedViewContainer__17mljma5: !!l,
                      }),
                      children: [
                        (0, e2.jsx)('div', {
                          className: 'ConnectModal_backButtonContainer__17mljma6',
                          children: (0, e2.jsx)(yv, {
                            type: 'button',
                            'aria-label': 'Back',
                            onClick: () => p(),
                            children: (0, e2.jsx)(yd, {}),
                          }),
                        }),
                        a,
                      ],
                    }),
                    (0, e2.jsx)(rB, {
                      className: 'ConnectModal_closeButtonContainer__17mljma7',
                      asChild: !0,
                      children: (0, e2.jsx)(yv, {
                        type: 'button',
                        'aria-label': 'Close',
                        children: (0, e2.jsx)(yf, {}),
                      }),
                    }),
                  ],
                }),
              }),
            }),
          }),
        ],
      });
    }
    function yP() {
      return ys((e) => e.currentAccount);
    }
    yS.displayName = 'Text';
    var yN = class extends Error {},
      y_ = class extends Error {},
      yD = class extends Error {},
      yB = class extends Error {};
    function yU() {
      let e = ys((e) => e.currentWallet),
        t = ys((e) => e.connectionStatus),
        n = ys((e) => e.supportedIntents);
      switch (t) {
        case 'connecting':
          return {
            connectionStatus: t,
            currentWallet: null,
            isDisconnected: !1,
            isConnecting: !0,
            isConnected: !1,
            supportedIntents: [],
          };
        case 'disconnected':
          return {
            connectionStatus: t,
            currentWallet: null,
            isDisconnected: !0,
            isConnecting: !1,
            isConnected: !1,
            supportedIntents: [],
          };
        case 'connected':
          return {
            connectionStatus: t,
            currentWallet: e,
            isDisconnected: !1,
            isConnecting: !1,
            isConnected: !0,
            supportedIntents: n,
          };
      }
    }
    var yF = 'AccountDropdownMenu_menuItem__1x0gmpf4';
    function yL(e) {
      return (0, e2.jsx)('svg', {
        xmlns: 'http://www.w3.org/2000/svg',
        width: 16,
        height: 16,
        fill: 'none',
        ...e,
        children: (0, e2.jsx)('path', {
          fill: 'currentColor',
          d: 'm11.726 5.048-4.73 5.156-1.722-1.879a.72.72 0 0 0-.529-.23.722.722 0 0 0-.525.24.858.858 0 0 0-.22.573.86.86 0 0 0 .211.576l2.255 2.458c.14.153.332.24.53.24.2 0 .391-.087.532-.24l5.261-5.735A.86.86 0 0 0 13 5.63a.858.858 0 0 0-.22-.572.722.722 0 0 0-.525-.24.72.72 0 0 0-.529.23Z',
        }),
      });
    }
    function yz(e) {
      return (0, e2.jsx)('svg', {
        xmlns: 'http://www.w3.org/2000/svg',
        width: 16,
        height: 16,
        fill: 'none',
        ...e,
        children: (0, e2.jsx)('path', {
          stroke: '#A0B6C3',
          strokeLinecap: 'round',
          strokeLinejoin: 'round',
          strokeWidth: 1.5,
          d: 'm4 6 4 4 4-4',
        }),
      });
    }
    var yV = (0, eX.createContext)(null),
      y$ = { localnet: { url: sf(sd.Localnet)?.url } },
      yW = function (e, t) {
        return 'object' == typeof t && null !== t && !0 === t[hh] ? t : new hp(t);
      };
    function yq(e) {
      let { onNetworkChange: t, network: n, children: i } = e,
        a = e.networks ?? y$,
        o = e.createClient ?? yW,
        [s, l] = (0, eX.useState)(e.network ?? e.defaultNetwork ?? Object.keys(a)[0]),
        u = e.network ?? s,
        c = (0, eX.useMemo)(() => o(u, a[u]), [o, u, a]),
        d = (0, eX.useMemo)(
          () => ({
            client: c,
            networks: a,
            network: u,
            config: a[u] instanceof hp ? null : a[u],
            selectNetwork: (e) => {
              u !== e && (n || e === s || l(e), t?.(e));
            },
          }),
          [c, a, s, u, n, t]
        );
      return (0, e2.jsx)(yV.Provider, { value: d, children: i });
    }
    function yK() {
      let e = (0, eX.useContext)(yV);
      if (!e)
        throw Error(
          'Could not find IotaClientContext. Ensure that you have set up the IotaClientProvider'
        );
      return e;
    }
    function yG() {
      return yK().client;
    }
    function yH(e, t) {
      let n = sf(yK().network),
        i = (0, eX.useMemo)(
          () => new cd({ graphQlClient: new h_({ url: n.graphql }), network: n.id }),
          [n.id]
        ),
        a = !!i.config;
      return sk({
        queryKey: ['iota-name', 'default-name', e],
        queryFn: async () => {
          if (!e) return null;
          let t = await i?.getDefaultName(e);
          return t ? cu(t) : t;
        },
        enabled: !!i && !!e && t && a,
        staleTime: 6e5,
      });
    }
    function yZ({ currentAccount: e, size: t = 'lg', iotaNamesEnabled: n }) {
      let { mutate: i } = (function ({ mutationKey: e, ...t } = {}) {
          let { currentWallet: n } = yU(),
            i = ys((e) => e.setWalletDisconnected);
          return nI({
            mutationKey: yi.disconnectWallet(e),
            mutationFn: async () => {
              if (!n) throw new yN('No wallet is connected.');
              try {
                await n.features['standard:disconnect']?.disconnect();
              } catch (e) {
                console.error('Failed to disconnect the application from the current wallet.', e);
              }
              i();
            },
            ...t,
          });
        })(),
        a = ys((e) => e.accounts),
        { data: o } = yH(e.address, n),
        s = o ?? e.label ?? ir(e.address);
      return (0, e2.jsxs)(sn, {
        modal: !1,
        children: [
          (0, e2.jsx)(yg, {
            children: (0, e2.jsx)(sa, {
              asChild: !0,
              children: (0, e2.jsxs)(yx, {
                size: t,
                className: 'AccountDropdownMenu_connectedAccount__1x0gmpf0',
                children: [
                  (0, e2.jsx)(yS, { mono: !0, weight: 'bold', children: s }),
                  (0, e2.jsx)(yz, {}),
                ],
              }),
            }),
          }),
          (0, e2.jsx)(so, {
            children: (0, e2.jsx)(yg, {
              className: 'AccountDropdownMenu_menuContainer__1x0gmpf1',
              children: (0, e2.jsxs)(sl, {
                className: 'AccountDropdownMenu_menuContent__1x0gmpf2',
                children: [
                  (0, e2.jsx)('div', {
                    className: 'AccountDropdownMenu_scrollableContent__1x0gmpf3',
                    children: a.map((t) =>
                      (0, e2.jsx)(
                        yY,
                        { account: t, active: e.address === t.address, iotaNamesEnabled: n },
                        t.address
                      )
                    ),
                  }),
                  (0, e2.jsx)(sc, { className: 'AccountDropdownMenu_separator__1x0gmpf6' }),
                  (0, e2.jsx)(su, {
                    className: rW(yF),
                    onSelect: () => i(),
                    children: 'Disconnect',
                  }),
                ],
              }),
            }),
          }),
        ],
      });
    }
    function yY({ account: e, active: t, iotaNamesEnabled: n }) {
      let { mutate: i } = (function ({ mutationKey: e, ...t } = {}) {
          let { currentWallet: n } = yU(),
            i = ys((e) => e.setAccountSwitched);
          return nI({
            mutationKey: yi.switchAccount(e),
            mutationFn: async ({ account: e }) => {
              if (!n) throw new yN('No wallet is connected.');
              let t = n.accounts.find((t) => t.address === e.address);
              if (!t)
                throw new yB(`No account with address ${e.address} is connected to ${n.name}.`);
              i(t);
            },
            ...t,
          });
        })(),
        { data: a } = yH(e.address, n),
        o = a ?? e.label ?? ir(e.address);
      return (0, e2.jsxs)(su, {
        className: rW(yF, 'AccountDropdownMenu_switchAccountMenuItem__1x0gmpf5'),
        onSelect: () => i({ account: e }),
        children: [(0, e2.jsx)(yS, { mono: !0, children: o }), t ? (0, e2.jsx)(yL, {}) : null],
      });
    }
    function yQ({ connectText: e = 'Connect Wallet', size: t, iotaNamesEnabled: n = !0, ...i }) {
      let a = yP();
      return a
        ? (0, e2.jsx)(yZ, { currentAccount: a, size: t, iotaNamesEnabled: n })
        : (0, e2.jsx)(yM, {
            trigger: (0, e2.jsx)(yg, { children: (0, e2.jsx)(yx, { ...i, size: t, children: e }) }),
          });
    }
    function yX() {
      let e = new Map();
      return {
        getItem: (t) => e.get(t),
        setItem(t, n) {
          e.set(t, n);
        },
        removeItem(t) {
          e.delete(t);
        },
      };
    }
    var yJ = 'undefined' != typeof window && window.localStorage ? localStorage : yX(),
      y0 = ['iota:signTransaction'],
      y1 = (e) => y0.some((t) => e.features[t]),
      y5 = ['IOTA Wallet'],
      y2 = 'Unsafe Burner Wallet',
      y6 = {
        blurs: { modalOverlay: 'blur(0)' },
        backgroundColors: {
          primaryButton: '#F6F7F9',
          primaryButtonHover: '#F0F2F5',
          outlineButtonHover: '#F4F4F5',
          modalOverlay: 'rgba(24 36 53 / 20%)',
          modalPrimary: 'white',
          modalSecondary: '#F7F8F8',
          iconButton: 'transparent',
          dropdownMenu: '#FFFFFF',
          dropdownMenuSeparator: '#F3F6F8',
          walletItemSelected: 'white',
          walletItemHover: '#3C424226',
          scrollThumb: '#cad4e2',
        },
        borderColors: { outlineButton: '#E4E4E7' },
        colors: {
          primaryButton: '#373737',
          outlineButtonHover: '#373737',
          iconButton: '#000000',
          body: '#182435',
          bodyMuted: '#767A81',
          bodyDanger: '#FF794B',
        },
        radii: { small: '6px', medium: '8px', large: '12px', xlarge: '16px', full: '120px' },
        fontWeights: { normal: '400', medium: '500', bold: '600' },
        fontSizes: { small: '14px', medium: '16px', large: '18px', xlarge: '20px' },
        typography: {
          fontFamily:
            'ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji"',
          fontStyle: 'normal',
          lineHeight: '24px',
          letterSpacing: '0.1px',
        },
        spacing: {
          xxsmall: '4px',
          xsmall: '8px',
          small: '12px',
          medium: '16px',
          large: '24px',
          xlarge: '32px',
        },
      },
      y3 =
        ((H = {
          blurs: { modalOverlay: '' },
          backgroundColors: {
            primaryButton: '',
            primaryButtonHover: '',
            outlineButtonHover: '',
            walletItemHover: '',
            walletItemSelected: '',
            modalOverlay: '',
            modalPrimary: '',
            modalSecondary: '',
            iconButton: '',
            dropdownMenu: '',
            dropdownMenuSeparator: '',
            scrollThumb: '',
          },
          borderColors: { outlineButton: '' },
          colors: {
            primaryButton: '',
            outlineButtonHover: '',
            body: '',
            bodyMuted: '',
            bodyDanger: '',
            iconButton: '',
          },
          radii: { small: '', medium: '', large: '', xlarge: '', full: '' },
          fontWeights: { normal: '', medium: '', bold: '' },
          fontSizes: { small: '', medium: '', large: '', xlarge: '' },
          typography: { fontFamily: '', fontStyle: '', lineHeight: '', letterSpacing: '' },
          spacing: { xxsmall: '', xsmall: '', small: '', medium: '', large: '', xlarge: '' },
        }),
        (Z = (e, t) => `dapp-kit-${t.join('-')}`),
        mB(H, (e, t) => {
          var n = Z(e, t),
            i = 'string' == typeof n ? n.replace(/^\-\-/, '') : null;
          if ('string' != typeof i || i !== (0, mF.default)(i, { isIdentifier: !0 }))
            throw Error('Invalid variable name for "'.concat(t.join('.'), '": ').concat(i));
          return 'var(--'.concat(i, ')');
        }));
    function y4({ theme: e }) {
      let t = Array.isArray(e)
        ? e
            .map(({ mediaQuery: e, selector: t, variables: n }) => {
              let i = y8(n),
                a = t ? `${t} ${i}` : i;
              return e ? `@media ${e}{${a}}` : a;
            })
            .join(' ')
        : y8(e);
      return (0, e2.jsx)('style', {
        precedence: 'default',
        href: 'iota-dapp-kit-theme',
        dangerouslySetInnerHTML: { __html: t },
      });
    }
    function y8(e) {
      return `${yp} {${Object.entries(
        (function (e, t) {
          var n = {};
          if ('object' == typeof t)
            mB(t, (t, i) => {
              null != t &&
                (n[
                  mD(
                    (function (e, t) {
                      var n = e;
                      for (var i of t) {
                        if (!(i in n))
                          throw Error('Path '.concat(t.join(' -> '), ' does not exist in object'));
                        n = n[i];
                      }
                      return n;
                    })(e, i)
                  )
                ] = String(t));
            });
          else
            for (var i in e) {
              var a = e[i];
              null != a && (n[mD(i)] = a);
            }
          return (
            Object.defineProperty(n, 'toString', {
              value: function () {
                return Object.keys(this)
                  .map((e) => ''.concat(e, ':').concat(this[e]))
                  .join(';');
              },
              writable: !1,
            }),
            n
          );
        })(y3, e)
      )
        .map(([e, t]) => `${e}:${t};`)
        .join('')}}`;
    }
    function y9({
      preferredWallets: e = y5,
      walletFilter: t = y1,
      storage: n = yJ,
      storageKey: i = 'iota-dapp-kit:wallet-connection-info',
      enableUnsafeBurner: a = !1,
      autoConnect: o = !1,
      theme: s = y6,
      children: l,
      chain: u,
    }) {
      let c = (0, eX.useRef)(
        (function ({ wallets: e, storage: t, storageKey: n, autoConnectEnabled: i, chain: a }) {
          let o;
          return (o ? nT(o) : nT)(
            ((e, t) => {
              if ('getStorage' in t || 'serialize' in t || 'deserialize' in t)
                return (
                  (mP.env ? mP.env.MODE : void 0) !== 'production' &&
                    console.warn(
                      '[DEPRECATED] `getStorage`, `serialize` and `deserialize` options are deprecated. Use `storage` option instead.'
                    ),
                  (n, i, a) => {
                    let o,
                      s,
                      l = {
                        getStorage: () => localStorage,
                        serialize: JSON.stringify,
                        deserialize: JSON.parse,
                        partialize: (e) => e,
                        version: 0,
                        merge: (e, t) => ({ ...t, ...e }),
                        ...t,
                      },
                      u = !1,
                      c = new Set(),
                      d = new Set();
                    try {
                      o = l.getStorage();
                    } catch (e) {}
                    if (!o)
                      return e(
                        (...e) => {
                          console.warn(
                            `[zustand persist middleware] Unable to update item '${l.name}', the given storage is currently unavailable.`
                          ),
                            n(...e);
                        },
                        i,
                        a
                      );
                    let f = m_(l.serialize),
                      h = () => {
                        let e,
                          t = f({ state: l.partialize({ ...i() }), version: l.version })
                            .then((e) => o.setItem(l.name, e))
                            .catch((t) => {
                              e = t;
                            });
                        if (e) throw e;
                        return t;
                      },
                      p = a.setState;
                    a.setState = (e, t) => {
                      p(e, t), h();
                    };
                    let m = e(
                        (...e) => {
                          n(...e), h();
                        },
                        i,
                        a
                      ),
                      g = () => {
                        var e;
                        if (!o) return;
                        (u = !1), c.forEach((e) => e(i()));
                        let t =
                          (null == (e = l.onRehydrateStorage) ? void 0 : e.call(l, i())) || void 0;
                        return m_(o.getItem.bind(o))(l.name)
                          .then((e) => {
                            if (e) return l.deserialize(e);
                          })
                          .then((e) => {
                            if (e)
                              if ('number' != typeof e.version || e.version === l.version)
                                return e.state;
                              else {
                                if (l.migrate) return l.migrate(e.state, e.version);
                                console.error(
                                  "State loaded from storage couldn't be migrated since no migrate function was provided"
                                );
                              }
                          })
                          .then((e) => {
                            var t;
                            return n((s = l.merge(e, null != (t = i()) ? t : m)), !0), h();
                          })
                          .then(() => {
                            null == t || t(s, void 0), (u = !0), d.forEach((e) => e(s));
                          })
                          .catch((e) => {
                            null == t || t(void 0, e);
                          });
                      };
                    return (
                      (a.persist = {
                        setOptions: (e) => {
                          (l = { ...l, ...e }), e.getStorage && (o = e.getStorage());
                        },
                        clearStorage: () => {
                          null == o || o.removeItem(l.name);
                        },
                        getOptions: () => l,
                        rehydrate: () => g(),
                        hasHydrated: () => u,
                        onHydrate: (e) => (
                          c.add(e),
                          () => {
                            c.delete(e);
                          }
                        ),
                        onFinishHydration: (e) => (
                          d.add(e),
                          () => {
                            d.delete(e);
                          }
                        ),
                      }),
                      g(),
                      s || m
                    );
                  }
                );
              return (n, i, a) => {
                let o,
                  s = {
                    storage: mN(() => localStorage),
                    partialize: (e) => e,
                    version: 0,
                    merge: (e, t) => ({ ...t, ...e }),
                    ...t,
                  },
                  l = !1,
                  u = new Set(),
                  c = new Set(),
                  d = s.storage;
                if (!d)
                  return e(
                    (...e) => {
                      console.warn(
                        `[zustand persist middleware] Unable to update item '${s.name}', the given storage is currently unavailable.`
                      ),
                        n(...e);
                    },
                    i,
                    a
                  );
                let f = () => {
                    let e = s.partialize({ ...i() });
                    return d.setItem(s.name, { state: e, version: s.version });
                  },
                  h = a.setState;
                a.setState = (e, t) => {
                  h(e, t), f();
                };
                let p = e(
                  (...e) => {
                    n(...e), f();
                  },
                  i,
                  a
                );
                a.getInitialState = () => p;
                let m = () => {
                  var e, t;
                  if (!d) return;
                  (l = !1),
                    u.forEach((e) => {
                      var t;
                      return e(null != (t = i()) ? t : p);
                    });
                  let a =
                    (null == (t = s.onRehydrateStorage)
                      ? void 0
                      : t.call(s, null != (e = i()) ? e : p)) || void 0;
                  return m_(d.getItem.bind(d))(s.name)
                    .then((e) => {
                      if (e)
                        if ('number' != typeof e.version || e.version === s.version)
                          return [!1, e.state];
                        else {
                          if (s.migrate) return [!0, s.migrate(e.state, e.version)];
                          console.error(
                            "State loaded from storage couldn't be migrated since no migrate function was provided"
                          );
                        }
                      return [!1, void 0];
                    })
                    .then((e) => {
                      var t;
                      let [a, l] = e;
                      if ((n((o = s.merge(l, null != (t = i()) ? t : p)), !0), a)) return f();
                    })
                    .then(() => {
                      null == a || a(o, void 0), (o = i()), (l = !0), c.forEach((e) => e(o));
                    })
                    .catch((e) => {
                      null == a || a(void 0, e);
                    });
                };
                return (
                  (a.persist = {
                    setOptions: (e) => {
                      (s = { ...s, ...e }), e.storage && (d = e.storage);
                    },
                    clearStorage: () => {
                      null == d || d.removeItem(s.name);
                    },
                    getOptions: () => s,
                    rehydrate: () => m(),
                    hasHydrated: () => l,
                    onHydrate: (e) => (
                      u.add(e),
                      () => {
                        u.delete(e);
                      }
                    ),
                    onFinishHydration: (e) => (
                      c.add(e),
                      () => {
                        c.delete(e);
                      }
                    ),
                  }),
                  s.skipHydration || m(),
                  o || p
                );
              };
            })(
              (t, n) => ({
                autoConnectEnabled: i,
                wallets: e,
                accounts: [],
                currentWallet: null,
                currentAccount: null,
                lastConnectedAccountAddress: null,
                lastConnectedWalletName: null,
                connectionStatus: 'disconnected',
                supportedIntents: [],
                chain: a,
                setConnectionStatus(e) {
                  t(() => ({ connectionStatus: e }));
                },
                setWalletConnected(e, n, i, a = []) {
                  t(() => ({
                    accounts: n,
                    currentWallet: e,
                    currentAccount: i,
                    lastConnectedWalletName: yc(e),
                    lastConnectedAccountAddress: i?.address,
                    connectionStatus: 'connected',
                    supportedIntents: a,
                  }));
                },
                setWalletDisconnected() {
                  t(() => ({
                    accounts: [],
                    currentWallet: null,
                    currentAccount: null,
                    lastConnectedWalletName: null,
                    lastConnectedAccountAddress: null,
                    connectionStatus: 'disconnected',
                    supportedIntents: [],
                  }));
                },
                setAccountSwitched(e) {
                  t(() => ({ currentAccount: e, lastConnectedAccountAddress: e.address }));
                },
                setWalletRegistered(e) {
                  t(() => ({ wallets: e }));
                },
                setWalletUnregistered(e, i) {
                  i === n().currentWallet
                    ? t(() => ({
                        wallets: e,
                        accounts: [],
                        currentWallet: null,
                        currentAccount: null,
                        lastConnectedWalletName: null,
                        lastConnectedAccountAddress: null,
                        connectionStatus: 'disconnected',
                        supportedIntents: [],
                      }))
                    : t(() => ({ wallets: e }));
                },
                updateWalletAccounts(e) {
                  let i = n().currentAccount;
                  t(() => ({
                    accounts: e,
                    currentAccount: (i && e.find(({ address: e }) => e === i.address)) || e[0],
                  }));
                },
              }),
              {
                name: n,
                storage: mN(() => t),
                partialize: ({ lastConnectedWalletName: e, lastConnectedAccountAddress: t }) => ({
                  lastConnectedWalletName: e,
                  lastConnectedAccountAddress: t,
                }),
              }
            )
          );
        })({
          autoConnectEnabled: o,
          wallets: yu(e, t),
          storage: n || yX(),
          storageKey: i,
          chain: u,
        })
      );
      return (0, e2.jsx)(yo.Provider, {
        value: c.current,
        children: (0, e2.jsxs)(y7, {
          preferredWallets: e,
          walletFilter: t,
          enableUnsafeBurner: a,
          children: [s ? (0, e2.jsx)(y4, { theme: s }) : null, l],
        }),
      });
    }
    function y7({
      preferredWallets: e = y5,
      walletFilter: t = y1,
      enableUnsafeBurner: n = !1,
      children: i,
    }) {
      let a, o, s;
      return (
        (a = ys((e) => e.setWalletRegistered)),
        (o = ys((e) => e.setWalletUnregistered)),
        (0, eX.useEffect)(() => {
          let n = nF();
          a(yu(e, t));
          let i = n.on('register', () => {
              a(yu(e, t));
            }),
            s = n.on('unregister', (n) => {
              o(yu(e, t), n);
            });
          return () => {
            i(), s();
          };
        }, [e, t, a, o]),
        (function () {
          let { currentWallet: e } = yU(),
            t = ys((e) => e.updateWalletAccounts);
          (0, eX.useEffect)(
            () =>
              e?.features['standard:events'].on('change', ({ accounts: e }) => {
                e && t(e);
              }),
            [e?.features, t]
          );
        })(),
        (s = yG()),
        (0, eX.useEffect)(() => {
          if (n)
            return (function (e) {
              var t, n, i, a, o;
              let s = nF();
              if (s.get().find((e) => e.name === y2))
                return void console.warn(
                  'registerUnsafeBurnerWallet: Unsafe Burner Wallet already registered, skipping duplicate registration.'
                );
              console.warn(
                'Your application is currently using the unsafe burner wallet. Make sure that this wallet is disabled in production.'
              );
              let l = new mj(),
                u = new mM({
                  address: l.getPublicKey().toIotaAddress(),
                  publicKey: l.getPublicKey().toIotaBytes(),
                  chains: ['iota:unknown'],
                  features: ['iota:signTransaction', 'iota:signAndExecuteTransaction'],
                });
              return (
                (t = new WeakMap()),
                (n = new WeakMap()),
                (i = new WeakMap()),
                (a = new WeakMap()),
                (o = new WeakMap()),
                s.register(
                  new (class {
                    constructor() {
                      yt(this, t, () => () => {}),
                        yt(this, n, async () => ({ accounts: this.accounts })),
                        yt(this, i, async (e) => {
                          let { bytes: t, signature: n } = await l.signPersonalMessage(e.message);
                          return { bytes: t, signature: n };
                        }),
                        yt(this, a, async (t) => {
                          let { bytes: n, signature: i } = await f2
                            .from(await t.transaction.toJSON())
                            .sign({ client: e, signer: l });
                          return t.signal?.throwIfAborted(), { bytes: n, signature: i };
                        }),
                        yt(this, o, async (t) => {
                          let { bytes: n, signature: i } = await f2
                            .from(await t.transaction.toJSON())
                            .sign({ client: e, signer: l });
                          t.signal?.throwIfAborted();
                          let { rawEffects: a, digest: o } = await e.executeTransactionBlock({
                            signature: i,
                            transactionBlock: n,
                            options: { showRawEffects: !0 },
                          });
                          return {
                            bytes: n,
                            signature: i,
                            digest: o,
                            effects: n3(new Uint8Array(a)),
                          };
                        });
                    }
                    get version() {
                      return '1.0.0';
                    }
                    get name() {
                      return y2;
                    }
                    get icon() {
                      return 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADwAAAA8CAYAAAA6/NlyAAAJrElEQVR42tWbe2xT1x3H7UxAyD3XrdrSbGXlUbKWsq5rWdVuVOMRSEqSOmnVRZMmJqZNYv1nf3R/jWmVmVrtRRM/YwPd1nVTNcrE3pQCoikrIRAC4VVNY0hlD9ZOo1uCfe3ra9979v0dcy3s5Pper76Oh/STE+495/4+5/c85zqe2f7HAx5vKsS+monJj/CdHi/f4/HWW4f6AwdblmXjTM0NyS+movKtw9v+j6C5gKhyTMTTpA2x15Qwy+Pz75motOGdgKep8WF5ATgVZIt5NeO2wMqD0hfVGNPh3oYaYflsjG0l63PeyLCDnqbsLpZIhaRNFI+Ox+Le5KB0RybK8gDmJOkI07U4i/FhT1NDQl8Me5rUIfaDfELOJ0NsFa/SJQHm1WLsHcDqRWiy9BCL8s0N5t6UWWFVvxplejYm60hC91cNjPtzCTZsAptCVoeLP8PDDQJNCSodap6H+LtE8ZcdkvVkkD38vwDn4/Jvy4EhBhZSvRaUHiTXn31gJJxkUPoClBKKFizM+inhVA2cYIdM4HJouPvoe9s9H+KzDhyGK6KkmIqitBhww2C11rjQL2L4kgUwFxk8yPyzauUA3Pk/353XnA6zKbKCaQ2UlMvJF6W5uF5F8yHfZWZpC9HRmBziaEpm1bpY9XvhxuWJRldC7Mt03WlZwpjnkZUNa2DMG2EaPj9MGd2l2mofd0hQ7ZSopsXckHxVCUp32fXGdD0ZktrgFUmMqwhcWFjp87RArsD+9bn585IRaSHAKgBL3SZwOTRc8BKg7yYoskp5OJDiiPmF2Sj7ox0siYJ7lJA04EqvzZ9B1xSVt6PlW0IxZgUMJdZYAJuWngLQt9IRuZXmoTEkmci8ZtTXTViUKyasA9FRun5d8z6bfw0gYWm9mmCXxZatQgxfC7I2NVpRYQOxKWppLs4mcgn5NcibgL1K40xYp8CYY5TXEpjcb3LAJ0OZyyg3+2nySm6fjEtzkEz+7VBx3RTb+60z9dma7pkvwO2QQL5HzTtAdpKF7euw/HuzfrosBHy+ZsBimzbQshjWTVMDgez53B5MbjcGbr1ZjdUJOM5O0SLXzJ2R+uOA1dMAVoLsm5zb73JSId8t8Aa1LsAJdoTCrCaw6e3NC2DdFMUXWRg173mysJNOSUNskUJ1cOlXa2LhcbgmSszXYSn9hl3KSxTDjrZ2cbbfbWDyumsh9m3e7zCG7a3ETt+gtI7fx6lEOanZKDVvuA2cjYmt5xNOd2Louz3IQ12UZ2Zo3lkb9cDlvSs6m4Vk5Yqlabs0B97wT7PUuCXQz0Bnt9QxMPTW4iwBtmUlY8hFsHJPlzcQ1xuG75CVK1kXofCUGnU9fg1aVD7kfE9MoabtYkcAvIUYS2op3Hc3TTrDQzIAeojugTVLFolWDR6wFPtY0R66n6HltwjCIawnE2ymresk9NtN+pfUUi0mX6RJLfrh9zMRaRPOqubSA8W2MNzC0mHpK7j2ruuw5mYkxl5+2+HGQeg4yNYg7vNg+xMxFsuRMuiTsRJZG3cysAl4D9n4aC4un8L9qUyVvbCyYwFXX1nGUxFf1cCiEQqy75O+TpMwYKNKSPQUqhLyyWLsRbESLctx0YnixgfphRWA8pOPc+N4F9d+eV9V4OlCX/As5w5g+wtGhJGukp5go2R3D7EW9rSDcnGL56YgJHj+8GcFND/Vy41jj/H0jxc6HU/AA2QlR01UlH3D7CmITQnJq4lVWBi1yl8XYEh278c5H++F+Iui7r7bYR8tH/gbqoJN7fVODUhLYVVxzmYCEyOxFg7RUVa0egCHZZ55eRHnp/tKgMna6s/bbMdTxZgMzl9CCcmq7k690OzDfaeSN4QcsREjsQpgXHwyWyfg9K5WE7hc6JqTWjyihObfygOFOkv6i5K5TZx8LsL1sVS4NL8ItiB7sgAcEKcWHfUCVhK3kUVnBNbfXIs4l5xAv5sJs234eTUy93L0Au2otQOw5ORMyfQ6WwexFupVSHowG6uThXfebmlhWojMS3fazmMeGxEI6S2SUti6RAo2vKohVuH3qUG5FWm/PjH8kzutgSH5g58xrVwzIbZkxHf7OFjFC+wrMDXcpOqOKX/g01U/XPvVJyxdWsiJblqYmnZoWbDxAcR56X5WPuh4ewcL5PY9JBRUYjc7fzjG6Uc3mHBWbg23X1BLaFHOSnrw4bWiNAXSEWcWRntIignXTP/oDsfKZX66mMbZAPfhviU1AyYmJLYAMZa/QXjUSeIiixpj3UUFtd884KytjN7EjdGNNMbWwtlf3FvbQ4OQtIoYSzbxqVDLXMTxP8jnnbiyKcaJLvueGLD6kXW2sKZov1tpn7hwXf3ZUvq0K2FXOM7Op/Xgb6PhxsWIErYGVuK3WGXWkkwMMZVCVl5kWtax5A6usgemvnx4DelUcYcFC0eIbcbXKzggeyBjeXIhkftaKknJKLtnuSg7KmKQsrH+1nqbmLWY6w/tBGy/8xrruR5SM99LLIjfT/4ZbNZnQEPssIVb21rKTGRIPDagNoLdFMKgcuLc/TF6Bulk6c7ovg4TU+XvS6FNw1tDfVqH9MOPmBDui0hcK6wz744FlDjNe0m3aVldJYagtI6YbF+3ZGPsQHlN1vbeh8lJofqJ+uo9Zi4wXZxKFiXKGxbHT7pNq71oNg4Qi6MviE0FpRVqjGXILYoJ4tCjdYU1rWeMdPLc/ochj3B9pGNGL4NupGPRlUl35KMVxFLNO6ZnxYlBsUPqoMkbUqAb6VhMVKQ7MVT1dYdrL8hzEAcjpmvjHKphgaFb0ZVJZw7dwVD9q5fkgPTRbBxnzmGfgRLQsMCkG+moQdcp6GzzZsL2MGyllvBNGWM9RqMCk26kI7aBK526csVShZTfzid6FEzeiNAGP92jpCPQEbrW7EW5MbZxAz/fN9lg0IbQaaxrQ83/VoKPb/HqJx67Hw+43CDQBPsX0gm6ufXNvH4vP9rZapzx7+Nn+oxZAjfo2caZ3n350c5W6FSEdQ86sNarj3c/jRV+H42AXsdGRBfPPIlnb/mUtxzWXfALn/PmRze2Gud6E/xsXwYtnlsWN8Tc5/oyxjn/jvyJrlY82xLUfWuPr/TqxzuXQZkIP9M7CXiyuP4B4WmsTnNhzinjrD+WO9bRhmdZWLXe4EKRtV5tpN3Hx3s2G+d79/MJf4qff0LnE72kfFEs4ITQvWLMab8C131dP9n9Je1Yx000Nz2jAf+UJwCBchc3NvGR1Qx71XXY2Ww1Jvx7YalzAPkX9rp5E5Z+pv+ja8bE43uN491b9dHO9Xx4lUxziLn21Nai/wXWM6t9vkvtrwAAAABJRU5ErkJggg==';
                    }
                    get chains() {
                      return rK;
                    }
                    get accounts() {
                      return [u];
                    }
                    get features() {
                      return {
                        'standard:connect': { version: '1.0.0', connect: ye(this, n) },
                        'standard:events': { version: '1.0.0', on: ye(this, t) },
                        'iota:signPersonalMessage': {
                          version: '1.0.0',
                          signPersonalMessage: ye(this, i),
                        },
                        'iota:signTransaction': { version: '2.0.0', signTransaction: ye(this, a) },
                        'iota:signAndExecuteTransaction': {
                          version: '2.0.0',
                          signAndExecuteTransaction: ye(this, o),
                        },
                      };
                    }
                  })()
                )
              );
            })(s);
        }, [n, s]),
        !(function () {
          let { mutateAsync: e } = yl(),
            t = ys((e) => e.autoConnectEnabled),
            n = ys((e) => e.lastConnectedWalletName),
            i = ys((e) => e.lastConnectedAccountAddress),
            a = yI(),
            { isConnected: o } = yU(),
            [s, l] = (0, eX.useState)(!1);
          (0, eX.useLayoutEffect)(() => {
            l(!0);
          }, []);
          let { data: u, isError: c } = sk({
            queryKey: [
              '@iota/dapp-kit',
              'autoconnect',
              {
                isConnected: o,
                autoConnectEnabled: t,
                lastConnectedWalletName: n,
                lastConnectedAccountAddress: i,
                walletCount: a.length,
              },
            ],
            queryFn: async () => {
              if (!t) return 'disabled';
              if (!n || !i || o) return 'attempted';
              let s = a.find((e) => yc(e) === n);
              return s && (await e({ wallet: s, accountAddress: i, silent: !0 })), 'attempted';
            },
            enabled: t,
            persister: void 0,
            gcTime: 0,
            staleTime: 0,
            networkMode: 'always',
            retry: !1,
            retryOnMount: !1,
            refetchInterval: !1,
            refetchIntervalInBackground: !1,
            refetchOnMount: !1,
            refetchOnReconnect: !1,
            refetchOnWindowFocus: !1,
          });
        })(),
        i
      );
    }
    function be(e) {
      function t() {
        let { config: e } = yK();
        if (!e) throw Error('No network config found');
        return e;
      }
      function n() {
        let { variables: e } = t();
        return e ?? {};
      }
      return {
        networkConfig: e,
        useNetworkConfig: t,
        useNetworkVariables: n,
        useNetworkVariable: function (e) {
          return n()[e];
        },
      };
    }
    function bt(...e) {
      let [t, n, { queryKey: i = [], ...a } = {}] = e,
        o = yK();
      return sk({
        ...a,
        queryKey: [o.network, t, n, ...i],
        queryFn: async () => await o.client[t](n),
      });
    }
    function br({ mutationKey: e, execute: t, ...n } = {}) {
      let i = ys((e) => e.chain),
        { currentWallet: a, supportedIntents: o } = yU(),
        s = yP(),
        l = yG(),
        { mutate: u } = (function ({ mutationKey: e, ...t } = {}) {
          let { currentWallet: n } = yU(),
            i = yP();
          return nI({
            mutationKey: yi.reportTransactionEffects(e),
            mutationFn: async ({ effects: e, chain: t = n?.chains[0], account: a = i }) => {
              if (!n) throw new yN('No wallet is connected.');
              if (!a)
                throw new y_('No wallet account is selected to report transaction effects for');
              let o = n.features['iota:reportTransactionEffects'];
              if (o)
                return await o.reportTransactionEffects({
                  effects: Array.isArray(e) ? n3(new Uint8Array(e)) : e,
                  account: a,
                  chain: t ?? n?.chains[0],
                });
            },
            ...t,
          });
        })(),
        c =
          t ??
          (async ({ bytes: e, signature: t }) => {
            let { digest: n, rawEffects: i } = await l.executeTransactionBlock({
              transactionBlock: e,
              signature: t,
              options: { showRawEffects: !0 },
            });
            return {
              digest: n,
              rawEffects: i,
              effects: n3(new Uint8Array(i)),
              bytes: e,
              signature: t,
            };
          });
      return nI({
        mutationKey: yi.signAndExecuteTransaction(e),
        mutationFn: async ({ transaction: e, ...t }) => {
          let n;
          if (!a) throw new yN('No wallet is connected.');
          let d = t.account ?? s;
          if (!d) throw new y_('No wallet account is selected to sign the transaction with.');
          if (!a.features['iota:signTransaction'])
            throw new yD("This wallet doesn't support the `signTransaction` feature.");
          let f = t.chain ?? i ?? d?.chains[0],
            { signature: h, bytes: p } = await g5(a, {
              ...t,
              transaction: {
                toJSON: async () =>
                  'string' == typeof e ? e : await e.toJSON({ supportedIntents: o, client: l }),
              },
              account: d,
              chain: f,
            }),
            m = await c({ bytes: p, signature: h });
          if ('effects' in m && m.effects?.bcs) n = m.effects.bcs;
          else if ('rawEffects' in m) n = n3(new Uint8Array(m.rawEffects));
          else throw Error('Could not parse effects from transaction result.');
          return (
            u({ effects: n, account: d, chain: f }),
            t.waitForTransaction &&
              'digest' in m &&
              (await l.waitForTransaction({ digest: m.digest })),
            m
          );
        },
        ...n,
      });
    }
    e.s(
      [
        'ConnectButton',
        () => yQ,
        'IotaClientProvider',
        () => yq,
        'WalletProvider',
        () => y9,
        'createNetworkConfig',
        () => be,
        'useCurrentAccount',
        () => yP,
        'useIotaClient',
        () => yG,
        'useIotaClientQuery',
        () => bt,
        'useSignAndExecuteTransaction',
        () => br,
      ],
      29391
    );
  },
  43794,
  (e, t, n) => {
    !(function () {
      'use strict';
      var n = {}.hasOwnProperty;
      function i() {
        for (var e = '', t = 0; t < arguments.length; t++) {
          var o = arguments[t];
          o &&
            (e = a(
              e,
              (function (e) {
                if ('string' == typeof e || 'number' == typeof e) return e;
                if ('object' != typeof e) return '';
                if (Array.isArray(e)) return i.apply(null, e);
                if (
                  e.toString !== Object.prototype.toString &&
                  !e.toString.toString().includes('[native code]')
                )
                  return e.toString();
                var t = '';
                for (var o in e) n.call(e, o) && e[o] && (t = a(t, o));
                return t;
              })(o)
            ));
        }
        return e;
      }
      function a(e, t) {
        return t ? (e ? e + ' ' + t : e + t) : e;
      }
      if (t.exports) (i.default = i), (t.exports = i);
      else if ('function' == typeof define && 'object' == typeof define.amd && define.amd)
        void 0 !== i && e.v(i);
      else window.classNames = i;
    })();
  },
  9840,
  (e) => {
    'use strict';
    var t = e.i(71645),
      n = e.i(20783),
      i = e.i(43476);
    function a(e) {
      var a;
      let o,
        s =
          ((a = e),
          ((o = t.forwardRef((e, i) => {
            let { children: a, ...o } = e;
            if (t.isValidElement(a)) {
              var s;
              let e,
                l,
                u =
                  ((s = a),
                  (l =
                    (e = Object.getOwnPropertyDescriptor(s.props, 'ref')?.get) &&
                    'isReactWarning' in e &&
                    e.isReactWarning)
                    ? s.ref
                    : (l =
                        (e = Object.getOwnPropertyDescriptor(s, 'ref')?.get) &&
                        'isReactWarning' in e &&
                        e.isReactWarning)
                    ? s.props.ref
                    : s.props.ref || s.ref),
                c = (function (e, t) {
                  let n = { ...t };
                  for (let i in t) {
                    let a = e[i],
                      o = t[i];
                    /^on[A-Z]/.test(i)
                      ? a && o
                        ? (n[i] = (...e) => {
                            let t = o(...e);
                            return a(...e), t;
                          })
                        : a && (n[i] = a)
                      : 'style' === i
                      ? (n[i] = { ...a, ...o })
                      : 'className' === i && (n[i] = [a, o].filter(Boolean).join(' '));
                  }
                  return { ...e, ...n };
                })(o, a.props);
              return (
                a.type !== t.Fragment && (c.ref = i ? (0, n.composeRefs)(i, u) : u),
                t.cloneElement(a, c)
              );
            }
            return t.Children.count(a) > 1 ? t.Children.only(null) : null;
          })).displayName = `${a}.SlotClone`),
          o),
        l = t.forwardRef((e, n) => {
          let { children: a, ...o } = e,
            l = t.Children.toArray(a),
            u = l.find(c);
          if (u) {
            let e = u.props.children,
              a = l.map((n) =>
                n !== u
                  ? n
                  : t.Children.count(e) > 1
                  ? t.Children.only(null)
                  : t.isValidElement(e)
                  ? e.props.children
                  : null
              );
            return (0, i.jsx)(s, {
              ...o,
              ref: n,
              children: t.isValidElement(e) ? t.cloneElement(e, void 0, a) : null,
            });
          }
          return (0, i.jsx)(s, { ...o, ref: n, children: a });
        });
      return (l.displayName = `${e}.Slot`), l;
    }
    var o = a('Slot'),
      s = Symbol('radix.slottable');
    function l(e) {
      let t = ({ children: e }) => (0, i.jsx)(i.Fragment, { children: e });
      return (t.displayName = `${e}.Slottable`), (t.__radixId = s), t;
    }
    var u = l('Slottable');
    function c(e) {
      return (
        t.isValidElement(e) &&
        'function' == typeof e.type &&
        '__radixId' in e.type &&
        e.type.__radixId === s
      );
    }
    e.s(
      [
        'Root',
        () => o,
        'Slot',
        () => o,
        'Slottable',
        () => u,
        'createSlot',
        () => a,
        'createSlottable',
        () => l,
      ],
      43556
    );
    var d = e.i(43556);
    e.s(['Slot', 0, d], 9840);
  },
  59411,
  (e) => {
    'use strict';
    var t = e.i(71645),
      n = e.i(48425),
      i = e.i(43476),
      a = Object.freeze({
        position: 'absolute',
        border: 0,
        width: 1,
        height: 1,
        padding: 0,
        margin: -1,
        overflow: 'hidden',
        clip: 'rect(0, 0, 0, 0)',
        whiteSpace: 'nowrap',
        wordWrap: 'normal',
      }),
      o = t.forwardRef((e, t) =>
        (0, i.jsx)(n.Primitive.span, { ...e, ref: t, style: { ...a, ...e.style } })
      );
    (o.displayName = 'VisuallyHidden'),
      e.s(['Root', () => o, 'VISUALLY_HIDDEN_STYLES', () => a, 'VisuallyHidden', () => o]);
  },
  14554,
  69931,
  10712,
  (e) => {
    'use strict';
    let t = { asChild: { type: 'boolean' } };
    e.s(['asChildPropDef', () => t], 14554);
    let n = [
        'gray',
        'gold',
        'bronze',
        'brown',
        'yellow',
        'amber',
        'orange',
        'tomato',
        'red',
        'ruby',
        'crimson',
        'pink',
        'plum',
        'purple',
        'violet',
        'iris',
        'indigo',
        'blue',
        'cyan',
        'teal',
        'jade',
        'green',
        'grass',
        'lime',
        'mint',
        'sky',
      ],
      i = ['auto', 'gray', 'mauve', 'slate', 'sage', 'olive', 'sand'],
      a = { color: { type: 'enum', values: n, default: void 0 } },
      o = { color: { type: 'enum', values: n, default: '' } };
    e.s(
      [
        'accentColorPropDef',
        () => o,
        'accentColors',
        () => n,
        'colorPropDef',
        () => a,
        'grayColors',
        () => i,
      ],
      69931
    );
    let s = ['none', 'small', 'medium', 'large', 'full'],
      l = { radius: { type: 'enum', values: s, default: void 0 } };
    e.s(['radii', () => s, 'radiusPropDef', () => l], 10712);
  },
  61664,
  (e) => {
    'use strict';
    var t,
      n =
        (((t = n || {}).Mainnet = 'mainnet'),
        (t.Devnet = 'devnet'),
        (t.Testnet = 'testnet'),
        (t.Localnet = 'localnet'),
        (t.Custom = 'custom'),
        t);
    function i(e) {
      return (
        (function () {
          let e;
          try {
            e = JSON.parse(
              '{\n    "mainnet": {\n        "id": "mainnet",\n        "name": "Mainnet",\n        "url": "https://api.mainnet.iota.cafe",\n        "graphql": "https://graphql.mainnet.iota.cafe",\n        "explorer": "https://explorer.rebased.iota.org",\n        "chain": "iota:mainnet"\n    },\n    "testnet": {\n        "id": "testnet",\n        "name": "Testnet",\n        "url": "https://api.testnet.iota.cafe",\n        "graphql": "https://graphql.testnet.iota.cafe",\n        "explorer": "https://explorer.rebased.iota.org",\n        "chain": "iota:testnet",\n        "faucet": "https://faucet.testnet.iota.cafe",\n        "kiosk": {\n            "royaltyRulePackageId": "0x975f749f57701209454e4b9b9e33825ccb6a9abf57de2ce86979e5fa86c343f2",\n            "kioskLockRulePackageId": "0x975f749f57701209454e4b9b9e33825ccb6a9abf57de2ce86979e5fa86c343f2",\n            "floorPriceRulePackageId": "0x975f749f57701209454e4b9b9e33825ccb6a9abf57de2ce86979e5fa86c343f2",\n            "personalKioskRulePackageId": "0x975f749f57701209454e4b9b9e33825ccb6a9abf57de2ce86979e5fa86c343f2"\n        }\n    },\n    "devnet": {\n        "id": "devnet",\n        "name": "Devnet",\n        "url": "https://api.devnet.iota.cafe",\n        "graphql": "https://graphql.devnet.iota.cafe",\n        "explorer": "https://explorer.rebased.iota.org",\n        "chain": "iota:devnet",\n        "faucet": "https://faucet.devnet.iota.cafe"\n    },\n    "localnet": {\n        "id": "localnet",\n        "name": "Localnet",\n        "url": "http://localhost:9000",\n        "graphql": "http://localhost:9125",\n        "explorer": "http://localhost:3000",\n        "chain": "iota:local",\n        "faucet": "http://localhost:9123"\n    }\n}'
            );
          } catch {
            throw Error('Failed to parse env var "IOTA_NETWORKS".');
          }
          return e;
        })()[e] ?? e
      ).url;
    }
    let {
      networkConfig: a,
      useNetworkVariable: o,
      useNetworkVariables: s,
    } = (0, e.i(29391).createNetworkConfig)({
      devnet: {
        url: i('devnet'),
        variables: {
          packageId: '0x9db832e7c6fba2bab1459ebec461e381a5f59f6f39d56eb5d1f852b7aaac768a',
        },
      },
      testnet: {
        url: i('testnet'),
        variables: {
          packageId: '0x2448997aae116858911c172aabd061f615984f8b3692d4df7e2926c82ada1d73',
        },
      },
      mainnet: { url: i('mainnet'), variables: { packageId: '' } },
    });
    e.s(['networkConfig', () => a, 'useNetworkVariable', () => o], 61664);
  },
]);
